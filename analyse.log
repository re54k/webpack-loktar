{
  "errors": [],
  "warnings": [],
  "version": "1.12.3",
  "hash": "f1df7aefe70b410407ac",
  "time": 890,
  "publicPath": "/static/",
  "assetsByChunkName": {
    "parent": [
      "bundle.js",
      "bundle.js.map"
    ],
    "echart": [
      "1.bundle.js",
      "1.bundle.js.map"
    ]
  },
  "assets": [
    {
      "name": "bundle.js.map",
      "size": 3902,
      "chunks": [
        0
      ],
      "chunkNames": [
        "parent"
      ],
      "emitted": true
    },
    {
      "name": "bundle.js",
      "size": 3892,
      "chunks": [
        0
      ],
      "chunkNames": [
        "parent"
      ],
      "emitted": true
    },
    {
      "name": "2.bundle.js",
      "size": 701148,
      "chunks": [
        2
      ],
      "chunkNames": [],
      "emitted": true
    },
    {
      "name": "3.bundle.js",
      "size": 44353,
      "chunks": [
        3
      ],
      "chunkNames": [],
      "emitted": true
    },
    {
      "name": "4.bundle.js",
      "size": 12213,
      "chunks": [
        4
      ],
      "chunkNames": [],
      "emitted": true
    },
    {
      "name": "5.bundle.js",
      "size": 51167,
      "chunks": [
        5
      ],
      "chunkNames": [],
      "emitted": true
    },
    {
      "name": "1.bundle.js",
      "size": 1148,
      "chunks": [
        1
      ],
      "chunkNames": [
        "echart"
      ],
      "emitted": true
    },
    {
      "name": "1.bundle.js.map",
      "size": 1449,
      "chunks": [
        1
      ],
      "chunkNames": [
        "echart"
      ],
      "emitted": true
    },
    {
      "name": "2.bundle.js.map",
      "size": 808707,
      "chunks": [
        2
      ],
      "chunkNames": [],
      "emitted": true
    },
    {
      "name": "3.bundle.js.map",
      "size": 49915,
      "chunks": [
        3
      ],
      "chunkNames": [],
      "emitted": true
    },
    {
      "name": "4.bundle.js.map",
      "size": 13668,
      "chunks": [
        4
      ],
      "chunkNames": [],
      "emitted": true
    },
    {
      "name": "5.bundle.js.map",
      "size": 57758,
      "chunks": [
        5
      ],
      "chunkNames": [],
      "emitted": true
    }
  ],
  "chunks": [
    {
      "id": 0,
      "rendered": true,
      "initial": true,
      "entry": true,
      "extraAsync": false,
      "size": 76,
      "names": [
        "parent"
      ],
      "files": [
        "bundle.js",
        "bundle.js.map"
      ],
      "hash": "cfa3e718dae0fd1587b0",
      "parents": [],
      "modules": [
        {
          "id": 0,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
          "name": "./parent.js",
          "index": 0,
          "index2": 68,
          "size": 76,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": null,
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [],
          "source": "require.ensure([], function(require) {\r\n\trequire('./echart');\r\n}, 'echart');"
        }
      ],
      "filteredModules": 0,
      "origins": [
        {
          "moduleId": 0,
          "module": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
          "moduleName": "./parent.js",
          "loc": "",
          "name": "parent",
          "reasons": []
        }
      ]
    },
    {
      "id": 1,
      "rendered": true,
      "initial": false,
      "entry": false,
      "extraAsync": false,
      "size": 750,
      "names": [
        "echart"
      ],
      "files": [
        "1.bundle.js",
        "1.bundle.js.map"
      ],
      "hash": "0ec3fd3a48e86eb6d968",
      "parents": [
        0
      ],
      "modules": [
        {
          "id": 1,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\echart.js",
          "name": "./echart.js",
          "index": 1,
          "index2": 67,
          "size": 750,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            1
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 0,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
              "module": "./parent.js",
              "moduleName": "./parent.js",
              "type": "cjs require",
              "userRequest": "./echart",
              "loc": "2:1-20"
            }
          ],
          "source": "//var echarts = require('echarts/echarts');\r\nvar expr = 'bar';\r\n\r\n\trequire([\"bundle!echarts/chart/\" + expr + \".js\"], function(bundledResult) {\r\n\t\tbundledResult(function(result) {\r\n\t\t\tvar mychart = echarts.init(document.getElementById('root'));\r\n\t\t\tvar option = {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tshow: true\r\n\t\t\t\t},\r\n\t\t\t\tlegend: {\r\n\t\t\t\t\tdata:['销量']\r\n\t\t\t\t},\r\n\t\t\t\txAxis : [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttype : 'category',\r\n\t\t\t\t\t\tdata : [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"]\r\n\t\t\t\t\t}\r\n\t\t\t\t],\r\n\t\t\t\tyAxis : [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttype : 'value'\r\n\t\t\t\t\t}\r\n\t\t\t\t],\r\n\t\t\t\tseries : [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"name\":\"销量\",\r\n\t\t\t\t\t\t\"type\":\"bar\",\r\n\t\t\t\t\t\t\"data\":[5, 20, 40, 10, 10, 20]\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t};\r\n\r\n// 为echarts对象加载数1212s11ss11据\r\n\t\t\tmychart.setOption(option);\r\n\r\n\t\t});\r\n\t});\r\n\r\nmodule.exports = {};\r\n\r\n"
        }
      ],
      "filteredModules": 0,
      "loc": "1:0-3:12",
      "origins": [
        {
          "moduleId": 0,
          "module": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
          "moduleName": "./parent.js",
          "loc": "1:0-3:12",
          "name": "echart",
          "reasons": []
        }
      ]
    },
    {
      "id": 2,
      "rendered": true,
      "initial": false,
      "entry": false,
      "extraAsync": false,
      "size": 647796,
      "names": [],
      "files": [
        "2.bundle.js",
        "2.bundle.js.map"
      ],
      "hash": "fef8f13f6477a72fe29a",
      "parents": [
        1
      ],
      "modules": [
        {
          "id": 2,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
          "index": 2,
          "index2": 66,
          "size": 217,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\echart.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\echart.js",
              "module": "./echart.js",
              "moduleName": "./echart.js",
              "type": "amd require context",
              "userRequest": "bundle!echarts/chart",
              "loc": "4:1-38:3"
            }
          ]
        },
        {
          "id": 3,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "name": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "index": 3,
          "index2": 58,
          "size": 280,
          "cacheable": true,
          "built": true,
          "optional": true,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
              "type": "context element",
              "userRequest": "./bar.js"
            }
          ],
          "source": "var cbs = [], \n\tdata;\nmodule.exports = function(cb) {\n\tif(cbs) cbs.push(cb);\n\telse cb(data);\n}\nrequire.ensure([], function(require) {\n\tdata = require(\"!!./bar.js\");\n\tvar callbacks = cbs;\n\tcbs = null;\n\tfor(var i = 0, l = callbacks.length; i < l; i++) {\n\t\tcallbacks[i](data);\n\t}\n});"
        },
        {
          "id": 5,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "index": 5,
          "index2": 44,
          "size": 70590,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "./base",
              "loc": "9:20-37"
            },
            {
              "moduleId": 62,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "!!./base.js",
              "loc": "8:8-30"
            },
            {
              "moduleId": 64,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "./base",
              "loc": "9:20-37"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "./base",
              "loc": "9:20-37"
            }
          ],
          "source": "/**\r\n * echarts图表基类\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    // 图形依赖\r\n    var ImageShape = require('zrenderjs/shape/Image');\r\n    var IconShape = require('../util/shape/Icon');\r\n    var MarkLineShape = require('../util/shape/MarkLine');\r\n    var SymbolShape = require('../util/shape/Symbol');\r\n    var PolylineShape = require('zrenderjs/shape/Polyline');\r\n    var ShapeBundle = require('zrenderjs/shape/ShapeBundle');\r\n    \r\n    var ecConfig = require('../config');\r\n    var ecData = require('../util/ecData');\r\n    var ecAnimation = require('../util/ecAnimation');\r\n    var ecEffect = require('../util/ecEffect');\r\n    var accMath = require('../util/accMath');\r\n    var ComponentBase = require('../component/base');\r\n    var EdgeBundling = require('../layout/EdgeBundling');\r\n\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrArea = require('zrenderjs/tool/area');\r\n\r\n    // Some utility functions\r\n    function isCoordAvailable(coord) {\r\n        return coord.x != null && coord.y != null;\r\n    }\r\n    \r\n    function Base(ecTheme, messageCenter, zr, option, myChart) {\r\n\r\n        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        var self = this;\r\n        this.selectedMap = {};\r\n        this.lastShapeList = [];\r\n        this.shapeHandler = {\r\n            onclick: function () {\r\n                self.isClick = true;\r\n            },\r\n            \r\n            ondragover: function (param) {\r\n                // 返回触发可计算特性的图形提示\r\n                var calculableShape = param.target;\r\n                calculableShape.highlightStyle = calculableShape.highlightStyle || {};\r\n                \r\n                // 备份特出特性\r\n                var highlightStyle = calculableShape.highlightStyle;\r\n                var brushType = highlightStyle.brushTyep;\r\n                var strokeColor = highlightStyle.strokeColor;\r\n                var lineWidth = highlightStyle.lineWidth;\r\n                \r\n                highlightStyle.brushType = 'stroke';\r\n                highlightStyle.strokeColor = self.ecTheme.calculableColor\r\n                                             || ecConfig.calculableColor;\r\n                highlightStyle.lineWidth = calculableShape.type === 'icon' ? 30 : 10;\r\n\r\n                self.zr.addHoverShape(calculableShape);\r\n                \r\n                setTimeout(function (){\r\n                    // 复位\r\n                    if (highlightStyle) {\r\n                        highlightStyle.brushType = brushType;\r\n                        highlightStyle.strokeColor = strokeColor;\r\n                        highlightStyle.lineWidth = lineWidth;\r\n                    }\r\n                },20);\r\n            },\r\n            \r\n            ondrop: function (param) {\r\n                // 排除一些非数据的拖拽进入\r\n                if (ecData.get(param.dragged, 'data') != null) {\r\n                    self.isDrop = true;\r\n                }\r\n            },\r\n            \r\n            ondragend: function () {\r\n                self.isDragend = true;\r\n            }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * 基类方法\r\n     */\r\n    Base.prototype = {\r\n        /**\r\n         * 图形拖拽特性 \r\n         */\r\n        setCalculable: function (shape) {\r\n            shape.dragEnableTime = this.ecTheme.DRAG_ENABLE_TIME || ecConfig.DRAG_ENABLE_TIME;\r\n            shape.ondragover = this.shapeHandler.ondragover;\r\n            shape.ondragend = this.shapeHandler.ondragend;\r\n            shape.ondrop = this.shapeHandler.ondrop;\r\n            return shape;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽进来\r\n         */\r\n        ondrop: function (param, status) {\r\n            if (!this.isDrop || !param.target || status.dragIn) {\r\n                // 没有在当前实例上发生拖拽行为或者已经被认领了则直接返回\r\n                return;\r\n            }\r\n            var target = param.target;      // 拖拽安放目标\r\n            var dragged = param.dragged;    // 当前被拖拽的图形对象\r\n\r\n            var seriesIndex = ecData.get(target, 'seriesIndex');\r\n            var dataIndex = ecData.get(target, 'dataIndex');\r\n\r\n            var series = this.series;\r\n            var data;\r\n            var legend = this.component.legend;\r\n            if (dataIndex === -1) {\r\n                // 落到calculableCase上，数据被拖拽进某个饼图|雷达|漏斗，增加数据\r\n                if (ecData.get(dragged, 'seriesIndex') == seriesIndex) {\r\n                    // 自己拖拽到自己\r\n                    status.dragOut = status.dragIn = status.needRefresh = true;\r\n                    this.isDrop = false;\r\n                    return;\r\n                }\r\n                \r\n                data = {\r\n                    value: ecData.get(dragged, 'value'),\r\n                    name: ecData.get(dragged, 'name')\r\n                };\r\n\r\n                // 修饼图数值不为负值\r\n                if (this.type === ecConfig.CHART_TYPE_PIE && data.value < 0) {\r\n                    data.value = 0;\r\n                }\r\n\r\n                var hasFind = false;\r\n                var sData = series[seriesIndex].data;\r\n                for (var i = 0, l = sData.length; i < l; i++) {\r\n                    if (sData[i].name === data.name && sData[i].value === '-') {\r\n                        series[seriesIndex].data[i].value = data.value;\r\n                        hasFind = true;\r\n                    }\r\n                }\r\n                !hasFind && series[seriesIndex].data.push(data);\r\n\r\n                legend && legend.add(\r\n                    data.name,\r\n                    dragged.style.color || dragged.style.strokeColor\r\n                );\r\n            }\r\n            else {\r\n                // 落到数据item上，数据被拖拽到某个数据项上，数据修改\r\n                data = series[seriesIndex].data[dataIndex] || '-';\r\n                if (data.value != null) {\r\n                    if (data.value != '-') {\r\n                        series[seriesIndex].data[dataIndex].value = \r\n                            accMath.accAdd(\r\n                                series[seriesIndex].data[dataIndex].value,\r\n                                ecData.get(dragged, 'value')\r\n                            );\r\n                    }\r\n                    else {\r\n                        series[seriesIndex].data[dataIndex].value =\r\n                            ecData.get(dragged, 'value');\r\n                    }\r\n                    \r\n                    if (this.type === ecConfig.CHART_TYPE_FUNNEL\r\n                        || this.type === ecConfig.CHART_TYPE_PIE\r\n                    ) {\r\n                        legend && legend.getRelatedAmount(data.name) === 1 \r\n                               && this.component.legend.del(data.name);\r\n                        data.name += this.option.nameConnector + ecData.get(dragged, 'name');\r\n                        legend && legend.add(\r\n                            data.name,\r\n                            dragged.style.color || dragged.style.strokeColor\r\n                        );\r\n                    }\r\n                }\r\n                else {\r\n                    if (data != '-') {\r\n                        series[seriesIndex].data[dataIndex] = \r\n                            accMath.accAdd(\r\n                                series[seriesIndex].data[dataIndex],\r\n                                ecData.get(dragged, 'value')\r\n                            );\r\n                    }\r\n                    else {\r\n                        series[seriesIndex].data[dataIndex] =\r\n                            ecData.get(dragged, 'value');\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 别status = {}赋值啊！！\r\n            status.dragIn = status.dragIn || true;\r\n\r\n            // 处理完拖拽事件后复位\r\n            this.isDrop = false;\r\n\r\n            var self = this;\r\n            setTimeout(function(){\r\n                self.zr.trigger('mousemove', param.event);\r\n            }, 300);\r\n            \r\n            return;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽出去\r\n         */\r\n        ondragend: function (param, status) {\r\n            if (!this.isDragend || !param.target || status.dragOut) {\r\n                // 没有在当前实例上发生拖拽行为或者已经被认领了则直接返回\r\n                return;\r\n            }\r\n            var target = param.target;      // 被拖拽图形元素\r\n\r\n            var seriesIndex = ecData.get(target, 'seriesIndex');\r\n            var dataIndex = ecData.get(target, 'dataIndex');\r\n\r\n            var series = this.series;\r\n\r\n            // 删除被拖拽走的数据\r\n            if (series[seriesIndex].data[dataIndex].value != null) {\r\n                series[seriesIndex].data[dataIndex].value = '-';\r\n                // 清理可能有且唯一的legend data\r\n                var name = series[seriesIndex].data[dataIndex].name;\r\n                var legend = this.component.legend;\r\n                if (legend && legend.getRelatedAmount(name) === 0) {\r\n                    legend.del(name);\r\n                }\r\n            }\r\n            else {\r\n                series[seriesIndex].data[dataIndex] = '-';\r\n            }\r\n            \r\n            // 别status = {}赋值啊！！\r\n            status.dragOut = true;\r\n            status.needRefresh = true;\r\n\r\n            // 处理完拖拽事件后复位\r\n            this.isDragend = false;\r\n\r\n            return;\r\n        },\r\n\r\n        /**\r\n         * 图例选择\r\n         */\r\n        onlegendSelected: function (param, status) {\r\n            var legendSelected = param.selected;\r\n            for (var itemName in this.selectedMap) {\r\n                if (this.selectedMap[itemName] != legendSelected[itemName]) {\r\n                    // 有一项不一致都需要重绘\r\n                    status.needRefresh = true;\r\n                }\r\n                this.selectedMap[itemName] = legendSelected[itemName];\r\n            }\r\n            return;\r\n        },\r\n        \r\n        /**\r\n         * 折线图、柱形图公用方法\r\n         */\r\n        _buildPosition: function() {\r\n            this._symbol = this.option.symbolList;\r\n            this._sIndex2ShapeMap = {};  // series拐点图形类型，seriesIndex索引到shape type\r\n            this._sIndex2ColorMap = {};  // series默认颜色索引，seriesIndex索引到color\r\n\r\n            this.selectedMap = {};\r\n            this.xMarkMap = {};\r\n            \r\n            var series = this.series;\r\n            // 水平垂直双向series索引 ，position索引到seriesIndex\r\n            var _position2sIndexMap = {\r\n                top: [],\r\n                bottom: [],\r\n                left: [],\r\n                right: [],\r\n                other: []\r\n            };\r\n            var xAxisIndex;\r\n            var yAxisIndex;\r\n            var xAxis;\r\n            var yAxis;\r\n            for (var i = 0, l = series.length; i < l; i++) {\r\n                if (series[i].type === this.type) {\r\n                    series[i] = this.reformOption(series[i]);\r\n                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;\r\n                    xAxisIndex = series[i].xAxisIndex;\r\n                    yAxisIndex = series[i].yAxisIndex;\r\n                    xAxis = this.component.xAxis.getAxis(xAxisIndex);\r\n                    yAxis = this.component.yAxis.getAxis(yAxisIndex);\r\n                    if (xAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {\r\n                        _position2sIndexMap[xAxis.getPosition()].push(i);\r\n                    }\r\n                    else if (yAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {\r\n                        _position2sIndexMap[yAxis.getPosition()].push(i);\r\n                    }\r\n                    else {\r\n                        _position2sIndexMap.other.push(i);\r\n                    }\r\n                }\r\n            }\r\n            // console.log(_position2sIndexMap);\r\n            for (var position in _position2sIndexMap) {\r\n                if (_position2sIndexMap[position].length > 0) {\r\n                    this._buildSinglePosition(\r\n                        position, _position2sIndexMap[position]\r\n                    );\r\n                }\r\n            }\r\n\r\n            this.addShapeList();\r\n        },\r\n        \r\n        /**\r\n         * 构建单个方向上的折线图、柱形图公用方法\r\n         *\r\n         * @param {number} seriesIndex 系列索引\r\n         */\r\n        _buildSinglePosition: function (position, seriesArray) {\r\n            var mapData = this._mapData(seriesArray);\r\n            var locationMap = mapData.locationMap;\r\n            var maxDataLength = mapData.maxDataLength;\r\n\r\n            if (maxDataLength === 0 || locationMap.length === 0) {\r\n                return;\r\n            }\r\n            switch (position) {\r\n                case 'bottom' :\r\n                case 'top' :\r\n                    this._buildHorizontal(seriesArray, maxDataLength, locationMap, this.xMarkMap);\r\n                    break;\r\n                case 'left' :\r\n                case 'right' :\r\n                    this._buildVertical(seriesArray, maxDataLength, locationMap, this.xMarkMap);\r\n                    break;\r\n                case 'other' :\r\n                    this._buildOther(seriesArray, maxDataLength, locationMap, this.xMarkMap);\r\n                    break;\r\n            }\r\n            \r\n            for (var i = 0, l = seriesArray.length; i < l; i++) {\r\n                this.buildMark(seriesArray[i]);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 数据整形，折线图、柱形图公用方法\r\n         * 数组位置映射到系列索引\r\n         */\r\n        _mapData: function (seriesArray) {\r\n            var series = this.series;\r\n            var serie;                              // 临时映射变量\r\n            var dataIndex = 0;                      // 堆积数据所在位置映射\r\n            var stackMap = {};                      // 堆积数据位置映射，堆积组在二维中的第几项\r\n            var magicStackKey = '__kener__stack__'; // 堆积命名，非堆积数据安单一堆积处理\r\n            var stackKey;                           // 临时映射变量\r\n            var serieName;                          // 临时映射变量\r\n            var legend = this.component.legend;\r\n            var locationMap = [];                   // 需要返回的东西：数组位置映射到系列索引\r\n            var maxDataLength = 0;                  // 需要返回的东西：最大数据长度\r\n            var iconShape;\r\n            // 计算需要显示的个数和分配位置并记在下面这个结构里\r\n            for (var i = 0, l = seriesArray.length; i < l; i++) {\r\n                serie = series[seriesArray[i]];\r\n                serieName = serie.name;\r\n                \r\n                this._sIndex2ShapeMap[seriesArray[i]] = this._sIndex2ShapeMap[seriesArray[i]]\r\n                                                        || this.query(serie,'symbol')\r\n                                                        || this._symbol[i % this._symbol.length];\r\n                      \r\n                if (legend){\r\n                    this.selectedMap[serieName] = legend.isSelected(serieName);\r\n                    \r\n                    this._sIndex2ColorMap[seriesArray[i]] = legend.getColor(serieName);\r\n                        \r\n                    iconShape = legend.getItemShape(serieName);\r\n                    if (iconShape) {\r\n                        // 回调legend，换一个更形象的icon\r\n                        var style = iconShape.style;\r\n                        if (this.type == ecConfig.CHART_TYPE_LINE) {\r\n                            style.iconType = 'legendLineIcon';\r\n                            style.symbol =  this._sIndex2ShapeMap[seriesArray[i]];\r\n                        }\r\n                        else if (serie.itemStyle.normal.barBorderWidth > 0) {\r\n                            var highlightStyle = iconShape.highlightStyle;\r\n                            style.brushType = 'both';\r\n                            style.x += 1;\r\n                            style.y += 1;\r\n                            style.width -= 2;\r\n                            style.height -= 2;\r\n                            style.strokeColor \r\n                                = highlightStyle.strokeColor \r\n                                = serie.itemStyle.normal.barBorderColor;\r\n                            highlightStyle.lineWidth = 3;\r\n                        }\r\n                        \r\n                        legend.setItemShape(serieName, iconShape);\r\n                    }\r\n                }\r\n                else {\r\n                    this.selectedMap[serieName] = true;\r\n                    this._sIndex2ColorMap[seriesArray[i]] = this.zr.getColor(seriesArray[i]);\r\n                }\r\n\r\n                if (this.selectedMap[serieName]) {\r\n                    stackKey = serie.stack || (magicStackKey + seriesArray[i]);\r\n                    if (stackMap[stackKey] == null) {\r\n                        stackMap[stackKey] = dataIndex;\r\n                        locationMap[dataIndex] = [seriesArray[i]];\r\n                        dataIndex++;\r\n                    }\r\n                    else {\r\n                        // 已经分配了位置就推进去就行\r\n                        locationMap[stackMap[stackKey]].push(seriesArray[i]);\r\n                    }\r\n                }\r\n                // 兼职帮算一下最大长度\r\n                maxDataLength = Math.max(maxDataLength, serie.data.length);\r\n            }\r\n            /* 调试输出\r\n            var s = '';\r\n            for (var i = 0, l = maxDataLength; i < l; i++) {\r\n                s = '[';\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    s +='['\r\n                    for (var m = 0, n = locationMap[j].length - 1; m < n; m++) {\r\n                        s += series[locationMap[j][m]].data[i] + ','\r\n                    }\r\n                    s += series[locationMap[j][locationMap[j].length - 1]]\r\n                         .data[i];\r\n                    s += ']'\r\n                }\r\n                s += ']';\r\n                console.log(s);\r\n            }\r\n            console.log(locationMap)\r\n            */\r\n\r\n            return {\r\n                locationMap: locationMap,\r\n                maxDataLength: maxDataLength\r\n            };\r\n        },\r\n        \r\n        _calculMarkMapXY : function(xMarkMap, locationMap, xy) {\r\n            var series = this.series;\r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                    var seriesIndex = locationMap[j][m];\r\n                    var valueIndex = xy == 'xy' ? 0 : '';\r\n                    var grid = this.component.grid;\r\n                    var tarMark = xMarkMap[seriesIndex];\r\n\r\n                    if (xy.indexOf('x') != '-1') {\r\n                        if (tarMark['counter' + valueIndex] > 0) {\r\n                            tarMark['average' + valueIndex] =\r\n                                tarMark['sum' + valueIndex] / tarMark['counter' + valueIndex];\r\n                        }\r\n                        \r\n                        var x = this.component.xAxis.getAxis(series[seriesIndex].xAxisIndex || 0)\r\n                                .getCoord(tarMark['average' + valueIndex]);\r\n                        tarMark['averageLine' + valueIndex] = [\r\n                            [x, grid.getYend()],\r\n                            [x, grid.getY()]\r\n                        ];\r\n                        tarMark['minLine' + valueIndex] = [\r\n                            [tarMark['minX' + valueIndex], grid.getYend()],\r\n                            [tarMark['minX' + valueIndex], grid.getY()]\r\n                        ];\r\n                        tarMark['maxLine' + valueIndex] = [\r\n                            [tarMark['maxX' + valueIndex], grid.getYend()],\r\n                            [tarMark['maxX' + valueIndex], grid.getY()]\r\n                        ];\r\n                        \r\n                        tarMark.isHorizontal = false;\r\n                    }\r\n                    \r\n                    valueIndex = xy == 'xy' ? 1 : '';\r\n                    if (xy.indexOf('y') != '-1') {\r\n                        if (tarMark['counter' + valueIndex] > 0) {\r\n                            tarMark['average' + valueIndex] = \r\n                                tarMark['sum' + valueIndex] / tarMark['counter' + valueIndex];\r\n                        }\r\n                        var y = this.component.yAxis.getAxis(series[seriesIndex].yAxisIndex || 0)\r\n                                .getCoord(tarMark['average' + valueIndex]);\r\n                        tarMark['averageLine' + valueIndex] = [\r\n                            [grid.getX(), y],\r\n                            [grid.getXend(), y]\r\n                        ];\r\n                        tarMark['minLine' + valueIndex] = [\r\n                            [grid.getX(), tarMark['minY' + valueIndex]],\r\n                            [grid.getXend(), tarMark['minY' + valueIndex]]\r\n                        ];\r\n                        tarMark['maxLine' + valueIndex] = [\r\n                            [grid.getX(), tarMark['maxY' + valueIndex]],\r\n                            [grid.getXend(), tarMark['maxY' + valueIndex]]\r\n                        ];\r\n                        \r\n                        tarMark.isHorizontal = true;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 添加文本 \r\n         */\r\n        addLabel: function (tarShape, serie, data, name, orient) {\r\n            // 多级控制\r\n            var queryTarget = [data, serie];\r\n            var nLabel = this.deepMerge(queryTarget, 'itemStyle.normal.label');\r\n            var eLabel = this.deepMerge(queryTarget, 'itemStyle.emphasis.label');\r\n\r\n            var nTextStyle = nLabel.textStyle || {};\r\n            var eTextStyle = eLabel.textStyle || {};\r\n            \r\n            if (nLabel.show) {\r\n                var style = tarShape.style;\r\n                style.text = this._getLabelText(\r\n                    serie, data, name, 'normal'\r\n                );\r\n                style.textPosition = nLabel.position == null\r\n                                     ? (orient === 'horizontal' ? 'right' : 'top')\r\n                                     : nLabel.position;\r\n                style.textColor = nTextStyle.color;\r\n                style.textFont = this.getFont(nTextStyle);\r\n                style.textAlign = nTextStyle.align;\r\n                style.textBaseline = nTextStyle.baseline;\r\n            }\r\n            if (eLabel.show) {\r\n                var highlightStyle = tarShape.highlightStyle;\r\n                highlightStyle.text = this._getLabelText(\r\n                    serie, data, name, 'emphasis'\r\n                );\r\n                highlightStyle.textPosition = nLabel.show\r\n                                              ? tarShape.style.textPosition\r\n                                              : (eLabel.position == null\r\n                                                 ? (orient === 'horizontal' ? 'right' : 'top')\r\n                                                 : eLabel.position);\r\n                highlightStyle.textColor = eTextStyle.color;\r\n                highlightStyle.textFont = this.getFont(eTextStyle);\r\n                highlightStyle.textAlign = eTextStyle.align;\r\n                highlightStyle.textBaseline = eTextStyle.baseline;\r\n            }\r\n            \r\n            return tarShape;\r\n        },\r\n        \r\n        /**\r\n         * 根据lable.format计算label text\r\n         */\r\n        _getLabelText: function (serie, data, name, status) {\r\n            var formatter = this.deepQuery(\r\n                [data, serie],\r\n                'itemStyle.' + status + '.label.formatter'\r\n            );\r\n            if (!formatter && status === 'emphasis') {\r\n                // emphasis时需要看看normal下是否有formatter\r\n                formatter = this.deepQuery(\r\n                    [data, serie],\r\n                    'itemStyle.normal.label.formatter'\r\n                );\r\n            }\r\n            \r\n            var value = this.getDataFromOption(data, '-');\r\n            \r\n            if (formatter) {\r\n                if (typeof formatter === 'function') {\r\n                    return formatter.call(\r\n                        this.myChart,\r\n                        {\r\n                            seriesName: serie.name,\r\n                            series: serie,\r\n                            name: name,\r\n                            value: value,\r\n                            data: data,\r\n                            status: status\r\n                        }\r\n                    );\r\n                }\r\n                else if (typeof formatter === 'string') {\r\n                    formatter = formatter.replace('{a}','{a0}')\r\n                                         .replace('{b}','{b0}')\r\n                                         .replace('{c}','{c0}')\r\n                                         .replace('{a0}', serie.name)\r\n                                         .replace('{b0}', name)\r\n                                         .replace('{c0}', this.numAddCommas(value));\r\n    \r\n                    return formatter;\r\n                }\r\n            }\r\n            else {\r\n                if (value instanceof Array) {\r\n                    return value[2] != null\r\n                           ? this.numAddCommas(value[2])\r\n                           : (value[0] + ' , ' + value[1]);\r\n                }\r\n                else {\r\n                    return this.numAddCommas(value);\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标线标注 \r\n         */\r\n        buildMark: function (seriesIndex) {\r\n            var serie = this.series[seriesIndex];\r\n            if (this.selectedMap[serie.name]) {\r\n                serie.markLine && this._buildMarkLine(seriesIndex);\r\n                serie.markPoint && this._buildMarkPoint(seriesIndex);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标注逻辑\r\n         */\r\n        _buildMarkPoint: function (seriesIndex) {\r\n            var attachStyle =  (this.markAttachStyle || {})[seriesIndex];\r\n            var serie = this.series[seriesIndex];\r\n            var mpData;\r\n            var pos;\r\n            var markPoint = zrUtil.clone(serie.markPoint);\r\n            for (var i = 0, l = markPoint.data.length; i < l; i++) {\r\n                mpData = markPoint.data[i];\r\n                pos = this.getMarkCoord(seriesIndex, mpData);\r\n                mpData.x = mpData.x != null ? mpData.x : pos[0];\r\n                mpData.y = mpData.y != null ? mpData.y : pos[1];\r\n                if (mpData.type\r\n                    && (mpData.type === 'max' || mpData.type === 'min')\r\n                ) {\r\n                    // 特殊值内置支持\r\n                    mpData.value = pos[3];\r\n                    mpData.name = mpData.name || mpData.type;\r\n                    mpData.symbolSize = mpData.symbolSize\r\n                        || (zrArea.getTextWidth(pos[3], this.getFont()) / 2 + 5);\r\n                }\r\n            }\r\n            \r\n            var shapeList = this._markPoint(seriesIndex, markPoint);\r\n            \r\n            for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                var tarShape = shapeList[i];\r\n                tarShape.zlevel = serie.zlevel;\r\n                tarShape.z = serie.z + 1;\r\n                for (var key in attachStyle) {\r\n                    tarShape[key] = zrUtil.clone(attachStyle[key]);\r\n                }\r\n                this.shapeList.push(tarShape);\r\n            }\r\n            // 个别特殊图表需要自己addShape\r\n            if (this.type === ecConfig.CHART_TYPE_FORCE\r\n                || this.type === ecConfig.CHART_TYPE_CHORD\r\n            ) {\r\n                for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                    this.zr.addShape(shapeList[i]);\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标线逻辑\r\n         */\r\n        _buildMarkLine: function (seriesIndex) {\r\n            var attachStyle =  (this.markAttachStyle || {})[seriesIndex];\r\n            var serie = this.series[seriesIndex];\r\n            var pos;\r\n            var markLine = zrUtil.clone(serie.markLine);\r\n            for (var i = 0, l = markLine.data.length; i < l; i++) {\r\n                var mlData = markLine.data[i];\r\n                if (mlData.type\r\n                    && (mlData.type === 'max' || mlData.type === 'min' || mlData.type === 'average')\r\n                ) {\r\n                    // 特殊值内置支持\r\n                    pos = this.getMarkCoord(seriesIndex, mlData);\r\n                    markLine.data[i] = [zrUtil.clone(mlData), {}];\r\n                    markLine.data[i][0].name = mlData.name || mlData.type;\r\n                    markLine.data[i][0].value = mlData.type !== 'average'\r\n                                                ? pos[3]\r\n                                                : +pos[3].toFixed(\r\n                                                      markLine.precision != null \r\n                                                      ? markLine.precision \r\n                                                      : this.deepQuery(\r\n                                                            [this.ecTheme, ecConfig],\r\n                                                            'markLine.precision'\r\n                                                        )\r\n                                                  );\r\n                    pos = pos[2];\r\n                    mlData = [{},{}];\r\n                }\r\n                else {\r\n                    pos = [\r\n                        this.getMarkCoord(seriesIndex, mlData[0]),\r\n                        this.getMarkCoord(seriesIndex, mlData[1])\r\n                    ];\r\n                }\r\n                if (pos == null || pos[0] == null || pos[1] == null) {\r\n                    // 不在显示区域内\r\n                    continue;\r\n                }\r\n                markLine.data[i][0].x = mlData[0].x != null ? mlData[0].x : pos[0][0];\r\n                markLine.data[i][0].y = mlData[0].y != null ? mlData[0].y : pos[0][1];\r\n                markLine.data[i][1].x = mlData[1].x != null ? mlData[1].x : pos[1][0];\r\n                markLine.data[i][1].y = mlData[1].y != null ? mlData[1].y : pos[1][1];\r\n            }\r\n            \r\n            var shapeList = this._markLine(seriesIndex, markLine);\r\n\r\n            var isLarge = markLine.large;\r\n\r\n            if (isLarge) {\r\n                var shapeBundle = new ShapeBundle({\r\n                    style: {\r\n                        shapeList: shapeList\r\n                    }\r\n                });\r\n                var firstShape = shapeList[0];\r\n                if (firstShape) {\r\n                    zrUtil.merge(shapeBundle.style, firstShape.style);\r\n                    zrUtil.merge(shapeBundle.highlightStyle = {}, firstShape.highlightStyle);\r\n                    shapeBundle.style.brushType = 'stroke';\r\n                    shapeBundle.zlevel = serie.zlevel;\r\n                    shapeBundle.z = serie.z + 1;\r\n                    shapeBundle.hoverable = false;\r\n                    for (var key in attachStyle) {\r\n                        shapeBundle[key] = zrUtil.clone(attachStyle[key]);\r\n                    }\r\n                }\r\n                this.shapeList.push(shapeBundle);\r\n                this.zr.addShape(shapeBundle);\r\n\r\n                shapeBundle._mark = 'largeLine';\r\n                var effect = markLine.effect;\r\n                if (effect.show) {\r\n                    shapeBundle.effect = effect;\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                    var tarShape = shapeList[i];\r\n                    tarShape.zlevel = serie.zlevel;\r\n                    tarShape.z = serie.z + 1;\r\n                    for (var key in attachStyle) {\r\n                        tarShape[key] = zrUtil.clone(attachStyle[key]);\r\n                    }\r\n                    this.shapeList.push(tarShape);\r\n                }\r\n                // 个别特殊图表需要自己addShape\r\n                if (this.type === ecConfig.CHART_TYPE_FORCE\r\n                    || this.type === ecConfig.CHART_TYPE_CHORD\r\n                ) {\r\n                    for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                        this.zr.addShape(shapeList[i]);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标注多级控制构造\r\n         */\r\n        _markPoint: function (seriesIndex, mpOption) {\r\n            var serie = this.series[seriesIndex];\r\n            var component = this.component;\r\n            zrUtil.merge(\r\n                zrUtil.merge(\r\n                    mpOption,\r\n                    zrUtil.clone(this.ecTheme.markPoint || {})\r\n                ),\r\n                zrUtil.clone(ecConfig.markPoint)\r\n            );\r\n\r\n            mpOption.name = serie.name;\r\n                   \r\n            var pList = [];\r\n            var data = mpOption.data;\r\n            var itemShape;\r\n            \r\n            var dataRange = component.dataRange;\r\n            var legend = component.legend;\r\n            var color;\r\n            var value;\r\n            var queryTarget;\r\n            var nColor;\r\n            var eColor;\r\n            var effect;\r\n            var zrWidth = this.zr.getWidth();\r\n            var zrHeight = this.zr.getHeight();\r\n\r\n            if (!mpOption.large) {\r\n                for (var i = 0, l = data.length; i < l; i++) {\r\n                    if (data[i].x == null || data[i].y == null) {\r\n                        continue;\r\n                    }\r\n                    value = data[i].value != null ? data[i].value : '';\r\n                    // 图例\r\n                    if (legend) {\r\n                        color = legend.getColor(serie.name);\r\n                    }\r\n                    // 值域\r\n                    if (dataRange) {\r\n                        color = isNaN(value) ? color : dataRange.getColor(value);\r\n                        \r\n                        queryTarget = [data[i], mpOption];\r\n                        nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color')\r\n                                 || color;\r\n                        eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color')\r\n                                 || nColor;\r\n                        // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark\r\n                        if (nColor == null && eColor == null) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    \r\n                    color = color == null ? this.zr.getColor(seriesIndex) : color;\r\n                    \r\n                    // 标准化一些参数\r\n                    data[i].tooltip = data[i].tooltip\r\n                                      || mpOption.tooltip\r\n                                      || {trigger:'item'}; // tooltip.trigger指定为item\r\n                    data[i].name = data[i].name != null ? data[i].name : '';\r\n                    data[i].value = value;\r\n\r\n                    // 复用getSymbolShape\r\n                    itemShape = this.getSymbolShape(\r\n                        mpOption, seriesIndex,      // 系列 \r\n                        data[i], i, data[i].name,   // 数据\r\n                        this.parsePercent(data[i].x, zrWidth),   // 坐标\r\n                        this.parsePercent(data[i].y, zrHeight),  // 坐标\r\n                        'pin', color,               // 默认symbol和color\r\n                        'rgba(0,0,0,0)',\r\n                        'horizontal'                // 走向，用于默认文字定位\r\n                    );\r\n                    itemShape._mark = 'point';\r\n                    \r\n                    effect = this.deepMerge(\r\n                        [data[i], mpOption],\r\n                        'effect'\r\n                    );\r\n                    if (effect.show) {\r\n                        itemShape.effect = effect;\r\n                    }\r\n                    \r\n                    if (serie.type === ecConfig.CHART_TYPE_MAP) {\r\n                        itemShape._geo = this.getMarkGeo(data[i]);\r\n                    }\r\n                    \r\n                    // 重新pack一下数据\r\n                    ecData.pack(\r\n                        itemShape,\r\n                        serie, seriesIndex,\r\n                        data[i], i,\r\n                        data[i].name,\r\n                        value\r\n                    );\r\n                    pList.push(itemShape);\r\n                }\r\n            }\r\n            else {\r\n                // 大规模MarkPoint\r\n                itemShape = this.getLargeMarkPointShape(seriesIndex, mpOption);\r\n                itemShape._mark = 'largePoint';\r\n                itemShape && pList.push(itemShape);\r\n            }\r\n            return pList;\r\n        },\r\n        \r\n        /**\r\n         * 标线多级控制构造\r\n         */\r\n        _markLine: (function () {\r\n            function normalizeOptionValue(mlOption, key) {\r\n                mlOption[key] = mlOption[key] instanceof Array\r\n                          ? mlOption[key].length > 1 \r\n                            ? mlOption[key] \r\n                            : [mlOption[key][0], mlOption[key][0]]\r\n                          : [mlOption[key], mlOption[key]];\r\n            }\r\n\r\n            return function (seriesIndex, mlOption) {\r\n                var serie = this.series[seriesIndex];\r\n                var component = this.component;\r\n                var dataRange = component.dataRange;\r\n                var legend = component.legend;\r\n\r\n                zrUtil.merge(\r\n                    zrUtil.merge(\r\n                        mlOption,\r\n                        zrUtil.clone(this.ecTheme.markLine || {})\r\n                    ),\r\n                    zrUtil.clone(ecConfig.markLine)\r\n                );\r\n\r\n                var defaultColor = legend ? legend.getColor(serie.name)\r\n                    : this.zr.getColor(seriesIndex);\r\n\r\n                // 标准化一些同时支持Array和String的参数\r\n                normalizeOptionValue(mlOption, 'symbol');\r\n                normalizeOptionValue(mlOption, 'symbolSize');\r\n                normalizeOptionValue(mlOption, 'symbolRotate');\r\n\r\n                // Normalize and filter data\r\n                var data = mlOption.data;\r\n                var edges = [];\r\n                var zrWidth = this.zr.getWidth();\r\n                var zrHeight = this.zr.getHeight();\r\n                for (var i = 0; i < data.length; i++) {\r\n                    var mlData = data[i];\r\n                    if (isCoordAvailable(mlData[0])\r\n                        && isCoordAvailable(mlData[1])\r\n                    ) {\r\n                        // 组装一个mergeData\r\n                        var mergeData = this.deepMerge(mlData);\r\n                        var queryTarget = [mergeData, mlOption];\r\n                        var color = defaultColor;\r\n                        var value = mergeData.value != null ? mergeData.value : '';\r\n                        // 值域\r\n                        if (dataRange) {\r\n                            color = isNaN(value) ? color : dataRange.getColor(value);\r\n\r\n                            var nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color')\r\n                                     || color;\r\n                            var eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color')\r\n                                     || nColor;\r\n                            // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark\r\n                            if (nColor == null && eColor == null) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        // 标准化一些参数\r\n                        mlData[0].tooltip = mergeData.tooltip\r\n                                            || mlOption.tooltip\r\n                                            || {trigger:'item'}; // tooltip.trigger指定为item\r\n                        mlData[0].name = mlData[0].name || '';\r\n                        mlData[1].name = mlData[1].name || '';\r\n                        mlData[0].value = value;\r\n\r\n                        edges.push({\r\n                            points: [\r\n                                [this.parsePercent(mlData[0].x, zrWidth),\r\n                                this.parsePercent(mlData[0].y, zrHeight)],\r\n                                [this.parsePercent(mlData[1].x, zrWidth),\r\n                                this.parsePercent(mlData[1].y, zrHeight)]\r\n                            ],\r\n                            rawData: mlData,\r\n                            color: color\r\n                        });\r\n                    }\r\n                }\r\n\r\n                var enableBundling = this.query(mlOption, 'bundling.enable');\r\n                if (enableBundling) {\r\n                    var edgeBundling = new EdgeBundling();\r\n                    edgeBundling.maxTurningAngle = this.query(\r\n                        mlOption, 'bundling.maxTurningAngle'\r\n                    ) / 180 * Math.PI;\r\n                    edges = edgeBundling.run(edges);\r\n                }\r\n\r\n                mlOption.name = serie.name;\r\n  \r\n                var shapeList = [];\r\n\r\n                for (var i = 0, l = edges.length; i < l; i++) {\r\n                    var edge = edges[i];\r\n                    var rawEdge = edge.rawEdge || edge; \r\n                    var mlData = rawEdge.rawData;\r\n                    var value = mlData.value != null ? mlData.value : '';\r\n\r\n                    var itemShape = this.getMarkLineShape(\r\n                        mlOption,\r\n                        seriesIndex,\r\n                        mlData,\r\n                        i,\r\n                        edge.points,\r\n                        enableBundling,\r\n                        rawEdge.color\r\n                    );\r\n                    itemShape._mark = 'line';\r\n                    \r\n                    var effect = this.deepMerge(\r\n                        [mlData[0], mlData[1], mlOption],\r\n                        'effect'\r\n                    );\r\n                    if (effect.show) {\r\n                        itemShape.effect = effect;\r\n                        itemShape.effect.large = mlOption.large;\r\n                    }\r\n                    \r\n                    if (serie.type === ecConfig.CHART_TYPE_MAP) {\r\n                        itemShape._geo = [\r\n                            this.getMarkGeo(mlData[0]),\r\n                            this.getMarkGeo(mlData[1])\r\n                        ];\r\n                    }\r\n                    \r\n                    // 重新pack一下数据\r\n                    ecData.pack(\r\n                        itemShape,\r\n                        serie, seriesIndex,\r\n                        mlData[0], i,\r\n                        mlData[0].name \r\n                            // 不要帮我代码规范\r\n                            + (mlData[1].name !== '' ? (' > ' + mlData[1].name) : ''),\r\n                        value\r\n                    );\r\n                    shapeList.push(itemShape);\r\n                }\r\n\r\n                return shapeList;\r\n            };\r\n        })(),\r\n        \r\n        getMarkCoord: function () {\r\n            // 无转换位置\r\n            return [0, 0];\r\n        },\r\n        \r\n        /**\r\n         * symbol构造器 \r\n         */\r\n        getSymbolShape: function (\r\n            serie, seriesIndex,     // 系列 \r\n            data, dataIndex, name,  // 数据\r\n            x, y,                   // 坐标\r\n            symbol, color,          // 默认symbol和color，来自legend或dataRange全局分配\r\n            emptyColor,             // 折线的emptySymbol用白色填充\r\n            orient                  // 走向，用于默认文字定位\r\n        ) {\r\n            var queryTarget = [data, serie];\r\n            var value = this.getDataFromOption(data, '-');\r\n            \r\n            symbol = this.deepQuery(queryTarget, 'symbol') || symbol;\r\n            var symbolSize = this.deepQuery(queryTarget, 'symbolSize');\r\n            symbolSize = typeof symbolSize === 'function'\r\n                         ? symbolSize(value)\r\n                         : symbolSize;\r\n            if (typeof symbolSize === 'number') {\r\n                symbolSize = [symbolSize, symbolSize];\r\n            }\r\n            var symbolRotate = this.deepQuery(queryTarget, 'symbolRotate');\r\n            \r\n            var normal = this.deepMerge(\r\n                queryTarget,\r\n                'itemStyle.normal'\r\n            );\r\n            var emphasis = this.deepMerge(\r\n                queryTarget,\r\n                'itemStyle.emphasis'\r\n            );\r\n            var nBorderWidth = normal.borderWidth != null\r\n                               ? normal.borderWidth\r\n                               : (normal.lineStyle && normal.lineStyle.width);\r\n            if (nBorderWidth == null) {\r\n                nBorderWidth = symbol.match('empty') ? 2 : 0;\r\n            }\r\n            var eBorderWidth = emphasis.borderWidth != null\r\n                               ? emphasis.borderWidth\r\n                               : (emphasis.lineStyle && emphasis.lineStyle.width);\r\n            if (eBorderWidth == null) {\r\n                eBorderWidth = nBorderWidth + 2;\r\n            }\r\n\r\n            var nColor = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);\r\n            var eColor = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);\r\n            \r\n            var width = symbolSize[0];\r\n            var height = symbolSize[1];\r\n            var itemShape = new IconShape({\r\n                style: {\r\n                    iconType: symbol.replace('empty', '').toLowerCase(),\r\n                    x: x - width,\r\n                    y: y - height,\r\n                    width: width * 2,\r\n                    height: height * 2,\r\n                    brushType: 'both',\r\n                    color: symbol.match('empty') \r\n                           ? emptyColor \r\n                           : (nColor || color),\r\n                    strokeColor: normal.borderColor || nColor || color,\r\n                    lineWidth: nBorderWidth\r\n                },\r\n                highlightStyle: {\r\n                    color: symbol.match('empty') \r\n                           ? emptyColor \r\n                           : (eColor || nColor || color),\r\n                    strokeColor: emphasis.borderColor \r\n                                 || normal.borderColor\r\n                                 || eColor\r\n                                 || nColor\r\n                                 || color,\r\n                    lineWidth: eBorderWidth\r\n                },\r\n                clickable: this.deepQuery(queryTarget, 'clickable')\r\n            });\r\n\r\n            if (symbol.match('image')) {\r\n                itemShape.style.image = symbol.replace(new RegExp('^image:\\\\/\\\\/'), '');\r\n                itemShape = new ImageShape({\r\n                    style: itemShape.style,\r\n                    highlightStyle: itemShape.highlightStyle,\r\n                    clickable: this.deepQuery(queryTarget, 'clickable')\r\n                });\r\n            }\r\n            \r\n            if (symbolRotate != null) {\r\n                itemShape.rotation = [\r\n                    symbolRotate * Math.PI / 180, x, y\r\n                ];\r\n            }\r\n            \r\n            if (symbol.match('star')) {\r\n                itemShape.style.iconType = 'star';\r\n                itemShape.style.n = \r\n                    (symbol.replace('empty', '').replace('star','') - 0) || 5;\r\n            }\r\n            \r\n            if (symbol === 'none') {\r\n                itemShape.invisible = true;\r\n                itemShape.hoverable = false;\r\n            }\r\n            \r\n            /*\r\n            if (this.deepQuery([data, serie, option], 'calculable')) {\r\n                this.setCalculable(itemShape);\r\n                itemShape.draggable = true;\r\n            }\r\n            */\r\n\r\n            itemShape = this.addLabel(\r\n                itemShape, \r\n                serie, data, name, \r\n                orient\r\n            );\r\n            \r\n            if (symbol.match('empty')) {\r\n                if (itemShape.style.textColor == null) {\r\n                    itemShape.style.textColor = itemShape.style.strokeColor;\r\n                }\r\n                if (itemShape.highlightStyle.textColor == null) {\r\n                    itemShape.highlightStyle.textColor = \r\n                        itemShape.highlightStyle.strokeColor;\r\n                }\r\n            }\r\n            \r\n            ecData.pack(\r\n                itemShape,\r\n                serie, seriesIndex,\r\n                data, dataIndex,\r\n                name\r\n            );\r\n\r\n            itemShape._x = x;\r\n            itemShape._y = y;\r\n            \r\n            itemShape._dataIndex = dataIndex;\r\n            itemShape._seriesIndex = seriesIndex;\r\n\r\n            return itemShape;\r\n        },\r\n        \r\n        /**\r\n         * 标线构造器 \r\n         */\r\n        getMarkLineShape: function (\r\n            mlOption,               // 系列 \r\n            seriesIndex,            // 系列索引\r\n            data,                   // 数据\r\n            dataIndex,              // 数据索引\r\n            points,                 // 坐标点\r\n            bundling,               // 是否边捆绑过\r\n            color                   // 默认color，来自legend或dataRange全局分配\r\n        ) {\r\n            var value0 = data[0].value != null ? data[0].value : '-';\r\n            var value1 = data[1].value != null ? data[1].value : '-';\r\n            var symbol = [\r\n                data[0].symbol || mlOption.symbol[0],\r\n                data[1].symbol || mlOption.symbol[1]\r\n            ];\r\n            var symbolSize = [\r\n                data[0].symbolSize || mlOption.symbolSize[0],\r\n                data[1].symbolSize || mlOption.symbolSize[1]\r\n            ];\r\n            symbolSize[0] = typeof symbolSize[0] === 'function'\r\n                            ? symbolSize[0](value0)\r\n                            : symbolSize[0];\r\n            symbolSize[1] = typeof symbolSize[1] === 'function'\r\n                            ? symbolSize[1](value1)\r\n                            : symbolSize[1];\r\n            var symbolRotate = [\r\n                this.query(data[0], 'symbolRotate') || mlOption.symbolRotate[0],\r\n                this.query(data[1], 'symbolRotate') || mlOption.symbolRotate[1]\r\n            ];\r\n            //console.log(symbol, symbolSize, symbolRotate);\r\n\r\n            var queryTarget = [data[0], data[1], mlOption];\r\n            var normal = this.deepMerge(\r\n                queryTarget,\r\n                'itemStyle.normal'\r\n            );\r\n            normal.color = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);\r\n            var emphasis = this.deepMerge(\r\n                queryTarget,\r\n                'itemStyle.emphasis'\r\n            );\r\n            emphasis.color = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);\r\n            \r\n            var nlineStyle = normal.lineStyle;\r\n            var elineStyle = emphasis.lineStyle;\r\n            \r\n            var nBorderWidth = nlineStyle.width;\r\n            if (nBorderWidth == null) {\r\n                nBorderWidth = normal.borderWidth;\r\n            }\r\n            var eBorderWidth = elineStyle.width;\r\n            if (eBorderWidth == null) {\r\n                eBorderWidth = emphasis.borderWidth != null \r\n                               ? emphasis.borderWidth\r\n                               : (nBorderWidth + 2);\r\n            }\r\n            var smoothness = this.deepQuery(queryTarget, 'smoothness');\r\n            if (! this.deepQuery(queryTarget, 'smooth')) {\r\n                smoothness = 0;\r\n            }\r\n\r\n            var ShapeCtor = bundling ? PolylineShape : MarkLineShape;\r\n            var itemShape = new ShapeCtor({\r\n                style: {\r\n                    symbol: symbol,\r\n                    symbolSize: symbolSize,\r\n                    symbolRotate: symbolRotate,\r\n                    // data: [data[0].name,data[1].name],\r\n                    brushType: 'both',\r\n                    lineType: nlineStyle.type,\r\n                    shadowColor: nlineStyle.shadowColor\r\n                                 || nlineStyle.color\r\n                                 || normal.borderColor\r\n                                 || normal.color\r\n                                 || color,\r\n                    shadowBlur: nlineStyle.shadowBlur,\r\n                    shadowOffsetX: nlineStyle.shadowOffsetX,\r\n                    shadowOffsetY: nlineStyle.shadowOffsetY,\r\n                    color: normal.color || color,\r\n                    strokeColor: nlineStyle.color\r\n                                 || normal.borderColor\r\n                                 || normal.color\r\n                                 || color,\r\n                    lineWidth: nBorderWidth,\r\n                    symbolBorderColor: normal.borderColor\r\n                                       || normal.color\r\n                                       || color,\r\n                    symbolBorder: normal.borderWidth\r\n                },\r\n                highlightStyle: {\r\n                    shadowColor: elineStyle.shadowColor,\r\n                    shadowBlur: elineStyle.shadowBlur,\r\n                    shadowOffsetX: elineStyle.shadowOffsetX,\r\n                    shadowOffsetY: elineStyle.shadowOffsetY,\r\n                    color: emphasis.color|| normal.color || color,\r\n                    strokeColor: elineStyle.color\r\n                                 || nlineStyle.color\r\n                                 || emphasis.borderColor \r\n                                 || normal.borderColor\r\n                                 || emphasis.color \r\n                                 || normal.color\r\n                                 || color,\r\n                    lineWidth: eBorderWidth,\r\n                    symbolBorderColor: emphasis.borderColor\r\n                                       || normal.borderColor\r\n                                       || emphasis.color\r\n                                       || normal.color\r\n                                       || color,\r\n                    symbolBorder: emphasis.borderWidth == null\r\n                                  ? (normal.borderWidth + 2)\r\n                                  : (emphasis.borderWidth)\r\n                },\r\n                clickable: this.deepQuery(queryTarget, 'clickable')\r\n            });\r\n            var shapeStyle = itemShape.style;\r\n            if (bundling) {\r\n                shapeStyle.pointList = points;\r\n                shapeStyle.smooth = smoothness;\r\n            }\r\n            else {\r\n                shapeStyle.xStart = points[0][0];\r\n                shapeStyle.yStart = points[0][1];\r\n                shapeStyle.xEnd = points[1][0];\r\n                shapeStyle.yEnd = points[1][1];\r\n                shapeStyle.curveness = smoothness;\r\n                itemShape.updatePoints(itemShape.style);\r\n            }\r\n            \r\n            itemShape = this.addLabel(\r\n                itemShape, \r\n                mlOption, \r\n                data[0], \r\n                data[0].name + ' : ' + data[1].name\r\n            );\r\n\r\n            return itemShape;\r\n        },\r\n        \r\n        /**\r\n         * 大规模标注构造器 \r\n         */\r\n        getLargeMarkPointShape: function(seriesIndex, mpOption) {\r\n            var serie = this.series[seriesIndex];\r\n            var component = this.component;\r\n            var data = mpOption.data;\r\n            var itemShape;\r\n            \r\n            var dataRange = component.dataRange;\r\n            var legend = component.legend;\r\n            var color;\r\n            var value;\r\n            var queryTarget = [data[0], mpOption];\r\n            var nColor;\r\n            var eColor;\r\n            var effect;\r\n            \r\n            // 图例\r\n            if (legend) {\r\n                color = legend.getColor(serie.name);\r\n            }\r\n            // 值域\r\n            if (dataRange) {\r\n                value = data[0].value != null ? data[0].value : '';\r\n                color = isNaN(value) ? color : dataRange.getColor(value);\r\n                \r\n                nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color')\r\n                         || color;\r\n                eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color')\r\n                         || nColor;\r\n                // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark\r\n                if (nColor == null && eColor == null) {\r\n                    return;\r\n                }\r\n            }\r\n            color = this.deepMerge(queryTarget, 'itemStyle.normal').color \r\n                    || color;\r\n            \r\n            var symbol = this.deepQuery(queryTarget, 'symbol') || 'circle';\r\n            symbol = symbol.replace('empty', '').replace(/\\d/g, '');\r\n            \r\n            effect = this.deepMerge(\r\n                [data[0], mpOption],\r\n                'effect'\r\n            );\r\n            \r\n            var devicePixelRatio = window.devicePixelRatio || 1;\r\n            \r\n            //console.log(data)\r\n            itemShape = new SymbolShape({\r\n                style: {\r\n                    pointList: data,\r\n                    color: color,\r\n                    strokeColor: color,\r\n                    shadowColor: effect.shadowColor || color,\r\n                    shadowBlur: (effect.shadowBlur != null ? effect.shadowBlur : 8)\r\n                                 * devicePixelRatio,\r\n                    size: this.deepQuery(queryTarget, 'symbolSize'),\r\n                    iconType: symbol,\r\n                    brushType: 'fill',\r\n                    lineWidth:1\r\n                },\r\n                draggable: false,\r\n                hoverable: false\r\n            });\r\n            \r\n            if (effect.show) {\r\n                itemShape.effect = effect;\r\n            }\r\n            \r\n            return itemShape;\r\n        },\r\n        \r\n        backupShapeList: function () {\r\n            if (this.shapeList && this.shapeList.length > 0) {\r\n                this.lastShapeList = this.shapeList;\r\n                this.shapeList = [];\r\n            }\r\n            else {\r\n                this.lastShapeList = [];\r\n            }\r\n        },\r\n        \r\n        addShapeList: function () {\r\n            var maxLenth = this.option.animationThreshold / (this.canvasSupported ? 2 : 4);\r\n            var lastShapeList = this.lastShapeList;\r\n            var shapeList = this.shapeList;\r\n            var isUpdate = lastShapeList.length > 0;\r\n            var duration = isUpdate\r\n                           ? this.query(this.option, 'animationDurationUpdate')\r\n                           : this.query(this.option, 'animationDuration');\r\n            var easing = this.query(this.option, 'animationEasing');\r\n            var delay;\r\n            var key;\r\n            var oldMap = {};\r\n            var newMap = {};\r\n            if (this.option.animation \r\n                && !this.option.renderAsImage \r\n                && shapeList.length < maxLenth\r\n                && !this.motionlessOnce\r\n            ) {\r\n                // 通过已有的shape做动画过渡\r\n                for (var i = 0, l = lastShapeList.length; i < l; i++) {\r\n                    key = this._getAnimationKey(lastShapeList[i]);\r\n                    if (key.match('undefined')) {\r\n                        this.zr.delShape(lastShapeList[i].id);  // 非关键元素直接删除\r\n                    }\r\n                    else {\r\n                        key += lastShapeList[i].type;\r\n                        // https://github.com/ecomfe/echarts/issues/1219#issuecomment-71987602\r\n                        // 响应中断可能产生的重复元素\r\n                        if (oldMap[key]) {\r\n                            this.zr.delShape(lastShapeList[i].id);\r\n                        }\r\n                        else {\r\n                            oldMap[key] = lastShapeList[i];\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                    key = this._getAnimationKey(shapeList[i]);\r\n                    if (key.match('undefined')) {\r\n                        this.zr.addShape(shapeList[i]);         // 非关键元素直接添加\r\n                    }\r\n                    else {\r\n                        key += shapeList[i].type;\r\n                        newMap[key] = shapeList[i];\r\n                    }\r\n                }\r\n                \r\n                for (key in oldMap) {\r\n                    if (!newMap[key]) {\r\n                        // 新的没有 删除\r\n                        this.zr.delShape(oldMap[key].id);\r\n                    }\r\n                }\r\n                for (key in newMap) {\r\n                    if (oldMap[key]) {\r\n                        // 新旧都有 动画过渡\r\n                        this.zr.delShape(oldMap[key].id);\r\n                        this._animateMod(\r\n                            oldMap[key], newMap[key], duration, easing, 0, isUpdate\r\n                        );\r\n                    }\r\n                    else {\r\n                        // 新有旧没有  添加并动画过渡\r\n                        //this._animateAdd(newMap[key], duration, easing);\r\n                        delay = (this.type == ecConfig.CHART_TYPE_LINE\r\n                                || this.type == ecConfig.CHART_TYPE_RADAR)\r\n                                && key.indexOf('icon') !== 0\r\n                                ? duration / 2\r\n                                : 0;\r\n                        this._animateMod(\r\n                            false, newMap[key], duration, easing, delay, isUpdate\r\n                        );\r\n                    }\r\n                }\r\n                this.zr.refresh();\r\n                this.animationEffect();\r\n            }\r\n            else {\r\n                this.motionlessOnce = false;\r\n                // clear old\r\n                this.zr.delShape(lastShapeList);\r\n                // 直接添加\r\n                for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                    this.zr.addShape(shapeList[i]);\r\n                }\r\n            }\r\n        },\r\n        \r\n        _getAnimationKey: function(shape) {\r\n            if (this.type != ecConfig.CHART_TYPE_MAP\r\n                && this.type != ecConfig.CHART_TYPE_TREEMAP\r\n                && this.type != ecConfig.CHART_TYPE_VENN\r\n                && this.type != ecConfig.CHART_TYPE_TREE\r\n                ) {\r\n                return ecData.get(shape, 'seriesIndex') + '_'\r\n                       + ecData.get(shape, 'dataIndex')\r\n                       + (shape._mark ? shape._mark : '')\r\n                       + (this.type === ecConfig.CHART_TYPE_RADAR \r\n                          ? ecData.get(shape, 'special') : '');\r\n            }\r\n            else {\r\n                return ecData.get(shape, 'seriesIndex') + '_'\r\n                       + ecData.get(shape, 'dataIndex')\r\n                       + (shape._mark ? shape._mark : 'undefined');\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 动画过渡 \r\n         */\r\n        _animateMod: function (oldShape, newShape, duration, easing, delay, isUpdate) {\r\n            switch (newShape.type) {\r\n                case 'polyline' :\r\n                case 'half-smooth-polygon' :\r\n                    ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'rectangle' :\r\n                    ecAnimation.rectangle(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'image' :\r\n                case 'icon' :\r\n                    ecAnimation.icon(this.zr, oldShape, newShape, duration, easing, delay);\r\n                    break;\r\n                case 'candle' :\r\n                    if (!isUpdate) {\r\n                        ecAnimation.candle(this.zr, oldShape, newShape, duration, easing);\r\n                    }\r\n                    else {\r\n                        this.zr.addShape(newShape);\r\n                    }\r\n                    break;\r\n                case 'ring' :\r\n                case 'sector' :\r\n                case 'circle' :\r\n                    if (!isUpdate) {\r\n                        // 进入动画，加旋转\r\n                        ecAnimation.ring(\r\n                            this.zr,\r\n                            oldShape,\r\n                            newShape, \r\n                            duration + ((ecData.get(newShape, 'dataIndex') || 0) % 20 * 100), \r\n                            easing\r\n                        );\r\n                    }\r\n                    else if (newShape.type === 'sector') {\r\n                        ecAnimation.sector(this.zr, oldShape, newShape, duration, easing);\r\n                    }\r\n                    else {\r\n                        this.zr.addShape(newShape);\r\n                    }\r\n                    break;\r\n                case 'text' :\r\n                    ecAnimation.text(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'polygon' :\r\n                    if (!isUpdate) {\r\n                        ecAnimation.polygon(this.zr, oldShape, newShape, duration, easing);\r\n                    }\r\n                    else {\r\n                        ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);\r\n                    }\r\n                    break;\r\n                case 'ribbon' :\r\n                    ecAnimation.ribbon(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'gauge-pointer' :\r\n                    ecAnimation.gaugePointer(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'mark-line' :\r\n                    ecAnimation.markline(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'bezier-curve' :\r\n                case 'line' :\r\n                    ecAnimation.line(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                default :\r\n                    this.zr.addShape(newShape);\r\n                    break;\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标注动画\r\n         * @param {number} duration 时长\r\n         * @param {string=} easing 缓动效果\r\n         * @param {Array=} shapeList 指定特效对象，不指定默认使用this.shapeList\r\n         */\r\n        animationMark: function (duration , easing, shapeList) {\r\n            var shapeList = shapeList || this.shapeList;\r\n            for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                if (!shapeList[i]._mark) {\r\n                    continue;\r\n                }\r\n                this._animateMod(false, shapeList[i], duration, easing, 0, true);\r\n            }\r\n            this.animationEffect(shapeList);\r\n        },\r\n\r\n        /**\r\n         * 特效动画\r\n         * @param {Array=} shapeList 指定特效对象，不知道默认使用this.shapeList\r\n         */\r\n        animationEffect: function (shapeList) {\r\n            !shapeList && this.clearEffectShape();\r\n            shapeList = shapeList || this.shapeList;\r\n            if (shapeList == null) {\r\n                return;\r\n            }\r\n            var zlevel = ecConfig.EFFECT_ZLEVEL;\r\n            if (this.canvasSupported) {\r\n                this.zr.modLayer(\r\n                    zlevel,\r\n                    {\r\n                        motionBlur: true,\r\n                        lastFrameAlpha: this.option.effectBlendAlpha\r\n                            || ecConfig.effectBlendAlpha\r\n                    }\r\n                );\r\n            }\r\n            var shape;\r\n            for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                shape = shapeList[i];\r\n                if (!(shape._mark && shape.effect && shape.effect.show && ecEffect[shape._mark])) {\r\n                    continue;\r\n                }\r\n                ecEffect[shape._mark](this.zr, this.effectList, shape, zlevel);\r\n                this.effectList[this.effectList.length - 1]._mark = shape._mark;\r\n            }\r\n        },\r\n        \r\n        clearEffectShape: function (clearMotionBlur) {\r\n            var effectList = this.effectList;\r\n            if (this.zr && effectList && effectList.length > 0) {\r\n                clearMotionBlur && this.zr.modLayer(\r\n                    ecConfig.EFFECT_ZLEVEL, \r\n                    { motionBlur: false }\r\n                );\r\n                this.zr.delShape(effectList);\r\n\r\n                // 手动清除不会被 zr 自动清除的动画控制器\r\n                for (var i = 0; i < effectList.length; i++) {\r\n                    if (effectList[i].effectAnimator) {\r\n                        effectList[i].effectAnimator.stop();\r\n                    }\r\n                }\r\n            }\r\n            this.effectList = [];\r\n        },\r\n        \r\n        /**\r\n         * 动态标线标注添加\r\n         * @param {number} seriesIndex 系列索引\r\n         * @param {Object} markData 标线标注对象，支持多个\r\n         * @param {string} markType 标线标注类型\r\n         */\r\n        addMark: function (seriesIndex, markData, markType) {\r\n            var serie = this.series[seriesIndex];\r\n            if (this.selectedMap[serie.name]) {\r\n                var duration = this.query(this.option, 'animationDurationUpdate');\r\n                var easing = this.query(this.option, 'animationEasing');\r\n                // 备份，复用_buildMarkX\r\n                var oriMarkData = serie[markType].data;\r\n                var lastLength = this.shapeList.length;\r\n                \r\n                serie[markType].data = markData.data;\r\n                this['_build' + markType.replace('m', 'M')](seriesIndex);\r\n                if (this.option.animation && !this.option.renderAsImage) {\r\n                    // animationMark就会addShape\r\n                    this.animationMark(duration, easing, this.shapeList.slice(lastLength));\r\n                }\r\n                else {\r\n                    for (var i = lastLength, l = this.shapeList.length; i < l; i++) {\r\n                        this.zr.addShape(this.shapeList[i]);\r\n                    }\r\n                    this.zr.refreshNextFrame();\r\n                }\r\n                // 还原，复用_buildMarkX\r\n                serie[markType].data = oriMarkData;\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 动态标线标注删除\r\n         * @param {number} seriesIndex 系列索引\r\n         * @param {string} markName 标线标注名称\r\n         * @param {string} markType 标线标注类型\r\n         */\r\n        delMark: function (seriesIndex, markName, markType) {\r\n            markType = markType.replace('mark', '').replace('large', '').toLowerCase();\r\n            var serie = this.series[seriesIndex];\r\n            if (this.selectedMap[serie.name]) {\r\n                var needRefresh = false;\r\n                var shapeList = [this.shapeList, this.effectList];\r\n                var len = 2;\r\n                while(len--) {\r\n                    for (var i = 0, l = shapeList[len].length; i < l; i++) {\r\n                        if (shapeList[len][i]._mark == markType\r\n                            && ecData.get(shapeList[len][i], 'seriesIndex') == seriesIndex\r\n                            && ecData.get(shapeList[len][i], 'name') == markName\r\n                        ) {\r\n                            this.zr.delShape(shapeList[len][i].id);\r\n                            shapeList[len].splice(i, 1);\r\n                            needRefresh = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                needRefresh && this.zr.refreshNextFrame();\r\n            }\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(Base, ComponentBase);\r\n\r\n    return Base;\r\n});\r\n"
        },
        {
          "id": 6,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Image.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
          "index": 6,
          "index2": 13,
          "size": 7017,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Image",
              "loc": "10:21-53"
            },
            {
              "moduleId": 20,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Image",
              "loc": "493:25-57"
            },
            {
              "moduleId": 20,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Image",
              "loc": "546:33-65"
            },
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Image",
              "loc": "12:21-53"
            }
          ],
          "source": "/**\r\n * 图片绘制\r\n * @module zrender/shape/Image\r\n * @author pissang(https://www.github.com/pissang)\r\n * @example\r\n *     var ImageShape = require('zrender/shape/Image');\r\n *     var image = new ImageShape({\r\n *         style: {\r\n *             image: 'test.jpg',\r\n *             x: 100,\r\n *             y: 100\r\n *         }\r\n *     });\r\n *     zr.addShape(image);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IImageStyle\r\n * @property {string|HTMLImageElement|HTMLCanvasElement} image 图片url或者图片对象\r\n * @property {number} x 左上角横坐标\r\n * @property {number} y 左上角纵坐标\r\n * @property {number} [width] 绘制到画布上的宽度，默认为图片宽度\r\n * @property {number} [height] 绘制到画布上的高度，默认为图片高度\r\n * @property {number} [sx=0] 从图片中裁剪的左上角横坐标\r\n * @property {number} [sy=0] 从图片中裁剪的左上角纵坐标\r\n * @property {number} [sWidth] 从图片中裁剪的宽度，默认为图片高度\r\n * @property {number} [sHeight] 从图片中裁剪的高度，默认为图片高度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n\r\n        var Base = require('./Base');\r\n\r\n        /**\r\n         * @alias zrender/shape/Image\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var ZImage = function(options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 图片绘制样式\r\n             * @name module:zrender/shape/Image#style\r\n             * @type {module:zrender/shape/Image~IImageStyle}\r\n             */\r\n            /**\r\n             * 图片高亮绘制样式\r\n             * @name module:zrender/shape/Image#highlightStyle\r\n             * @type {module:zrender/shape/Image~IImageStyle}\r\n             */\r\n        };\r\n\r\n        ZImage.prototype = {\r\n            \r\n            type: 'image',\r\n\r\n            brush : function(ctx, isHighlight, refreshNextFrame) {\r\n                var style = this.style || {};\r\n\r\n                if (isHighlight) {\r\n                    // 根据style扩展默认高亮样式\r\n                    style = this.getHighlightStyle(\r\n                        style, this.highlightStyle || {}\r\n                    );\r\n                }\r\n\r\n                var image = style.image;\r\n                var self = this;\r\n\r\n                if (!this._imageCache) {\r\n                    this._imageCache = {};\r\n                }\r\n                if (typeof(image) === 'string') {\r\n                    var src = image;\r\n                    if (this._imageCache[src]) {\r\n                        image = this._imageCache[src];\r\n                    } else {\r\n                        image = new Image();\r\n                        image.onload = function () {\r\n                            image.onload = null;\r\n                            self.modSelf();\r\n                            refreshNextFrame();\r\n                        };\r\n\r\n                        image.src = src;\r\n                        this._imageCache[src] = image;\r\n                    }\r\n                }\r\n                if (image) {\r\n                    // 图片已经加载完成\r\n                    if (image.nodeName.toUpperCase() == 'IMG') {\r\n                        if (window.ActiveXObject) {\r\n                            if (image.readyState != 'complete') {\r\n                                return;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (!image.complete) {\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                    // Else is canvas\r\n                    var width = style.width || image.width;\r\n                    var height = style.height || image.height;\r\n                    var x = style.x;\r\n                    var y = style.y;\r\n                    // 图片加载失败\r\n                    if (!image.width || !image.height) {\r\n                        return;\r\n                    }\r\n\r\n                    ctx.save();\r\n\r\n                    this.doClip(ctx);\r\n\r\n                    this.setContext(ctx, style);\r\n\r\n                    // 设置transform\r\n                    this.setTransform(ctx);\r\n\r\n                    if (style.sWidth && style.sHeight) {\r\n                        var sx = style.sx || 0;\r\n                        var sy = style.sy || 0;\r\n                        ctx.drawImage(\r\n                            image,\r\n                            sx, sy, style.sWidth, style.sHeight,\r\n                            x, y, width, height\r\n                        );\r\n                    }\r\n                    else if (style.sx && style.sy) {\r\n                        var sx = style.sx;\r\n                        var sy = style.sy;\r\n                        var sWidth = width - sx;\r\n                        var sHeight = height - sy;\r\n                        ctx.drawImage(\r\n                            image,\r\n                            sx, sy, sWidth, sHeight,\r\n                            x, y, width, height\r\n                        );\r\n                    }\r\n                    else {\r\n                        ctx.drawImage(image, x, y, width, height);\r\n                    }\r\n                    // 如果没设置宽和高的话自动根据图片宽高设置\r\n                    if (!style.width) {\r\n                        style.width = width;\r\n                    }\r\n                    if (!style.height) {\r\n                        style.height = height;\r\n                    }\r\n                    if (!this.style.width) {\r\n                        this.style.width = width;\r\n                    }\r\n                    if (!this.style.height) {\r\n                        this.style.height = height;\r\n                    }\r\n\r\n                    this.drawText(ctx, style, this.style);\r\n\r\n                    ctx.restore();\r\n                }\r\n            },\r\n\r\n            /**\r\n             * 计算返回图片的包围盒矩形\r\n             * @param {module:zrender/shape/Image~IImageStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect: function(style) {\r\n                return {\r\n                    x : style.x,\r\n                    y : style.y,\r\n                    width : style.width,\r\n                    height : style.height\r\n                };\r\n            },\r\n\r\n            clearCache: function() {\r\n                this._imageCache = {};\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(ZImage, Base);\r\n        return ZImage;\r\n    }\r\n);\r\n"
        },
        {
          "id": 7,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "index": 7,
          "index2": 12,
          "size": 23221,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 6,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Image.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "45:19-36"
            },
            {
              "moduleId": 20,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Base",
              "loc": "503:15-46"
            },
            {
              "moduleId": 21,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "55:19-36"
            },
            {
              "moduleId": 23,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "51:19-36"
            },
            {
              "moduleId": 25,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "52:19-36"
            },
            {
              "moduleId": 26,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Base",
              "loc": "23:15-46"
            },
            {
              "moduleId": 27,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "44:19-36"
            },
            {
              "moduleId": 29,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\BezierCurve.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "55:19-36"
            },
            {
              "moduleId": 30,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Base",
              "loc": "35:15-46"
            },
            {
              "moduleId": 31,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "43:19-36"
            },
            {
              "moduleId": 35,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "42:19-36"
            },
            {
              "moduleId": 36,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\ShapeBundle.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "42:15-32"
            },
            {
              "moduleId": 41,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Circle.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "50:19-36"
            },
            {
              "moduleId": 50,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Rectangle.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "48:19-36"
            },
            {
              "moduleId": 53,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Text.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
              "type": "cjs require",
              "userRequest": "./Base",
              "loc": "41:19-36"
            },
            {
              "moduleId": 68,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Base",
              "loc": "48:15-46"
            }
          ],
          "source": "/**\r\n * shape基类\r\n * @module zrender/shape/Base\r\n * @author  Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *          errorrik (errorrik@gmail.com)\r\n */\r\n\r\n/**\r\n * @typedef {Object} IBaseShapeStyle\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\n\r\n/**\r\n * @typedef {Object} module:zrender/shape/Base~IBoundingRect\r\n * @property {number} x 左上角顶点x轴坐标 \r\n * @property {number} y 左上角顶点y轴坐标\r\n * @property {number} width 包围盒矩形宽度\r\n * @property {number} height 包围盒矩形高度\r\n */\r\n\r\ndefine(\r\n    function(require) {\r\n        var vmlCanvasManager = window['G_vmlCanvasManager'];\r\n\r\n        var matrix = require('../tool/matrix');\r\n        var guid = require('../tool/guid');\r\n        var util = require('../tool/util');\r\n        var log = require('../tool/log');\r\n\r\n        var Transformable = require('../mixin/Transformable');\r\n        var Eventful = require('../mixin/Eventful');\r\n\r\n        function _fillText(ctx, text, x, y, textFont, textAlign, textBaseline) {\r\n            if (textFont) {\r\n                ctx.font = textFont;\r\n            }\r\n            ctx.textAlign = textAlign;\r\n            ctx.textBaseline = textBaseline;\r\n            var rect = _getTextRect(\r\n                text, x, y, textFont, textAlign, textBaseline\r\n            );\r\n            \r\n            text = (text + '').split('\\n');\r\n            var lineHeight = require('../tool/area').getTextHeight('国', textFont);\r\n            \r\n            switch (textBaseline) {\r\n                case 'top':\r\n                    y = rect.y;\r\n                    break;\r\n                case 'bottom':\r\n                    y = rect.y + lineHeight;\r\n                    break;\r\n                default:\r\n                    y = rect.y + lineHeight / 2;\r\n            }\r\n            \r\n            for (var i = 0, l = text.length; i < l; i++) {\r\n                ctx.fillText(text[i], x, y);\r\n                y += lineHeight;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 返回矩形区域，用于局部刷新和文字定位\r\n         * @inner\r\n         * @param {string} text\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @param {string} textFont\r\n         * @param {string} textAlign\r\n         * @param {string} textBaseline\r\n         */\r\n        function _getTextRect(text, x, y, textFont, textAlign, textBaseline) {\r\n            var area = require('../tool/area');\r\n            var width = area.getTextWidth(text, textFont);\r\n            var lineHeight = area.getTextHeight('国', textFont);\r\n            \r\n            text = (text + '').split('\\n');\r\n            \r\n            switch (textAlign) {\r\n                case 'end':\r\n                case 'right':\r\n                    x -= width;\r\n                    break;\r\n                case 'center':\r\n                    x -= (width / 2);\r\n                    break;\r\n            }\r\n\r\n            switch (textBaseline) {\r\n                case 'top':\r\n                    break;\r\n                case 'bottom':\r\n                    y -= lineHeight * text.length;\r\n                    break;\r\n                default:\r\n                    y -= lineHeight * text.length / 2;\r\n            }\r\n\r\n            return {\r\n                x : x,\r\n                y : y,\r\n                width : width,\r\n                height : lineHeight * text.length\r\n            };\r\n        }\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Base\r\n         * @constructor\r\n         * @extends module:zrender/mixin/Transformable\r\n         * @extends module:zrender/mixin/Eventful\r\n         * @param {Object} options 关于shape的配置项，可以是shape的自有属性，也可以是自定义的属性。\r\n         */\r\n        var Base = function(options) {\r\n            \r\n            options = options || {};\r\n            \r\n            /**\r\n             * Shape id, 全局唯一\r\n             * @type {string}\r\n             */\r\n            this.id = options.id || guid();\r\n\r\n            for (var key in options) {\r\n                this[key] = options[key];\r\n            }\r\n\r\n            /**\r\n             * 基础绘制样式\r\n             * @type {module:zrender/shape/Base~IBaseShapeStyle}\r\n             */\r\n            this.style = this.style || {};\r\n\r\n            /**\r\n             * 高亮样式\r\n             * @type {module:zrender/shape/Base~IBaseShapeStyle}\r\n             */\r\n            this.highlightStyle = this.highlightStyle || null;\r\n\r\n            /**\r\n             * 父节点\r\n             * @readonly\r\n             * @type {module:zrender/Group}\r\n             * @default null\r\n             */\r\n            this.parent = null;\r\n\r\n            this.__dirty = true;\r\n\r\n            this.__clipShapes = [];\r\n\r\n            Transformable.call(this);\r\n            Eventful.call(this);\r\n        };\r\n        /**\r\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\r\n         * @name module:zrender/shape/Base#invisible\r\n         * @type {boolean}\r\n         * @default false\r\n         */\r\n        Base.prototype.invisible = false;\r\n\r\n        /**\r\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\r\n         * @name module:zrender/shape/Base#ignore\r\n         * @type {boolean}\r\n         * @default false\r\n         */\r\n        Base.prototype.ignore = false;\r\n\r\n        /**\r\n         * z层level，决定绘画在哪层canvas中\r\n         * @name module:zrender/shape/Base#zlevel\r\n         * @type {number}\r\n         * @default 0\r\n         */\r\n        Base.prototype.zlevel = 0;\r\n\r\n        /**\r\n         * 是否可拖拽\r\n         * @name module:zrender/shape/Base#draggable\r\n         * @type {boolean}\r\n         * @default false\r\n         */\r\n        Base.prototype.draggable = false;\r\n\r\n        /**\r\n         * 是否可点击\r\n         * @name module:zrender/shape/Base#clickable\r\n         * @type {boolean}\r\n         * @default false\r\n         */\r\n        Base.prototype.clickable = false;\r\n\r\n        /**\r\n         * 是否可以hover\r\n         * @name module:zrender/shape/Base#hoverable\r\n         * @type {boolean}\r\n         * @default true\r\n         */\r\n        Base.prototype.hoverable = true;\r\n        \r\n        /**\r\n         * z值，跟zlevel一样影响shape绘制的前后顺序，z值大的shape会覆盖在z值小的上面，\r\n         * 但是并不会创建新的canvas，所以优先级低于zlevel，而且频繁改动的开销比zlevel小很多。\r\n         * \r\n         * @name module:zrender/shape/Base#z\r\n         * @type {number}\r\n         * @default 0\r\n         */\r\n        Base.prototype.z = 0;\r\n\r\n        /**\r\n         * 绘制图形\r\n         * \r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {boolean} [isHighlight=false] 是否使用高亮属性\r\n         * @param {Function} [updateCallback]\r\n         *        需要异步加载资源的shape可以通过这个callback(e), \r\n         *        让painter更新视图，base.brush没用，需要的话重载brush\r\n         */\r\n        Base.prototype.brush = function (ctx, isHighlight) {\r\n\r\n            var style = this.beforeBrush(ctx, isHighlight);\r\n\r\n            ctx.beginPath();\r\n            this.buildPath(ctx, style);\r\n\r\n            switch (style.brushType) {\r\n                /* jshint ignore:start */\r\n                case 'both':\r\n                    ctx.fill();\r\n                case 'stroke':\r\n                    style.lineWidth > 0 && ctx.stroke();\r\n                    break;\r\n                /* jshint ignore:end */\r\n                default:\r\n                    ctx.fill();\r\n            }\r\n            \r\n            this.drawText(ctx, style, this.style);\r\n\r\n            this.afterBrush(ctx);\r\n        };\r\n\r\n        /**\r\n         * 具体绘制操作前的一些公共操作\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {boolean} [isHighlight=false] 是否使用高亮属性\r\n         * @return {Object} 处理后的样式\r\n         */\r\n        Base.prototype.beforeBrush = function (ctx, isHighlight) {\r\n            var style = this.style;\r\n            \r\n            if (this.brushTypeOnly) {\r\n                style.brushType = this.brushTypeOnly;\r\n            }\r\n\r\n            if (isHighlight) {\r\n                // 根据style扩展默认高亮样式\r\n                style = this.getHighlightStyle(\r\n                    style,\r\n                    this.highlightStyle || {},\r\n                    this.brushTypeOnly\r\n                );\r\n            }\r\n\r\n            if (this.brushTypeOnly == 'stroke') {\r\n                style.strokeColor = style.strokeColor || style.color;\r\n            }\r\n\r\n            ctx.save();\r\n\r\n            this.doClip(ctx);\r\n\r\n            this.setContext(ctx, style);\r\n\r\n            // 设置transform\r\n            this.setTransform(ctx);\r\n\r\n            return style;\r\n        };\r\n\r\n        /**\r\n         * 绘制后的处理\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         */\r\n        Base.prototype.afterBrush = function (ctx) {\r\n            ctx.restore();\r\n        };\r\n\r\n        var STYLE_CTX_MAP = [\r\n            [ 'color', 'fillStyle' ],\r\n            [ 'strokeColor', 'strokeStyle' ],\r\n            [ 'opacity', 'globalAlpha' ],\r\n            [ 'lineCap', 'lineCap' ],\r\n            [ 'lineJoin', 'lineJoin' ],\r\n            [ 'miterLimit', 'miterLimit' ],\r\n            [ 'lineWidth', 'lineWidth' ],\r\n            [ 'shadowBlur', 'shadowBlur' ],\r\n            [ 'shadowColor', 'shadowColor' ],\r\n            [ 'shadowOffsetX', 'shadowOffsetX' ],\r\n            [ 'shadowOffsetY', 'shadowOffsetY' ]\r\n        ];\r\n\r\n        /**\r\n         * 设置 fillStyle, strokeStyle, shadow 等通用绘制样式\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style\r\n         */\r\n        Base.prototype.setContext = function (ctx, style) {\r\n            for (var i = 0, len = STYLE_CTX_MAP.length; i < len; i++) {\r\n                var styleProp = STYLE_CTX_MAP[i][0];\r\n                var styleValue = style[styleProp];\r\n                var ctxProp = STYLE_CTX_MAP[i][1];\r\n\r\n                if (typeof styleValue != 'undefined') {\r\n                    ctx[ctxProp] = styleValue;\r\n                }\r\n            }\r\n        };\r\n\r\n        var clipShapeInvTransform = matrix.create();\r\n        Base.prototype.doClip = function (ctx) {\r\n            if (this.__clipShapes && !vmlCanvasManager) {\r\n                for (var i = 0; i < this.__clipShapes.length; i++) {\r\n                    var clipShape = this.__clipShapes[i];\r\n                    if (clipShape.needTransform) {\r\n                        var m = clipShape.transform;\r\n                        matrix.invert(clipShapeInvTransform, m);\r\n                        ctx.transform(\r\n                            m[0], m[1],\r\n                            m[2], m[3],\r\n                            m[4], m[5]\r\n                        );\r\n                    }\r\n                    ctx.beginPath();\r\n                    clipShape.buildPath(ctx, clipShape.style);\r\n                    ctx.clip();\r\n                    // Transform back\r\n                    if (clipShape.needTransform) {\r\n                        var m = clipShapeInvTransform;\r\n                        ctx.transform(\r\n                            m[0], m[1],\r\n                            m[2], m[3],\r\n                            m[4], m[5]\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    \r\n        /**\r\n         * 根据默认样式扩展高亮样式\r\n         * \r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style 默认样式\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} highlightStyle 高亮样式\r\n         * @param {string} brushTypeOnly\r\n         */\r\n        Base.prototype.getHighlightStyle = function (style, highlightStyle, brushTypeOnly) {\r\n            var newStyle = {};\r\n            for (var k in style) {\r\n                newStyle[k] = style[k];\r\n            }\r\n\r\n            var color = require('../tool/color');\r\n            var highlightColor = color.getHighlightColor();\r\n            // 根据highlightStyle扩展\r\n            if (style.brushType != 'stroke') {\r\n                // 带填充则用高亮色加粗边线\r\n                newStyle.strokeColor = highlightColor;\r\n                newStyle.lineWidth = (style.lineWidth || 1)\r\n                                      + this.getHighlightZoom();\r\n                newStyle.brushType = 'both';\r\n            }\r\n            else {\r\n                if (brushTypeOnly != 'stroke') {\r\n                    // 描边型的则用原色加工高亮\r\n                    newStyle.strokeColor = highlightColor;\r\n                    newStyle.lineWidth = (style.lineWidth || 1)\r\n                                          + this.getHighlightZoom();\r\n                } \r\n                else {\r\n                    // 线型的则用原色加工高亮\r\n                    newStyle.strokeColor = highlightStyle.strokeColor\r\n                                           || color.mix(\r\n                                                 style.strokeColor,\r\n                                                 color.toRGB(highlightColor)\r\n                                              );\r\n                }\r\n            }\r\n\r\n            // 可自定义覆盖默认值\r\n            for (var k in highlightStyle) {\r\n                if (typeof highlightStyle[k] != 'undefined') {\r\n                    newStyle[k] = highlightStyle[k];\r\n                }\r\n            }\r\n\r\n            return newStyle;\r\n        };\r\n\r\n        // 高亮放大效果参数\r\n        // 当前统一设置为6，如有需要差异设置，通过this.type判断实例类型\r\n        Base.prototype.getHighlightZoom = function () {\r\n            return this.type != 'text' ? 6 : 2;\r\n        };\r\n\r\n        /**\r\n         * 移动位置\r\n         * @param {number} dx 横坐标变化\r\n         * @param {number} dy 纵坐标变化\r\n         */\r\n        Base.prototype.drift = function (dx, dy) {\r\n            this.position[0] += dx;\r\n            this.position[1] += dy;\r\n        };\r\n\r\n        /**\r\n         * 构建绘制的Path\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style\r\n         */\r\n        Base.prototype.buildPath = function (ctx, style) {\r\n            log('buildPath not implemented in ' + this.type);\r\n        };\r\n\r\n        /**\r\n         * 计算返回包围盒矩形\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style\r\n         * @return {module:zrender/shape/Base~IBoundingRect}\r\n         */\r\n        Base.prototype.getRect = function (style) {\r\n            log('getRect not implemented in ' + this.type);   \r\n        };\r\n        \r\n        /**\r\n         * 判断鼠标位置是否在图形内\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @return {boolean}\r\n         */\r\n        Base.prototype.isCover = function (x, y) {\r\n            var originPos = this.transformCoordToLocal(x, y);\r\n            x = originPos[0];\r\n            y = originPos[1];\r\n\r\n            // 快速预判并保留判断矩形\r\n            if (this.isCoverRect(x, y)) {\r\n                // 矩形内\r\n                return require('../tool/area').isInside(this, this.style, x, y);\r\n            }\r\n            \r\n            return false;\r\n        };\r\n\r\n        Base.prototype.isCoverRect = function (x, y) {\r\n            // 快速预判并保留判断矩形\r\n            var rect = this.style.__rect;\r\n            if (!rect) {\r\n                rect = this.style.__rect = this.getRect(this.style);\r\n            }\r\n            return x >= rect.x\r\n                && x <= (rect.x + rect.width)\r\n                && y >= rect.y\r\n                && y <= (rect.y + rect.height);\r\n        };\r\n\r\n        /**\r\n         * 绘制附加文本\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style 样式\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} normalStyle 默认样式，用于定位文字显示\r\n         */\r\n        Base.prototype.drawText = function (ctx, style, normalStyle) {\r\n            if (typeof(style.text) == 'undefined' || style.text === false) {\r\n                return;\r\n            }\r\n            // 字体颜色策略\r\n            var textColor = style.textColor || style.color || style.strokeColor;\r\n            ctx.fillStyle = textColor;\r\n\r\n            // 文本与图形间空白间隙\r\n            var dd = 10;\r\n            var al;         // 文本水平对齐\r\n            var bl;         // 文本垂直对齐\r\n            var tx;         // 文本横坐标\r\n            var ty;         // 文本纵坐标\r\n\r\n            var textPosition = style.textPosition       // 用户定义\r\n                               || this.textPosition     // shape默认\r\n                               || 'top';                // 全局默认\r\n\r\n            switch (textPosition) {\r\n                case 'inside': \r\n                case 'top': \r\n                case 'bottom': \r\n                case 'left': \r\n                case 'right': \r\n                    if (this.getRect) {\r\n                        var rect = (normalStyle || style).__rect\r\n                                   || this.getRect(normalStyle || style);\r\n\r\n                        switch (textPosition) {\r\n                            case 'inside':\r\n                                tx = rect.x + rect.width / 2;\r\n                                ty = rect.y + rect.height / 2;\r\n                                al = 'center';\r\n                                bl = 'middle';\r\n                                if (style.brushType != 'stroke'\r\n                                    && textColor == style.color\r\n                                ) {\r\n                                    ctx.fillStyle = '#fff';\r\n                                }\r\n                                break;\r\n                            case 'left':\r\n                                tx = rect.x - dd;\r\n                                ty = rect.y + rect.height / 2;\r\n                                al = 'end';\r\n                                bl = 'middle';\r\n                                break;\r\n                            case 'right':\r\n                                tx = rect.x + rect.width + dd;\r\n                                ty = rect.y + rect.height / 2;\r\n                                al = 'start';\r\n                                bl = 'middle';\r\n                                break;\r\n                            case 'top':\r\n                                tx = rect.x + rect.width / 2;\r\n                                ty = rect.y - dd;\r\n                                al = 'center';\r\n                                bl = 'bottom';\r\n                                break;\r\n                            case 'bottom':\r\n                                tx = rect.x + rect.width / 2;\r\n                                ty = rect.y + rect.height + dd;\r\n                                al = 'center';\r\n                                bl = 'top';\r\n                                break;\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'start':\r\n                case 'end':\r\n                    var pointList = style.pointList\r\n                                    || [\r\n                                        [style.xStart || 0, style.yStart || 0],\r\n                                        [style.xEnd || 0, style.yEnd || 0]\r\n                                    ];\r\n                    var length = pointList.length;\r\n                    if (length < 2) {\r\n                        // 少于2个点就不画了~\r\n                        return;\r\n                    }\r\n                    var xStart;\r\n                    var xEnd;\r\n                    var yStart;\r\n                    var yEnd;\r\n                    switch (textPosition) {\r\n                        case 'start':\r\n                            xStart = pointList[1][0];\r\n                            xEnd = pointList[0][0];\r\n                            yStart = pointList[1][1];\r\n                            yEnd = pointList[0][1];\r\n                            break;\r\n                        case 'end':\r\n                            xStart = pointList[length - 2][0];\r\n                            xEnd = pointList[length - 1][0];\r\n                            yStart = pointList[length - 2][1];\r\n                            yEnd = pointList[length - 1][1];\r\n                            break;\r\n                    }\r\n                    tx = xEnd;\r\n                    ty = yEnd;\r\n                    \r\n                    var angle = Math.atan((yStart - yEnd) / (xEnd - xStart)) / Math.PI * 180;\r\n                    if ((xEnd - xStart) < 0) {\r\n                        angle += 180;\r\n                    }\r\n                    else if ((yStart - yEnd) < 0) {\r\n                        angle += 360;\r\n                    }\r\n                    \r\n                    dd = 5;\r\n                    if (angle >= 30 && angle <= 150) {\r\n                        al = 'center';\r\n                        bl = 'bottom';\r\n                        ty -= dd;\r\n                    }\r\n                    else if (angle > 150 && angle < 210) {\r\n                        al = 'right';\r\n                        bl = 'middle';\r\n                        tx -= dd;\r\n                    }\r\n                    else if (angle >= 210 && angle <= 330) {\r\n                        al = 'center';\r\n                        bl = 'top';\r\n                        ty += dd;\r\n                    }\r\n                    else {\r\n                        al = 'left';\r\n                        bl = 'middle';\r\n                        tx += dd;\r\n                    }\r\n                    break;\r\n                case 'specific':\r\n                    tx = style.textX || 0;\r\n                    ty = style.textY || 0;\r\n                    al = 'start';\r\n                    bl = 'middle';\r\n                    break;\r\n            }\r\n\r\n            if (tx != null && ty != null) {\r\n                _fillText(\r\n                    ctx,\r\n                    style.text, \r\n                    tx, ty, \r\n                    style.textFont,\r\n                    style.textAlign || al,\r\n                    style.textBaseline || bl\r\n                );\r\n            }\r\n        };\r\n\r\n        Base.prototype.modSelf = function() {\r\n            this.__dirty = true;\r\n            if (this.style) {\r\n                this.style.__rect = null;\r\n            }\r\n            if (this.highlightStyle) {\r\n                this.highlightStyle.__rect = null;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * 图形是否会触发事件\r\n         * @return {boolean}\r\n         */\r\n        // TODO, 通过 bind 绑定的事件\r\n        Base.prototype.isSilent = function () {\r\n            return !(\r\n                this.hoverable || this.draggable || this.clickable\r\n                || this.onmousemove || this.onmouseover || this.onmouseout\r\n                || this.onmousedown || this.onmouseup || this.onclick\r\n                || this.ondragenter || this.ondragover || this.ondragleave\r\n                || this.ondrop\r\n            );\r\n        };\r\n\r\n        util.merge(Base.prototype, Transformable.prototype, true);\r\n        util.merge(Base.prototype, Eventful.prototype, true);\r\n\r\n        return Base;\r\n    }\r\n);\r\n"
        },
        {
          "id": 8,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\matrix.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/matrix.js",
          "index": 8,
          "index2": 0,
          "size": 4932,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../tool/matrix",
              "loc": "42:21-46"
            },
            {
              "moduleId": 14,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\mixin\\Transformable.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
              "type": "cjs require",
              "userRequest": "../tool/matrix",
              "loc": "10:17-42"
            }
          ],
          "source": "define(\r\n    function () {\r\n\r\n        var ArrayCtor = typeof Float32Array === 'undefined'\r\n            ? Array\r\n            : Float32Array;\r\n        /**\r\n         * 3x2矩阵操作类\r\n         * @exports zrender/tool/matrix\r\n         */\r\n        var matrix = {\r\n            /**\r\n             * 创建一个单位矩阵\r\n             * @return {Float32Array|Array.<number>}\r\n             */\r\n            create : function() {\r\n                var out = new ArrayCtor(6);\r\n                matrix.identity(out);\r\n                \r\n                return out;\r\n            },\r\n            /**\r\n             * 设置矩阵为单位矩阵\r\n             * @param {Float32Array|Array.<number>} out\r\n             */\r\n            identity : function(out) {\r\n                out[0] = 1;\r\n                out[1] = 0;\r\n                out[2] = 0;\r\n                out[3] = 1;\r\n                out[4] = 0;\r\n                out[5] = 0;\r\n                return out;\r\n            },\r\n            /**\r\n             * 复制矩阵\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} m\r\n             */\r\n            copy: function(out, m) {\r\n                out[0] = m[0];\r\n                out[1] = m[1];\r\n                out[2] = m[2];\r\n                out[3] = m[3];\r\n                out[4] = m[4];\r\n                out[5] = m[5];\r\n                return out;\r\n            },\r\n            /**\r\n             * 矩阵相乘\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} m1\r\n             * @param {Float32Array|Array.<number>} m2\r\n             */\r\n            mul : function (out, m1, m2) {\r\n                out[0] = m1[0] * m2[0] + m1[2] * m2[1];\r\n                out[1] = m1[1] * m2[0] + m1[3] * m2[1];\r\n                out[2] = m1[0] * m2[2] + m1[2] * m2[3];\r\n                out[3] = m1[1] * m2[2] + m1[3] * m2[3];\r\n                out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\r\n                out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\r\n                return out;\r\n            },\r\n            /**\r\n             * 平移变换\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} a\r\n             * @param {Float32Array|Array.<number>} v\r\n             */\r\n            translate : function(out, a, v) {\r\n                out[0] = a[0];\r\n                out[1] = a[1];\r\n                out[2] = a[2];\r\n                out[3] = a[3];\r\n                out[4] = a[4] + v[0];\r\n                out[5] = a[5] + v[1];\r\n                return out;\r\n            },\r\n            /**\r\n             * 旋转变换\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} a\r\n             * @param {number} rad\r\n             */\r\n            rotate : function(out, a, rad) {\r\n                var aa = a[0];\r\n                var ac = a[2];\r\n                var atx = a[4];\r\n                var ab = a[1];\r\n                var ad = a[3];\r\n                var aty = a[5];\r\n                var st = Math.sin(rad);\r\n                var ct = Math.cos(rad);\r\n\r\n                out[0] = aa * ct + ab * st;\r\n                out[1] = -aa * st + ab * ct;\r\n                out[2] = ac * ct + ad * st;\r\n                out[3] = -ac * st + ct * ad;\r\n                out[4] = ct * atx + st * aty;\r\n                out[5] = ct * aty - st * atx;\r\n                return out;\r\n            },\r\n            /**\r\n             * 缩放变换\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} a\r\n             * @param {Float32Array|Array.<number>} v\r\n             */\r\n            scale : function(out, a, v) {\r\n                var vx = v[0];\r\n                var vy = v[1];\r\n                out[0] = a[0] * vx;\r\n                out[1] = a[1] * vy;\r\n                out[2] = a[2] * vx;\r\n                out[3] = a[3] * vy;\r\n                out[4] = a[4] * vx;\r\n                out[5] = a[5] * vy;\r\n                return out;\r\n            },\r\n            /**\r\n             * 求逆矩阵\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} a\r\n             */\r\n            invert : function(out, a) {\r\n            \r\n                var aa = a[0];\r\n                var ac = a[2];\r\n                var atx = a[4];\r\n                var ab = a[1];\r\n                var ad = a[3];\r\n                var aty = a[5];\r\n\r\n                var det = aa * ad - ab * ac;\r\n                if (!det) {\r\n                    return null;\r\n                }\r\n                det = 1.0 / det;\r\n\r\n                out[0] = ad * det;\r\n                out[1] = -ab * det;\r\n                out[2] = -ac * det;\r\n                out[3] = aa * det;\r\n                out[4] = (ac * aty - ad * atx) * det;\r\n                out[5] = (ab * atx - aa * aty) * det;\r\n                return out;\r\n            }\r\n        };\r\n\r\n        return matrix;\r\n    }\r\n);\r\n"
        },
        {
          "id": 9,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\guid.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/guid.js",
          "index": 9,
          "index2": 1,
          "size": 238,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../tool/guid",
              "loc": "43:19-42"
            }
          ],
          "source": "/**\r\n * zrender: 生成唯一id\r\n *\r\n * @author errorrik (errorrik@gmail.com)\r\n */\r\n\r\ndefine(\r\n    function() {\r\n        var idStart = 0x0907;\r\n\r\n        return function () {\r\n            return 'zrender__' + (idStart++);\r\n        };\r\n    }\r\n);\r\n"
        },
        {
          "id": 10,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\util.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/util.js",
          "index": 10,
          "index2": 3,
          "size": 7888,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "63:17-47"
            },
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "25:17-47"
            },
            {
              "moduleId": 6,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Image.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "198:8-31"
            },
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "44:19-42"
            },
            {
              "moduleId": 17,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\area.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
              "type": "cjs require",
              "userRequest": "./util",
              "loc": "16:19-36"
            },
            {
              "moduleId": 19,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\color.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/color.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/color.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "6:15-38"
            },
            {
              "moduleId": 20,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "35:17-47"
            },
            {
              "moduleId": 21,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "161:8-31"
            },
            {
              "moduleId": 23,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "138:8-31"
            },
            {
              "moduleId": 25,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "137:8-31"
            },
            {
              "moduleId": 26,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "32:17-47"
            },
            {
              "moduleId": 27,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "122:8-31"
            },
            {
              "moduleId": 29,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\BezierCurve.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "145:8-31"
            },
            {
              "moduleId": 30,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "38:17-47"
            },
            {
              "moduleId": 31,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "211:8-31"
            },
            {
              "moduleId": 35,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "155:8-31"
            },
            {
              "moduleId": 36,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\ShapeBundle.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "149:4-27"
            },
            {
              "moduleId": 39,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecAnimation.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "9:17-47"
            },
            {
              "moduleId": 41,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Circle.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "114:8-31"
            },
            {
              "moduleId": 44,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "13:17-47"
            },
            {
              "moduleId": 45,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecQuery.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecQuery.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecQuery.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "9:17-47"
            },
            {
              "moduleId": 50,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Rectangle.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "203:8-31"
            },
            {
              "moduleId": 51,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "23:17-47"
            },
            {
              "moduleId": 52,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "76:17-47"
            },
            {
              "moduleId": 53,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Text.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
              "type": "cjs require",
              "userRequest": "../tool/util",
              "loc": "207:8-31"
            },
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "76:17-47"
            },
            {
              "moduleId": 59,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "30:17-47"
            },
            {
              "moduleId": 60,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "45:17-47"
            },
            {
              "moduleId": 64,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "23:17-47"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "70:17-47"
            },
            {
              "moduleId": 68,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/util",
              "loc": "50:17-47"
            }
          ],
          "source": "/**\r\n * @module zrender/tool/util\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         Yi Shen(https://github.com/pissang)\r\n */\r\ndefine(\r\n    function(require) {\r\n\r\n        var ArrayProto = Array.prototype;\r\n        var nativeForEach = ArrayProto.forEach;\r\n        var nativeMap = ArrayProto.map;\r\n        var nativeFilter = ArrayProto.filter;\r\n\r\n        // 用于处理merge时无法遍历Date等对象的问题\r\n        var BUILTIN_OBJECT = {\r\n            '[object Function]': 1,\r\n            '[object RegExp]': 1,\r\n            '[object Date]': 1,\r\n            '[object Error]': 1,\r\n            '[object CanvasGradient]': 1\r\n        };\r\n\r\n        var objToString = Object.prototype.toString;\r\n\r\n        function isDom(obj) {\r\n            return obj && obj.nodeType === 1\r\n                   && typeof(obj.nodeName) == 'string';\r\n        }\r\n\r\n        /**\r\n         * 对一个object进行深度拷贝\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {*} source 需要进行拷贝的对象\r\n         * @return {*} 拷贝后的新对象\r\n         */\r\n        function clone(source) {\r\n            if (typeof source == 'object' && source !== null) {\r\n                var result = source;\r\n                if (source instanceof Array) {\r\n                    result = [];\r\n                    for (var i = 0, len = source.length; i < len; i++) {\r\n                        result[i] = clone(source[i]);\r\n                    }\r\n                }\r\n                else if (\r\n                    !BUILTIN_OBJECT[objToString.call(source)]\r\n                    // 是否为 dom 对象\r\n                    && !isDom(source)\r\n                ) {\r\n                    result = {};\r\n                    for (var key in source) {\r\n                        if (source.hasOwnProperty(key)) {\r\n                            result[key] = clone(source[key]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return result;\r\n            }\r\n\r\n            return source;\r\n        }\r\n\r\n        function mergeItem(target, source, key, overwrite) {\r\n            if (source.hasOwnProperty(key)) {\r\n                var targetProp = target[key];\r\n                if (typeof targetProp == 'object'\r\n                    && !BUILTIN_OBJECT[objToString.call(targetProp)]\r\n                    // 是否为 dom 对象\r\n                    && !isDom(targetProp)\r\n                ) {\r\n                    // 如果需要递归覆盖，就递归调用merge\r\n                    merge(\r\n                        target[key],\r\n                        source[key],\r\n                        overwrite\r\n                    );\r\n                }\r\n                else if (overwrite || !(key in target)) {\r\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\r\n                    target[key] = source[key];\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 合并源对象的属性到目标对象\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {*} target 目标对象\r\n         * @param {*} source 源对象\r\n         * @param {boolean} overwrite 是否覆盖\r\n         */\r\n        function merge(target, source, overwrite) {\r\n            for (var i in source) {\r\n                mergeItem(target, source, i, overwrite);\r\n            }\r\n            \r\n            return target;\r\n        }\r\n\r\n        var _ctx;\r\n\r\n        function getContext() {\r\n            if (!_ctx) {\r\n                require('../dep/excanvas');\r\n                /* jshint ignore:start */\r\n                if (window['G_vmlCanvasManager']) {\r\n                    var _div = document.createElement('div');\r\n                    _div.style.position = 'absolute';\r\n                    _div.style.top = '-1000px';\r\n                    document.body.appendChild(_div);\r\n\r\n                    _ctx = G_vmlCanvasManager.initElement(_div)\r\n                               .getContext('2d');\r\n                }\r\n                else {\r\n                    _ctx = document.createElement('canvas').getContext('2d');\r\n                }\r\n                /* jshint ignore:end */\r\n            }\r\n            return _ctx;\r\n        }\r\n\r\n        /**\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Array} array\r\n         * @param {*} value\r\n         */\r\n        function indexOf(array, value) {\r\n            if (array.indexOf) {\r\n                return array.indexOf(value);\r\n            }\r\n            for (var i = 0, len = array.length; i < len; i++) {\r\n                if (array[i] === value) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        /**\r\n         * 构造类继承关系\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Function} clazz 源类\r\n         * @param {Function} baseClazz 基类\r\n         */\r\n        function inherits(clazz, baseClazz) {\r\n            var clazzPrototype = clazz.prototype;\r\n            function F() {}\r\n            F.prototype = baseClazz.prototype;\r\n            clazz.prototype = new F();\r\n\r\n            for (var prop in clazzPrototype) {\r\n                clazz.prototype[prop] = clazzPrototype[prop];\r\n            }\r\n            clazz.constructor = clazz;\r\n        }\r\n\r\n        /**\r\n         * 数组或对象遍历\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Object|Array} obj\r\n         * @param {Function} cb\r\n         * @param {*} [context]\r\n         */\r\n        function each(obj, cb, context) {\r\n            if (!(obj && cb)) {\r\n                return;\r\n            }\r\n            if (obj.forEach && obj.forEach === nativeForEach) {\r\n                obj.forEach(cb, context);\r\n            }\r\n            else if (obj.length === +obj.length) {\r\n                for (var i = 0, len = obj.length; i < len; i++) {\r\n                    cb.call(context, obj[i], i, obj);\r\n                }\r\n            }\r\n            else {\r\n                for (var key in obj) {\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        cb.call(context, obj[key], key, obj);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 数组映射\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Array} obj\r\n         * @param {Function} cb\r\n         * @param {*} [context]\r\n         * @return {Array}\r\n         */\r\n        function map(obj, cb, context) {\r\n            if (!(obj && cb)) {\r\n                return;\r\n            }\r\n            if (obj.map && obj.map === nativeMap) {\r\n                return obj.map(cb, context);\r\n            }\r\n            else {\r\n                var result = [];\r\n                for (var i = 0, len = obj.length; i < len; i++) {\r\n                    result.push(cb.call(context, obj[i], i, obj));\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 数组过滤\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Array} obj\r\n         * @param {Function} cb\r\n         * @param {*} [context]\r\n         * @return {Array}\r\n         */\r\n        function filter(obj, cb, context) {\r\n            if (!(obj && cb)) {\r\n                return;\r\n            }\r\n            if (obj.filter && obj.filter === nativeFilter) {\r\n                return obj.filter(cb, context);\r\n            }\r\n            else {\r\n                var result = [];\r\n                for (var i = 0, len = obj.length; i < len; i++) {\r\n                    if (cb.call(context, obj[i], i, obj)) {\r\n                        result.push(obj[i]);\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n\r\n        function bind(func, context) {\r\n            \r\n            return function () {\r\n                func.apply(context, arguments);\r\n            }\r\n        }\r\n\r\n        return {\r\n            inherits: inherits,\r\n            clone: clone,\r\n            merge: merge,\r\n            getContext: getContext,\r\n            indexOf: indexOf,\r\n            each: each,\r\n            map: map,\r\n            filter: filter,\r\n            bind: bind\r\n        };\r\n    }\r\n);\r\n"
        },
        {
          "id": 11,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\dep\\excanvas.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/dep/excanvas.js",
          "index": 11,
          "index2": 2,
          "size": 44025,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\util.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 10,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\util.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/util.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/util.js",
              "type": "cjs require",
              "userRequest": "../dep/excanvas",
              "loc": "105:16-42"
            }
          ],
          "source": "// Copyright 2006 Google Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n\r\n// Known Issues:\r\n//\r\n// * Patterns only support repeat.\r\n// * Radial gradient are not implemented. The VML version of these look very\r\n//   different from the canvas one.\r\n// * Clipping paths are not implemented.\r\n// * Coordsize. The width and height attribute have higher priority than the\r\n//   width and height style values which isn't correct.\r\n// * Painting mode isn't implemented.\r\n// * Canvas width/height should is using content-box by default. IE in\r\n//   Quirks mode will draw the canvas using border-box. Either change your\r\n//   doctype to HTML5\r\n//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype)\r\n//   or use Box Sizing Behavior from WebFX\r\n//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html)\r\n// * Non uniform scaling does not correctly scale strokes.\r\n// * Optimize. There is always room for speed improvements.\r\n\r\n// AMD by kener.linfeng@gmail.com\r\ndefine(function(require) {\r\n\r\n// Only add this code if we do not already have a canvas implementation\r\nif (!document.createElement('canvas').getContext) {\r\n\r\n(function() {\r\n\r\n  // alias some functions to make (compiled) code shorter\r\n  var m = Math;\r\n  var mr = m.round;\r\n  var ms = m.sin;\r\n  var mc = m.cos;\r\n  var abs = m.abs;\r\n  var sqrt = m.sqrt;\r\n\r\n  // this is used for sub pixel precision\r\n  var Z = 10;\r\n  var Z2 = Z / 2;\r\n\r\n  var IE_VERSION = +navigator.userAgent.match(/MSIE ([\\d.]+)?/)[1];\r\n\r\n  /**\r\n   * This funtion is assigned to the <canvas> elements as element.getContext().\r\n   * @this {HTMLElement}\r\n   * @return {CanvasRenderingContext2D_}\r\n   */\r\n  function getContext() {\r\n    return this.context_ ||\r\n        (this.context_ = new CanvasRenderingContext2D_(this));\r\n  }\r\n\r\n  var slice = Array.prototype.slice;\r\n\r\n  /**\r\n   * Binds a function to an object. The returned function will always use the\r\n   * passed in {@code obj} as {@code this}.\r\n   *\r\n   * Example:\r\n   *\r\n   *   g = bind(f, obj, a, b)\r\n   *   g(c, d) // will do f.call(obj, a, b, c, d)\r\n   *\r\n   * @param {Function} f The function to bind the object to\r\n   * @param {Object} obj The object that should act as this when the function\r\n   *     is called\r\n   * @param {*} var_args Rest arguments that will be used as the initial\r\n   *     arguments when the function is called\r\n   * @return {Function} A new function that has bound this\r\n   */\r\n  function bind(f, obj, var_args) {\r\n    var a = slice.call(arguments, 2);\r\n    return function() {\r\n      return f.apply(obj, a.concat(slice.call(arguments)));\r\n    };\r\n  }\r\n\r\n  function encodeHtmlAttribute(s) {\r\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\r\n  }\r\n\r\n  function addNamespace(doc, prefix, urn) {\r\n    if (!doc.namespaces[prefix]) {\r\n      doc.namespaces.add(prefix, urn, '#default#VML');\r\n    }\r\n  }\r\n\r\n  function addNamespacesAndStylesheet(doc) {\r\n    addNamespace(doc, 'g_vml_', 'urn:schemas-microsoft-com:vml');\r\n    addNamespace(doc, 'g_o_', 'urn:schemas-microsoft-com:office:office');\r\n\r\n    // Setup default CSS.  Only add one style sheet per document\r\n    if (!doc.styleSheets['ex_canvas_']) {\r\n      var ss = doc.createStyleSheet();\r\n      ss.owningElement.id = 'ex_canvas_';\r\n      ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +\r\n          // default size is 300x150 in Gecko and Opera\r\n          'text-align:left;width:300px;height:150px}';\r\n    }\r\n  }\r\n\r\n  // Add namespaces and stylesheet at startup.\r\n  addNamespacesAndStylesheet(document);\r\n\r\n  var G_vmlCanvasManager_ = {\r\n    init: function(opt_doc) {\r\n      var doc = opt_doc || document;\r\n      // Create a dummy element so that IE will allow canvas elements to be\r\n      // recognized.\r\n      doc.createElement('canvas');\r\n      doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));\r\n    },\r\n\r\n    init_: function(doc) {\r\n      // find all canvas elements\r\n      var els = doc.getElementsByTagName('canvas');\r\n      for (var i = 0; i < els.length; i++) {\r\n        this.initElement(els[i]);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Public initializes a canvas element so that it can be used as canvas\r\n     * element from now on. This is called automatically before the page is\r\n     * loaded but if you are creating elements using createElement you need to\r\n     * make sure this is called on the element.\r\n     * @param {HTMLElement} el The canvas element to initialize.\r\n     * @return {HTMLElement} the element that was created.\r\n     */\r\n    initElement: function(el) {\r\n      if (!el.getContext) {\r\n        el.getContext = getContext;\r\n\r\n        // Add namespaces and stylesheet to document of the element.\r\n        addNamespacesAndStylesheet(el.ownerDocument);\r\n\r\n        // Remove fallback content. There is no way to hide text nodes so we\r\n        // just remove all childNodes. We could hide all elements and remove\r\n        // text nodes but who really cares about the fallback content.\r\n        el.innerHTML = '';\r\n\r\n        // do not use inline function because that will leak memory\r\n        el.attachEvent('onpropertychange', onPropertyChange);\r\n        el.attachEvent('onresize', onResize);\r\n\r\n        var attrs = el.attributes;\r\n        if (attrs.width && attrs.width.specified) {\r\n          // TODO: use runtimeStyle and coordsize\r\n          // el.getContext().setWidth_(attrs.width.nodeValue);\r\n          el.style.width = attrs.width.nodeValue + 'px';\r\n        } else {\r\n          el.width = el.clientWidth;\r\n        }\r\n        if (attrs.height && attrs.height.specified) {\r\n          // TODO: use runtimeStyle and coordsize\r\n          // el.getContext().setHeight_(attrs.height.nodeValue);\r\n          el.style.height = attrs.height.nodeValue + 'px';\r\n        } else {\r\n          el.height = el.clientHeight;\r\n        }\r\n        //el.getContext().setCoordsize_()\r\n      }\r\n      return el;\r\n    }\r\n  };\r\n\r\n  function onPropertyChange(e) {\r\n    var el = e.srcElement;\r\n\r\n    switch (e.propertyName) {\r\n      case 'width':\r\n        el.getContext().clearRect();\r\n        el.style.width = el.attributes.width.nodeValue + 'px';\r\n        // In IE8 this does not trigger onresize.\r\n        el.firstChild.style.width =  el.clientWidth + 'px';\r\n        break;\r\n      case 'height':\r\n        el.getContext().clearRect();\r\n        el.style.height = el.attributes.height.nodeValue + 'px';\r\n        el.firstChild.style.height = el.clientHeight + 'px';\r\n        break;\r\n    }\r\n  }\r\n\r\n  function onResize(e) {\r\n    var el = e.srcElement;\r\n    if (el.firstChild) {\r\n      el.firstChild.style.width =  el.clientWidth + 'px';\r\n      el.firstChild.style.height = el.clientHeight + 'px';\r\n    }\r\n  }\r\n\r\n  G_vmlCanvasManager_.init();\r\n\r\n  // precompute \"00\" to \"FF\"\r\n  var decToHex = [];\r\n  for (var i = 0; i < 16; i++) {\r\n    for (var j = 0; j < 16; j++) {\r\n      decToHex[i * 16 + j] = i.toString(16) + j.toString(16);\r\n    }\r\n  }\r\n\r\n  function createMatrixIdentity() {\r\n    return [\r\n      [1, 0, 0],\r\n      [0, 1, 0],\r\n      [0, 0, 1]\r\n    ];\r\n  }\r\n\r\n  function matrixMultiply(m1, m2) {\r\n    var result = createMatrixIdentity();\r\n\r\n    for (var x = 0; x < 3; x++) {\r\n      for (var y = 0; y < 3; y++) {\r\n        var sum = 0;\r\n\r\n        for (var z = 0; z < 3; z++) {\r\n          sum += m1[x][z] * m2[z][y];\r\n        }\r\n\r\n        result[x][y] = sum;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function copyState(o1, o2) {\r\n    o2.fillStyle     = o1.fillStyle;\r\n    o2.lineCap       = o1.lineCap;\r\n    o2.lineJoin      = o1.lineJoin;\r\n    o2.lineWidth     = o1.lineWidth;\r\n    o2.miterLimit    = o1.miterLimit;\r\n    o2.shadowBlur    = o1.shadowBlur;\r\n    o2.shadowColor   = o1.shadowColor;\r\n    o2.shadowOffsetX = o1.shadowOffsetX;\r\n    o2.shadowOffsetY = o1.shadowOffsetY;\r\n    o2.strokeStyle   = o1.strokeStyle;\r\n    o2.globalAlpha   = o1.globalAlpha;\r\n    o2.font          = o1.font;\r\n    o2.textAlign     = o1.textAlign;\r\n    o2.textBaseline  = o1.textBaseline;\r\n    o2.scaleX_    = o1.scaleX_;\r\n    o2.scaleY_    = o1.scaleY_;\r\n    o2.lineScale_    = o1.lineScale_;\r\n  }\r\n\r\n  var colorData = {\r\n    aliceblue: '#F0F8FF',\r\n    antiquewhite: '#FAEBD7',\r\n    aquamarine: '#7FFFD4',\r\n    azure: '#F0FFFF',\r\n    beige: '#F5F5DC',\r\n    bisque: '#FFE4C4',\r\n    black: '#000000',\r\n    blanchedalmond: '#FFEBCD',\r\n    blueviolet: '#8A2BE2',\r\n    brown: '#A52A2A',\r\n    burlywood: '#DEB887',\r\n    cadetblue: '#5F9EA0',\r\n    chartreuse: '#7FFF00',\r\n    chocolate: '#D2691E',\r\n    coral: '#FF7F50',\r\n    cornflowerblue: '#6495ED',\r\n    cornsilk: '#FFF8DC',\r\n    crimson: '#DC143C',\r\n    cyan: '#00FFFF',\r\n    darkblue: '#00008B',\r\n    darkcyan: '#008B8B',\r\n    darkgoldenrod: '#B8860B',\r\n    darkgray: '#A9A9A9',\r\n    darkgreen: '#006400',\r\n    darkgrey: '#A9A9A9',\r\n    darkkhaki: '#BDB76B',\r\n    darkmagenta: '#8B008B',\r\n    darkolivegreen: '#556B2F',\r\n    darkorange: '#FF8C00',\r\n    darkorchid: '#9932CC',\r\n    darkred: '#8B0000',\r\n    darksalmon: '#E9967A',\r\n    darkseagreen: '#8FBC8F',\r\n    darkslateblue: '#483D8B',\r\n    darkslategray: '#2F4F4F',\r\n    darkslategrey: '#2F4F4F',\r\n    darkturquoise: '#00CED1',\r\n    darkviolet: '#9400D3',\r\n    deeppink: '#FF1493',\r\n    deepskyblue: '#00BFFF',\r\n    dimgray: '#696969',\r\n    dimgrey: '#696969',\r\n    dodgerblue: '#1E90FF',\r\n    firebrick: '#B22222',\r\n    floralwhite: '#FFFAF0',\r\n    forestgreen: '#228B22',\r\n    gainsboro: '#DCDCDC',\r\n    ghostwhite: '#F8F8FF',\r\n    gold: '#FFD700',\r\n    goldenrod: '#DAA520',\r\n    grey: '#808080',\r\n    greenyellow: '#ADFF2F',\r\n    honeydew: '#F0FFF0',\r\n    hotpink: '#FF69B4',\r\n    indianred: '#CD5C5C',\r\n    indigo: '#4B0082',\r\n    ivory: '#FFFFF0',\r\n    khaki: '#F0E68C',\r\n    lavender: '#E6E6FA',\r\n    lavenderblush: '#FFF0F5',\r\n    lawngreen: '#7CFC00',\r\n    lemonchiffon: '#FFFACD',\r\n    lightblue: '#ADD8E6',\r\n    lightcoral: '#F08080',\r\n    lightcyan: '#E0FFFF',\r\n    lightgoldenrodyellow: '#FAFAD2',\r\n    lightgreen: '#90EE90',\r\n    lightgrey: '#D3D3D3',\r\n    lightpink: '#FFB6C1',\r\n    lightsalmon: '#FFA07A',\r\n    lightseagreen: '#20B2AA',\r\n    lightskyblue: '#87CEFA',\r\n    lightslategray: '#778899',\r\n    lightslategrey: '#778899',\r\n    lightsteelblue: '#B0C4DE',\r\n    lightyellow: '#FFFFE0',\r\n    limegreen: '#32CD32',\r\n    linen: '#FAF0E6',\r\n    magenta: '#FF00FF',\r\n    mediumaquamarine: '#66CDAA',\r\n    mediumblue: '#0000CD',\r\n    mediumorchid: '#BA55D3',\r\n    mediumpurple: '#9370DB',\r\n    mediumseagreen: '#3CB371',\r\n    mediumslateblue: '#7B68EE',\r\n    mediumspringgreen: '#00FA9A',\r\n    mediumturquoise: '#48D1CC',\r\n    mediumvioletred: '#C71585',\r\n    midnightblue: '#191970',\r\n    mintcream: '#F5FFFA',\r\n    mistyrose: '#FFE4E1',\r\n    moccasin: '#FFE4B5',\r\n    navajowhite: '#FFDEAD',\r\n    oldlace: '#FDF5E6',\r\n    olivedrab: '#6B8E23',\r\n    orange: '#FFA500',\r\n    orangered: '#FF4500',\r\n    orchid: '#DA70D6',\r\n    palegoldenrod: '#EEE8AA',\r\n    palegreen: '#98FB98',\r\n    paleturquoise: '#AFEEEE',\r\n    palevioletred: '#DB7093',\r\n    papayawhip: '#FFEFD5',\r\n    peachpuff: '#FFDAB9',\r\n    peru: '#CD853F',\r\n    pink: '#FFC0CB',\r\n    plum: '#DDA0DD',\r\n    powderblue: '#B0E0E6',\r\n    rosybrown: '#BC8F8F',\r\n    royalblue: '#4169E1',\r\n    saddlebrown: '#8B4513',\r\n    salmon: '#FA8072',\r\n    sandybrown: '#F4A460',\r\n    seagreen: '#2E8B57',\r\n    seashell: '#FFF5EE',\r\n    sienna: '#A0522D',\r\n    skyblue: '#87CEEB',\r\n    slateblue: '#6A5ACD',\r\n    slategray: '#708090',\r\n    slategrey: '#708090',\r\n    snow: '#FFFAFA',\r\n    springgreen: '#00FF7F',\r\n    steelblue: '#4682B4',\r\n    tan: '#D2B48C',\r\n    thistle: '#D8BFD8',\r\n    tomato: '#FF6347',\r\n    turquoise: '#40E0D0',\r\n    violet: '#EE82EE',\r\n    wheat: '#F5DEB3',\r\n    whitesmoke: '#F5F5F5',\r\n    yellowgreen: '#9ACD32'\r\n  };\r\n\r\n\r\n  function getRgbHslContent(styleString) {\r\n    var start = styleString.indexOf('(', 3);\r\n    var end = styleString.indexOf(')', start + 1);\r\n    var parts = styleString.substring(start + 1, end).split(',');\r\n    // add alpha if needed\r\n    if (parts.length != 4 || styleString.charAt(3) != 'a') {\r\n      parts[3] = 1;\r\n    }\r\n    return parts;\r\n  }\r\n\r\n  function percent(s) {\r\n    return parseFloat(s) / 100;\r\n  }\r\n\r\n  function clamp(v, min, max) {\r\n    return Math.min(max, Math.max(min, v));\r\n  }\r\n\r\n  function hslToRgb(parts){\r\n    var r, g, b, h, s, l;\r\n    h = parseFloat(parts[0]) / 360 % 360;\r\n    if (h < 0)\r\n      h++;\r\n    s = clamp(percent(parts[1]), 0, 1);\r\n    l = clamp(percent(parts[2]), 0, 1);\r\n    if (s == 0) {\r\n      r = g = b = l; // achromatic\r\n    } else {\r\n      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n      var p = 2 * l - q;\r\n      r = hueToRgb(p, q, h + 1 / 3);\r\n      g = hueToRgb(p, q, h);\r\n      b = hueToRgb(p, q, h - 1 / 3);\r\n    }\r\n\r\n    return '#' + decToHex[Math.floor(r * 255)] +\r\n        decToHex[Math.floor(g * 255)] +\r\n        decToHex[Math.floor(b * 255)];\r\n  }\r\n\r\n  function hueToRgb(m1, m2, h) {\r\n    if (h < 0)\r\n      h++;\r\n    if (h > 1)\r\n      h--;\r\n\r\n    if (6 * h < 1)\r\n      return m1 + (m2 - m1) * 6 * h;\r\n    else if (2 * h < 1)\r\n      return m2;\r\n    else if (3 * h < 2)\r\n      return m1 + (m2 - m1) * (2 / 3 - h) * 6;\r\n    else\r\n      return m1;\r\n  }\r\n\r\n  var processStyleCache = {};\r\n\r\n  function processStyle(styleString) {\r\n    if (styleString in processStyleCache) {\r\n      return processStyleCache[styleString];\r\n    }\r\n\r\n    var str, alpha = 1;\r\n\r\n    styleString = String(styleString);\r\n    if (styleString.charAt(0) == '#') {\r\n      str = styleString;\r\n    } else if (/^rgb/.test(styleString)) {\r\n      var parts = getRgbHslContent(styleString);\r\n      var str = '#', n;\r\n      for (var i = 0; i < 3; i++) {\r\n        if (parts[i].indexOf('%') != -1) {\r\n          n = Math.floor(percent(parts[i]) * 255);\r\n        } else {\r\n          n = +parts[i];\r\n        }\r\n        str += decToHex[clamp(n, 0, 255)];\r\n      }\r\n      alpha = +parts[3];\r\n    } else if (/^hsl/.test(styleString)) {\r\n      var parts = getRgbHslContent(styleString);\r\n      str = hslToRgb(parts);\r\n      alpha = parts[3];\r\n    } else {\r\n      str = colorData[styleString] || styleString;\r\n    }\r\n    return processStyleCache[styleString] = {color: str, alpha: alpha};\r\n  }\r\n\r\n  var DEFAULT_STYLE = {\r\n    style: 'normal',\r\n    variant: 'normal',\r\n    weight: 'normal',\r\n    size: 12,           //10\r\n    family: '微软雅黑'     //'sans-serif'\r\n  };\r\n\r\n  // Internal text style cache\r\n  var fontStyleCache = {};\r\n\r\n  function processFontStyle(styleString) {\r\n    if (fontStyleCache[styleString]) {\r\n      return fontStyleCache[styleString];\r\n    }\r\n\r\n    var el = document.createElement('div');\r\n    var style = el.style;\r\n    var fontFamily;\r\n    try {\r\n      style.font = styleString;\r\n      fontFamily = style.fontFamily.split(',')[0];\r\n    } catch (ex) {\r\n      // Ignore failures to set to invalid font.\r\n    }\r\n\r\n    return fontStyleCache[styleString] = {\r\n      style: style.fontStyle || DEFAULT_STYLE.style,\r\n      variant: style.fontVariant || DEFAULT_STYLE.variant,\r\n      weight: style.fontWeight || DEFAULT_STYLE.weight,\r\n      size: style.fontSize || DEFAULT_STYLE.size,\r\n      family: fontFamily || DEFAULT_STYLE.family\r\n    };\r\n  }\r\n\r\n  function getComputedStyle(style, element) {\r\n    var computedStyle = {};\r\n\r\n    for (var p in style) {\r\n      computedStyle[p] = style[p];\r\n    }\r\n\r\n    // Compute the size\r\n    var canvasFontSize = parseFloat(element.currentStyle.fontSize),\r\n        fontSize = parseFloat(style.size);\r\n\r\n    if (typeof style.size == 'number') {\r\n      computedStyle.size = style.size;\r\n    } else if (style.size.indexOf('px') != -1) {\r\n      computedStyle.size = fontSize;\r\n    } else if (style.size.indexOf('em') != -1) {\r\n      computedStyle.size = canvasFontSize * fontSize;\r\n    } else if(style.size.indexOf('%') != -1) {\r\n      computedStyle.size = (canvasFontSize / 100) * fontSize;\r\n    } else if (style.size.indexOf('pt') != -1) {\r\n      computedStyle.size = fontSize / .75;\r\n    } else {\r\n      computedStyle.size = canvasFontSize;\r\n    }\r\n\r\n    // Different scaling between normal text and VML text. This was found using\r\n    // trial and error to get the same size as non VML text.\r\n    //computedStyle.size *= 0.981;\r\n\r\n    return computedStyle;\r\n  }\r\n\r\n  function buildStyle(style) {\r\n    return style.style + ' ' + style.variant + ' ' + style.weight + ' ' +\r\n        style.size + \"px '\" + style.family + \"'\";\r\n  }\r\n\r\n  var lineCapMap = {\r\n    'butt': 'flat',\r\n    'round': 'round'\r\n  };\r\n\r\n  function processLineCap(lineCap) {\r\n    return lineCapMap[lineCap] || 'square';\r\n  }\r\n\r\n  /**\r\n   * This class implements CanvasRenderingContext2D interface as described by\r\n   * the WHATWG.\r\n   * @param {HTMLElement} canvasElement The element that the 2D context should\r\n   * be associated with\r\n   */\r\n  function CanvasRenderingContext2D_(canvasElement) {\r\n    this.m_ = createMatrixIdentity();\r\n\r\n    this.mStack_ = [];\r\n    this.aStack_ = [];\r\n    this.currentPath_ = [];\r\n\r\n    // Canvas context properties\r\n    this.strokeStyle = '#000';\r\n    this.fillStyle = '#000';\r\n\r\n    this.lineWidth = 1;\r\n    this.lineJoin = 'miter';\r\n    this.lineCap = 'butt';\r\n    this.miterLimit = Z * 1;\r\n    this.globalAlpha = 1;\r\n    // this.font = '10px sans-serif';\r\n    this.font = '12px 微软雅黑';        // 决定还是改这吧，影响代价最小\r\n    this.textAlign = 'left';\r\n    this.textBaseline = 'alphabetic';\r\n    this.canvas = canvasElement;\r\n\r\n    var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' +\r\n        canvasElement.clientHeight + 'px;overflow:hidden;position:absolute';\r\n    var el = canvasElement.ownerDocument.createElement('div');\r\n    el.style.cssText = cssText;\r\n    canvasElement.appendChild(el);\r\n\r\n    var overlayEl = el.cloneNode(false);\r\n    // Use a non transparent background.\r\n    overlayEl.style.backgroundColor = '#fff'; //red, I don't know why, it work!\r\n    overlayEl.style.filter = 'alpha(opacity=0)';\r\n    canvasElement.appendChild(overlayEl);\r\n\r\n    this.element_ = el;\r\n    this.scaleX_ = 1;\r\n    this.scaleY_ = 1;\r\n    this.lineScale_ = 1;\r\n  }\r\n\r\n  var contextPrototype = CanvasRenderingContext2D_.prototype;\r\n  contextPrototype.clearRect = function() {\r\n    if (this.textMeasureEl_) {\r\n      this.textMeasureEl_.removeNode(true);\r\n      this.textMeasureEl_ = null;\r\n    }\r\n    this.element_.innerHTML = '';\r\n  };\r\n\r\n  contextPrototype.beginPath = function() {\r\n    // TODO: Branch current matrix so that save/restore has no effect\r\n    //       as per safari docs.\r\n    this.currentPath_ = [];\r\n  };\r\n\r\n  contextPrototype.moveTo = function(aX, aY) {\r\n    var p = getCoords(this, aX, aY);\r\n    this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});\r\n    this.currentX_ = p.x;\r\n    this.currentY_ = p.y;\r\n  };\r\n\r\n  contextPrototype.lineTo = function(aX, aY) {\r\n    var p = getCoords(this, aX, aY);\r\n    this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});\r\n\r\n    this.currentX_ = p.x;\r\n    this.currentY_ = p.y;\r\n  };\r\n\r\n  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,\r\n                                            aCP2x, aCP2y,\r\n                                            aX, aY) {\r\n    var p = getCoords(this, aX, aY);\r\n    var cp1 = getCoords(this, aCP1x, aCP1y);\r\n    var cp2 = getCoords(this, aCP2x, aCP2y);\r\n    bezierCurveTo(this, cp1, cp2, p);\r\n  };\r\n\r\n  // Helper function that takes the already fixed cordinates.\r\n  function bezierCurveTo(self, cp1, cp2, p) {\r\n    self.currentPath_.push({\r\n      type: 'bezierCurveTo',\r\n      cp1x: cp1.x,\r\n      cp1y: cp1.y,\r\n      cp2x: cp2.x,\r\n      cp2y: cp2.y,\r\n      x: p.x,\r\n      y: p.y\r\n    });\r\n    self.currentX_ = p.x;\r\n    self.currentY_ = p.y;\r\n  }\r\n\r\n  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {\r\n    // the following is lifted almost directly from\r\n    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes\r\n\r\n    var cp = getCoords(this, aCPx, aCPy);\r\n    var p = getCoords(this, aX, aY);\r\n\r\n    var cp1 = {\r\n      x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),\r\n      y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)\r\n    };\r\n    var cp2 = {\r\n      x: cp1.x + (p.x - this.currentX_) / 3.0,\r\n      y: cp1.y + (p.y - this.currentY_) / 3.0\r\n    };\r\n\r\n    bezierCurveTo(this, cp1, cp2, p);\r\n  };\r\n\r\n  contextPrototype.arc = function(aX, aY, aRadius,\r\n                                  aStartAngle, aEndAngle, aClockwise) {\r\n    aRadius *= Z;\r\n    var arcType = aClockwise ? 'at' : 'wa';\r\n\r\n    var xStart = aX + mc(aStartAngle) * aRadius - Z2;\r\n    var yStart = aY + ms(aStartAngle) * aRadius - Z2;\r\n\r\n    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;\r\n    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;\r\n\r\n    // IE won't render arches drawn counter clockwise if xStart == xEnd.\r\n    if (xStart == xEnd && !aClockwise) {\r\n      xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something\r\n                       // that can be represented in binary\r\n    }\r\n\r\n    var p = getCoords(this, aX, aY);\r\n    var pStart = getCoords(this, xStart, yStart);\r\n    var pEnd = getCoords(this, xEnd, yEnd);\r\n\r\n    this.currentPath_.push({type: arcType,\r\n                           x: p.x,\r\n                           y: p.y,\r\n                           radius: aRadius,\r\n                           xStart: pStart.x,\r\n                           yStart: pStart.y,\r\n                           xEnd: pEnd.x,\r\n                           yEnd: pEnd.y});\r\n\r\n  };\r\n\r\n  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {\r\n    this.moveTo(aX, aY);\r\n    this.lineTo(aX + aWidth, aY);\r\n    this.lineTo(aX + aWidth, aY + aHeight);\r\n    this.lineTo(aX, aY + aHeight);\r\n    this.closePath();\r\n  };\r\n\r\n  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {\r\n    var oldPath = this.currentPath_;\r\n    this.beginPath();\r\n\r\n    this.moveTo(aX, aY);\r\n    this.lineTo(aX + aWidth, aY);\r\n    this.lineTo(aX + aWidth, aY + aHeight);\r\n    this.lineTo(aX, aY + aHeight);\r\n    this.closePath();\r\n    this.stroke();\r\n\r\n    this.currentPath_ = oldPath;\r\n  };\r\n\r\n  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {\r\n    var oldPath = this.currentPath_;\r\n    this.beginPath();\r\n\r\n    this.moveTo(aX, aY);\r\n    this.lineTo(aX + aWidth, aY);\r\n    this.lineTo(aX + aWidth, aY + aHeight);\r\n    this.lineTo(aX, aY + aHeight);\r\n    this.closePath();\r\n    this.fill();\r\n\r\n    this.currentPath_ = oldPath;\r\n  };\r\n\r\n  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {\r\n    var gradient = new CanvasGradient_('gradient');\r\n    gradient.x0_ = aX0;\r\n    gradient.y0_ = aY0;\r\n    gradient.x1_ = aX1;\r\n    gradient.y1_ = aY1;\r\n    return gradient;\r\n  };\r\n\r\n  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,\r\n                                                   aX1, aY1, aR1) {\r\n    var gradient = new CanvasGradient_('gradientradial');\r\n    gradient.x0_ = aX0;\r\n    gradient.y0_ = aY0;\r\n    gradient.r0_ = aR0;\r\n    gradient.x1_ = aX1;\r\n    gradient.y1_ = aY1;\r\n    gradient.r1_ = aR1;\r\n    return gradient;\r\n  };\r\n\r\n  contextPrototype.drawImage = function(image, var_args) {\r\n    var dx, dy, dw, dh, sx, sy, sw, sh;\r\n\r\n    // to find the original width we overide the width and height\r\n    var oldRuntimeWidth = image.runtimeStyle.width;\r\n    var oldRuntimeHeight = image.runtimeStyle.height;\r\n    image.runtimeStyle.width = 'auto';\r\n    image.runtimeStyle.height = 'auto';\r\n\r\n    // get the original size\r\n    var w = image.width;\r\n    var h = image.height;\r\n\r\n    // and remove overides\r\n    image.runtimeStyle.width = oldRuntimeWidth;\r\n    image.runtimeStyle.height = oldRuntimeHeight;\r\n\r\n    if (arguments.length == 3) {\r\n      dx = arguments[1];\r\n      dy = arguments[2];\r\n      sx = sy = 0;\r\n      sw = dw = w;\r\n      sh = dh = h;\r\n    } else if (arguments.length == 5) {\r\n      dx = arguments[1];\r\n      dy = arguments[2];\r\n      dw = arguments[3];\r\n      dh = arguments[4];\r\n      sx = sy = 0;\r\n      sw = w;\r\n      sh = h;\r\n    } else if (arguments.length == 9) {\r\n      sx = arguments[1];\r\n      sy = arguments[2];\r\n      sw = arguments[3];\r\n      sh = arguments[4];\r\n      dx = arguments[5];\r\n      dy = arguments[6];\r\n      dw = arguments[7];\r\n      dh = arguments[8];\r\n    } else {\r\n      throw Error('Invalid number of arguments');\r\n    }\r\n\r\n    var d = getCoords(this, dx, dy);\r\n\r\n    var w2 = sw / 2;\r\n    var h2 = sh / 2;\r\n\r\n    var vmlStr = [];\r\n\r\n    var W = 10;\r\n    var H = 10;\r\n\r\n    var scaleX = scaleY = 1;\r\n\r\n    // For some reason that I've now forgotten, using divs didn't work\r\n    vmlStr.push(' <g_vml_:group',\r\n                ' coordsize=\"', Z * W, ',', Z * H, '\"',\r\n                ' coordorigin=\"0,0\"' ,\r\n                ' style=\"width:', W, 'px;height:', H, 'px;position:absolute;');\r\n\r\n    // If filters are necessary (rotation exists), create them\r\n    // filters are bog-slow, so only create them if abbsolutely necessary\r\n    // The following check doesn't account for skews (which don't exist\r\n    // in the canvas spec (yet) anyway.\r\n\r\n    if (this.m_[0][0] != 1 || this.m_[0][1] ||\r\n        this.m_[1][1] != 1 || this.m_[1][0]) {\r\n      var filter = [];\r\n\r\n     var scaleX = this.scaleX_;\r\n     var scaleY = this.scaleY_;\r\n      // Note the 12/21 reversal\r\n      filter.push('M11=', this.m_[0][0] / scaleX, ',',\r\n                  'M12=', this.m_[1][0] / scaleY, ',',\r\n                  'M21=', this.m_[0][1] / scaleX, ',',\r\n                  'M22=', this.m_[1][1] / scaleY, ',',\r\n                  'Dx=', mr(d.x / Z), ',',\r\n                  'Dy=', mr(d.y / Z), '');\r\n\r\n      // Bounding box calculation (need to minimize displayed area so that\r\n      // filters don't waste time on unused pixels.\r\n      var max = d;\r\n      var c2 = getCoords(this, dx + dw, dy);\r\n      var c3 = getCoords(this, dx, dy + dh);\r\n      var c4 = getCoords(this, dx + dw, dy + dh);\r\n\r\n      max.x = m.max(max.x, c2.x, c3.x, c4.x);\r\n      max.y = m.max(max.y, c2.y, c3.y, c4.y);\r\n\r\n      vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),\r\n                  'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',\r\n                  filter.join(''), \", SizingMethod='clip');\");\r\n\r\n    } else {\r\n      vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');\r\n    }\r\n\r\n    vmlStr.push(' \">');\r\n\r\n    // Draw a special cropping div if needed\r\n    if (sx || sy) {\r\n      // Apply scales to width and height\r\n      vmlStr.push('<div style=\"overflow: hidden; width:', Math.ceil((dw + sx * dw / sw) * scaleX), 'px;',\r\n                  ' height:', Math.ceil((dh + sy * dh / sh) * scaleY), 'px;',\r\n                  ' filter:progid:DxImageTransform.Microsoft.Matrix(Dx=',\r\n                  -sx * dw / sw * scaleX, ',Dy=', -sy * dh / sh * scaleY, ');\">');\r\n    }\r\n\r\n\r\n    // Apply scales to width and height\r\n    vmlStr.push('<div style=\"width:', Math.round(scaleX * w * dw / sw), 'px;',\r\n                ' height:', Math.round(scaleY * h * dh / sh), 'px;',\r\n                ' filter:');\r\n\r\n    // If there is a globalAlpha, apply it to image\r\n    if(this.globalAlpha < 1) {\r\n      vmlStr.push(' progid:DXImageTransform.Microsoft.Alpha(opacity=' + (this.globalAlpha * 100) + ')');\r\n    }\r\n\r\n    vmlStr.push(' progid:DXImageTransform.Microsoft.AlphaImageLoader(src=', image.src, ',sizingMethod=scale)\">');\r\n\r\n    // Close the crop div if necessary\r\n    if (sx || sy) vmlStr.push('</div>');\r\n\r\n    vmlStr.push('</div></div>');\r\n\r\n    this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));\r\n  };\r\n\r\n  contextPrototype.stroke = function(aFill) {\r\n    var lineStr = [];\r\n    var lineOpen = false;\r\n\r\n    var W = 10;\r\n    var H = 10;\r\n\r\n    lineStr.push('<g_vml_:shape',\r\n                 ' filled=\"', !!aFill, '\"',\r\n                 ' style=\"position:absolute;width:', W, 'px;height:', H, 'px;\"',\r\n                 ' coordorigin=\"0,0\"',\r\n                 ' coordsize=\"', Z * W, ',', Z * H, '\"',\r\n                 ' stroked=\"', !aFill, '\"',\r\n                 ' path=\"');\r\n\r\n    var newSeq = false;\r\n    var min = {x: null, y: null};\r\n    var max = {x: null, y: null};\r\n\r\n    for (var i = 0; i < this.currentPath_.length; i++) {\r\n      var p = this.currentPath_[i];\r\n      var c;\r\n\r\n      switch (p.type) {\r\n        case 'moveTo':\r\n          c = p;\r\n          lineStr.push(' m ', mr(p.x), ',', mr(p.y));\r\n          break;\r\n        case 'lineTo':\r\n          lineStr.push(' l ', mr(p.x), ',', mr(p.y));\r\n          break;\r\n        case 'close':\r\n          lineStr.push(' x ');\r\n          p = null;\r\n          break;\r\n        case 'bezierCurveTo':\r\n          lineStr.push(' c ',\r\n                       mr(p.cp1x), ',', mr(p.cp1y), ',',\r\n                       mr(p.cp2x), ',', mr(p.cp2y), ',',\r\n                       mr(p.x), ',', mr(p.y));\r\n          break;\r\n        case 'at':\r\n        case 'wa':\r\n          lineStr.push(' ', p.type, ' ',\r\n                       mr(p.x - this.scaleX_ * p.radius), ',',\r\n                       mr(p.y - this.scaleY_ * p.radius), ' ',\r\n                       mr(p.x + this.scaleX_ * p.radius), ',',\r\n                       mr(p.y + this.scaleY_ * p.radius), ' ',\r\n                       mr(p.xStart), ',', mr(p.yStart), ' ',\r\n                       mr(p.xEnd), ',', mr(p.yEnd));\r\n          break;\r\n      }\r\n\r\n\r\n      // TODO: Following is broken for curves due to\r\n      //       move to proper paths.\r\n\r\n      // Figure out dimensions so we can do gradient fills\r\n      // properly\r\n      if (p) {\r\n        if (min.x == null || p.x < min.x) {\r\n          min.x = p.x;\r\n        }\r\n        if (max.x == null || p.x > max.x) {\r\n          max.x = p.x;\r\n        }\r\n        if (min.y == null || p.y < min.y) {\r\n          min.y = p.y;\r\n        }\r\n        if (max.y == null || p.y > max.y) {\r\n          max.y = p.y;\r\n        }\r\n      }\r\n    }\r\n    lineStr.push(' \">');\r\n\r\n    if (!aFill) {\r\n      appendStroke(this, lineStr);\r\n    } else {\r\n      appendFill(this, lineStr, min, max);\r\n    }\r\n\r\n    lineStr.push('</g_vml_:shape>');\r\n\r\n    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));\r\n  };\r\n\r\n  function appendStroke(ctx, lineStr) {\r\n    var a = processStyle(ctx.strokeStyle);\r\n    var color = a.color;\r\n    var opacity = a.alpha * ctx.globalAlpha;\r\n    var lineWidth = ctx.lineScale_ * ctx.lineWidth;\r\n\r\n    // VML cannot correctly render a line if the width is less than 1px.\r\n    // In that case, we dilute the color to make the line look thinner.\r\n    if (lineWidth < 1) {\r\n      opacity *= lineWidth;\r\n    }\r\n\r\n    lineStr.push(\r\n      '<g_vml_:stroke',\r\n      ' opacity=\"', opacity, '\"',\r\n      ' joinstyle=\"', ctx.lineJoin, '\"',\r\n      ' miterlimit=\"', ctx.miterLimit, '\"',\r\n      ' endcap=\"', processLineCap(ctx.lineCap), '\"',\r\n      ' weight=\"', lineWidth, 'px\"',\r\n      ' color=\"', color, '\" />'\r\n    );\r\n  }\r\n\r\n  function appendFill(ctx, lineStr, min, max) {\r\n    var fillStyle = ctx.fillStyle;\r\n    var arcScaleX = ctx.scaleX_;\r\n    var arcScaleY = ctx.scaleY_;\r\n    var width = max.x - min.x;\r\n    var height = max.y - min.y;\r\n    if (fillStyle instanceof CanvasGradient_) {\r\n      // TODO: Gradients transformed with the transformation matrix.\r\n      var angle = 0;\r\n      var focus = {x: 0, y: 0};\r\n\r\n      // additional offset\r\n      var shift = 0;\r\n      // scale factor for offset\r\n      var expansion = 1;\r\n\r\n      if (fillStyle.type_ == 'gradient') {\r\n        var x0 = fillStyle.x0_ / arcScaleX;\r\n        var y0 = fillStyle.y0_ / arcScaleY;\r\n        var x1 = fillStyle.x1_ / arcScaleX;\r\n        var y1 = fillStyle.y1_ / arcScaleY;\r\n        var p0 = getCoords(ctx, x0, y0);\r\n        var p1 = getCoords(ctx, x1, y1);\r\n        var dx = p1.x - p0.x;\r\n        var dy = p1.y - p0.y;\r\n        angle = Math.atan2(dx, dy) * 180 / Math.PI;\r\n\r\n        // The angle should be a non-negative number.\r\n        if (angle < 0) {\r\n          angle += 360;\r\n        }\r\n\r\n        // Very small angles produce an unexpected result because they are\r\n        // converted to a scientific notation string.\r\n        if (angle < 1e-6) {\r\n          angle = 0;\r\n        }\r\n      } else {\r\n        var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);\r\n        focus = {\r\n          x: (p0.x - min.x) / width,\r\n          y: (p0.y - min.y) / height\r\n        };\r\n\r\n        width  /= arcScaleX * Z;\r\n        height /= arcScaleY * Z;\r\n        var dimension = m.max(width, height);\r\n        shift = 2 * fillStyle.r0_ / dimension;\r\n        expansion = 2 * fillStyle.r1_ / dimension - shift;\r\n      }\r\n\r\n      // We need to sort the color stops in ascending order by offset,\r\n      // otherwise IE won't interpret it correctly.\r\n      var stops = fillStyle.colors_;\r\n      stops.sort(function(cs1, cs2) {\r\n        return cs1.offset - cs2.offset;\r\n      });\r\n\r\n      var length = stops.length;\r\n      var color1 = stops[0].color;\r\n      var color2 = stops[length - 1].color;\r\n      var opacity1 = stops[0].alpha * ctx.globalAlpha;\r\n      var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;\r\n\r\n      var colors = [];\r\n      for (var i = 0; i < length; i++) {\r\n        var stop = stops[i];\r\n        colors.push(stop.offset * expansion + shift + ' ' + stop.color);\r\n      }\r\n\r\n      // When colors attribute is used, the meanings of opacity and o:opacity2\r\n      // are reversed.\r\n      lineStr.push('<g_vml_:fill type=\"', fillStyle.type_, '\"',\r\n                   ' method=\"none\" focus=\"100%\"',\r\n                   ' color=\"', color1, '\"',\r\n                   ' color2=\"', color2, '\"',\r\n                   ' colors=\"', colors.join(','), '\"',\r\n                   ' opacity=\"', opacity2, '\"',\r\n                   ' g_o_:opacity2=\"', opacity1, '\"',\r\n                   ' angle=\"', angle, '\"',\r\n                   ' focusposition=\"', focus.x, ',', focus.y, '\" />');\r\n    } else if (fillStyle instanceof CanvasPattern_) {\r\n      if (width && height) {\r\n        var deltaLeft = -min.x;\r\n        var deltaTop = -min.y;\r\n        lineStr.push('<g_vml_:fill',\r\n                     ' position=\"',\r\n                     deltaLeft / width * arcScaleX * arcScaleX, ',',\r\n                     deltaTop / height * arcScaleY * arcScaleY, '\"',\r\n                     ' type=\"tile\"',\r\n                     // TODO: Figure out the correct size to fit the scale.\r\n                     //' size=\"', w, 'px ', h, 'px\"',\r\n                     ' src=\"', fillStyle.src_, '\" />');\r\n       }\r\n    } else {\r\n      var a = processStyle(ctx.fillStyle);\r\n      var color = a.color;\r\n      var opacity = a.alpha * ctx.globalAlpha;\r\n      lineStr.push('<g_vml_:fill color=\"', color, '\" opacity=\"', opacity,\r\n                   '\" />');\r\n    }\r\n  }\r\n\r\n  contextPrototype.fill = function() {\r\n    this.stroke(true);\r\n  };\r\n\r\n  contextPrototype.closePath = function() {\r\n    this.currentPath_.push({type: 'close'});\r\n  };\r\n\r\n  function getCoords(ctx, aX, aY) {\r\n    var m = ctx.m_;\r\n    return {\r\n      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,\r\n      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2\r\n    };\r\n  };\r\n\r\n  contextPrototype.save = function() {\r\n    var o = {};\r\n    copyState(this, o);\r\n    this.aStack_.push(o);\r\n    this.mStack_.push(this.m_);\r\n    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);\r\n  };\r\n\r\n  contextPrototype.restore = function() {\r\n    if (this.aStack_.length) {\r\n      copyState(this.aStack_.pop(), this);\r\n      this.m_ = this.mStack_.pop();\r\n    }\r\n  };\r\n\r\n  function matrixIsFinite(m) {\r\n    return isFinite(m[0][0]) && isFinite(m[0][1]) &&\r\n        isFinite(m[1][0]) && isFinite(m[1][1]) &&\r\n        isFinite(m[2][0]) && isFinite(m[2][1]);\r\n  }\r\n\r\n  function setM(ctx, m, updateLineScale) {\r\n    if (!matrixIsFinite(m)) {\r\n      return;\r\n    }\r\n    ctx.m_ = m;\r\n\r\n    ctx.scaleX_ = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1]);\r\n    ctx.scaleY_ = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1]);\r\n\r\n    if (updateLineScale) {\r\n      // Get the line scale.\r\n      // Determinant of this.m_ means how much the area is enlarged by the\r\n      // transformation. So its square root can be used as a scale factor\r\n      // for width.\r\n      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];\r\n      ctx.lineScale_ = sqrt(abs(det));\r\n    }\r\n  }\r\n\r\n  contextPrototype.translate = function(aX, aY) {\r\n    var m1 = [\r\n      [1,  0,  0],\r\n      [0,  1,  0],\r\n      [aX, aY, 1]\r\n    ];\r\n\r\n    setM(this, matrixMultiply(m1, this.m_), false);\r\n  };\r\n\r\n  contextPrototype.rotate = function(aRot) {\r\n    var c = mc(aRot);\r\n    var s = ms(aRot);\r\n\r\n    var m1 = [\r\n      [c,  s, 0],\r\n      [-s, c, 0],\r\n      [0,  0, 1]\r\n    ];\r\n\r\n    setM(this, matrixMultiply(m1, this.m_), false);\r\n  };\r\n\r\n  contextPrototype.scale = function(aX, aY) {\r\n    var m1 = [\r\n      [aX, 0,  0],\r\n      [0,  aY, 0],\r\n      [0,  0,  1]\r\n    ];\r\n\r\n    setM(this, matrixMultiply(m1, this.m_), true);\r\n  };\r\n\r\n  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {\r\n    var m1 = [\r\n      [m11, m12, 0],\r\n      [m21, m22, 0],\r\n      [dx,  dy,  1]\r\n    ];\r\n\r\n    setM(this, matrixMultiply(m1, this.m_), true);\r\n\r\n  };\r\n\r\n  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {\r\n    var m = [\r\n      [m11, m12, 0],\r\n      [m21, m22, 0],\r\n      [dx,  dy,  1]\r\n    ];\r\n\r\n    setM(this, m, true);\r\n  };\r\n\r\n  /**\r\n   * The text drawing function.\r\n   * The maxWidth argument isn't taken in account, since no browser supports\r\n   * it yet.\r\n   */\r\n  contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {\r\n    var m = this.m_,\r\n        delta = 1000,\r\n        left = 0,\r\n        right = delta,\r\n        offset = {x: 0, y: 0},\r\n        lineStr = [];\r\n\r\n    var fontStyle = getComputedStyle(processFontStyle(this.font),\r\n                                     this.element_);\r\n\r\n    var fontStyleString = buildStyle(fontStyle);\r\n\r\n    var elementStyle = this.element_.currentStyle;\r\n    var textAlign = this.textAlign.toLowerCase();\r\n    switch (textAlign) {\r\n      case 'left':\r\n      case 'center':\r\n      case 'right':\r\n        break;\r\n      case 'end':\r\n        textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';\r\n        break;\r\n      case 'start':\r\n        textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';\r\n        break;\r\n      default:\r\n        textAlign = 'left';\r\n    }\r\n\r\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\r\n    switch (this.textBaseline) {\r\n      case 'hanging':\r\n      case 'top':\r\n        offset.y = fontStyle.size / 1.75;\r\n        break;\r\n      case 'middle':\r\n        break;\r\n      default:\r\n      case null:\r\n      case 'alphabetic':\r\n      case 'ideographic':\r\n      case 'bottom':\r\n        offset.y = -fontStyle.size / 2.25;\r\n        break;\r\n    }\r\n\r\n    switch(textAlign) {\r\n      case 'right':\r\n        left = delta;\r\n        right = 0.05;\r\n        break;\r\n      case 'center':\r\n        left = right = delta / 2;\r\n        break;\r\n    }\r\n\r\n    var d = getCoords(this, x + offset.x, y + offset.y);\r\n\r\n    lineStr.push('<g_vml_:line from=\"', -left ,' 0\" to=\"', right ,' 0.05\" ',\r\n                 ' coordsize=\"100 100\" coordorigin=\"0 0\"',\r\n                 ' filled=\"', !stroke, '\" stroked=\"', !!stroke,\r\n                 '\" style=\"position:absolute;width:1px;height:1px;\">');\r\n\r\n    if (stroke) {\r\n      appendStroke(this, lineStr);\r\n    } else {\r\n      // TODO: Fix the min and max params.\r\n      appendFill(this, lineStr, {x: -left, y: 0},\r\n                 {x: right, y: fontStyle.size});\r\n    }\r\n\r\n    var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' +\r\n                m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';\r\n\r\n    var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);\r\n\r\n    lineStr.push('<g_vml_:skew on=\"t\" matrix=\"', skewM ,'\" ',\r\n                 ' offset=\"', skewOffset, '\" origin=\"', left ,' 0\" />',\r\n                 '<g_vml_:path textpathok=\"true\" />',\r\n                 '<g_vml_:textpath on=\"true\" string=\"',\r\n                 encodeHtmlAttribute(text),\r\n                 '\" style=\"v-text-align:', textAlign,\r\n                 ';font:', encodeHtmlAttribute(fontStyleString),\r\n                 '\" /></g_vml_:line>');\r\n\r\n    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));\r\n  };\r\n\r\n  contextPrototype.fillText = function(text, x, y, maxWidth) {\r\n    this.drawText_(text, x, y, maxWidth, false);\r\n  };\r\n\r\n  contextPrototype.strokeText = function(text, x, y, maxWidth) {\r\n    this.drawText_(text, x, y, maxWidth, true);\r\n  };\r\n\r\n  contextPrototype.measureText = function(text) {\r\n    if (!this.textMeasureEl_) {\r\n      var s = '<span style=\"position:absolute;' +\r\n          'top:-20000px;left:0;padding:0;margin:0;border:none;' +\r\n          'white-space:pre;\"></span>';\r\n      this.element_.insertAdjacentHTML('beforeEnd', s);\r\n      this.textMeasureEl_ = this.element_.lastChild;\r\n    }\r\n    var doc = this.element_.ownerDocument;\r\n    this.textMeasureEl_.innerHTML = '';\r\n    try {\r\n        this.textMeasureEl_.style.font = this.font;\r\n    } catch (ex) {\r\n        // Ignore failures to set to invalid font.\r\n    }\r\n\r\n    // Don't use innerHTML or innerText because they allow markup/whitespace.\r\n    this.textMeasureEl_.appendChild(doc.createTextNode(text));\r\n    return {width: this.textMeasureEl_.offsetWidth};\r\n  };\r\n\r\n  /******** STUBS ********/\r\n  contextPrototype.clip = function() {\r\n    // TODO: Implement\r\n  };\r\n\r\n  contextPrototype.arcTo = function() {\r\n    // TODO: Implement\r\n  };\r\n\r\n  contextPrototype.createPattern = function(image, repetition) {\r\n    return new CanvasPattern_(image, repetition);\r\n  };\r\n\r\n  // Gradient / Pattern Stubs\r\n  function CanvasGradient_(aType) {\r\n    this.type_ = aType;\r\n    this.x0_ = 0;\r\n    this.y0_ = 0;\r\n    this.r0_ = 0;\r\n    this.x1_ = 0;\r\n    this.y1_ = 0;\r\n    this.r1_ = 0;\r\n    this.colors_ = [];\r\n  }\r\n\r\n  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {\r\n    aColor = processStyle(aColor);\r\n    this.colors_.push({offset: aOffset,\r\n                       color: aColor.color,\r\n                       alpha: aColor.alpha});\r\n  };\r\n\r\n  function CanvasPattern_(image, repetition) {\r\n    assertImageIsValid(image);\r\n    switch (repetition) {\r\n      case 'repeat':\r\n      case null:\r\n      case '':\r\n        this.repetition_ = 'repeat';\r\n        break\r\n      case 'repeat-x':\r\n      case 'repeat-y':\r\n      case 'no-repeat':\r\n        this.repetition_ = repetition;\r\n        break;\r\n      default:\r\n        throwException('SYNTAX_ERR');\r\n    }\r\n\r\n    this.src_ = image.src;\r\n    this.width_ = image.width;\r\n    this.height_ = image.height;\r\n  }\r\n\r\n  function throwException(s) {\r\n    throw new DOMException_(s);\r\n  }\r\n\r\n  function assertImageIsValid(img) {\r\n    if (!img || img.nodeType != 1 || img.tagName != 'IMG') {\r\n      throwException('TYPE_MISMATCH_ERR');\r\n    }\r\n    if (img.readyState != 'complete') {\r\n      throwException('INVALID_STATE_ERR');\r\n    }\r\n  }\r\n\r\n  function DOMException_(s) {\r\n    this.code = this[s];\r\n    this.message = s +': DOM Exception ' + this.code;\r\n  }\r\n  var p = DOMException_.prototype = new Error;\r\n  p.INDEX_SIZE_ERR = 1;\r\n  p.DOMSTRING_SIZE_ERR = 2;\r\n  p.HIERARCHY_REQUEST_ERR = 3;\r\n  p.WRONG_DOCUMENT_ERR = 4;\r\n  p.INVALID_CHARACTER_ERR = 5;\r\n  p.NO_DATA_ALLOWED_ERR = 6;\r\n  p.NO_MODIFICATION_ALLOWED_ERR = 7;\r\n  p.NOT_FOUND_ERR = 8;\r\n  p.NOT_SUPPORTED_ERR = 9;\r\n  p.INUSE_ATTRIBUTE_ERR = 10;\r\n  p.INVALID_STATE_ERR = 11;\r\n  p.SYNTAX_ERR = 12;\r\n  p.INVALID_MODIFICATION_ERR = 13;\r\n  p.NAMESPACE_ERR = 14;\r\n  p.INVALID_ACCESS_ERR = 15;\r\n  p.VALIDATION_ERR = 16;\r\n  p.TYPE_MISMATCH_ERR = 17;\r\n\r\n  // set up externs\r\n  G_vmlCanvasManager = G_vmlCanvasManager_;\r\n  CanvasRenderingContext2D = CanvasRenderingContext2D_;\r\n  CanvasGradient = CanvasGradient_;\r\n  CanvasPattern = CanvasPattern_;\r\n  DOMException = DOMException_;\r\n})();\r\n\r\n} // if\r\nelse { // make the canvas test simple by kener.linfeng@gmail.com\r\n    G_vmlCanvasManager = void 0;\r\n}\r\nreturn G_vmlCanvasManager;\r\n}); // define\r\n"
        },
        {
          "id": 12,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\log.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/log.js",
          "index": 12,
          "index2": 5,
          "size": 983,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../tool/log",
              "loc": "45:18-40"
            }
          ],
          "source": "define(\r\n    function (require) {\r\n        var config = require('../config');\r\n\r\n        /**\r\n         * @exports zrender/tool/log\r\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n         */\r\n        return function() {\r\n            if (config.debugMode === 0) {\r\n                return;\r\n            }\r\n            else if (config.debugMode == 1) {\r\n                for (var k in arguments) {\r\n                    throw new Error(arguments[k]);\r\n                }\r\n            }\r\n            else if (config.debugMode > 1) {\r\n                for (var k in arguments) {\r\n                    console.log(arguments[k]);\r\n                }\r\n            }\r\n        };\r\n\r\n        /* for debug\r\n        return function(mes) {\r\n            document.getElementById('wrong-message').innerHTML =\r\n                mes + ' ' + (new Date() - 0)\r\n                + '<br/>' \r\n                + document.getElementById('wrong-message').innerHTML;\r\n        };\r\n        */\r\n    }\r\n);\r\n"
        },
        {
          "id": 13,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\config.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/config.js",
          "index": 13,
          "index2": 4,
          "size": 3235,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\log.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 12,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\log.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/log.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/log.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "3:21-41"
            }
          ],
          "source": "define(function () {\r\n    /**\r\n     * config默认配置项\r\n     * @exports zrender/config\r\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n     */\r\n    var config = {\r\n        /**\r\n         * @namespace module:zrender/config.EVENT\r\n         */\r\n        EVENT : {\r\n            /**\r\n             * 窗口大小变化\r\n             * @type {string}\r\n             */\r\n            RESIZE : 'resize',\r\n            /**\r\n             * 鼠标按钮被（手指）按下，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            CLICK : 'click',\r\n            /**\r\n             * 双击事件\r\n             * @type {string}\r\n             */\r\n            DBLCLICK : 'dblclick',\r\n            /**\r\n             * 鼠标滚轮变化，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            MOUSEWHEEL : 'mousewheel',\r\n            /**\r\n             * 鼠标（手指）被移动，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            MOUSEMOVE : 'mousemove',\r\n            /**\r\n             * 鼠标移到某图形元素之上，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            MOUSEOVER : 'mouseover',\r\n            /**\r\n             * 鼠标从某图形元素移开，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            MOUSEOUT : 'mouseout',\r\n            /**\r\n             * 鼠标按钮（手指）被按下，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            MOUSEDOWN : 'mousedown',\r\n            /**\r\n             * 鼠标按键（手指）被松开，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            MOUSEUP : 'mouseup',\r\n            /**\r\n             * 全局离开，MOUSEOUT触发比较频繁，一次离开优化绑定\r\n             * @type {string}\r\n             */\r\n            GLOBALOUT : 'globalout',    // \r\n\r\n            // 一次成功元素拖拽的行为事件过程是：\r\n            // dragstart > dragenter > dragover [> dragleave] > drop > dragend\r\n            /**\r\n             * 开始拖拽时触发，事件对象是：被拖拽图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGSTART : 'dragstart',\r\n            /**\r\n             * 拖拽完毕时触发（在drop之后触发），事件对象是：被拖拽图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGEND : 'dragend',\r\n            /**\r\n             * 拖拽图形元素进入目标图形元素时触发，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGENTER : 'dragenter',\r\n            /**\r\n             * 拖拽图形元素在目标图形元素上移动时触发，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGOVER : 'dragover',\r\n            /**\r\n             * 拖拽图形元素离开目标图形元素时触发，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGLEAVE : 'dragleave',\r\n            /**\r\n             * 拖拽图形元素放在目标图形元素内时触发，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            DROP : 'drop',\r\n            /**\r\n             * touch end - start < delay is click\r\n             * @type {number}\r\n             */\r\n            touchClickDelay : 300\r\n        },\r\n\r\n        elementClassName: 'zr-element',\r\n\r\n        // 是否异常捕获\r\n        catchBrushException: false,\r\n\r\n        /**\r\n         * debug日志选项：catchBrushException为true下有效\r\n         * 0 : 不生成debug数据，发布用\r\n         * 1 : 异常抛出，调试用\r\n         * 2 : 控制台输出，调试用\r\n         */\r\n        debugMode: 0,\r\n\r\n        // retina 屏幕优化\r\n        devicePixelRatio: Math.max(window.devicePixelRatio || 1, 1)\r\n    };\r\n    return config;\r\n});\r\n\r\n"
        },
        {
          "id": 14,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\mixin\\Transformable.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
          "index": 14,
          "index2": 7,
          "size": 7955,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../mixin/Transformable",
              "loc": "47:28-61"
            }
          ],
          "source": "/**\r\n * 提供变换扩展\r\n * @module zrender/mixin/Transformable\r\n * @author pissang (https://www.github.com/pissang)\r\n */\r\ndefine(function (require) {\r\n\r\n    'use strict';\r\n\r\n    var matrix = require('../tool/matrix');\r\n    var vector = require('../tool/vector');\r\n    var origin = [0, 0];\r\n\r\n    var mTranslate = matrix.translate;\r\n\r\n    var EPSILON = 5e-5;\r\n\r\n    function isAroundZero(val) {\r\n        return val > -EPSILON && val < EPSILON;\r\n    }\r\n    function isNotAroundZero(val) {\r\n        return val > EPSILON || val < -EPSILON;\r\n    }\r\n\r\n    /**\r\n     * @alias module:zrender/mixin/Transformable\r\n     * @constructor\r\n     */\r\n    var Transformable = function () {\r\n\r\n        if (!this.position) {\r\n            /**\r\n             * 平移\r\n             * @type {Array.<number>}\r\n             * @default [0, 0]\r\n             */\r\n            this.position = [ 0, 0 ];\r\n        }\r\n        if (typeof(this.rotation) == 'undefined') {\r\n            /**\r\n             * 旋转，可以通过数组二三项指定旋转的原点\r\n             * @type {Array.<number>}\r\n             * @default [0, 0, 0]\r\n             */\r\n            this.rotation = [ 0, 0, 0 ];\r\n        }\r\n        if (!this.scale) {\r\n            /**\r\n             * 缩放，可以通过数组三四项指定缩放的原点\r\n             * @type {Array.<number>}\r\n             * @default [1, 1, 0, 0]\r\n             */\r\n            this.scale = [ 1, 1, 0, 0 ];\r\n        }\r\n\r\n        this.needLocalTransform = false;\r\n\r\n        /**\r\n         * 是否有坐标变换\r\n         * @type {boolean}\r\n         * @readOnly\r\n         */\r\n        this.needTransform = false;\r\n    };\r\n\r\n    Transformable.prototype = {\r\n        \r\n        constructor: Transformable,\r\n\r\n        updateNeedTransform: function () {\r\n            this.needLocalTransform = isNotAroundZero(this.rotation[0])\r\n                || isNotAroundZero(this.position[0])\r\n                || isNotAroundZero(this.position[1])\r\n                || isNotAroundZero(this.scale[0] - 1)\r\n                || isNotAroundZero(this.scale[1] - 1);\r\n        },\r\n\r\n        /**\r\n         * 判断是否需要有坐标变换，更新needTransform属性。\r\n         * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\r\n         */\r\n        updateTransform: function () {\r\n            \r\n            this.updateNeedTransform();\r\n\r\n            var parentHasTransform = this.parent && this.parent.needTransform;\r\n            this.needTransform = this.needLocalTransform || parentHasTransform;\r\n            \r\n            if (!this.needTransform) {\r\n                return;\r\n            }\r\n\r\n            var m = this.transform || matrix.create();\r\n            matrix.identity(m);\r\n\r\n            if (this.needLocalTransform) {\r\n                var scale = this.scale;\r\n                if (\r\n                    isNotAroundZero(scale[0])\r\n                 || isNotAroundZero(scale[1])\r\n                ) {\r\n                    origin[0] = -scale[2] || 0;\r\n                    origin[1] = -scale[3] || 0;\r\n                    var haveOrigin = isNotAroundZero(origin[0])\r\n                                  || isNotAroundZero(origin[1]);\r\n                    if (haveOrigin) {\r\n                        mTranslate(m, m, origin);\r\n                    }\r\n                    matrix.scale(m, m, scale);\r\n                    if (haveOrigin) {\r\n                        origin[0] = -origin[0];\r\n                        origin[1] = -origin[1];\r\n                        mTranslate(m, m, origin);\r\n                    }\r\n                }\r\n\r\n                if (this.rotation instanceof Array) {\r\n                    if (this.rotation[0] !== 0) {\r\n                        origin[0] = -this.rotation[1] || 0;\r\n                        origin[1] = -this.rotation[2] || 0;\r\n                        var haveOrigin = isNotAroundZero(origin[0])\r\n                                      || isNotAroundZero(origin[1]);\r\n                        if (haveOrigin) {\r\n                            mTranslate(m, m, origin);\r\n                        }\r\n                        matrix.rotate(m, m, this.rotation[0]);\r\n                        if (haveOrigin) {\r\n                            origin[0] = -origin[0];\r\n                            origin[1] = -origin[1];\r\n                            mTranslate(m, m, origin);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (this.rotation !== 0) {\r\n                        matrix.rotate(m, m, this.rotation);\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1])\r\n                ) {\r\n                    mTranslate(m, m, this.position);\r\n                }\r\n            }\r\n\r\n            // 应用父节点变换\r\n            if (parentHasTransform) {\r\n                if (this.needLocalTransform) {\r\n                    matrix.mul(m, this.parent.transform, m);\r\n                }\r\n                else {\r\n                    matrix.copy(m, this.parent.transform);\r\n                }\r\n            }\r\n            // 保存这个变换矩阵\r\n            this.transform = m;\r\n\r\n            this.invTransform = this.invTransform || matrix.create();\r\n            matrix.invert(this.invTransform, m);\r\n        },\r\n        /**\r\n         * 将自己的transform应用到context上\r\n         * @param {Context2D} ctx\r\n         */\r\n        setTransform: function (ctx) {\r\n            if (this.needTransform) {\r\n                var m = this.transform;\r\n                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\r\n            }\r\n        },\r\n        /**\r\n         * 设置图形的朝向\r\n         * @param  {Array.<number>|Float32Array} target\r\n         * @method\r\n         */\r\n        lookAt: (function () {\r\n            var v = vector.create();\r\n            return function(target) {\r\n                if (!this.transform) {\r\n                    this.transform = matrix.create();\r\n                }\r\n                var m = this.transform;\r\n                vector.sub(v, target, this.position);\r\n                if (isAroundZero(v[0]) && isAroundZero(v[1])) {\r\n                    return;\r\n                }\r\n                vector.normalize(v, v);\r\n                var scale = this.scale;\r\n                // Y Axis\r\n                // TODO Scale origin ?\r\n                m[2] = v[0] * scale[1];\r\n                m[3] = v[1] * scale[1];\r\n                // X Axis\r\n                m[0] = v[1] * scale[0];\r\n                m[1] = -v[0] * scale[0];\r\n                // Position\r\n                m[4] = this.position[0];\r\n                m[5] = this.position[1];\r\n\r\n                this.decomposeTransform();\r\n            };\r\n        })(),\r\n        /**\r\n         * 分解`transform`矩阵到`position`, `rotation`, `scale`\r\n         */\r\n        decomposeTransform: function () {\r\n            if (!this.transform) {\r\n                return;\r\n            }\r\n            var m = this.transform;\r\n            var sx = m[0] * m[0] + m[1] * m[1];\r\n            var position = this.position;\r\n            var scale = this.scale;\r\n            var rotation = this.rotation;\r\n            if (isNotAroundZero(sx - 1)) {\r\n                sx = Math.sqrt(sx);\r\n            }\r\n            var sy = m[2] * m[2] + m[3] * m[3];\r\n            if (isNotAroundZero(sy - 1)) {\r\n                sy = Math.sqrt(sy);\r\n            }\r\n            position[0] = m[4];\r\n            position[1] = m[5];\r\n            scale[0] = sx;\r\n            scale[1] = sy;\r\n            scale[2] = scale[3] = 0;\r\n            rotation[0] = Math.atan2(-m[1] / sy, m[0] / sx);\r\n            rotation[1] = rotation[2] = 0;\r\n        },\r\n\r\n        /**\r\n         * 变换坐标位置到 shape 的局部坐标空间\r\n         * @method\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @return {Array.<number>}\r\n         */\r\n        transformCoordToLocal: function (x, y) {\r\n            var v2 = [x, y];\r\n            if (this.needTransform && this.invTransform) {\r\n                vector.applyTransform(v2, v2, this.invTransform);\r\n            }\r\n            return v2;\r\n        }\r\n    };\r\n\r\n    return Transformable;\r\n});\r\n"
        },
        {
          "id": 15,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\vector.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/vector.js",
          "index": 15,
          "index2": 6,
          "size": 7857,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 14,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\mixin\\Transformable.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
              "type": "cjs require",
              "userRequest": "../tool/vector",
              "loc": "11:17-42"
            },
            {
              "moduleId": 18,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\curve.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/curve.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/curve.js",
              "type": "cjs require",
              "userRequest": "./vector",
              "loc": "8:17-36"
            },
            {
              "moduleId": 24,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\PathProxy.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/PathProxy.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/PathProxy.js",
              "type": "cjs require",
              "userRequest": "../../tool/vector",
              "loc": "42:17-45"
            },
            {
              "moduleId": 32,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\smoothSpline.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothSpline.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothSpline.js",
              "type": "cjs require",
              "userRequest": "../../tool/vector",
              "loc": "10:21-49"
            },
            {
              "moduleId": 33,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\smoothBezier.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothBezier.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothBezier.js",
              "type": "cjs require",
              "userRequest": "../../tool/vector",
              "loc": "10:21-49"
            },
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/vector",
              "loc": "18:15-47"
            },
            {
              "moduleId": 47,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\layout\\EdgeBundling.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/vector",
              "loc": "12:15-47"
            }
          ],
          "source": "define(\r\n    function () {\r\n        var ArrayCtor = typeof Float32Array === 'undefined'\r\n            ? Array\r\n            : Float32Array;\r\n\r\n        /**\r\n         * @typedef {Float32Array|Array.<number>} Vector2\r\n         */\r\n        /**\r\n         * 二维向量类\r\n         * @exports zrender/tool/vector\r\n         */\r\n        var vector = {\r\n            /**\r\n             * 创建一个向量\r\n             * @param {number} [x=0]\r\n             * @param {number} [y=0]\r\n             * @return {Vector2}\r\n             */\r\n            create: function (x, y) {\r\n                var out = new ArrayCtor(2);\r\n                out[0] = x || 0;\r\n                out[1] = y || 0;\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 复制向量数据\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             * @return {Vector2}\r\n             */\r\n            copy: function (out, v) {\r\n                out[0] = v[0];\r\n                out[1] = v[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 克隆一个向量\r\n             * @param {Vector2} v\r\n             * @return {Vector2}\r\n             */\r\n            clone: function (v) {\r\n                var out = new ArrayCtor(2);\r\n                out[0] = v[0];\r\n                out[1] = v[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 设置向量的两个项\r\n             * @param {Vector2} out\r\n             * @param {number} a\r\n             * @param {number} b\r\n             * @return {Vector2} 结果\r\n             */\r\n            set: function (out, a, b) {\r\n                out[0] = a;\r\n                out[1] = b;\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量相加\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             */\r\n            add: function (out, v1, v2) {\r\n                out[0] = v1[0] + v2[0];\r\n                out[1] = v1[1] + v2[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量缩放后相加\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @param {number} a\r\n             */\r\n            scaleAndAdd: function (out, v1, v2, a) {\r\n                out[0] = v1[0] + v2[0] * a;\r\n                out[1] = v1[1] + v2[1] * a;\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量相减\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             */\r\n            sub: function (out, v1, v2) {\r\n                out[0] = v1[0] - v2[0];\r\n                out[1] = v1[1] - v2[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量长度\r\n             * @param {Vector2} v\r\n             * @return {number}\r\n             */\r\n            len: function (v) {\r\n                return Math.sqrt(this.lenSquare(v));\r\n            },\r\n\r\n            /**\r\n             * 向量长度平方\r\n             * @param {Vector2} v\r\n             * @return {number}\r\n             */\r\n            lenSquare: function (v) {\r\n                return v[0] * v[0] + v[1] * v[1];\r\n            },\r\n\r\n            /**\r\n             * 向量乘法\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             */\r\n            mul: function (out, v1, v2) {\r\n                out[0] = v1[0] * v2[0];\r\n                out[1] = v1[1] * v2[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量除法\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             */\r\n            div: function (out, v1, v2) {\r\n                out[0] = v1[0] / v2[0];\r\n                out[1] = v1[1] / v2[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量点乘\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @return {number}\r\n             */\r\n            dot: function (v1, v2) {\r\n                return v1[0] * v2[0] + v1[1] * v2[1];\r\n            },\r\n\r\n            /**\r\n             * 向量缩放\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             * @param {number} s\r\n             */\r\n            scale: function (out, v, s) {\r\n                out[0] = v[0] * s;\r\n                out[1] = v[1] * s;\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量归一化\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             */\r\n            normalize: function (out, v) {\r\n                var d = vector.len(v);\r\n                if (d === 0) {\r\n                    out[0] = 0;\r\n                    out[1] = 0;\r\n                }\r\n                else {\r\n                    out[0] = v[0] / d;\r\n                    out[1] = v[1] / d;\r\n                }\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 计算向量间距离\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @return {number}\r\n             */\r\n            distance: function (v1, v2) {\r\n                return Math.sqrt(\r\n                    (v1[0] - v2[0]) * (v1[0] - v2[0])\r\n                    + (v1[1] - v2[1]) * (v1[1] - v2[1])\r\n                );\r\n            },\r\n\r\n            /**\r\n             * 向量距离平方\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @return {number}\r\n             */\r\n            distanceSquare: function (v1, v2) {\r\n                return (v1[0] - v2[0]) * (v1[0] - v2[0])\r\n                    + (v1[1] - v2[1]) * (v1[1] - v2[1]);\r\n            },\r\n\r\n            /**\r\n             * 求负向量\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             */\r\n            negate: function (out, v) {\r\n                out[0] = -v[0];\r\n                out[1] = -v[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 插值两个点\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @param {number} t\r\n             */\r\n            lerp: function (out, v1, v2, t) {\r\n                // var ax = v1[0];\r\n                // var ay = v1[1];\r\n                out[0] = v1[0] + t * (v2[0] - v1[0]);\r\n                out[1] = v1[1] + t * (v2[1] - v1[1]);\r\n                return out;\r\n            },\r\n            \r\n            /**\r\n             * 矩阵左乘向量\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             * @param {Vector2} m\r\n             */\r\n            applyTransform: function (out, v, m) {\r\n                var x = v[0];\r\n                var y = v[1];\r\n                out[0] = m[0] * x + m[2] * y + m[4];\r\n                out[1] = m[1] * x + m[3] * y + m[5];\r\n                return out;\r\n            },\r\n            /**\r\n             * 求两个向量最小值\r\n             * @param  {Vector2} out\r\n             * @param  {Vector2} v1\r\n             * @param  {Vector2} v2\r\n             */\r\n            min: function (out, v1, v2) {\r\n                out[0] = Math.min(v1[0], v2[0]);\r\n                out[1] = Math.min(v1[1], v2[1]);\r\n                return out;\r\n            },\r\n            /**\r\n             * 求两个向量最大值\r\n             * @param  {Vector2} out\r\n             * @param  {Vector2} v1\r\n             * @param  {Vector2} v2\r\n             */\r\n            max: function (out, v1, v2) {\r\n                out[0] = Math.max(v1[0], v2[0]);\r\n                out[1] = Math.max(v1[1], v2[1]);\r\n                return out;\r\n            }\r\n        };\r\n\r\n        vector.length = vector.len;\r\n        vector.lengthSquare = vector.lenSquare;\r\n        vector.dist = vector.distance;\r\n        vector.distSquare = vector.distanceSquare;\r\n        \r\n        return vector;\r\n    }\r\n);\r\n"
        },
        {
          "id": 16,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\mixin\\Eventful.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Eventful.js",
          "index": 16,
          "index2": 8,
          "size": 6861,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\event.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../mixin/Eventful",
              "loc": "48:23-51"
            },
            {
              "moduleId": 65,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\event.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/event.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/event.js",
              "type": "cjs require",
              "userRequest": "../mixin/Eventful",
              "loc": "11:23-51"
            }
          ],
          "source": "/**\r\n * 事件扩展\r\n * @module zrender/mixin/Eventful\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         pissang (https://www.github.com/pissang)\r\n */\r\ndefine(function (require) {\r\n\r\n    /**\r\n     * 事件分发器\r\n     * @alias module:zrender/mixin/Eventful\r\n     * @constructor\r\n     */\r\n    var Eventful = function () {\r\n        this._handlers = {};\r\n    };\r\n    /**\r\n     * 单次触发绑定，dispatch后销毁\r\n     * \r\n     * @param {string} event 事件名\r\n     * @param {Function} handler 响应函数\r\n     * @param {Object} context\r\n     */\r\n    Eventful.prototype.one = function (event, handler, context) {\r\n        var _h = this._handlers;\r\n\r\n        if (!handler || !event) {\r\n            return this;\r\n        }\r\n\r\n        if (!_h[event]) {\r\n            _h[event] = [];\r\n        }\r\n\r\n        _h[event].push({\r\n            h : handler,\r\n            one : true,\r\n            ctx: context || this\r\n        });\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 绑定事件\r\n     * @param {string} event 事件名\r\n     * @param {Function} handler 事件处理函数\r\n     * @param {Object} [context]\r\n     */\r\n    Eventful.prototype.bind = function (event, handler, context) {\r\n        var _h = this._handlers;\r\n\r\n        if (!handler || !event) {\r\n            return this;\r\n        }\r\n\r\n        if (!_h[event]) {\r\n            _h[event] = [];\r\n        }\r\n\r\n        _h[event].push({\r\n            h : handler,\r\n            one : false,\r\n            ctx: context || this\r\n        });\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 解绑事件\r\n     * @param {string} event 事件名\r\n     * @param {Function} [handler] 事件处理函数\r\n     */\r\n    Eventful.prototype.unbind = function (event, handler) {\r\n        var _h = this._handlers;\r\n\r\n        if (!event) {\r\n            this._handlers = {};\r\n            return this;\r\n        }\r\n\r\n        if (handler) {\r\n            if (_h[event]) {\r\n                var newList = [];\r\n                for (var i = 0, l = _h[event].length; i < l; i++) {\r\n                    if (_h[event][i]['h'] != handler) {\r\n                        newList.push(_h[event][i]);\r\n                    }\r\n                }\r\n                _h[event] = newList;\r\n            }\r\n\r\n            if (_h[event] && _h[event].length === 0) {\r\n                delete _h[event];\r\n            }\r\n        }\r\n        else {\r\n            delete _h[event];\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 事件分发\r\n     * \r\n     * @param {string} type 事件类型\r\n     */\r\n    Eventful.prototype.dispatch = function (type) {\r\n        if (this._handlers[type]) {\r\n            var args = arguments;\r\n            var argLen = args.length;\r\n\r\n            if (argLen > 3) {\r\n                args = Array.prototype.slice.call(args, 1);\r\n            }\r\n            \r\n            var _h = this._handlers[type];\r\n            var len = _h.length;\r\n            for (var i = 0; i < len;) {\r\n                // Optimize advise from backbone\r\n                switch (argLen) {\r\n                    case 1:\r\n                        _h[i]['h'].call(_h[i]['ctx']);\r\n                        break;\r\n                    case 2:\r\n                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\r\n                        break;\r\n                    case 3:\r\n                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\r\n                        break;\r\n                    default:\r\n                        // have more than 2 given arguments\r\n                        _h[i]['h'].apply(_h[i]['ctx'], args);\r\n                        break;\r\n                }\r\n                \r\n                if (_h[i]['one']) {\r\n                    _h.splice(i, 1);\r\n                    len--;\r\n                }\r\n                else {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 带有context的事件分发, 最后一个参数是事件回调的context\r\n     * @param {string} type 事件类型\r\n     */\r\n    Eventful.prototype.dispatchWithContext = function (type) {\r\n        if (this._handlers[type]) {\r\n            var args = arguments;\r\n            var argLen = args.length;\r\n\r\n            if (argLen > 4) {\r\n                args = Array.prototype.slice.call(args, 1, args.length - 1);\r\n            }\r\n            var ctx = args[args.length - 1];\r\n\r\n            var _h = this._handlers[type];\r\n            var len = _h.length;\r\n            for (var i = 0; i < len;) {\r\n                // Optimize advise from backbone\r\n                switch (argLen) {\r\n                    case 1:\r\n                        _h[i]['h'].call(ctx);\r\n                        break;\r\n                    case 2:\r\n                        _h[i]['h'].call(ctx, args[1]);\r\n                        break;\r\n                    case 3:\r\n                        _h[i]['h'].call(ctx, args[1], args[2]);\r\n                        break;\r\n                    default:\r\n                        // have more than 2 given arguments\r\n                        _h[i]['h'].apply(ctx, args);\r\n                        break;\r\n                }\r\n                \r\n                if (_h[i]['one']) {\r\n                    _h.splice(i, 1);\r\n                    len--;\r\n                }\r\n                else {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    // 对象可以通过 onxxxx 绑定事件\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onclick\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmouseover\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmouseout\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmousemove\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmousewheel\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmousedown\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmouseup\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragstart\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragend\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragenter\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragleave\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragover\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondrop\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    \r\n    return Eventful;\r\n});\r\n"
        },
        {
          "id": 17,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\area.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
          "index": 17,
          "index2": 10,
          "size": 29342,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/area",
              "loc": "26:17-47"
            },
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../tool/area",
              "loc": "61:29-52"
            },
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../tool/area",
              "loc": "91:23-46"
            },
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../tool/area",
              "loc": "469:23-46"
            },
            {
              "moduleId": 23,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
              "type": "cjs require",
              "userRequest": "../tool/area",
              "loc": "53:19-42"
            },
            {
              "moduleId": 25,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
              "type": "cjs require",
              "userRequest": "../tool/area",
              "loc": "54:19-42"
            },
            {
              "moduleId": 26,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/area",
              "loc": "30:15-45"
            },
            {
              "moduleId": 52,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/area",
              "loc": "77:17-47"
            },
            {
              "moduleId": 53,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Text.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
              "type": "cjs require",
              "userRequest": "../tool/area",
              "loc": "40:19-42"
            }
          ],
          "source": "/**\r\n * zrender: 图形空间辅助类\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         pissang (https://www.github.com/pissang)\r\n *\r\n * isInside：是否在区域内部\r\n * isOutside：是否在区域外部\r\n * getTextWidth：测算单行文本宽度\r\n */\r\ndefine(\r\n    function (require) {\r\n\r\n        'use strict';\r\n\r\n        var util = require('./util');\r\n        var curve = require('./curve');\r\n\r\n        var _ctx;\r\n        \r\n        var _textWidthCache = {};\r\n        var _textHeightCache = {};\r\n        var _textWidthCacheCounter = 0;\r\n        var _textHeightCacheCounter = 0;\r\n        var TEXT_CACHE_MAX = 5000;\r\n            \r\n        var PI2 = Math.PI * 2;\r\n\r\n        function normalizeRadian(angle) {\r\n            angle %= PI2;\r\n            if (angle < 0) {\r\n                angle += PI2;\r\n            }\r\n            return angle;\r\n        }\r\n        /**\r\n         * 包含判断\r\n         *\r\n         * @param {Object} shape : 图形\r\n         * @param {Object} area ： 目标区域\r\n         * @param {number} x ： 横坐标\r\n         * @param {number} y ： 纵坐标\r\n         */\r\n        function isInside(shape, area, x, y) {\r\n            if (!area || !shape) {\r\n                // 无参数或不支持类型\r\n                return false;\r\n            }\r\n            var zoneType = shape.type;\r\n\r\n            _ctx = _ctx || util.getContext();\r\n\r\n            // 未实现或不可用时(excanvas不支持)则数学运算，主要是line，polyline，ring\r\n            var _mathReturn = _mathMethod(shape, area, x, y);\r\n            if (typeof _mathReturn != 'undefined') {\r\n                return _mathReturn;\r\n            }\r\n\r\n            if (shape.buildPath && _ctx.isPointInPath) {\r\n                return _buildPathMethod(shape, _ctx, area, x, y);\r\n            }\r\n\r\n            // 上面的方法都行不通时\r\n            switch (zoneType) {\r\n                case 'ellipse': // Todo，不精确\r\n                    return true;\r\n                // 旋轮曲线  不准确\r\n                case 'trochoid':\r\n                    var _r = area.location == 'out'\r\n                            ? area.r1 + area.r2 + area.d\r\n                            : area.r1 - area.r2 + area.d;\r\n                    return isInsideCircle(area, x, y, _r);\r\n                // 玫瑰线 不准确\r\n                case 'rose' :\r\n                    return isInsideCircle(area, x, y, area.maxr);\r\n                // 路径，椭圆，曲线等-----------------13\r\n                default:\r\n                    return false;   // Todo，暂不支持\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @param {Object} shape : 图形\r\n         * @param {Object} area ：目标区域\r\n         * @param {number} x ： 横坐标\r\n         * @param {number} y ： 纵坐标\r\n         * @return {boolean=} true表示坐标处在图形中\r\n         */\r\n        function _mathMethod(shape, area, x, y) {\r\n            var zoneType = shape.type;\r\n            // 在矩形内则部分图形需要进一步判断\r\n            switch (zoneType) {\r\n                // 贝塞尔曲线\r\n                case 'bezier-curve':\r\n                    if (typeof(area.cpX2) === 'undefined') {\r\n                        return isInsideQuadraticStroke(\r\n                            area.xStart, area.yStart,\r\n                            area.cpX1, area.cpY1, \r\n                            area.xEnd, area.yEnd,\r\n                            area.lineWidth, x, y\r\n                        );\r\n                    }\r\n                    return isInsideCubicStroke(\r\n                        area.xStart, area.yStart,\r\n                        area.cpX1, area.cpY1, \r\n                        area.cpX2, area.cpY2, \r\n                        area.xEnd, area.yEnd,\r\n                        area.lineWidth, x, y\r\n                    );\r\n                // 线\r\n                case 'line':\r\n                    return isInsideLine(\r\n                        area.xStart, area.yStart,\r\n                        area.xEnd, area.yEnd,\r\n                        area.lineWidth, x, y\r\n                    );\r\n                // 折线\r\n                case 'polyline':\r\n                    return isInsidePolyline(\r\n                        area.pointList, area.lineWidth, x, y\r\n                    );\r\n                // 圆环\r\n                case 'ring':\r\n                    return isInsideRing(\r\n                        area.x, area.y, area.r0, area.r, x, y\r\n                    );\r\n                // 圆形\r\n                case 'circle':\r\n                    return isInsideCircle(\r\n                        area.x, area.y, area.r, x, y\r\n                    );\r\n                // 扇形\r\n                case 'sector':\r\n                    var startAngle = area.startAngle * Math.PI / 180;\r\n                    var endAngle = area.endAngle * Math.PI / 180;\r\n                    if (!area.clockWise) {\r\n                        startAngle = -startAngle;\r\n                        endAngle = -endAngle;\r\n                    }\r\n                    return isInsideSector(\r\n                        area.x, area.y, area.r0, area.r,\r\n                        startAngle, endAngle,\r\n                        !area.clockWise,\r\n                        x, y\r\n                    );\r\n                // 多边形\r\n                case 'path':\r\n                    return area.pathArray && isInsidePath(\r\n                        area.pathArray, Math.max(area.lineWidth, 5),\r\n                        area.brushType, x, y\r\n                    );\r\n                case 'polygon':\r\n                case 'star':\r\n                case 'isogon':\r\n                    return isInsidePolygon(area.pointList, x, y);\r\n                // 文本\r\n                case 'text':\r\n                    var rect =  area.__rect || shape.getRect(area);\r\n                    return isInsideRect(\r\n                        rect.x, rect.y, rect.width, rect.height, x, y\r\n                    );\r\n                // 矩形\r\n                case 'rectangle':\r\n                // 图片\r\n                case 'image':\r\n                    return isInsideRect(\r\n                        area.x, area.y, area.width, area.height, x, y\r\n                    );\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 通过buildPath方法来判断，三个方法中较快，但是不支持线条类型的shape，\r\n         * 而且excanvas不支持isPointInPath方法\r\n         *\r\n         * @param {Object} shape ： shape\r\n         * @param {Object} context : 上下文\r\n         * @param {Object} area ：目标区域\r\n         * @param {number} x ： 横坐标\r\n         * @param {number} y ： 纵坐标\r\n         * @return {boolean} true表示坐标处在图形中\r\n         */\r\n        function _buildPathMethod(shape, context, area, x, y) {\r\n            // 图形类实现路径创建了则用类的path\r\n            context.beginPath();\r\n            shape.buildPath(context, area);\r\n            context.closePath();\r\n            return context.isPointInPath(x, y);\r\n        }\r\n\r\n        /**\r\n         * !isInside\r\n         */\r\n        function isOutside(shape, area, x, y) {\r\n            return !isInside(shape, area, x, y);\r\n        }\r\n\r\n        /**\r\n         * 线段包含判断\r\n         * @param  {number}  x0\r\n         * @param  {number}  y0\r\n         * @param  {number}  x1\r\n         * @param  {number}  y1\r\n         * @param  {number}  lineWidth\r\n         * @param  {number}  x\r\n         * @param  {number}  y\r\n         * @return {boolean}\r\n         */\r\n        function isInsideLine(x0, y0, x1, y1, lineWidth, x, y) {\r\n            if (lineWidth === 0) {\r\n                return false;\r\n            }\r\n            var _l = Math.max(lineWidth, 5);\r\n            var _a = 0;\r\n            var _b = x0;\r\n            // Quick reject\r\n            if (\r\n                (y > y0 + _l && y > y1 + _l)\r\n                || (y < y0 - _l && y < y1 - _l)\r\n                || (x > x0 + _l && x > x1 + _l)\r\n                || (x < x0 - _l && x < x1 - _l)\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            if (x0 !== x1) {\r\n                _a = (y0 - y1) / (x0 - x1);\r\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\r\n            }\r\n            else {\r\n                return Math.abs(x - x0) <= _l / 2;\r\n            }\r\n            var tmp = _a * x - y + _b;\r\n            var _s = tmp * tmp / (_a * _a + 1);\r\n            return _s <= _l / 2 * _l / 2;\r\n        }\r\n\r\n        /**\r\n         * 三次贝塞尔曲线描边包含判断\r\n         * @param  {number}  x0\r\n         * @param  {number}  y0\r\n         * @param  {number}  x1\r\n         * @param  {number}  y1\r\n         * @param  {number}  x2\r\n         * @param  {number}  y2\r\n         * @param  {number}  x3\r\n         * @param  {number}  y3\r\n         * @param  {number}  lineWidth\r\n         * @param  {number}  x\r\n         * @param  {number}  y\r\n         * @return {boolean}\r\n         */\r\n        function isInsideCubicStroke(\r\n            x0, y0, x1, y1, x2, y2, x3, y3,\r\n            lineWidth, x, y\r\n        ) {\r\n            if (lineWidth === 0) {\r\n                return false;\r\n            }\r\n            var _l = Math.max(lineWidth, 5);\r\n            // Quick reject\r\n            if (\r\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\r\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\r\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\r\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\r\n            ) {\r\n                return false;\r\n            }\r\n            var d =  curve.cubicProjectPoint(\r\n                x0, y0, x1, y1, x2, y2, x3, y3,\r\n                x, y, null\r\n            );\r\n            return d <= _l / 2;\r\n        }\r\n\r\n        /**\r\n         * 二次贝塞尔曲线描边包含判断\r\n         * @param  {number}  x0\r\n         * @param  {number}  y0\r\n         * @param  {number}  x1\r\n         * @param  {number}  y1\r\n         * @param  {number}  x2\r\n         * @param  {number}  y2\r\n         * @param  {number}  lineWidth\r\n         * @param  {number}  x\r\n         * @param  {number}  y\r\n         * @return {boolean}\r\n         */\r\n        function isInsideQuadraticStroke(\r\n            x0, y0, x1, y1, x2, y2,\r\n            lineWidth, x, y\r\n        ) {\r\n            if (lineWidth === 0) {\r\n                return false;\r\n            }\r\n            var _l = Math.max(lineWidth, 5);\r\n            // Quick reject\r\n            if (\r\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\r\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\r\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\r\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\r\n            ) {\r\n                return false;\r\n            }\r\n            var d =  curve.quadraticProjectPoint(\r\n                x0, y0, x1, y1, x2, y2,\r\n                x, y, null\r\n            );\r\n            return d <= _l / 2;\r\n        }\r\n\r\n        /**\r\n         * 圆弧描边包含判断\r\n         * @param  {number}  cx\r\n         * @param  {number}  cy\r\n         * @param  {number}  r\r\n         * @param  {number}  startAngle\r\n         * @param  {number}  endAngle\r\n         * @param  {boolean}  anticlockwise\r\n         * @param  {number} lineWidth\r\n         * @param  {number}  x\r\n         * @param  {number}  y\r\n         * @return {Boolean}\r\n         */\r\n        function isInsideArcStroke(\r\n            cx, cy, r, startAngle, endAngle, anticlockwise,\r\n            lineWidth, x, y\r\n        ) {\r\n            if (lineWidth === 0) {\r\n                return false;\r\n            }\r\n            var _l = Math.max(lineWidth, 5);\r\n\r\n            x -= cx;\r\n            y -= cy;\r\n            var d = Math.sqrt(x * x + y * y);\r\n            if ((d - _l > r) || (d + _l < r)) {\r\n                return false;\r\n            }\r\n            if (Math.abs(startAngle - endAngle) >= PI2) {\r\n                // Is a circle\r\n                return true;\r\n            }\r\n            if (anticlockwise) {\r\n                var tmp = startAngle;\r\n                startAngle = normalizeRadian(endAngle);\r\n                endAngle = normalizeRadian(tmp);\r\n            } else {\r\n                startAngle = normalizeRadian(startAngle);\r\n                endAngle = normalizeRadian(endAngle);\r\n            }\r\n            if (startAngle > endAngle) {\r\n                endAngle += PI2;\r\n            }\r\n            \r\n            var angle = Math.atan2(y, x);\r\n            if (angle < 0) {\r\n                angle += PI2;\r\n            }\r\n            return (angle >= startAngle && angle <= endAngle)\r\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\r\n        }\r\n\r\n        function isInsidePolyline(points, lineWidth, x, y) {\r\n            var lineWidth = Math.max(lineWidth, 10);\r\n            for (var i = 0, l = points.length - 1; i < l; i++) {\r\n                var x0 = points[i][0];\r\n                var y0 = points[i][1];\r\n                var x1 = points[i + 1][0];\r\n                var y1 = points[i + 1][1];\r\n\r\n                if (isInsideLine(x0, y0, x1, y1, lineWidth, x, y)) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isInsideRing(cx, cy, r0, r, x, y) {\r\n            var d = (x - cx) * (x - cx) + (y - cy) * (y - cy);\r\n            return (d < r * r) && (d > r0 * r0);\r\n        }\r\n\r\n        /**\r\n         * 矩形包含判断\r\n         */\r\n        function isInsideRect(x0, y0, width, height, x, y) {\r\n            return x >= x0 && x <= (x0 + width)\r\n                && y >= y0 && y <= (y0 + height);\r\n        }\r\n\r\n        /**\r\n         * 圆形包含判断\r\n         */\r\n        function isInsideCircle(x0, y0, r, x, y) {\r\n            return (x - x0) * (x - x0) + (y - y0) * (y - y0)\r\n                   < r * r;\r\n        }\r\n\r\n        /**\r\n         * 扇形包含判断\r\n         */\r\n        function isInsideSector(\r\n            cx, cy, r0, r, startAngle, endAngle, anticlockwise, x, y\r\n        ) {\r\n            return isInsideArcStroke(\r\n                cx, cy, (r0 + r) / 2, startAngle, endAngle, anticlockwise,\r\n                r - r0, x, y\r\n            );\r\n        }\r\n\r\n        /**\r\n         * 多边形包含判断\r\n         * 与 canvas 一样采用 non-zero winding rule\r\n         */\r\n        function isInsidePolygon(points, x, y) {\r\n            var N = points.length;\r\n            var w = 0;\r\n\r\n            for (var i = 0, j = N - 1; i < N; i++) {\r\n                var x0 = points[j][0];\r\n                var y0 = points[j][1];\r\n                var x1 = points[i][0];\r\n                var y1 = points[i][1];\r\n                w += windingLine(x0, y0, x1, y1, x, y);\r\n                j = i;\r\n            }\r\n            return w !== 0;\r\n        }\r\n\r\n        function windingLine(x0, y0, x1, y1, x, y) {\r\n            if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\r\n                return 0;\r\n            }\r\n            if (y1 == y0) {\r\n                return 0;\r\n            }\r\n            var dir = y1 < y0 ? 1 : -1;\r\n            var t = (y - y0) / (y1 - y0);\r\n            var x_ = t * (x1 - x0) + x0;\r\n\r\n            return x_ > x ? dir : 0;\r\n        }\r\n\r\n        // 临时数组\r\n        var roots = [-1, -1, -1];\r\n        var extrema = [-1, -1];\r\n\r\n        function swapExtrema() {\r\n            var tmp = extrema[0];\r\n            extrema[0] = extrema[1];\r\n            extrema[1] = tmp;\r\n        }\r\n        function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\r\n            // Quick reject\r\n            if (\r\n                (y > y0 && y > y1 && y > y2 && y > y3)\r\n                || (y < y0 && y < y1 && y < y2 && y < y3)\r\n            ) {\r\n                return 0;\r\n            }\r\n            var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\r\n            if (nRoots === 0) {\r\n                return 0;\r\n            }\r\n            else {\r\n                var w = 0;\r\n                var nExtrema = -1;\r\n                var y0_, y1_;\r\n                for (var i = 0; i < nRoots; i++) {\r\n                    var t = roots[i];\r\n                    var x_ = curve.cubicAt(x0, x1, x2, x3, t);\r\n                    if (x_ < x) { // Quick reject\r\n                        continue;\r\n                    }\r\n                    if (nExtrema < 0) {\r\n                        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\r\n                        if (extrema[1] < extrema[0] && nExtrema > 1) {\r\n                            swapExtrema();\r\n                        }\r\n                        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\r\n                        if (nExtrema > 1) {\r\n                            y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\r\n                        }\r\n                    }\r\n                    if (nExtrema == 2) {\r\n                        // 分成三段单调函数\r\n                        if (t < extrema[0]) {\r\n                            w += y0_ < y0 ? 1 : -1;\r\n                        } \r\n                        else if (t < extrema[1]) {\r\n                            w += y1_ < y0_ ? 1 : -1;\r\n                        } \r\n                        else {\r\n                            w += y3 < y1_ ? 1 : -1;\r\n                        }\r\n                    } \r\n                    else {\r\n                        // 分成两段单调函数\r\n                        if (t < extrema[0]) {\r\n                            w += y0_ < y0 ? 1 : -1;\r\n                        } \r\n                        else {\r\n                            w += y3 < y0_ ? 1 : -1;\r\n                        }\r\n                    }\r\n                }\r\n                return w;\r\n            }\r\n        }\r\n\r\n        function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\r\n            // Quick reject\r\n            if (\r\n                (y > y0 && y > y1 && y > y2)\r\n                || (y < y0 && y < y1 && y < y2)\r\n            ) {\r\n                return 0;\r\n            }\r\n            var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\r\n            if (nRoots === 0) {\r\n                return 0;\r\n            } \r\n            else {\r\n                var t = curve.quadraticExtremum(y0, y1, y2);\r\n                if (t >=0 && t <= 1) {\r\n                    var w = 0;\r\n                    var y_ = curve.quadraticAt(y0, y1, y2, t);\r\n                    for (var i = 0; i < nRoots; i++) {\r\n                        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\r\n                        if (x_ < x) {\r\n                            continue;\r\n                        }\r\n                        if (roots[i] < t) {\r\n                            w += y_ < y0 ? 1 : -1;\r\n                        } \r\n                        else {\r\n                            w += y2 < y_ ? 1 : -1;\r\n                        }\r\n                    }\r\n                    return w;\r\n                } \r\n                else {\r\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\r\n                    if (x_ < x) {\r\n                        return 0;\r\n                    }\r\n                    return y2 < y0 ? 1 : -1;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // TODO\r\n        // Arc 旋转\r\n        function windingArc(\r\n            cx, cy, r, startAngle, endAngle, anticlockwise, x, y\r\n        ) {\r\n            y -= cy;\r\n            if (y > r || y < -r) {\r\n                return 0;\r\n            }\r\n            var tmp = Math.sqrt(r * r - y * y);\r\n            roots[0] = -tmp;\r\n            roots[1] = tmp;\r\n\r\n            if (Math.abs(startAngle - endAngle) >= PI2) {\r\n                // Is a circle\r\n                startAngle = 0;\r\n                endAngle = PI2;\r\n                var dir = anticlockwise ? 1 : -1;\r\n                if (x >= roots[0] + cx && x <= roots[1] + cx) {\r\n                    return dir;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            if (anticlockwise) {\r\n                var tmp = startAngle;\r\n                startAngle = normalizeRadian(endAngle);\r\n                endAngle = normalizeRadian(tmp);   \r\n            } else {\r\n                startAngle = normalizeRadian(startAngle);\r\n                endAngle = normalizeRadian(endAngle);   \r\n            }\r\n            if (startAngle > endAngle) {\r\n                endAngle += PI2;\r\n            }\r\n\r\n            var w = 0;\r\n            for (var i = 0; i < 2; i++) {\r\n                var x_ = roots[i];\r\n                if (x_ + cx > x) {\r\n                    var angle = Math.atan2(y, x_);\r\n                    var dir = anticlockwise ? 1 : -1;\r\n                    if (angle < 0) {\r\n                        angle = PI2 + angle;\r\n                    }\r\n                    if (\r\n                        (angle >= startAngle && angle <= endAngle)\r\n                        || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\r\n                    ) {\r\n                        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\r\n                            dir = -dir;\r\n                        }\r\n                        w += dir;\r\n                    }\r\n                }\r\n            }\r\n            return w;\r\n        }\r\n\r\n        /**\r\n         * 路径包含判断\r\n         * 与 canvas 一样采用 non-zero winding rule\r\n         */\r\n        function isInsidePath(pathArray, lineWidth, brushType, x, y) {\r\n            var w = 0;\r\n            var xi = 0;\r\n            var yi = 0;\r\n            var x0 = 0;\r\n            var y0 = 0;\r\n            var beginSubpath = true;\r\n            var firstCmd = true;\r\n\r\n            brushType = brushType || 'fill';\r\n\r\n            var hasStroke = brushType === 'stroke' || brushType === 'both';\r\n            var hasFill = brushType === 'fill' || brushType === 'both';\r\n\r\n            // var roots = [-1, -1, -1];\r\n            for (var i = 0; i < pathArray.length; i++) {\r\n                var seg = pathArray[i];\r\n                var p = seg.points;\r\n                // Begin a new subpath\r\n                if (beginSubpath || seg.command === 'M') {\r\n                    if (i > 0) {\r\n                        // Close previous subpath\r\n                        if (hasFill) {\r\n                            w += windingLine(xi, yi, x0, y0, x, y);\r\n                        }\r\n                        if (w !== 0) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    x0 = p[p.length - 2];\r\n                    y0 = p[p.length - 1];\r\n                    beginSubpath = false;\r\n                    if (firstCmd && seg.command !== 'A') {\r\n                        // 如果第一个命令不是M, 是lineTo, bezierCurveTo\r\n                        // 等绘制命令的话，是会从该绘制的起点开始算的\r\n                        // Arc 会在之后做单独处理所以这里忽略\r\n                        firstCmd = false;\r\n                        xi = x0;\r\n                        yi = y0;\r\n                    }\r\n                }\r\n                switch (seg.command) {\r\n                    case 'M':\r\n                        xi = p[0];\r\n                        yi = p[1];\r\n                        break;\r\n                    case 'L':\r\n                        if (hasStroke) {\r\n                            if (isInsideLine(\r\n                                xi, yi, p[0], p[1], lineWidth, x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (hasFill) {\r\n                            w += windingLine(xi, yi, p[0], p[1], x, y);\r\n                        }\r\n                        xi = p[0];\r\n                        yi = p[1];\r\n                        break;\r\n                    case 'C':\r\n                        if (hasStroke) {\r\n                            if (isInsideCubicStroke(\r\n                                xi, yi, p[0], p[1], p[2], p[3], p[4], p[5],\r\n                                lineWidth, x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (hasFill) {\r\n                            w += windingCubic(\r\n                                xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], x, y\r\n                            );\r\n                        }\r\n                        xi = p[4];\r\n                        yi = p[5];\r\n                        break;\r\n                    case 'Q':\r\n                        if (hasStroke) {\r\n                            if (isInsideQuadraticStroke(\r\n                                xi, yi, p[0], p[1], p[2], p[3],\r\n                                lineWidth, x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (hasFill) {\r\n                            w += windingQuadratic(\r\n                                xi, yi, p[0], p[1], p[2], p[3], x, y\r\n                            );\r\n                        }\r\n                        xi = p[2];\r\n                        yi = p[3];\r\n                        break;\r\n                    case 'A':\r\n                        // TODO Arc 旋转\r\n                        // TODO Arc 判断的开销比较大\r\n                        var cx = p[0];\r\n                        var cy = p[1];\r\n                        var rx = p[2];\r\n                        var ry = p[3];\r\n                        var theta = p[4];\r\n                        var dTheta = p[5];\r\n                        var x1 = Math.cos(theta) * rx + cx;\r\n                        var y1 = Math.sin(theta) * ry + cy;\r\n                        // 不是直接使用 arc 命令\r\n                        if (!firstCmd) {\r\n                            w += windingLine(xi, yi, x1, y1);\r\n                        } else {\r\n                            firstCmd = false;\r\n                            // 第一个命令起点还未定义\r\n                            x0 = x1;\r\n                            y0 = y1;\r\n                        }\r\n                        // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\r\n                        var _x = (x - cx) * ry / rx + cx;\r\n                        if (hasStroke) {\r\n                            if (isInsideArcStroke(\r\n                                cx, cy, ry, theta, theta + dTheta, 1 - p[7],\r\n                                lineWidth, _x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (hasFill) {\r\n                            w += windingArc(\r\n                                cx, cy, ry, theta, theta + dTheta, 1 - p[7],\r\n                                _x, y\r\n                            );\r\n                        }\r\n                        xi = Math.cos(theta + dTheta) * rx + cx;\r\n                        yi = Math.sin(theta + dTheta) * ry + cy;\r\n                        break;\r\n                    case 'z':\r\n                        if (hasStroke) {\r\n                            if (isInsideLine(\r\n                                xi, yi, x0, y0, lineWidth, x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        beginSubpath = true;\r\n                        break;\r\n                }\r\n            }\r\n            if (hasFill) {\r\n                w += windingLine(xi, yi, x0, y0, x, y);\r\n            }\r\n            return w !== 0;\r\n        }\r\n\r\n        /**\r\n         * 测算多行文本宽度\r\n         * @param {Object} text\r\n         * @param {Object} textFont\r\n         */\r\n        function getTextWidth(text, textFont) {\r\n            var key = text + ':' + textFont;\r\n            if (_textWidthCache[key]) {\r\n                return _textWidthCache[key];\r\n            }\r\n            _ctx = _ctx || util.getContext();\r\n            _ctx.save();\r\n\r\n            if (textFont) {\r\n                _ctx.font = textFont;\r\n            }\r\n            \r\n            text = (text + '').split('\\n');\r\n            var width = 0;\r\n            for (var i = 0, l = text.length; i < l; i++) {\r\n                width =  Math.max(\r\n                    _ctx.measureText(text[i]).width,\r\n                    width\r\n                );\r\n            }\r\n            _ctx.restore();\r\n\r\n            _textWidthCache[key] = width;\r\n            if (++_textWidthCacheCounter > TEXT_CACHE_MAX) {\r\n                // 内存释放\r\n                _textWidthCacheCounter = 0;\r\n                _textWidthCache = {};\r\n            }\r\n            \r\n            return width;\r\n        }\r\n        \r\n        /**\r\n         * 测算多行文本高度\r\n         * @param {Object} text\r\n         * @param {Object} textFont\r\n         */\r\n        function getTextHeight(text, textFont) {\r\n            var key = text + ':' + textFont;\r\n            if (_textHeightCache[key]) {\r\n                return _textHeightCache[key];\r\n            }\r\n            \r\n            _ctx = _ctx || util.getContext();\r\n\r\n            _ctx.save();\r\n            if (textFont) {\r\n                _ctx.font = textFont;\r\n            }\r\n            \r\n            text = (text + '').split('\\n');\r\n            // 比较粗暴\r\n            var height = (_ctx.measureText('国').width + 2) * text.length;\r\n\r\n            _ctx.restore();\r\n\r\n            _textHeightCache[key] = height;\r\n            if (++_textHeightCacheCounter > TEXT_CACHE_MAX) {\r\n                // 内存释放\r\n                _textHeightCacheCounter = 0;\r\n                _textHeightCache = {};\r\n            }\r\n            return height;\r\n        }\r\n\r\n        return {\r\n            isInside : isInside,\r\n            isOutside : isOutside,\r\n            getTextWidth : getTextWidth,\r\n            getTextHeight : getTextHeight,\r\n\r\n            isInsidePath: isInsidePath,\r\n            isInsidePolygon: isInsidePolygon,\r\n            isInsideSector: isInsideSector,\r\n            isInsideCircle: isInsideCircle,\r\n            isInsideLine: isInsideLine,\r\n            isInsideRect: isInsideRect,\r\n            isInsidePolyline: isInsidePolyline,\r\n\r\n            isInsideCubicStroke: isInsideCubicStroke,\r\n            isInsideQuadraticStroke: isInsideQuadraticStroke\r\n        };\r\n    }\r\n);\r\n"
        },
        {
          "id": 18,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\curve.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/curve.js",
          "index": 18,
          "index2": 9,
          "size": 14871,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 17,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\area.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
              "type": "cjs require",
              "userRequest": "./curve",
              "loc": "17:20-38"
            },
            {
              "moduleId": 26,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/curve",
              "loc": "33:20-51"
            },
            {
              "moduleId": 39,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecAnimation.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/curve",
              "loc": "10:20-51"
            },
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/curve",
              "loc": "13:20-51"
            }
          ],
          "source": "/**\r\n * 曲线辅助模块\r\n * @module zrender/tool/curve\r\n * @author pissang(https://www.github.com/pissang)\r\n */\r\ndefine(function(require) {\r\n\r\n    var vector = require('./vector');\r\n\r\n    'use strict';\r\n\r\n    var EPSILON = 1e-4;\r\n\r\n    var THREE_SQRT = Math.sqrt(3);\r\n    var ONE_THIRD = 1 / 3;\r\n\r\n    // 临时变量\r\n    var _v0 = vector.create();\r\n    var _v1 = vector.create();\r\n    var _v2 = vector.create();\r\n    // var _v3 = vector.create();\r\n\r\n    function isAroundZero(val) {\r\n        return val > -EPSILON && val < EPSILON;\r\n    }\r\n    function isNotAroundZero(val) {\r\n        return val > EPSILON || val < -EPSILON;\r\n    }\r\n    /*\r\n    function evalCubicCoeff(a, b, c, d, t) {\r\n        return ((a * t + b) * t + c) * t + d;\r\n    }\r\n    */\r\n\r\n    /** \r\n     * 计算三次贝塞尔值\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {number} t\r\n     * @return {number}\r\n     */\r\n    function cubicAt(p0, p1, p2, p3, t) {\r\n        var onet = 1 - t;\r\n        return onet * onet * (onet * p0 + 3 * t * p1)\r\n             + t * t * (t * p3 + 3 * onet * p2);\r\n    }\r\n\r\n    /** \r\n     * 计算三次贝塞尔导数值\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {number} t\r\n     * @return {number}\r\n     */\r\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\r\n        var onet = 1 - t;\r\n        return 3 * (\r\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\r\n            + (p3 - p2) * t * t\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 计算三次贝塞尔方程根，使用盛金公式\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {number} val\r\n     * @param  {Array.<number>} roots\r\n     * @return {number} 有效根数目\r\n     */\r\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\r\n        // Evaluate roots of cubic functions\r\n        var a = p3 + 3 * (p1 - p2) - p0;\r\n        var b = 3 * (p2 - p1 * 2 + p0);\r\n        var c = 3 * (p1  - p0);\r\n        var d = p0 - val;\r\n\r\n        var A = b * b - 3 * a * c;\r\n        var B = b * c - 9 * a * d;\r\n        var C = c * c - 3 * b * d;\r\n\r\n        var n = 0;\r\n\r\n        if (isAroundZero(A) && isAroundZero(B)) {\r\n            if (isAroundZero(b)) {\r\n                roots[0] = 0;\r\n            }\r\n            else {\r\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var disc = B * B - 4 * A * C;\r\n\r\n            if (isAroundZero(disc)) {\r\n                var K = B / A;\r\n                var t1 = -b / a + K;  // t1, a is not zero\r\n                var t2 = -K / 2;  // t2, t3\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n                if (t2 >= 0 && t2 <= 1) {\r\n                    roots[n++] = t2;\r\n                }\r\n            }\r\n            else if (disc > 0) {\r\n                var discSqrt = Math.sqrt(disc);\r\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\r\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\r\n                if (Y1 < 0) {\r\n                    Y1 = -Math.pow(-Y1, ONE_THIRD);\r\n                }\r\n                else {\r\n                    Y1 = Math.pow(Y1, ONE_THIRD);\r\n                }\r\n                if (Y2 < 0) {\r\n                    Y2 = -Math.pow(-Y2, ONE_THIRD);\r\n                }\r\n                else {\r\n                    Y2 = Math.pow(Y2, ONE_THIRD);\r\n                }\r\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n            }\r\n            else {\r\n                var T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));\r\n                var theta = Math.acos(T) / 3;\r\n                var ASqrt = Math.sqrt(A);\r\n                var tmp = Math.cos(theta);\r\n                \r\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\r\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\r\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n                if (t2 >= 0 && t2 <= 1) {\r\n                    roots[n++] = t2;\r\n                }\r\n                if (t3 >= 0 && t3 <= 1) {\r\n                    roots[n++] = t3;\r\n                }\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n\r\n    /**\r\n     * 计算三次贝塞尔方程极限值的位置\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {Array.<number>} extrema\r\n     * @return {number} 有效数目\r\n     */\r\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\r\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\r\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\r\n        var c = 3 * p1 - 3 * p0;\r\n\r\n        var n = 0;\r\n        if (isAroundZero(a)) {\r\n            if (isNotAroundZero(b)) {\r\n                var t1 = -c / b;\r\n                if (t1 >= 0 && t1 <=1) {\r\n                    extrema[n++] = t1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var disc = b * b - 4 * a * c;\r\n            if (isAroundZero(disc)) {\r\n                extrema[0] = -b / (2 * a);\r\n            }\r\n            else if (disc > 0) {\r\n                var discSqrt = Math.sqrt(disc);\r\n                var t1 = (-b + discSqrt) / (2 * a);\r\n                var t2 = (-b - discSqrt) / (2 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    extrema[n++] = t1;\r\n                }\r\n                if (t2 >= 0 && t2 <= 1) {\r\n                    extrema[n++] = t2;\r\n                }\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n\r\n    /**\r\n     * 细分三次贝塞尔曲线\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {number} t\r\n     * @param  {Array.<number>} out\r\n     */\r\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\r\n        var p01 = (p1 - p0) * t + p0;\r\n        var p12 = (p2 - p1) * t + p1;\r\n        var p23 = (p3 - p2) * t + p2;\r\n\r\n        var p012 = (p12 - p01) * t + p01;\r\n        var p123 = (p23 - p12) * t + p12;\r\n\r\n        var p0123 = (p123 - p012) * t + p012;\r\n        // Seg0\r\n        out[0] = p0;\r\n        out[1] = p01;\r\n        out[2] = p012;\r\n        out[3] = p0123;\r\n        // Seg1\r\n        out[4] = p0123;\r\n        out[5] = p123;\r\n        out[6] = p23;\r\n        out[7] = p3;\r\n    }\r\n\r\n    /**\r\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\r\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\r\n     * @param {number} x0\r\n     * @param {number} y0\r\n     * @param {number} x1\r\n     * @param {number} y1\r\n     * @param {number} x2\r\n     * @param {number} y2\r\n     * @param {number} x3\r\n     * @param {number} y3\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {Array.<number>} [out] 投射点\r\n     * @return {number}\r\n     */\r\n    function cubicProjectPoint(\r\n        x0, y0, x1, y1, x2, y2, x3, y3,\r\n        x, y, out\r\n    ) {\r\n        // http://pomax.github.io/bezierinfo/#projections\r\n        var t;\r\n        var interval = 0.005;\r\n        var d = Infinity;\r\n\r\n        _v0[0] = x;\r\n        _v0[1] = y;\r\n\r\n        // 先粗略估计一下可能的最小距离的 t 值\r\n        // PENDING\r\n        for (var _t = 0; _t < 1; _t += 0.05) {\r\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\r\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\r\n            var d1 = vector.distSquare(_v0, _v1);\r\n            if (d1 < d) {\r\n                t = _t;\r\n                d = d1;\r\n            }\r\n        }\r\n        d = Infinity;\r\n\r\n        // At most 32 iteration\r\n        for (var i = 0; i < 32; i++) {\r\n            if (interval < EPSILON) {\r\n                break;\r\n            }\r\n            var prev = t - interval;\r\n            var next = t + interval;\r\n            // t - interval\r\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\r\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\r\n\r\n            var d1 = vector.distSquare(_v1, _v0);\r\n\r\n            if (prev >= 0 && d1 < d) {\r\n                t = prev;\r\n                d = d1;\r\n            }\r\n            else {\r\n                // t + interval\r\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\r\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\r\n                var d2 = vector.distSquare(_v2, _v0);\r\n\r\n                if (next <= 1 && d2 < d) {\r\n                    t = next;\r\n                    d = d2;\r\n                }\r\n                else {\r\n                    interval *= 0.5;\r\n                }\r\n            }\r\n        }\r\n        // t\r\n        if (out) {\r\n            out[0] = cubicAt(x0, x1, x2, x3, t);\r\n            out[1] = cubicAt(y0, y1, y2, y3, t);   \r\n        }\r\n        // console.log(interval, i);\r\n        return Math.sqrt(d);\r\n    }\r\n\r\n    /**\r\n     * 计算二次方贝塞尔值\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} t\r\n     * @return {number}\r\n     */\r\n    function quadraticAt(p0, p1, p2, t) {\r\n        var onet = 1 - t;\r\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\r\n    }\r\n\r\n    /**\r\n     * 计算二次方贝塞尔导数值\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} t\r\n     * @return {number}\r\n     */\r\n    function quadraticDerivativeAt(p0, p1, p2, t) {\r\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\r\n    }\r\n\r\n    /**\r\n     * 计算二次方贝塞尔方程根\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} t\r\n     * @param  {Array.<number>} roots\r\n     * @return {number} 有效根数目\r\n     */\r\n    function quadraticRootAt(p0, p1, p2, val, roots) {\r\n        var a = p0 - 2 * p1 + p2;\r\n        var b = 2 * (p1 - p0);\r\n        var c = p0 - val;\r\n\r\n        var n = 0;\r\n        if (isAroundZero(a)) {\r\n            if (isNotAroundZero(b)) {\r\n                var t1 = -c / b;\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var disc = b * b - 4 * a * c;\r\n            if (isAroundZero(disc)) {\r\n                var t1 = -b / (2 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n            }\r\n            else if (disc > 0) {\r\n                var discSqrt = Math.sqrt(disc);\r\n                var t1 = (-b + discSqrt) / (2 * a);\r\n                var t2 = (-b - discSqrt) / (2 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n                if (t2 >= 0 && t2 <= 1) {\r\n                    roots[n++] = t2;\r\n                }\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n\r\n    /**\r\n     * 计算二次贝塞尔方程极限值\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @return {number}\r\n     */\r\n    function quadraticExtremum(p0, p1, p2) {\r\n        var divider = p0 + p2 - 2 * p1;\r\n        if (divider === 0) {\r\n            // p1 is center of p0 and p2 \r\n            return 0.5;\r\n        }\r\n        else {\r\n            return (p0 - p1) / divider;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 细分二次贝塞尔曲线\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} t\r\n     * @param  {Array.<number>} out\r\n     */\r\n    function quadraticSubdivide(p0, p1, p2, t, out) {\r\n        var p01 = (p1 - p0) * t + p0;\r\n        var p12 = (p2 - p1) * t + p1;\r\n        var p012 = (p12 - p01) * t + p01;\r\n\r\n        // Seg0\r\n        out[0] = p0;\r\n        out[1] = p01;\r\n        out[2] = p012;\r\n\r\n        // Seg1\r\n        out[3] = p012;\r\n        out[4] = p12;\r\n        out[5] = p2;\r\n    }\r\n\r\n    /**\r\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\r\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\r\n     * @param {number} x0\r\n     * @param {number} y0\r\n     * @param {number} x1\r\n     * @param {number} y1\r\n     * @param {number} x2\r\n     * @param {number} y2\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {Array.<number>} out 投射点\r\n     * @return {number}\r\n     */\r\n    function quadraticProjectPoint(\r\n        x0, y0, x1, y1, x2, y2,\r\n        x, y, out\r\n    ) {\r\n        // http://pomax.github.io/bezierinfo/#projections\r\n        var t;\r\n        var interval = 0.005;\r\n        var d = Infinity;\r\n\r\n        _v0[0] = x;\r\n        _v0[1] = y;\r\n\r\n        // 先粗略估计一下可能的最小距离的 t 值\r\n        // PENDING\r\n        for (var _t = 0; _t < 1; _t += 0.05) {\r\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\r\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\r\n            var d1 = vector.distSquare(_v0, _v1);\r\n            if (d1 < d) {\r\n                t = _t;\r\n                d = d1;\r\n            }\r\n        }\r\n        d = Infinity;\r\n\r\n        // At most 32 iteration\r\n        for (var i = 0; i < 32; i++) {\r\n            if (interval < EPSILON) {\r\n                break;\r\n            }\r\n            var prev = t - interval;\r\n            var next = t + interval;\r\n            // t - interval\r\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\r\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\r\n\r\n            var d1 = vector.distSquare(_v1, _v0);\r\n\r\n            if (prev >= 0 && d1 < d) {\r\n                t = prev;\r\n                d = d1;\r\n            }\r\n            else {\r\n                // t + interval\r\n                _v2[0] = quadraticAt(x0, x1, x2, next);\r\n                _v2[1] = quadraticAt(y0, y1, y2, next);\r\n                var d2 = vector.distSquare(_v2, _v0);\r\n                if (next <= 1 && d2 < d) {\r\n                    t = next;\r\n                    d = d2;\r\n                }\r\n                else {\r\n                    interval *= 0.5;\r\n                }\r\n            }\r\n        }\r\n        // t\r\n        if (out) {\r\n            out[0] = quadraticAt(x0, x1, x2, t);\r\n            out[1] = quadraticAt(y0, y1, y2, t);   \r\n        }\r\n        // console.log(interval, i);\r\n        return Math.sqrt(d);\r\n    }\r\n\r\n    return {\r\n\r\n        cubicAt: cubicAt,\r\n\r\n        cubicDerivativeAt: cubicDerivativeAt,\r\n\r\n        cubicRootAt: cubicRootAt,\r\n\r\n        cubicExtrema: cubicExtrema,\r\n\r\n        cubicSubdivide: cubicSubdivide,\r\n\r\n        cubicProjectPoint: cubicProjectPoint,\r\n\r\n        quadraticAt: quadraticAt,\r\n\r\n        quadraticDerivativeAt: quadraticDerivativeAt,\r\n\r\n        quadraticRootAt: quadraticRootAt,\r\n\r\n        quadraticExtremum: quadraticExtremum,\r\n\r\n        quadraticSubdivide: quadraticSubdivide,\r\n\r\n        quadraticProjectPoint: quadraticProjectPoint\r\n    };\r\n});"
        },
        {
          "id": 19,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\color.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/color.js",
          "index": 19,
          "index2": 11,
          "size": 29604,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/color",
              "loc": "64:18-49"
            },
            {
              "moduleId": 7,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
              "type": "cjs require",
              "userRequest": "../tool/color",
              "loc": "384:24-48"
            },
            {
              "moduleId": 51,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/color",
              "loc": "24:18-49"
            },
            {
              "moduleId": 64,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/color",
              "loc": "81:26-57"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/color",
              "loc": "71:18-49"
            }
          ],
          "source": "/**\r\n * 颜色辅助模块\r\n * @module zrender/tool/color\r\n */\r\ndefine(function(require) {\r\n    var util = require('../tool/util');\r\n\r\n    var _ctx;\r\n\r\n    // Color palette is an array containing the default colors for the chart's\r\n    // series.\r\n    // When all colors are used, new colors are selected from the start again.\r\n    // Defaults to:\r\n    // 默认色板\r\n    var palette = [\r\n        '#ff9277', ' #dddd00', ' #ffc877', ' #bbe3ff', ' #d5ffbb',\r\n        '#bbbbff', ' #ddb000', ' #b0dd00', ' #e2bbff', ' #ffbbe3',\r\n        '#ff7777', ' #ff9900', ' #83dd00', ' #77e3ff', ' #778fff',\r\n        '#c877ff', ' #ff77ab', ' #ff6600', ' #aa8800', ' #77c7ff',\r\n        '#ad77ff', ' #ff77ff', ' #dd0083', ' #777700', ' #00aa00',\r\n        '#0088aa', ' #8400dd', ' #aa0088', ' #dd0000', ' #772e00'\r\n    ];\r\n    var _palette = palette;\r\n\r\n    var highlightColor = 'rgba(255,255,0,0.5)';\r\n    var _highlightColor = highlightColor;\r\n\r\n    // 颜色格式\r\n    /*jshint maxlen: 330 */\r\n    var colorRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i;\r\n\r\n    var _nameColors = {\r\n        aliceblue : '#f0f8ff',\r\n        antiquewhite : '#faebd7',\r\n        aqua : '#0ff',\r\n        aquamarine : '#7fffd4',\r\n        azure : '#f0ffff',\r\n        beige : '#f5f5dc',\r\n        bisque : '#ffe4c4',\r\n        black : '#000',\r\n        blanchedalmond : '#ffebcd',\r\n        blue : '#00f',\r\n        blueviolet : '#8a2be2',\r\n        brown : '#a52a2a',\r\n        burlywood : '#deb887',\r\n        cadetblue : '#5f9ea0',\r\n        chartreuse : '#7fff00',\r\n        chocolate : '#d2691e',\r\n        coral : '#ff7f50',\r\n        cornflowerblue : '#6495ed',\r\n        cornsilk : '#fff8dc',\r\n        crimson : '#dc143c',\r\n        cyan : '#0ff',\r\n        darkblue : '#00008b',\r\n        darkcyan : '#008b8b',\r\n        darkgoldenrod : '#b8860b',\r\n        darkgray : '#a9a9a9',\r\n        darkgrey : '#a9a9a9',\r\n        darkgreen : '#006400',\r\n        darkkhaki : '#bdb76b',\r\n        darkmagenta : '#8b008b',\r\n        darkolivegreen : '#556b2f',\r\n        darkorange : '#ff8c00',\r\n        darkorchid : '#9932cc',\r\n        darkred : '#8b0000',\r\n        darksalmon : '#e9967a',\r\n        darkseagreen : '#8fbc8f',\r\n        darkslateblue : '#483d8b',\r\n        darkslategray : '#2f4f4f',\r\n        darkslategrey : '#2f4f4f',\r\n        darkturquoise : '#00ced1',\r\n        darkviolet : '#9400d3',\r\n        deeppink : '#ff1493',\r\n        deepskyblue : '#00bfff',\r\n        dimgray : '#696969',\r\n        dimgrey : '#696969',\r\n        dodgerblue : '#1e90ff',\r\n        firebrick : '#b22222',\r\n        floralwhite : '#fffaf0',\r\n        forestgreen : '#228b22',\r\n        fuchsia : '#f0f',\r\n        gainsboro : '#dcdcdc',\r\n        ghostwhite : '#f8f8ff',\r\n        gold : '#ffd700',\r\n        goldenrod : '#daa520',\r\n        gray : '#808080',\r\n        grey : '#808080',\r\n        green : '#008000',\r\n        greenyellow : '#adff2f',\r\n        honeydew : '#f0fff0',\r\n        hotpink : '#ff69b4',\r\n        indianred : '#cd5c5c',\r\n        indigo : '#4b0082',\r\n        ivory : '#fffff0',\r\n        khaki : '#f0e68c',\r\n        lavender : '#e6e6fa',\r\n        lavenderblush : '#fff0f5',\r\n        lawngreen : '#7cfc00',\r\n        lemonchiffon : '#fffacd',\r\n        lightblue : '#add8e6',\r\n        lightcoral : '#f08080',\r\n        lightcyan : '#e0ffff',\r\n        lightgoldenrodyellow : '#fafad2',\r\n        lightgray : '#d3d3d3',\r\n        lightgrey : '#d3d3d3',\r\n        lightgreen : '#90ee90',\r\n        lightpink : '#ffb6c1',\r\n        lightsalmon : '#ffa07a',\r\n        lightseagreen : '#20b2aa',\r\n        lightskyblue : '#87cefa',\r\n        lightslategray : '#789',\r\n        lightslategrey : '#789',\r\n        lightsteelblue : '#b0c4de',\r\n        lightyellow : '#ffffe0',\r\n        lime : '#0f0',\r\n        limegreen : '#32cd32',\r\n        linen : '#faf0e6',\r\n        magenta : '#f0f',\r\n        maroon : '#800000',\r\n        mediumaquamarine : '#66cdaa',\r\n        mediumblue : '#0000cd',\r\n        mediumorchid : '#ba55d3',\r\n        mediumpurple : '#9370d8',\r\n        mediumseagreen : '#3cb371',\r\n        mediumslateblue : '#7b68ee',\r\n        mediumspringgreen : '#00fa9a',\r\n        mediumturquoise : '#48d1cc',\r\n        mediumvioletred : '#c71585',\r\n        midnightblue : '#191970',\r\n        mintcream : '#f5fffa',\r\n        mistyrose : '#ffe4e1',\r\n        moccasin : '#ffe4b5',\r\n        navajowhite : '#ffdead',\r\n        navy : '#000080',\r\n        oldlace : '#fdf5e6',\r\n        olive : '#808000',\r\n        olivedrab : '#6b8e23',\r\n        orange : '#ffa500',\r\n        orangered : '#ff4500',\r\n        orchid : '#da70d6',\r\n        palegoldenrod : '#eee8aa',\r\n        palegreen : '#98fb98',\r\n        paleturquoise : '#afeeee',\r\n        palevioletred : '#d87093',\r\n        papayawhip : '#ffefd5',\r\n        peachpuff : '#ffdab9',\r\n        peru : '#cd853f',\r\n        pink : '#ffc0cb',\r\n        plum : '#dda0dd',\r\n        powderblue : '#b0e0e6',\r\n        purple : '#800080',\r\n        red : '#f00',\r\n        rosybrown : '#bc8f8f',\r\n        royalblue : '#4169e1',\r\n        saddlebrown : '#8b4513',\r\n        salmon : '#fa8072',\r\n        sandybrown : '#f4a460',\r\n        seagreen : '#2e8b57',\r\n        seashell : '#fff5ee',\r\n        sienna : '#a0522d',\r\n        silver : '#c0c0c0',\r\n        skyblue : '#87ceeb',\r\n        slateblue : '#6a5acd',\r\n        slategray : '#708090',\r\n        slategrey : '#708090',\r\n        snow : '#fffafa',\r\n        springgreen : '#00ff7f',\r\n        steelblue : '#4682b4',\r\n        tan : '#d2b48c',\r\n        teal : '#008080',\r\n        thistle : '#d8bfd8',\r\n        tomato : '#ff6347',\r\n        turquoise : '#40e0d0',\r\n        violet : '#ee82ee',\r\n        wheat : '#f5deb3',\r\n        white : '#fff',\r\n        whitesmoke : '#f5f5f5',\r\n        yellow : '#ff0',\r\n        yellowgreen : '#9acd32'\r\n    };\r\n\r\n    /**\r\n     * 自定义调色板\r\n     */\r\n    function customPalette(userPalete) {\r\n        palette = userPalete;\r\n    }\r\n\r\n    /**\r\n     * 复位默认色板\r\n     */\r\n    function resetPalette() {\r\n        palette = _palette;\r\n    }\r\n\r\n    /**\r\n     * 获取色板颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {number} idx 色板位置\r\n     * @param {Array.<string>} [userPalete] 自定义色板\r\n     * @return {string} 颜色\r\n     */\r\n    function getColor(idx, userPalete) {\r\n        idx = idx | 0;\r\n        userPalete = userPalete || palette;\r\n        return userPalete[idx % userPalete.length];\r\n    }\r\n\r\n    /**\r\n     * 自定义默认高亮颜色\r\n     */\r\n    function customHighlight(userHighlightColor) {\r\n        highlightColor = userHighlightColor;\r\n    }\r\n\r\n    /**\r\n     * 重置默认高亮颜色\r\n     */\r\n    function resetHighlight() {\r\n        _highlightColor = highlightColor;\r\n    }\r\n\r\n    /**\r\n     * 获取默认高亮颜色\r\n     */\r\n    function getHighlightColor() {\r\n        return highlightColor;\r\n    }\r\n\r\n    /**\r\n     * 径向渐变\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {number} x0 渐变起点\r\n     * @param {number} y0\r\n     * @param {number} r0\r\n     * @param {number} x1 渐变终点\r\n     * @param {number} y1\r\n     * @param {number} r1\r\n     * @param {Array} colorList 颜色列表\r\n     * @return {CanvasGradient}\r\n     */\r\n    function getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {\r\n        if (!_ctx) {\r\n            _ctx = util.getContext();\r\n        }\r\n        var gradient = _ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\r\n        for (var i = 0, l = colorList.length; i < l; i++) {\r\n            gradient.addColorStop(colorList[i][0], colorList[i][1]);\r\n        }\r\n        gradient.__nonRecursion = true;\r\n        return gradient;\r\n    }\r\n\r\n    /**\r\n     * 线性渐变\r\n     * @param {Object} x0 渐变起点\r\n     * @param {Object} y0\r\n     * @param {Object} x1 渐变终点\r\n     * @param {Object} y1\r\n     * @param {Array} colorList 颜色列表\r\n     */\r\n    function getLinearGradient(x0, y0, x1, y1, colorList) {\r\n        if (!_ctx) {\r\n            _ctx = util.getContext();\r\n        }\r\n        var gradient = _ctx.createLinearGradient(x0, y0, x1, y1);\r\n        for (var i = 0, l = colorList.length; i < l; i++) {\r\n            gradient.addColorStop(colorList[i][0], colorList[i][1]);\r\n        }\r\n        gradient.__nonRecursion = true;\r\n        return gradient;\r\n    }\r\n\r\n    /**\r\n     * 获取两种颜色之间渐变颜色数组\r\n     * @param {color} start 起始颜色\r\n     * @param {color} end 结束颜色\r\n     * @param {number} step 渐变级数\r\n     * @return {Array}  颜色数组\r\n     */\r\n    function getStepColors(start, end, step) {\r\n        start = toRGBA(start);\r\n        end = toRGBA(end);\r\n        start = getData(start);\r\n        end = getData(end);\r\n\r\n        var colors = [];\r\n        var stepR = (end[0] - start[0]) / step;\r\n        var stepG = (end[1] - start[1]) / step;\r\n        var stepB = (end[2] - start[2]) / step;\r\n        var stepA = (end[3] - start[3]) / step;\r\n        // 生成颜色集合\r\n        // fix by linfeng 颜色堆积\r\n        for (var i = 0, r = start[0], g = start[1], b = start[2], a = start[3]; i < step; i++) {\r\n            colors[i] = toColor([\r\n                adjust(Math.floor(r), [ 0, 255 ]),\r\n                adjust(Math.floor(g), [ 0, 255 ]), \r\n                adjust(Math.floor(b), [ 0, 255 ]),\r\n                a.toFixed(4) - 0\r\n            ],'rgba');\r\n            r += stepR;\r\n            g += stepG;\r\n            b += stepB;\r\n            a += stepA;\r\n        }\r\n        r = end[0];\r\n        g = end[1];\r\n        b = end[2];\r\n        a = end[3];\r\n        colors[i] = toColor([r, g, b, a], 'rgba');\r\n        return colors;\r\n    }\r\n\r\n    /**\r\n     * 获取指定级数的渐变颜色数组\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {Array.<string>} colors 颜色组\r\n     * @param {number} [step=20] 渐变级数\r\n     * @return {Array.<string>}  颜色数组\r\n     */\r\n    function getGradientColors(colors, step) {\r\n        var ret = [];\r\n        var len = colors.length;\r\n        if (step === undefined) {\r\n            step = 20;\r\n        }\r\n        if (len === 1) {\r\n            ret = getStepColors(colors[0], colors[0], step);\r\n        }\r\n        else if (len > 1) {\r\n            for (var i = 0, n = len - 1; i < n; i++) {\r\n                var steps = getStepColors(colors[i], colors[i + 1], step);\r\n                if (i < n - 1) {\r\n                    steps.pop();\r\n                }\r\n                ret = ret.concat(steps);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * 颜色值数组转为指定格式颜色,例如:<br/>\r\n     * data = [60,20,20,0.1] format = 'rgba'\r\n     * 返回：rgba(60,20,20,0.1)\r\n     * @param {Array} data 颜色值数组\r\n     * @param {string} format 格式,默认rgb\r\n     * @return {string} 颜色\r\n     */\r\n    function toColor(data, format) {\r\n        format = format || 'rgb';\r\n        if (data && (data.length === 3 || data.length === 4)) {\r\n            data = map(data,\r\n                function(c) {\r\n                    return c > 1 ? Math.ceil(c) : c;\r\n                }\r\n            );\r\n\r\n            if (format.indexOf('hex') > -1) {\r\n                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);\r\n            }\r\n            else if (format.indexOf('hs') > -1) {\r\n                var sx = map(data.slice(1, 3),\r\n                    function(c) {\r\n                        return c + '%';\r\n                    }\r\n                );\r\n                data[1] = sx[0];\r\n                data[2] = sx[1];\r\n            }\r\n\r\n            if (format.indexOf('a') > -1) {\r\n                if (data.length === 3) {\r\n                    data.push(1);\r\n                }\r\n                data[3] = adjust(data[3], [ 0, 1 ]);\r\n                return format + '(' + data.slice(0, 4).join(',') + ')';\r\n            }\r\n\r\n            return format + '(' + data.slice(0, 3).join(',') + ')';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 颜色字符串转换为rgba数组\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {Array.<number>} 颜色值数组\r\n     */\r\n    function toArray(color) {\r\n        color = trim(color);\r\n        if (color.indexOf('rgba') < 0) {\r\n            color = toRGBA(color);\r\n        }\r\n\r\n        var data = [];\r\n        var i = 0;\r\n        color.replace(/[\\d.]+/g, function (n) {\r\n            if (i < 3) {\r\n                n = n | 0;\r\n            }\r\n            else {\r\n                // Alpha\r\n                n = +n;\r\n            }\r\n            data[i++] = n;\r\n        });\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * 颜色格式转化\r\n     *\r\n     * @param {string} color 颜色值数组\r\n     * @param {string} format 格式,默认rgb\r\n     * @return {string} 颜色\r\n     */\r\n    function convert(color, format) {\r\n        if (!isCalculableColor(color)) {\r\n            return color;\r\n        }\r\n        var data = getData(color);\r\n        var alpha = data[3];\r\n        if (typeof alpha === 'undefined') {\r\n            alpha = 1;\r\n        }\r\n\r\n        if (color.indexOf('hsb') > -1) {\r\n            data = _HSV_2_RGB(data);\r\n        }\r\n        else if (color.indexOf('hsl') > -1) {\r\n            data = _HSL_2_RGB(data);\r\n        }\r\n\r\n        if (format.indexOf('hsb') > -1 || format.indexOf('hsv') > -1) {\r\n            data = _RGB_2_HSB(data);\r\n        }\r\n        else if (format.indexOf('hsl') > -1) {\r\n            data = _RGB_2_HSL(data);\r\n        }\r\n\r\n        data[3] = alpha;\r\n\r\n        return toColor(data, format);\r\n    }\r\n\r\n    /**\r\n     * 转换为rgba格式的颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} rgba颜色，rgba(r,g,b,a)\r\n     */\r\n    function toRGBA(color) {\r\n        return convert(color, 'rgba');\r\n    }\r\n\r\n    /**\r\n     * 转换为rgb数字格式的颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} rgb颜色，rgb(0,0,0)格式\r\n     */\r\n    function toRGB(color) {\r\n        return convert(color, 'rgb');\r\n    }\r\n\r\n    /**\r\n     * 转换为16进制颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} 16进制颜色，#rrggbb格式\r\n     */\r\n    function toHex(color) {\r\n        return convert(color, 'hex');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSV颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSVA颜色，hsva(h,s,v,a)\r\n     */\r\n    function toHSVA(color) {\r\n        return convert(color, 'hsva');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSV颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSV颜色，hsv(h,s,v)\r\n     */\r\n    function toHSV(color) {\r\n        return convert(color, 'hsv');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSBA颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSBA颜色，hsba(h,s,b,a)\r\n     */\r\n    function toHSBA(color) {\r\n        return convert(color, 'hsba');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSB颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSB颜色，hsb(h,s,b)\r\n     */\r\n    function toHSB(color) {\r\n        return convert(color, 'hsb');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSLA颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSLA颜色，hsla(h,s,l,a)\r\n     */\r\n    function toHSLA(color) {\r\n        return convert(color, 'hsla');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSL颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSL颜色，hsl(h,s,l)\r\n     */\r\n    function toHSL(color) {\r\n        return convert(color, 'hsl');\r\n    }\r\n\r\n    /**\r\n     * 转换颜色名\r\n     * \r\n     * @param {string} color 颜色\r\n     * @return {string} 颜色名\r\n     */\r\n    function toName(color) {\r\n        for (var key in _nameColors) {\r\n            if (toHex(_nameColors[key]) === toHex(color)) {\r\n                return key;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 移除颜色中多余空格\r\n     * \r\n     * @param {string} color 颜色\r\n     * @return {string} 无空格颜色\r\n     */\r\n    function trim(color) {\r\n        return String(color).replace(/\\s+/g, '');\r\n    }\r\n\r\n    /**\r\n     * 颜色规范化\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} 规范化后的颜色\r\n     */\r\n    function normalize(color) {\r\n        // 颜色名\r\n        if (_nameColors[color]) {\r\n            color = _nameColors[color];\r\n        }\r\n        // 去掉空格\r\n        color = trim(color);\r\n        // hsv与hsb等价\r\n        color = color.replace(/hsv/i, 'hsb');\r\n        // rgb转为rrggbb\r\n        if (/^#[\\da-f]{3}$/i.test(color)) {\r\n            color = parseInt(color.slice(1), 16);\r\n            var r = (color & 0xf00) << 8;\r\n            var g = (color & 0xf0) << 4;\r\n            var b = color & 0xf;\r\n\r\n            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);\r\n        }\r\n        // 或者使用以下正则替换，不过 chrome 下性能相对差点\r\n        // color = color.replace(/^#([\\da-f])([\\da-f])([\\da-f])$/i, '#$1$1$2$2$3$3');\r\n        return color;\r\n    }\r\n\r\n    /**\r\n     * 颜色加深或减淡，当level>0加深，当level<0减淡\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @param {number} level 升降程度,取值区间[-1,1]\r\n     * @return {string} 加深或减淡后颜色值\r\n     */\r\n    function lift(color, level) {\r\n        if (!isCalculableColor(color)) {\r\n            return color;\r\n        }\r\n        var direct = level > 0 ? 1 : -1;\r\n        if (typeof level === 'undefined') {\r\n            level = 0;\r\n        }\r\n        level = Math.abs(level) > 1 ? 1 : Math.abs(level);\r\n        color = toRGB(color);\r\n        var data = getData(color);\r\n        for (var i = 0; i < 3; i++) {\r\n            if (direct === 1) {\r\n                data[i] = data[i] * (1 - level) | 0;\r\n            }\r\n            else {\r\n                data[i] = ((255 - data[i]) * level + data[i]) | 0;\r\n            }\r\n        }\r\n        return 'rgb(' + data.join(',') + ')';\r\n    }\r\n\r\n    /**\r\n     * 颜色翻转,[255-r,255-g,255-b,1-a]\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} 翻转颜色\r\n     */\r\n    function reverse(color) {\r\n        if (!isCalculableColor(color)) {\r\n            return color;\r\n        }\r\n        var data = getData(toRGBA(color));\r\n        data = map(data,\r\n            function(c) {\r\n                return 255 - c;\r\n            }\r\n        );\r\n        return toColor(data, 'rgb');\r\n    }\r\n\r\n    /**\r\n     * 简单两种颜色混合\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color1 第一种颜色\r\n     * @param {string} color2 第二种颜色\r\n     * @param {number} weight 混合权重[0-1]\r\n     * @return {string} 结果色,rgb(r,g,b)或rgba(r,g,b,a)\r\n     */\r\n    function mix(color1, color2, weight) {\r\n        if (!isCalculableColor(color1) || !isCalculableColor(color2)) {\r\n            return color1;\r\n        }\r\n        \r\n        if (typeof weight === 'undefined') {\r\n            weight = 0.5;\r\n        }\r\n        weight = 1 - adjust(weight, [ 0, 1 ]);\r\n\r\n        var w = weight * 2 - 1;\r\n        var data1 = getData(toRGBA(color1));\r\n        var data2 = getData(toRGBA(color2));\r\n\r\n        var d = data1[3] - data2[3];\r\n\r\n        var weight1 = (((w * d === -1) ? w : (w + d) / (1 + w * d)) + 1) / 2;\r\n        var weight2 = 1 - weight1;\r\n\r\n        var data = [];\r\n\r\n        for (var i = 0; i < 3; i++) {\r\n            data[i] = data1[i] * weight1 + data2[i] * weight2;\r\n        }\r\n\r\n        var alpha = data1[3] * weight + data2[3] * (1 - weight);\r\n        alpha = Math.max(0, Math.min(1, alpha));\r\n\r\n        if (data1[3] === 1 && data2[3] === 1) {// 不考虑透明度\r\n            return toColor(data, 'rgb');\r\n        }\r\n        data[3] = alpha;\r\n        return toColor(data, 'rgba');\r\n    }\r\n\r\n    /**\r\n     * 随机颜色\r\n     * \r\n     * @return {string} 颜色值，#rrggbb格式\r\n     */\r\n    function random() {\r\n        return '#' + (Math.random().toString(16) + '0000').slice(2, 8);\r\n    }\r\n\r\n    /**\r\n     * 获取颜色值数组,返回值范围： <br/>\r\n     * RGB 范围[0-255] <br/>\r\n     * HSL/HSV/HSB 范围[0-1]<br/>\r\n     * A透明度范围[0-1]\r\n     * 支持格式：\r\n     * #rgb\r\n     * #rrggbb\r\n     * rgb(r,g,b)\r\n     * rgb(r%,g%,b%)\r\n     * rgba(r,g,b,a)\r\n     * hsb(h,s,b) // hsv与hsb等价\r\n     * hsb(h%,s%,b%)\r\n     * hsba(h,s,b,a)\r\n     * hsl(h,s,l)\r\n     * hsl(h%,s%,l%)\r\n     * hsla(h,s,l,a)\r\n     *\r\n     * @param {string} color 颜色\r\n     * @return {Array.<number>} 颜色值数组或null\r\n     */\r\n    function getData(color) {\r\n        color = normalize(color);\r\n        var r = color.match(colorRegExp);\r\n        if (r === null) {\r\n            throw new Error('The color format error'); // 颜色格式错误\r\n        }\r\n        var d;\r\n        var a;\r\n        var data = [];\r\n        var rgb;\r\n\r\n        if (r[2]) {\r\n            // #rrggbb\r\n            d = r[2].replace('#', '').split('');\r\n            rgb = [ d[0] + d[1], d[2] + d[3], d[4] + d[5] ];\r\n            data = map(rgb,\r\n                function(c) {\r\n                    return adjust(parseInt(c, 16), [ 0, 255 ]);\r\n                }\r\n            );\r\n\r\n        }\r\n        else if (r[4]) {\r\n            // rgb rgba\r\n            var rgba = (r[4]).split(',');\r\n            a = rgba[3];\r\n            rgb = rgba.slice(0, 3);\r\n            data = map(\r\n                rgb,\r\n                function(c) {\r\n                    c = Math.floor(\r\n                        c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c\r\n                    );\r\n                    return adjust(c, [ 0, 255 ]);\r\n                }\r\n            );\r\n\r\n            if (typeof a !== 'undefined') {\r\n                data.push(adjust(parseFloat(a), [ 0, 1 ]));\r\n            }\r\n        }\r\n        else if (r[5] || r[6]) {\r\n            // hsb hsba hsl hsla\r\n            var hsxa = (r[5] || r[6]).split(',');\r\n            var h = parseInt(hsxa[0], 0) / 360;\r\n            var s = hsxa[1];\r\n            var x = hsxa[2];\r\n            a = hsxa[3];\r\n            data = map([ s, x ],\r\n                function(c) {\r\n                    return adjust(parseFloat(c) / 100, [ 0, 1 ]);\r\n                }\r\n            );\r\n            data.unshift(h);\r\n            if (typeof a !== 'undefined') {\r\n                data.push(adjust(parseFloat(a), [ 0, 1 ]));\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * 设置颜色透明度\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @param {number} a 透明度,区间[0,1]\r\n     * @return {string} rgba颜色值\r\n     */\r\n    function alpha(color, a) {\r\n        if (!isCalculableColor(color)) {\r\n            return color;\r\n        }\r\n        if (a === null) {\r\n            a = 1;\r\n        }\r\n        var data = getData(toRGBA(color));\r\n        data[3] = adjust(Number(a).toFixed(4), [ 0, 1 ]);\r\n\r\n        return toColor(data, 'rgba');\r\n    }\r\n\r\n    // 数组映射\r\n    function map(array, fun) {\r\n        if (typeof fun !== 'function') {\r\n            throw new TypeError();\r\n        }\r\n        var len = array ? array.length : 0;\r\n        for (var i = 0; i < len; i++) {\r\n            array[i] = fun(array[i]);\r\n        }\r\n        return array;\r\n    }\r\n\r\n    // 调整值区间\r\n    function adjust(value, region) {\r\n        // < to <= & > to >=\r\n        // modify by linzhifeng 2014-05-25 because -0 == 0\r\n        if (value <= region[0]) {\r\n            value = region[0];\r\n        }\r\n        else if (value >= region[1]) {\r\n            value = region[1];\r\n        }\r\n        return value;\r\n    }\r\n    \r\n    function isCalculableColor(color) {\r\n        return color instanceof Array || typeof color === 'string';\r\n    }\r\n\r\n    // 参见 http:// www.easyrgb.com/index.php?X=MATH\r\n    function _HSV_2_RGB(data) {\r\n        var H = data[0];\r\n        var S = data[1];\r\n        var V = data[2];\r\n        // HSV from 0 to 1\r\n        var R; \r\n        var G;\r\n        var B;\r\n        if (S === 0) {\r\n            R = V * 255;\r\n            G = V * 255;\r\n            B = V * 255;\r\n        }\r\n        else {\r\n            var h = H * 6;\r\n            if (h === 6) {\r\n                h = 0;\r\n            }\r\n            var i = h | 0;\r\n            var v1 = V * (1 - S);\r\n            var v2 = V * (1 - S * (h - i));\r\n            var v3 = V * (1 - S * (1 - (h - i)));\r\n            var r = 0;\r\n            var g = 0;\r\n            var b = 0;\r\n\r\n            if (i === 0) {\r\n                r = V;\r\n                g = v3;\r\n                b = v1;\r\n            }\r\n            else if (i === 1) {\r\n                r = v2;\r\n                g = V;\r\n                b = v1;\r\n            }\r\n            else if (i === 2) {\r\n                r = v1;\r\n                g = V;\r\n                b = v3;\r\n            }\r\n            else if (i === 3) {\r\n                r = v1;\r\n                g = v2;\r\n                b = V;\r\n            }\r\n            else if (i === 4) {\r\n                r = v3;\r\n                g = v1;\r\n                b = V;\r\n            }\r\n            else {\r\n                r = V;\r\n                g = v1;\r\n                b = v2;\r\n            }\r\n\r\n            // RGB results from 0 to 255\r\n            R = r * 255;\r\n            G = g * 255;\r\n            B = b * 255;\r\n        }\r\n        return [ R, G, B ];\r\n    }\r\n\r\n    function _HSL_2_RGB(data) {\r\n        var H = data[0];\r\n        var S = data[1];\r\n        var L = data[2];\r\n        // HSL from 0 to 1\r\n        var R;\r\n        var G;\r\n        var B;\r\n        if (S === 0) {\r\n            R = L * 255;\r\n            G = L * 255;\r\n            B = L * 255;\r\n        }\r\n        else {\r\n            var v2;\r\n            if (L < 0.5) {\r\n                v2 = L * (1 + S);\r\n            }\r\n            else {\r\n                v2 = (L + S) - (S * L);\r\n            }\r\n\r\n            var v1 = 2 * L - v2;\r\n\r\n            R = 255 * _HUE_2_RGB(v1, v2, H + (1 / 3));\r\n            G = 255 * _HUE_2_RGB(v1, v2, H);\r\n            B = 255 * _HUE_2_RGB(v1, v2, H - (1 / 3));\r\n        }\r\n        return [ R, G, B ];\r\n    }\r\n\r\n    function _HUE_2_RGB(v1, v2, vH) {\r\n        if (vH < 0) {\r\n            vH += 1;\r\n        }\r\n        if (vH > 1) {\r\n            vH -= 1;\r\n        }\r\n        if ((6 * vH) < 1) {\r\n            return (v1 + (v2 - v1) * 6 * vH);\r\n        }\r\n        if ((2 * vH) < 1) {\r\n            return (v2);\r\n        }\r\n        if ((3 * vH) < 2) {\r\n            return (v1 + (v2 - v1) * ((2 / 3) - vH) * 6);\r\n        }\r\n        return v1;\r\n    }\r\n\r\n    function _RGB_2_HSB(data) {\r\n        // RGB from 0 to 255\r\n        var R = (data[0] / 255);\r\n        var G = (data[1] / 255);\r\n        var B = (data[2] / 255);\r\n\r\n        var vMin = Math.min(R, G, B); // Min. value of RGB\r\n        var vMax = Math.max(R, G, B); // Max. value of RGB\r\n        var delta = vMax - vMin; // Delta RGB value\r\n        var V = vMax;\r\n        var H;\r\n        var S;\r\n\r\n        // HSV results from 0 to 1\r\n        if (delta === 0) {\r\n            H = 0;\r\n            S = 0;\r\n        }\r\n        else {\r\n            S = delta / vMax;\r\n\r\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\r\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\r\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\r\n\r\n            if (R === vMax) {\r\n                H = deltaB - deltaG;\r\n            }\r\n            else if (G === vMax) {\r\n                H = (1 / 3) + deltaR - deltaB;\r\n            }\r\n            else if (B === vMax) {\r\n                H = (2 / 3) + deltaG - deltaR;\r\n            }\r\n\r\n            if (H < 0) {\r\n                H += 1;\r\n            }\r\n            if (H > 1) {\r\n                H -= 1;\r\n            }\r\n        }\r\n        H = H * 360;\r\n        S = S * 100;\r\n        V = V * 100;\r\n        return [ H, S, V ];\r\n    }\r\n\r\n    function _RGB_2_HSL(data) {\r\n        // RGB from 0 to 255\r\n        var R = (data[0] / 255);\r\n        var G = (data[1] / 255);\r\n        var B = (data[2] / 255);\r\n\r\n        var vMin = Math.min(R, G, B); // Min. value of RGB\r\n        var vMax = Math.max(R, G, B); // Max. value of RGB\r\n        var delta = vMax - vMin; // Delta RGB value\r\n\r\n        var L = (vMax + vMin) / 2;\r\n        var H;\r\n        var S;\r\n        // HSL results from 0 to 1\r\n        if (delta === 0) {\r\n            H = 0;\r\n            S = 0;\r\n        }\r\n        else {\r\n            if (L < 0.5) {\r\n                S = delta / (vMax + vMin);\r\n            }\r\n            else {\r\n                S = delta / (2 - vMax - vMin);\r\n            }\r\n\r\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\r\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\r\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\r\n\r\n            if (R === vMax) {\r\n                H = deltaB - deltaG;\r\n            }\r\n            else if (G === vMax) {\r\n                H = (1 / 3) + deltaR - deltaB;\r\n            }\r\n            else if (B === vMax) {\r\n                H = (2 / 3) + deltaG - deltaR;\r\n            }\r\n\r\n            if (H < 0) {\r\n                H += 1;\r\n            }\r\n\r\n            if (H > 1) {\r\n                H -= 1;\r\n            }\r\n        }\r\n\r\n        H = H * 360;\r\n        S = S * 100;\r\n        L = L * 100;\r\n\r\n        return [ H, S, L ];\r\n    }\r\n\r\n    return {\r\n        customPalette : customPalette,\r\n        resetPalette : resetPalette,\r\n        getColor : getColor,\r\n        getHighlightColor : getHighlightColor,\r\n        customHighlight : customHighlight,\r\n        resetHighlight : resetHighlight,\r\n        getRadialGradient : getRadialGradient,\r\n        getLinearGradient : getLinearGradient,\r\n        getGradientColors : getGradientColors,\r\n        getStepColors : getStepColors,\r\n        reverse : reverse,\r\n        mix : mix,\r\n        lift : lift,\r\n        trim : trim,\r\n        random : random,\r\n        toRGB : toRGB,\r\n        toRGBA : toRGBA,\r\n        toHex : toHex,\r\n        toHSL : toHSL,\r\n        toHSLA : toHSLA,\r\n        toHSB : toHSB,\r\n        toHSBA : toHSBA,\r\n        toHSV : toHSV,\r\n        toHSVA : toHSVA,\r\n        toName : toName,\r\n        toColor : toColor,\r\n        toArray : toArray,\r\n        alpha : alpha,\r\n        getData : getData\r\n    };\r\n});\r\n\r\n"
        },
        {
          "id": 20,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "index": 20,
          "index2": 19,
          "size": 21602,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../util/shape/Icon",
              "loc": "11:20-49"
            },
            {
              "moduleId": 26,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "type": "cjs require",
              "userRequest": "./Icon",
              "loc": "24:20-37"
            },
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "../util/shape/Icon",
              "loc": "14:20-49"
            },
            {
              "moduleId": 60,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "type": "cjs require",
              "userRequest": "../util/shape/Icon",
              "loc": "14:20-49"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "../util/shape/Icon",
              "loc": "13:20-49"
            }
          ],
          "source": "/**\r\n * echarts扩展zrender shape\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * shape类：icon\r\n * 可配图形属性：\r\n   {\r\n       // 基础属性\r\n       shape  : 'icon',       // 必须，shape类标识，需要显式指定\r\n       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成\r\n       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中\r\n       invisible : {boolean},   // 默认为false，是否可见\r\n\r\n       // 样式属性，默认状态样式样式属性\r\n       style  : {\r\n           x             : {number},  // 必须，左上角横坐标\r\n           y             : {number},  // 必须，左上角纵坐标\r\n           width         : {number},  // 必须，宽度\r\n           height        : {number},  // 必须，高度\r\n           iconType      : {string},  // 必须，icon类型\r\n       },\r\n\r\n       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示\r\n       highlightStyle : {\r\n           // 同style\r\n       }\r\n\r\n       // 交互属性，详见shape.Base\r\n\r\n       // 事件属性，详见shape.Base\r\n   }\r\n */\r\ndefine(function (require) {\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    \r\n    function _iconMark(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n        ctx.moveTo(x,                 y + style.height);\r\n        ctx.lineTo(x + 5 * dx,        y + 14 * dy);\r\n        ctx.lineTo(x + style.width,   y + 3 * dy);\r\n        ctx.lineTo(x + 13 * dx,       y);\r\n        ctx.lineTo(x + 2 * dx,        y + 11 * dy);\r\n        ctx.lineTo(x,                 y + style.height);\r\n\r\n        ctx.moveTo(x + 6 * dx,        y + 10 * dy);\r\n        ctx.lineTo(x + 14 * dx,       y + 2 * dy);\r\n\r\n        ctx.moveTo(x + 10 * dx,       y + 13 * dy);\r\n        ctx.lineTo(x + style.width,   y + 13 * dy);\r\n\r\n        ctx.moveTo(x + 13 * dx,       y + 10 * dy);\r\n        ctx.lineTo(x + 13 * dx,       y + style.height);\r\n    }\r\n\r\n    function _iconMarkUndo(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n        ctx.moveTo(x,                 y + style.height);\r\n        ctx.lineTo(x + 5 * dx,        y + 14 * dy);\r\n        ctx.lineTo(x + style.width,   y + 3 * dy);\r\n        ctx.lineTo(x + 13 * dx,       y);\r\n        ctx.lineTo(x + 2 * dx,        y + 11 * dy);\r\n        ctx.lineTo(x,                 y + style.height);\r\n\r\n        ctx.moveTo(x + 6 * dx,        y + 10 * dy);\r\n        ctx.lineTo(x + 14 * dx,       y + 2 * dy);\r\n\r\n        ctx.moveTo(x + 10 * dx,       y + 13 * dy);\r\n        ctx.lineTo(x + style.width,   y + 13 * dy);\r\n    }\r\n\r\n    function _iconMarkClear(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x + 4 * dx,        y + 15 * dy);\r\n        ctx.lineTo(x + 9 * dx,        y + 13 * dy);\r\n        ctx.lineTo(x + 14 * dx,       y + 8 * dy);\r\n        ctx.lineTo(x + 11 * dx,       y + 5 * dy);\r\n        ctx.lineTo(x + 6 * dx,        y + 10 * dy);\r\n        ctx.lineTo(x + 4 * dx,        y + 15 * dy);\r\n\r\n        ctx.moveTo(x + 5 * dx,        y);\r\n        ctx.lineTo(x + 11 * dx,       y);\r\n        ctx.moveTo(x + 5 * dx,        y + dy);\r\n        ctx.lineTo(x + 11 * dx,       y + dy);\r\n        ctx.moveTo(x,                 y + 2 * dy);\r\n        ctx.lineTo(x + style.width,   y + 2 * dy);\r\n\r\n        ctx.moveTo(x,                 y + 5 * dy);\r\n        ctx.lineTo(x + 3 * dx,        y + style.height);\r\n        ctx.lineTo(x + 13 * dx,       y + style.height);\r\n        ctx.lineTo(x + style.width,   y + 5 * dy);\r\n    }\r\n\r\n    function _iconDataZoom(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x,               y + 3 * dy);\r\n        ctx.lineTo(x + 6 * dx,      y + 3 * dy);\r\n        \r\n        ctx.moveTo(x + 3 * dx,      y);\r\n        ctx.lineTo(x + 3 * dx,      y + 6 * dy);\r\n\r\n        ctx.moveTo(x + 3 * dx,      y + 8 * dy);\r\n        ctx.lineTo(x + 3 * dx,      y + style.height);\r\n        ctx.lineTo(x + style.width, y + style.height);\r\n        ctx.lineTo(x + style.width, y + 3 * dy);\r\n        ctx.lineTo(x + 8 * dx,      y + 3 * dy);\r\n    }\r\n    \r\n    function _iconDataZoomReset(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x + 6 * dx,      y);\r\n        ctx.lineTo(x + 2 * dx,      y + 3 * dy);\r\n        ctx.lineTo(x + 6 * dx,      y + 6 * dy);\r\n        \r\n        ctx.moveTo(x + 2 * dx,      y + 3 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 3 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 11 * dy);\r\n        \r\n        ctx.moveTo(x + 2 * dx,      y + 5 * dy);\r\n        ctx.lineTo(x + 2 * dx,      y + 13 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 13 * dy);\r\n        \r\n        ctx.moveTo(x + 10 * dx,     y + 10 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 13 * dy);\r\n        ctx.lineTo(x + 10 * dx,     y + style.height);\r\n    }\r\n    \r\n    function _iconRestore(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n        var r = style.width / 2;\r\n        \r\n        ctx.lineWidth = 1.5;\r\n\r\n        ctx.arc(x + r, y + r, r - dx, 0, Math.PI * 2 / 3);\r\n        ctx.moveTo(x + 3 * dx,        y + style.height);\r\n        ctx.lineTo(x + 0 * dx,        y + 12 * dy);\r\n        ctx.lineTo(x + 5 * dx,        y + 11 * dy);\r\n\r\n        ctx.moveTo(x, y + 8 * dy);\r\n        ctx.arc(x + r, y + r, r - dx, Math.PI, Math.PI * 5 / 3);\r\n        ctx.moveTo(x + 13 * dx,       y);\r\n        ctx.lineTo(x + style.width,   y + 4 * dy);\r\n        ctx.lineTo(x + 11 * dx,       y + 5 * dy);\r\n    }\r\n\r\n    function _iconLineChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x, y + style.height);\r\n        ctx.lineTo(x + style.width, y + style.height);\r\n\r\n        ctx.moveTo(x + 2 * dx,    y + 14 * dy);\r\n        ctx.lineTo(x + 7 * dx,    y + 6 * dy);\r\n        ctx.lineTo(x + 11 * dx,   y + 11 * dy);\r\n        ctx.lineTo(x + 15 * dx,   y + 2 * dy);\r\n    }\r\n\r\n    function _iconBarChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x, y + style.height);\r\n        ctx.lineTo(x + style.width, y + style.height);\r\n\r\n        ctx.moveTo(x + 3 * dx,        y + 14 * dy);\r\n        ctx.lineTo(x + 3 * dx,        y + 6 * dy);\r\n        ctx.lineTo(x + 4 * dx,        y + 6 * dy);\r\n        ctx.lineTo(x + 4 * dx,        y + 14 * dy);\r\n        ctx.moveTo(x + 7 * dx,        y + 14 * dy);\r\n        ctx.lineTo(x + 7 * dx,        y + 2 * dy);\r\n        ctx.lineTo(x + 8 * dx,        y + 2 * dy);\r\n        ctx.lineTo(x + 8 * dx,        y + 14 * dy);\r\n        ctx.moveTo(x + 11 * dx,       y + 14 * dy);\r\n        ctx.lineTo(x + 11 * dx,       y + 9 * dy);\r\n        ctx.lineTo(x + 12 * dx,       y + 9 * dy);\r\n        ctx.lineTo(x + 12 * dx,       y + 14 * dy);\r\n    }\r\n    \r\n    function _iconPieChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width - 2;\r\n        var height = style.height - 2;\r\n        var r = Math.min(width, height) / 2;\r\n        y += 2;\r\n        ctx.moveTo(x + r + 3, y + r - 3);\r\n        ctx.arc(x + r + 3, y + r - 3, r - 1, 0, -Math.PI / 2, true);\r\n        ctx.lineTo(x + r + 3, y + r - 3);\r\n      \r\n        ctx.moveTo(x + r, y);\r\n        ctx.lineTo(x + r, y + r);\r\n        ctx.arc(x + r, y + r, r, -Math.PI / 2, Math.PI * 2, true);\r\n        ctx.lineTo(x + r, y + r);\r\n        ctx.lineWidth = 1.5;\r\n    }\r\n    \r\n    function _iconFunnelChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n        y -= dy;\r\n        ctx.moveTo(x + 1 * dx,      y + 2 * dy);\r\n        ctx.lineTo(x + 15 * dx,     y + 2 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 3 * dy);\r\n        ctx.lineTo(x + 2 * dx,      y + 3 * dy);\r\n        \r\n        ctx.moveTo(x + 3 * dx,      y + 6 * dy);\r\n        ctx.lineTo(x + 13 * dx,     y + 6 * dy);\r\n        ctx.lineTo(x + 12 * dx,     y + 7 * dy);\r\n        ctx.lineTo(x + 4 * dx,      y + 7 * dy);\r\n        \r\n        ctx.moveTo(x + 5 * dx,      y + 10 * dy);\r\n        ctx.lineTo(x + 11 * dx,      y + 10 * dy);\r\n        ctx.lineTo(x + 10 * dx,      y + 11 * dy);\r\n        ctx.lineTo(x + 6 * dx,      y + 11 * dy);\r\n        \r\n        ctx.moveTo(x + 7 * dx,      y + 14 * dy);\r\n        ctx.lineTo(x + 9 * dx,      y + 14 * dy);\r\n        ctx.lineTo(x + 8 * dx,      y + 15 * dy);\r\n        ctx.lineTo(x + 7 * dx,      y + 15 * dy);\r\n    }\r\n    \r\n    function _iconForceChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        var dx = width / 16;\r\n        var dy = height / 16;\r\n        var r = Math.min(dx, dy) * 2;\r\n\r\n        ctx.moveTo(x + dx + r, y + dy + r);\r\n        ctx.arc(x + dx, y + dy, r, Math.PI / 4, Math.PI * 3);\r\n        \r\n        ctx.lineTo(x + 7 * dx - r, y + 6 * dy - r);\r\n        ctx.arc(x + 7 * dx, y + 6 * dy, r, Math.PI / 4 * 5, Math.PI * 4);\r\n        ctx.arc(x + 7 * dx, y + 6 * dy, r / 2, Math.PI / 4 * 5, Math.PI * 4);\r\n        \r\n        ctx.moveTo(x + 7 * dx - r / 2, y + 6 * dy + r);\r\n        ctx.lineTo(x + dx + r, y + 14 * dy - r);\r\n        ctx.arc(x + dx, y + 14 * dy, r, -Math.PI / 4, Math.PI * 2);\r\n        \r\n        ctx.moveTo(x + 7 * dx + r / 2, y + 6 * dy);\r\n        ctx.lineTo(x + 14 * dx - r, y + 10 * dy - r / 2);\r\n        ctx.moveTo(x + 16 * dx, y + 10 * dy);\r\n        ctx.arc(x + 14 * dx, y + 10 * dy, r, 0, Math.PI * 3);\r\n        ctx.lineWidth = 1.5;\r\n    }\r\n    \r\n    function _iconChordChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        var r = Math.min(width, height) / 2;\r\n\r\n        ctx.moveTo(x + width, y + height / 2);\r\n        ctx.arc(x + r, y + r, r, 0, Math.PI * 2);\r\n        \r\n        ctx.arc(x + r, y, r, Math.PI / 4, Math.PI / 5 * 4);\r\n        ctx.arc(x, y + r, r, -Math.PI / 3, Math.PI / 3);\r\n        ctx.arc(x + width, y + height, r, Math.PI, Math.PI / 2 * 3);\r\n        ctx.lineWidth = 1.5;\r\n    }\r\n\r\n    function _iconStackChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        var dy = Math.round(height / 3);\r\n        var delta = Math.round((dy - 2) / 2);\r\n        var len = 3;\r\n        while (len--) {\r\n            ctx.rect(x, y + dy * len + delta, width, 2);\r\n        }\r\n    }\r\n    \r\n    function _iconTiledChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        var dx = Math.round(width / 3);\r\n        var delta = Math.round((dx - 2) / 2);\r\n        var len = 3;\r\n        while (len--) {\r\n            ctx.rect(x + dx * len + delta, y, 2, height);\r\n        }\r\n    }\r\n    \r\n    function _iconDataView(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n\r\n        ctx.moveTo(x + dx, y);\r\n        ctx.lineTo(x + dx, y + style.height);\r\n        ctx.lineTo(x + 15 * dx, y + style.height);\r\n        ctx.lineTo(x + 15 * dx, y);\r\n        ctx.lineTo(x + dx, y);\r\n\r\n        ctx.moveTo(x + 3 * dx, y + 3 * dx);\r\n        ctx.lineTo(x + 13 * dx, y + 3 * dx);\r\n\r\n        ctx.moveTo(x + 3 * dx, y + 6 * dx);\r\n        ctx.lineTo(x + 13 * dx, y + 6 * dx);\r\n\r\n        ctx.moveTo(x + 3 * dx, y + 9 * dx);\r\n        ctx.lineTo(x + 13 * dx, y + 9 * dx);\r\n\r\n        ctx.moveTo(x + 3 * dx, y + 12 * dx);\r\n        ctx.lineTo(x + 9 * dx, y + 12 * dx);\r\n    }\r\n    \r\n    function _iconSave(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x, y + style.height);\r\n        ctx.lineTo(x + style.width, y + style.height);\r\n        ctx.lineTo(x + style.width, y);\r\n        ctx.lineTo(x, y);\r\n\r\n        ctx.moveTo(x + 4 * dx,    y);\r\n        ctx.lineTo(x + 4 * dx,    y + 8 * dy);\r\n        ctx.lineTo(x + 12 * dx,   y + 8 * dy);\r\n        ctx.lineTo(x + 12 * dx,   y);\r\n        \r\n        ctx.moveTo(x + 6 * dx,    y + 11 * dy);\r\n        ctx.lineTo(x + 6 * dx,    y + 13 * dy);\r\n        ctx.lineTo(x + 10 * dx,   y + 13 * dy);\r\n        ctx.lineTo(x + 10 * dx,   y + 11 * dy);\r\n        ctx.lineTo(x + 6 * dx,    y + 11 * dy);\r\n    }\r\n    \r\n    function _iconCross(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        ctx.moveTo(x, y + height / 2);\r\n        ctx.lineTo(x + width, y + height / 2);\r\n        \r\n        ctx.moveTo(x + width / 2, y);\r\n        ctx.lineTo(x + width / 2, y + height);\r\n    }\r\n    \r\n    function _iconCircle(ctx, style) {\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        var r = Math.min(width, height);\r\n        ctx.moveTo(\r\n            style.x + width + r, \r\n            style.y + height\r\n        );\r\n        ctx.arc(\r\n            style.x + width, \r\n            style.y + height, \r\n            r,\r\n            0, \r\n            Math.PI * 2\r\n        );\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconRectangle(ctx, style) {\r\n        ctx.rect(style.x, style.y, style.width, style.height);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconTriangle(ctx, style) {\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        var x = style.x + width;\r\n        var y = style.y + height;\r\n        var symbolSize = Math.min(width, height);\r\n        ctx.moveTo(x, y - symbolSize);\r\n        ctx.lineTo(x + symbolSize, y + symbolSize);\r\n        ctx.lineTo(x - symbolSize, y + symbolSize);\r\n        ctx.lineTo(x, y - symbolSize);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconDiamond(ctx, style) {\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        var x = style.x + width;\r\n        var y = style.y + height;\r\n        var symbolSize = Math.min(width, height);\r\n        ctx.moveTo(x, y - symbolSize);\r\n        ctx.lineTo(x + symbolSize, y);\r\n        ctx.lineTo(x, y + symbolSize);\r\n        ctx.lineTo(x - symbolSize, y);\r\n        ctx.lineTo(x, y - symbolSize);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconArrow(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        ctx.moveTo(x + 8 * dx,  y);\r\n        ctx.lineTo(x + dx,      y + style.height);\r\n        ctx.lineTo(x + 8 * dx,  y + style.height / 4 * 3);\r\n        ctx.lineTo(x + 15 * dx, y + style.height);\r\n        ctx.lineTo(x + 8 * dx,  y);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconStar(ctx, style) {\r\n        var StarShape = require('zrenderjs/shape/Star');\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        StarShape.prototype.buildPath(ctx, {\r\n            x : style.x + width,\r\n            y : style.y + height,\r\n            r : Math.min(width, height),\r\n            n : style.n || 5\r\n        });\r\n    }\r\n    \r\n    function _iconHeart(ctx, style) {\r\n        var HeartShape = require('zrenderjs/shape/Heart');\r\n        HeartShape.prototype.buildPath(ctx, {\r\n            x : style.x + style.width / 2,\r\n            y : style.y + style.height * 0.2,\r\n            a : style.width / 2,\r\n            b : style.height * 0.8\r\n        });\r\n    }\r\n    \r\n    function _iconDroplet(ctx, style) {\r\n        var DropletShape = require('zrenderjs/shape/Droplet');\r\n        DropletShape.prototype.buildPath(ctx, {\r\n            x : style.x + style.width * 0.5,\r\n            y : style.y + style.height * 0.5,\r\n            a : style.width * 0.5,\r\n            b : style.height * 0.8\r\n        });\r\n    }\r\n    \r\n    function _iconPin(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y - style.height / 2 * 1.5;\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        var r = Math.min(width, height);\r\n        ctx.arc(\r\n            x + width, \r\n            y + height, \r\n            r,\r\n            Math.PI / 5 * 4, \r\n            Math.PI / 5\r\n        );\r\n        ctx.lineTo(x + width, y + height + r * 1.5);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconImage(ctx, style, refreshNextFrame) {\r\n        var ImageShape = require('zrenderjs/shape/Image');\r\n        this._imageShape = this._imageShape || new ImageShape({\r\n            style: {}\r\n        });\r\n        for (var name in style) {\r\n            this._imageShape.style[name] = style[name];\r\n        }\r\n        this._imageShape.brush(ctx, false, refreshNextFrame);\r\n    }\r\n    \r\n    var Base = require('zrenderjs/shape/Base');\r\n    \r\n    function Icon(options) {\r\n        Base.call(this, options);\r\n    }\r\n\r\n    Icon.prototype =  {\r\n        type : 'icon',\r\n        iconLibrary : {\r\n            mark : _iconMark,\r\n            markUndo : _iconMarkUndo,\r\n            markClear : _iconMarkClear,\r\n            dataZoom : _iconDataZoom,\r\n            dataZoomReset : _iconDataZoomReset,\r\n            restore : _iconRestore,\r\n            lineChart : _iconLineChart,\r\n            barChart : _iconBarChart,\r\n            pieChart : _iconPieChart,\r\n            funnelChart : _iconFunnelChart,\r\n            forceChart : _iconForceChart,\r\n            chordChart : _iconChordChart,\r\n            stackChart : _iconStackChart,\r\n            tiledChart : _iconTiledChart,\r\n            dataView : _iconDataView,\r\n            saveAsImage : _iconSave,\r\n            \r\n            cross : _iconCross,\r\n            circle : _iconCircle,\r\n            rectangle : _iconRectangle,\r\n            triangle : _iconTriangle,\r\n            diamond : _iconDiamond,\r\n            arrow : _iconArrow,\r\n            star : _iconStar,\r\n            heart : _iconHeart,\r\n            droplet : _iconDroplet,\r\n            pin : _iconPin,\r\n            image : _iconImage\r\n        },\r\n        brush: function (ctx, isHighlight, refreshNextFrame) {\r\n            var style = isHighlight ? this.highlightStyle : this.style;\r\n            style = style || {};\r\n            var iconType = style.iconType || this.style.iconType;\r\n            if (iconType === 'image') {\r\n                var ImageShape = require('zrenderjs/shape/Image');\r\n                ImageShape.prototype.brush.call(this, ctx, isHighlight, refreshNextFrame);\r\n\r\n            } else {\r\n\r\n                var style = this.beforeBrush(ctx, isHighlight);\r\n\r\n                ctx.beginPath();\r\n                this.buildPath(ctx, style, refreshNextFrame);\r\n\r\n                switch (style.brushType) {\r\n                    /* jshint ignore:start */\r\n                    case 'both':\r\n                        ctx.fill();\r\n                    case 'stroke':\r\n                        style.lineWidth > 0 && ctx.stroke();\r\n                        break;\r\n                    /* jshint ignore:end */\r\n                    default:\r\n                        ctx.fill();\r\n                }\r\n                \r\n                this.drawText(ctx, style, this.style);\r\n\r\n                this.afterBrush(ctx);\r\n            }\r\n        },\r\n        /**\r\n         * 创建矩形路径\r\n         * @param {Context2D} ctx Canvas 2D上下文\r\n         * @param {Object} style 样式\r\n         */\r\n        buildPath : function (ctx, style, refreshNextFrame) {\r\n            if (this.iconLibrary[style.iconType]) {\r\n                this.iconLibrary[style.iconType].call(this, ctx, style, refreshNextFrame);\r\n            }\r\n            else {\r\n                ctx.moveTo(style.x, style.y);\r\n                ctx.lineTo(style.x + style.width, style.y);\r\n                ctx.lineTo(style.x + style.width, style.y + style.height);\r\n                ctx.lineTo(style.x, style.y + style.height);\r\n                ctx.lineTo(style.x, style.y);\r\n                ctx.closePath();\r\n            }\r\n\r\n            return;\r\n        },\r\n\r\n        /**\r\n         * 返回矩形区域，用于局部刷新和文字定位\r\n         * @param {Object} style\r\n         */\r\n        getRect : function (style) {\r\n            if (style.__rect) {\r\n                return style.__rect;\r\n            }\r\n            \r\n            // pin比较特殊，让尖端在目标x,y上\r\n            style.__rect = {\r\n                x : Math.round(style.x),\r\n                y : Math.round(style.y - (style.iconType == 'pin' \r\n                                         ? (style.height / 2 * 1.5) : 0)\r\n                               ),\r\n                width : style.width,\r\n                height : style.height * (\r\n                    style.iconType === 'pin' ? 1.25 : 1\r\n                )\r\n            };\r\n            \r\n            return style.__rect;\r\n        },\r\n\r\n        isCover : function (x, y) {\r\n            var originPos = this.transformCoordToLocal(x, y);\r\n            x = originPos[0];\r\n            y = originPos[1];\r\n\r\n            // 快速预判并保留判断矩形\r\n            var rect = this.style.__rect;\r\n            if (!rect) {\r\n                rect = this.style.__rect = this.getRect(this.style);\r\n            }\r\n            // 提高交互体验，太小的图形包围盒四向扩大4px\r\n            var delta = (rect.height < 8 || rect.width < 8 ) ? 4 : 0;\r\n            return x >= rect.x - delta\r\n                && x <= (rect.x + rect.width + delta)\r\n                && y >= rect.y - delta\r\n                && y <= (rect.y + rect.height + delta);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(Icon, Base);\r\n    \r\n    return Icon;\r\n});"
        },
        {
          "id": 21,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
          "index": 21,
          "index2": 15,
          "size": 5537,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 20,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Star",
              "loc": "444:24-55"
            }
          ],
          "source": "/**\r\n * n角星（n>3）\r\n * @module zrender/shape/Star\r\n * @author sushuang (宿爽, sushuang0322@gmail.com)\r\n * @example\r\n *     var Star = require('zrender/shape/Star');\r\n *     var shape = new Star({\r\n *         style: {\r\n *             x: 200,\r\n *             y: 100,\r\n *             r: 150,\r\n *             n: 5,\r\n *             text: '五角星'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IStarStyle\r\n * @property {number} x n角星外接圆心x坐标\r\n * @property {number} y n角星外接圆心y坐标\r\n * @property {number} r n角星外接圆半径\r\n * @property {number} [r0] n角星内部顶点（凹点）的外接圆半径。\r\n *                         如果不指定此参数，则自动计算：取相隔外部顶点连线的交点作内部顶点。\r\n * @property {number} n 指明几角星\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\n\r\ndefine(\r\n    function (require) {\r\n\r\n        var math = require('../tool/math');\r\n        var sin = math.sin;\r\n        var cos = math.cos;\r\n        var PI = Math.PI;\r\n\r\n        var Base = require('./Base');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Star\r\n         * @param {Object} options\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         */\r\n        var Star = function(options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * n角星绘制样式\r\n             * @name module:zrender/shape/Star#style\r\n             * @type {module:zrender/shape/Star~IStarStyle}\r\n             */\r\n            /**\r\n             * n角星高亮绘制样式\r\n             * @name module:zrender/shape/Star#highlightStyle\r\n             * @type {module:zrender/shape/Star~IStarStyle}\r\n             */\r\n        };\r\n\r\n        Star.prototype = {\r\n            type: 'star',\r\n\r\n            /**\r\n             * 创建n角星（n>3）路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Star~IStarStyle} style\r\n             */\r\n            buildPath : function(ctx, style) {\r\n                var n = style.n;\r\n                if (!n || n < 2) {\r\n                    return;\r\n                }\r\n\r\n                var x = style.x;\r\n                var y = style.y;\r\n                var r = style.r;\r\n                var r0 = style.r0;\r\n\r\n                // 如果未指定内部顶点外接圆半径，则自动计算\r\n                if (r0 == null) {\r\n                    r0 = n > 4\r\n                        // 相隔的外部顶点的连线的交点，\r\n                        // 被取为内部交点，以此计算r0\r\n                        ? r * cos(2 * PI / n) / cos(PI / n)\r\n                        // 二三四角星的特殊处理\r\n                        : r / 3;\r\n                }\r\n\r\n                var dStep = PI / n;\r\n                var deg = -PI / 2;\r\n                var xStart = x + r * cos(deg);\r\n                var yStart = y + r * sin(deg);\r\n                deg += dStep;\r\n\r\n                // 记录边界点，用于判断inside\r\n                var pointList = style.pointList = [];\r\n                pointList.push([ xStart, yStart ]);\r\n                for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {\r\n                    ri = i % 2 === 0 ? r0 : r;\r\n                    pointList.push([ x + ri * cos(deg), y + ri * sin(deg) ]);\r\n                    deg += dStep;\r\n                }\r\n                pointList.push([ xStart, yStart ]);\r\n\r\n                // 绘制\r\n                ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                for (var i = 0; i < pointList.length; i++) {\r\n                    ctx.lineTo(pointList[i][0], pointList[i][1]);\r\n                }\r\n                \r\n                ctx.closePath();\r\n\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 返回n角星包围盒矩形\r\n             * @param {module:zrender/shape/Star~IStarStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function(style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var lineWidth;\r\n                if (style.brushType == 'stroke' || style.brushType == 'fill') {\r\n                    lineWidth = style.lineWidth || 1;\r\n                }\r\n                else {\r\n                    lineWidth = 0;\r\n                }\r\n                style.__rect = {\r\n                    x : Math.round(style.x - style.r - lineWidth / 2),\r\n                    y : Math.round(style.y - style.r - lineWidth / 2),\r\n                    width : style.r * 2 + lineWidth,\r\n                    height : style.r * 2 + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Star, Base);\r\n        return Star;\r\n    }\r\n);\r\n"
        },
        {
          "id": 22,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\math.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/math.js",
          "index": 22,
          "index2": 14,
          "size": 1301,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 21,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
              "type": "cjs require",
              "userRequest": "../tool/math",
              "loc": "50:19-42"
            }
          ],
          "source": "/**\r\n * zrender: 数学辅助类\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * sin：正弦函数\r\n * cos：余弦函数\r\n * degreeToRadian：角度转弧度\r\n * radianToDegree：弧度转角度\r\n */\r\ndefine(\r\n    function () {\r\n\r\n        var _radians = Math.PI / 180;\r\n\r\n        /**\r\n         * @param {number} angle 弧度（角度）参数\r\n         * @param {boolean} isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度\r\n         */\r\n        function sin(angle, isDegrees) {\r\n            return Math.sin(isDegrees ? angle * _radians : angle);\r\n        }\r\n\r\n        /**\r\n         * @param {number} angle 弧度（角度）参数\r\n         * @param {boolean} isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度\r\n         */\r\n        function cos(angle, isDegrees) {\r\n            return Math.cos(isDegrees ? angle * _radians : angle);\r\n        }\r\n\r\n        /**\r\n         * 角度转弧度\r\n         * @param {Object} angle\r\n         */\r\n        function degreeToRadian(angle) {\r\n            return angle * _radians;\r\n        }\r\n\r\n        /**\r\n         * 弧度转角度\r\n         * @param {Object} angle\r\n         */\r\n        function radianToDegree(angle) {\r\n            return angle / _radians;\r\n        }\r\n\r\n        return {\r\n            sin : sin,\r\n            cos : cos,\r\n            degreeToRadian : degreeToRadian,\r\n            radianToDegree : radianToDegree\r\n        };\r\n    }\r\n);\r\n"
        },
        {
          "id": 23,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
          "index": 23,
          "index2": 17,
          "size": 4841,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 20,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Heart",
              "loc": "456:25-57"
            }
          ],
          "source": "/**\r\n * @module zrender/shape/Heart\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *   var Heart = require('zrender/shape/Heart');\r\n *   var shape = new Heart({\r\n *       style: {\r\n *           x: 100,\r\n *           y: 100,\r\n *           a: 40,\r\n *           b: 40,\r\n *           brushType: 'both',\r\n *           color: 'blue',\r\n *           strokeColor: 'red',\r\n *           lineWidth: 3,\r\n *           text: 'Heart'\r\n *       }    \r\n *   });\r\n *   zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IHeartStyle\r\n * @property {number} x 心形内部尖端横坐标\r\n * @property {number} y 心形内部尖端纵坐标\r\n * @property {number} a 心形横宽（中轴线到水平边缘最宽处距离）\r\n * @property {number} b 心形纵高（内尖到外尖距离）\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        'use strict';\r\n        \r\n        var Base = require('./Base');\r\n        var PathProxy = require('./util/PathProxy');\r\n        var area = require('../tool/area');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/Heart\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Heart = function (options) {\r\n            Base.call(this, options);\r\n\r\n            this._pathProxy = new PathProxy();\r\n            /**\r\n             * 心形绘制样式\r\n             * @name module:zrender/shape/Heart#style\r\n             * @type {module:zrender/shape/Heart~IHeartStyle}\r\n             */\r\n            /**\r\n             * 心形高亮绘制样式\r\n             * @name module:zrender/shape/Heart#highlightStyle\r\n             * @type {module:zrender/shape/Heart~IHeartStyle}\r\n             */\r\n        };\r\n\r\n        Heart.prototype = {\r\n            type: 'heart',\r\n\r\n            /**\r\n             * 创建扇形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Heart~IHeartStyle} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                var path = this._pathProxy || new PathProxy();\r\n                path.begin(ctx);\r\n\r\n                path.moveTo(style.x, style.y);\r\n                path.bezierCurveTo(\r\n                    style.x + style.a / 2,\r\n                    style.y - style.b * 2 / 3,\r\n                    style.x + style.a * 2,\r\n                    style.y + style.b / 3,\r\n                    style.x,\r\n                    style.y + style.b\r\n                );\r\n                path.bezierCurveTo(\r\n                    style.x - style.a *  2,\r\n                    style.y + style.b / 3,\r\n                    style.x - style.a / 2,\r\n                    style.y - style.b * 2 / 3,\r\n                    style.x,\r\n                    style.y\r\n                );\r\n                path.closePath();\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 计算返回心形的包围盒矩形\r\n             * @param {module:zrender/shape/Heart~IHeartStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                if (!this._pathProxy.isEmpty()) {\r\n                    this.buildPath(null, style);\r\n                }\r\n                return this._pathProxy.fastBoundingRect();\r\n            },\r\n\r\n            isCover: function (x, y) {\r\n                var originPos = this.transformCoordToLocal(x, y);\r\n                x = originPos[0];\r\n                y = originPos[1];\r\n                \r\n                if (this.isCoverRect(x, y)) {\r\n                    return area.isInsidePath(\r\n                        this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y\r\n                    );\r\n                }\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Heart, Base);\r\n        return Heart;\r\n    }\r\n);\r\n"
        },
        {
          "id": 24,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\PathProxy.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/PathProxy.js",
          "index": 24,
          "index2": 16,
          "size": 7660,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 23,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
              "type": "cjs require",
              "userRequest": "./util/PathProxy",
              "loc": "52:24-51"
            },
            {
              "moduleId": 25,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
              "type": "cjs require",
              "userRequest": "./util/PathProxy",
              "loc": "53:24-51"
            }
          ],
          "source": "/**\r\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\r\n * 可以用于 isInsidePath 判断以及获取boundingRect\r\n * \r\n * @module zrender/shape/tool/PathProxy\r\n * @author pissang (http://www.github.com/pissang)\r\n * \r\n * @example\r\n *     var SomeShape = function() {\r\n *         this._pathProxy = new PathProxy();\r\n *         ...\r\n *     }\r\n *     SomeShape.prototype.buildPath = function(ctx, style) {\r\n *         this._pathProxy.begin(ctx);\r\n *             .moveTo(style.x, style.y);\r\n *             .lineTo(style.x1, style.y1);\r\n *         ...\r\n *             .closePath();\r\n *     },\r\n *     SomeShape.prototype.getRect = function(style) {\r\n *         if (!style._rect) {\r\n *             // 这里必须要在 buildPath 之后才能调用\r\n *             style._rect = this._pathProxy.fastBoundingRect();\r\n *         }\r\n *         return this.style._rect;\r\n *     },\r\n *     SomeShape.prototype.isCover = function(x, y) {\r\n *         var rect = this.getRect(this.style);\r\n *         if (x >= rect.x\r\n *             && x <= (rect.x + rect.width)\r\n *             && y >= rect.y\r\n *             && y <= (rect.y + rect.height)\r\n *         ) {\r\n *             return area.isInsidePath(\r\n *                 this._pathProxy.pathCommands, 0, 'fill', x, y\r\n *             );\r\n *         }\r\n *     }\r\n */\r\ndefine(function (require) {\r\n    \r\n    var vector = require('../../tool/vector');\r\n    // var computeBoundingBox = require('../../tool/computeBoundingBox');\r\n\r\n    var PathSegment = function(command, points) {\r\n        this.command = command;\r\n        this.points = points || null;\r\n    };\r\n\r\n    /**\r\n     * @alias module:zrender/shape/tool/PathProxy\r\n     * @constructor\r\n     */\r\n    var PathProxy = function () {\r\n\r\n        /**\r\n         * Path描述的数组，用于`isInsidePath`的判断\r\n         * @type {Array.<Object>}\r\n         */\r\n        this.pathCommands = [];\r\n\r\n        this._ctx = null;\r\n\r\n        this._min = [];\r\n        this._max = [];\r\n    };\r\n\r\n    /**\r\n     * 快速计算Path包围盒（并不是最小包围盒）\r\n     * @return {Object}\r\n     */\r\n    PathProxy.prototype.fastBoundingRect = function () {\r\n        var min = this._min;\r\n        var max = this._max;\r\n        min[0] = min[1] = Infinity;\r\n        max[0] = max[1] = -Infinity;\r\n        for (var i = 0; i < this.pathCommands.length; i++) {\r\n            var seg = this.pathCommands[i];\r\n            var p = seg.points;\r\n            switch (seg.command) {\r\n                case 'M':\r\n                    vector.min(min, min, p);\r\n                    vector.max(max, max, p);\r\n                    break;\r\n                case 'L':\r\n                    vector.min(min, min, p);\r\n                    vector.max(max, max, p);\r\n                    break;\r\n                case 'C':\r\n                    for (var j = 0; j < 6; j += 2) {\r\n                        min[0] = Math.min(min[0], min[0], p[j]);\r\n                        min[1] = Math.min(min[1], min[1], p[j + 1]);\r\n                        max[0] = Math.max(max[0], max[0], p[j]);\r\n                        max[1] = Math.max(max[1], max[1], p[j + 1]);\r\n                    }\r\n                    break;\r\n                case 'Q':\r\n                    for (var j = 0; j < 4; j += 2) {\r\n                        min[0] = Math.min(min[0], min[0], p[j]);\r\n                        min[1] = Math.min(min[1], min[1], p[j + 1]);\r\n                        max[0] = Math.max(max[0], max[0], p[j]);\r\n                        max[1] = Math.max(max[1], max[1], p[j + 1]);\r\n                    }\r\n                    break;\r\n                case 'A':\r\n                    var cx = p[0];\r\n                    var cy = p[1];\r\n                    var rx = p[2];\r\n                    var ry = p[3];\r\n                    min[0] = Math.min(min[0], min[0], cx - rx);\r\n                    min[1] = Math.min(min[1], min[1], cy - ry);\r\n                    max[0] = Math.max(max[0], max[0], cx + rx);\r\n                    max[1] = Math.max(max[1], max[1], cy + ry);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return {\r\n            x: min[0],\r\n            y: min[1],\r\n            width: max[0] - min[0],\r\n            height: max[1] - min[1]\r\n        };\r\n    };\r\n\r\n    /**\r\n     * @param  {CanvasRenderingContext2D} ctx\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.begin = function (ctx) {\r\n        this._ctx = ctx || null;\r\n        // 清空pathCommands\r\n        this.pathCommands.length = 0;\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} x\r\n     * @param  {number} y\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.moveTo = function (x, y) {\r\n        this.pathCommands.push(new PathSegment('M', [x, y]));\r\n        if (this._ctx) {\r\n            this._ctx.moveTo(x, y);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} x\r\n     * @param  {number} y\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.lineTo = function (x, y) {\r\n        this.pathCommands.push(new PathSegment('L', [x, y]));\r\n        if (this._ctx) {\r\n            this._ctx.lineTo(x, y);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} x1\r\n     * @param  {number} y1\r\n     * @param  {number} x2\r\n     * @param  {number} y2\r\n     * @param  {number} x3\r\n     * @param  {number} y3\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {\r\n        this.pathCommands.push(new PathSegment('C', [x1, y1, x2, y2, x3, y3]));\r\n        if (this._ctx) {\r\n            this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} x1\r\n     * @param  {number} y1\r\n     * @param  {number} x2\r\n     * @param  {number} y2\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {\r\n        this.pathCommands.push(new PathSegment('Q', [x1, y1, x2, y2]));\r\n        if (this._ctx) {\r\n            this._ctx.quadraticCurveTo(x1, y1, x2, y2);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} cx\r\n     * @param  {number} cy\r\n     * @param  {number} r\r\n     * @param  {number} startAngle\r\n     * @param  {number} endAngle\r\n     * @param  {boolean} anticlockwise\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {\r\n        this.pathCommands.push(new PathSegment(\r\n            'A', [cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1]\r\n        ));\r\n        if (this._ctx) {\r\n            this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // TODO\r\n    PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {\r\n        if (this._ctx) {\r\n            this._ctx.arcTo(x1, y1, x2, y2, radius);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // TODO\r\n    PathProxy.prototype.rect = function (x, y, w, h) {\r\n        if (this._ctx) {\r\n            this._ctx.rect(x, y, w, h);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.closePath = function () {\r\n        this.pathCommands.push(new PathSegment('z'));\r\n        if (this._ctx) {\r\n            this._ctx.closePath();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 是否没有Path命令\r\n     * @return {boolean}\r\n     */\r\n    PathProxy.prototype.isEmpty = function() {\r\n        return this.pathCommands.length === 0;\r\n    };\r\n\r\n    PathProxy.PathSegment = PathSegment;\r\n\r\n    return PathProxy;\r\n});"
        },
        {
          "id": 25,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
          "index": 25,
          "index2": 18,
          "size": 4847,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 20,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Droplet",
              "loc": "466:27-61"
            }
          ],
          "source": "/**\r\n * 水滴形状\r\n * @module zrender/shape/Droplet\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *   var Droplet = require('zrender/shape/Droplet');\r\n *   var shape = new Droplet({\r\n *       style: {\r\n *           x: 100,\r\n *           y: 100,\r\n *           a: 40,\r\n *           b: 40,\r\n *           brushType: 'both',\r\n *           color: 'blue',\r\n *           strokeColor: 'red',\r\n *           lineWidth: 3,\r\n *           text: 'Droplet'\r\n *       }    \r\n *   });\r\n *   zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IDropletStyle\r\n * @property {number} x 水滴中心x坐标\r\n * @property {number} y 水滴中心y坐标\r\n * @property {number} a 水滴横宽（中心到水平边缘最宽处距离）\r\n * @property {number} b 水滴纵高（中心到尖端距离）\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        'use strict';\r\n\r\n        var Base = require('./Base');\r\n        var PathProxy = require('./util/PathProxy');\r\n        var area = require('../tool/area');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Droplet\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Droplet = function(options) {\r\n            Base.call(this, options);\r\n            this._pathProxy = new PathProxy();\r\n            /**\r\n             * 水滴绘制样式\r\n             * @name module:zrender/shape/Droplet#style\r\n             * @type {module:zrender/shape/Droplet~IDropletStyle}\r\n             */\r\n            /**\r\n             * 水滴高亮绘制样式\r\n             * @name module:zrender/shape/Droplet#highlightStyle\r\n             * @type {module:zrender/shape/Droplet~IDropletStyle}\r\n             */\r\n        };\r\n\r\n        Droplet.prototype = {\r\n            type: 'droplet',\r\n\r\n            /**\r\n             * 创建水滴路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Droplet~IDropletStyle} style\r\n             */\r\n            buildPath : function(ctx, style) {\r\n                var path = this._pathProxy || new PathProxy();\r\n                path.begin(ctx);\r\n\r\n                path.moveTo(style.x, style.y + style.a);\r\n                path.bezierCurveTo(\r\n                    style.x + style.a,\r\n                    style.y + style.a,\r\n                    style.x + style.a * 3 / 2,\r\n                    style.y - style.a / 3,\r\n                    style.x,\r\n                    style.y - style.b\r\n                );\r\n                path.bezierCurveTo(\r\n                    style.x - style.a * 3 / 2,\r\n                    style.y - style.a / 3,\r\n                    style.x - style.a,\r\n                    style.y + style.a,\r\n                    style.x,\r\n                    style.y + style.a\r\n                );\r\n                path.closePath();\r\n            },\r\n\r\n            /**\r\n             * 计算返回水滴的包围盒矩形\r\n             * @param {module:zrender/shape/Droplet~IDropletStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                if (!this._pathProxy.isEmpty()) {\r\n                    this.buildPath(null, style);\r\n                }\r\n                return this._pathProxy.fastBoundingRect();\r\n            },\r\n\r\n            isCover: function (x, y) {\r\n                var originPos = this.transformCoordToLocal(x, y);\r\n                x = originPos[0];\r\n                y = originPos[1];\r\n                \r\n                if (this.isCoverRect(x, y)) {\r\n                    return area.isInsidePath(\r\n                        this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y\r\n                    );\r\n                }\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Droplet, Base);\r\n        return Droplet;\r\n    }\r\n);\r\n"
        },
        {
          "id": 26,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "index": 26,
          "index2": 23,
          "size": 7817,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../util/shape/MarkLine",
              "loc": "12:24-57"
            }
          ],
          "source": "/**\r\n * zrender\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         Yi Shen(https://github.com/pissang)\r\n *\r\n * shape类：标线\r\n */\r\n\r\n/**\r\n * @typedef {Object} IMarkLineStyle\r\n * @property {number} xStart 起点x坐标\r\n * @property {number} yStart 起点y坐标\r\n * @property {number} xEnd 终止点x坐标\r\n * @property {number} yEnd 终止点y坐标\r\n * @property {number} cpX1 控制点x坐标，可以使用updatePoints自动根据curveness计算\r\n * @property {number} cpY1 控制点y坐标，可以使用updatePoints自动根据curveness计算\r\n * @property {number} curveness 曲度\r\n * @property {Array.<string>} symbol\r\n * @property {Array.<number>} symbolRotate\r\n */\r\ndefine(function (require) {\r\n    var Base = require('zrenderjs/shape/Base');\r\n    var IconShape = require('./Icon');\r\n    var LineShape = require('zrenderjs/shape/Line');\r\n    var lineInstance = new LineShape({});\r\n    var CurveShape = require('zrenderjs/shape/BezierCurve');\r\n    var curveInstance = new CurveShape({});\r\n\r\n    var area = require('zrenderjs/tool/area');\r\n    var dashedLineTo = require('zrenderjs/shape/util/dashedLineTo');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var curveTool = require('zrenderjs/tool/curve');\r\n\r\n    function MarkLine(options) {\r\n        Base.call(this, options);\r\n\r\n        if (this.style.curveness > 0) {\r\n            this.updatePoints(this.style);\r\n        }\r\n        if (this.highlightStyle.curveness > 0) {\r\n            this.updatePoints(this.highlightStyle);\r\n        }\r\n    }\r\n\r\n    MarkLine.prototype =  {\r\n        type : 'mark-line',\r\n        /**\r\n         * 画刷\r\n         * @param ctx 画布句柄\r\n         * @param isHighlight   是否为高亮状态\r\n         * @param updateCallback 让painter更新视图，base.brush没用，需要的话重载brush\r\n         */\r\n        brush : function (ctx, isHighlight) {\r\n            var style = this.style;\r\n\r\n            if (isHighlight) {\r\n                // 根据style扩展默认高亮样式\r\n                style = this.getHighlightStyle(\r\n                    style,\r\n                    this.highlightStyle || {}\r\n                );\r\n            }\r\n\r\n            ctx.save();\r\n            this.setContext(ctx, style);\r\n\r\n            // 设置transform\r\n            this.setTransform(ctx);\r\n\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            this.buildPath(ctx, style);\r\n            ctx.stroke();\r\n            ctx.restore();\r\n\r\n            this.brushSymbol(ctx, style, 0);\r\n            this.brushSymbol(ctx, style, 1);\r\n\r\n            this.drawText(ctx, style, this.style);\r\n\r\n            ctx.restore();\r\n        },\r\n\r\n        /**\r\n         * 创建线条路径\r\n         * @param {Context2D} ctx Canvas 2D上下文\r\n         * @param {Object} style 样式\r\n         */\r\n        buildPath : function (ctx, style) {\r\n            var lineType = style.lineType || 'solid';\r\n\r\n            ctx.moveTo(style.xStart, style.yStart);\r\n            if (style.curveness > 0) {\r\n                // FIXME Bezier 在少部分浏览器上暂时不支持虚线\r\n                var lineDash = null;\r\n                switch (lineType) {\r\n                    case 'dashed':\r\n                        lineDash = [5, 5];\r\n                        break;\r\n                    case'dotted':\r\n                        lineDash = [1, 1];\r\n                        break;\r\n                }\r\n                if (lineDash && ctx.setLineDash) {\r\n                    ctx.setLineDash(lineDash);\r\n                }\r\n                \r\n                ctx.quadraticCurveTo(\r\n                    style.cpX1, style.cpY1, style.xEnd, style.yEnd\r\n                );\r\n            }\r\n            else {\r\n                if (lineType == 'solid') {\r\n                    ctx.lineTo(style.xEnd, style.yEnd);\r\n                }\r\n                else {\r\n                    var dashLength = (style.lineWidth || 1) \r\n                        * (style.lineType == 'dashed' ? 5 : 1);\r\n                    dashedLineTo(\r\n                        ctx, style.xStart, style.yStart,\r\n                        style.xEnd, style.yEnd, dashLength\r\n                    );\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Update cpX1 and cpY1 according to curveniss\r\n         * @param  {Object} style\r\n         */\r\n        updatePoints: function (style) {\r\n            var curveness = style.curveness || 0;\r\n            var inv = 1;\r\n\r\n            var x0 = style.xStart;\r\n            var y0 = style.yStart;\r\n            var x2 = style.xEnd;\r\n            var y2 = style.yEnd;\r\n            var x1 = (x0 + x2) / 2 - inv * (y0 - y2) * curveness;\r\n            var y1 =(y0 + y2) / 2 - inv * (x2 - x0) * curveness;\r\n\r\n            style.cpX1 = x1;\r\n            style.cpY1 = y1;\r\n        },\r\n\r\n        /**\r\n         * 标线始末标注\r\n         */\r\n        brushSymbol : function (ctx, style, idx) {\r\n            if (style.symbol[idx] == 'none') {\r\n                return;\r\n            }\r\n            ctx.save();\r\n            ctx.beginPath();\r\n\r\n            ctx.lineWidth = style.symbolBorder;\r\n            ctx.strokeStyle = style.symbolBorderColor;\r\n            // symbol\r\n            var symbol = style.symbol[idx].replace('empty', '')\r\n                                              .toLowerCase();\r\n            if (style.symbol[idx].match('empty')) {\r\n                ctx.fillStyle = '#fff'; //'rgba(0, 0, 0, 0)';\r\n            }\r\n\r\n            // symbolRotate\r\n            var x0 = style.xStart;\r\n            var y0 = style.yStart;\r\n            var x2 = style.xEnd;\r\n            var y2 = style.yEnd;\r\n            var x = idx === 0 ? x0 : x2;\r\n            var y = idx === 0 ? y0 : y2;\r\n            var curveness = style.curveness || 0;\r\n            var rotate = style.symbolRotate[idx] != null ? (style.symbolRotate[idx] - 0) : 0;\r\n            rotate = rotate / 180 * Math.PI;\r\n\r\n            if (symbol == 'arrow' && rotate === 0) {\r\n                if (curveness === 0) {\r\n                    var sign = idx === 0 ? -1 : 1; \r\n                    rotate = Math.PI / 2 + Math.atan2(\r\n                        sign * (y2 - y0), sign * (x2 - x0)\r\n                    );\r\n                }\r\n                else {\r\n                    var x1 = style.cpX1;\r\n                    var y1 = style.cpY1;\r\n\r\n                    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\r\n                    var dx = quadraticDerivativeAt(x0, x1, x2, idx);\r\n                    var dy = quadraticDerivativeAt(y0, y1, y2, idx);\r\n\r\n                    rotate = Math.PI / 2 + Math.atan2(dy, dx);\r\n                }\r\n            }\r\n            \r\n            ctx.translate(x, y);\r\n\r\n            if (rotate !== 0) {\r\n                ctx.rotate(rotate);\r\n            }\r\n\r\n            // symbolSize\r\n            var symbolSize = style.symbolSize[idx];\r\n            IconShape.prototype.buildPath(ctx, {\r\n                x: -symbolSize,\r\n                y: -symbolSize,\r\n                width: symbolSize * 2,\r\n                height: symbolSize * 2,\r\n                iconType: symbol\r\n            });\r\n\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        },\r\n\r\n        /**\r\n         * 返回矩形区域，用于局部刷新和文字定位\r\n         * @param {Object} style\r\n         */\r\n        getRect : function (style) {\r\n            style.curveness > 0 ? curveInstance.getRect(style)\r\n                : lineInstance.getRect(style);\r\n            return style.__rect;\r\n        },\r\n\r\n        isCover : function (x, y) {\r\n            var originPos = this.transformCoordToLocal(x, y);\r\n            x = originPos[0];\r\n            y = originPos[1];\r\n\r\n            // 快速预判并保留判断矩形\r\n            if (this.isCoverRect(x, y)) {\r\n                // 矩形内\r\n                return this.style.curveness > 0\r\n                       ? area.isInside(curveInstance, this.style, x, y)\r\n                       : area.isInside(lineInstance, this.style, x, y);\r\n            }\r\n\r\n            return false;\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(MarkLine, Base);\r\n\r\n    return MarkLine;\r\n});\r\n"
        },
        {
          "id": 27,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Line.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
          "index": 27,
          "index2": 21,
          "size": 4479,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 26,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Line",
              "loc": "25:20-51"
            },
            {
              "moduleId": 51,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Line",
              "loc": "19:20-51"
            },
            {
              "moduleId": 52,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Line",
              "loc": "13:20-51"
            },
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Line",
              "loc": "13:20-51"
            }
          ],
          "source": "/**\r\n * 直线\r\n * @module zrender/shape/Line\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *   var Line = require('zrender/shape/Line');\r\n *   var shape = new Line({\r\n *       style: {\r\n *           xStart: 0,\r\n *           yStart: 0,\r\n *           xEnd: 100,\r\n *           yEnd: 100,\r\n *           strokeColor: '#000',\r\n *           lineWidth: 10\r\n *       }\r\n *   });\r\n *   zr.addShape(line);\r\n */\r\n/**\r\n * @typedef {Object} ILineStyle\r\n * @property {number} xStart 起点x坐标\r\n * @property {number} yStart 起点y坐标\r\n * @property {number} xEnd 终止点x坐标\r\n * @property {number} yEnd 终止点y坐标\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        var Base = require('./Base');\r\n        var dashedLineTo = require('./util/dashedLineTo');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/Line\r\n         * @param {Object} options\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         */\r\n        var Line = function (options) {\r\n            this.brushTypeOnly = 'stroke';  // 线条只能描边，填充后果自负\r\n            this.textPosition = 'end';\r\n            Base.call(this, options);\r\n\r\n            /**\r\n             * 直线绘制样式\r\n             * @name module:zrender/shape/Line#style\r\n             * @type {module:zrender/shape/Line~ILineStyle}\r\n             */\r\n            /**\r\n             * 直线高亮绘制样式\r\n             * @name module:zrender/shape/Line#highlightStyle\r\n             * @type {module:zrender/shape/Line~ILineStyle}\r\n             */\r\n        };\r\n\r\n        Line.prototype =  {\r\n            type: 'line',\r\n\r\n            /**\r\n             * 创建线条路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Line~ILineStyle} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                if (!style.lineType || style.lineType == 'solid') {\r\n                    // 默认为实线\r\n                    ctx.moveTo(style.xStart, style.yStart);\r\n                    ctx.lineTo(style.xEnd, style.yEnd);\r\n                }\r\n                else if (style.lineType == 'dashed'\r\n                        || style.lineType == 'dotted'\r\n                ) {\r\n                    var dashLength = (style.lineWidth || 1)  \r\n                                     * (style.lineType == 'dashed' ? 5 : 1);\r\n                    dashedLineTo(\r\n                        ctx,\r\n                        style.xStart, style.yStart,\r\n                        style.xEnd, style.yEnd,\r\n                        dashLength\r\n                    );\r\n                }\r\n            },\r\n\r\n            /**\r\n             * 计算返回线条的包围盒矩形\r\n             * @param {module:zrender/shape/Line~ILineStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var lineWidth = style.lineWidth || 1;\r\n                style.__rect = {\r\n                    x : Math.min(style.xStart, style.xEnd) - lineWidth,\r\n                    y : Math.min(style.yStart, style.yEnd) - lineWidth,\r\n                    width : Math.abs(style.xStart - style.xEnd)\r\n                            + lineWidth,\r\n                    height : Math.abs(style.yStart - style.yEnd)\r\n                             + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Line, Base);\r\n        return Line;\r\n    }\r\n);\r\n"
        },
        {
          "id": 28,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\dashedLineTo.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/dashedLineTo.js",
          "index": 28,
          "index2": 20,
          "size": 1451,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 26,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/util/dashedLineTo",
              "loc": "31:23-67"
            },
            {
              "moduleId": 27,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
              "type": "cjs require",
              "userRequest": "./util/dashedLineTo",
              "loc": "45:27-57"
            },
            {
              "moduleId": 31,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "type": "cjs require",
              "userRequest": "./util/dashedLineTo",
              "loc": "46:27-57"
            },
            {
              "moduleId": 35,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "type": "cjs require",
              "userRequest": "./util/dashedLineTo",
              "loc": "45:27-57"
            }
          ],
          "source": "/**\r\n * 虚线lineTo \r\n *\r\n * author:  Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *          errorrik (errorrik@gmail.com)\r\n */\r\ndefine(\r\n    function (/* require */) {\r\n\r\n        var dashPattern = [ 5, 5 ];\r\n        /**\r\n         * 虚线lineTo \r\n         */\r\n        return function (ctx, x1, y1, x2, y2, dashLength) {\r\n            // http://msdn.microsoft.com/en-us/library/ie/dn265063(v=vs.85).aspx\r\n            if (ctx.setLineDash) {\r\n                dashPattern[0] = dashPattern[1] = dashLength;\r\n                ctx.setLineDash(dashPattern);\r\n                ctx.moveTo(x1, y1);\r\n                ctx.lineTo(x2, y2);\r\n                return;\r\n            }\r\n\r\n            dashLength = typeof dashLength != 'number'\r\n                            ? 5 \r\n                            : dashLength;\r\n\r\n            var dx = x2 - x1;\r\n            var dy = y2 - y1;\r\n            var numDashes = Math.floor(\r\n                Math.sqrt(dx * dx + dy * dy) / dashLength\r\n            );\r\n            dx = dx / numDashes;\r\n            dy = dy / numDashes;\r\n            var flag = true;\r\n            for (var i = 0; i < numDashes; ++i) {\r\n                if (flag) {\r\n                    ctx.moveTo(x1, y1);\r\n                }\r\n                else {\r\n                    ctx.lineTo(x1, y1);\r\n                }\r\n                flag = !flag;\r\n                x1 += dx;\r\n                y1 += dy;\r\n            }\r\n            ctx.lineTo(x2, y2);\r\n        };\r\n    }\r\n);\r\n"
        },
        {
          "id": 29,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\BezierCurve.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
          "index": 29,
          "index2": 22,
          "size": 5355,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 26,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/BezierCurve",
              "loc": "27:21-59"
            }
          ],
          "source": "/**\r\n * 贝塞尔曲线\r\n * @module zrender/shape/BezierCurve\r\n * @author Neil (杨骥, 511415343@qq.com)\r\n * @example\r\n *     var BezierCurve = require('zrender/shape/BezierCurve');\r\n *     var shape = new BezierCurve({\r\n *         style: {\r\n *             xStart: 0,\r\n *             yStart: 0,\r\n *             cpX1: 100,\r\n *             cpY1: 0,\r\n *             cpX2: 0,\r\n *             cpY2: 100,\r\n *             xEnd: 100,\r\n *             yEnd: 100,\r\n *             strokeColor: 'red'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IBezierCurveStyle\r\n * @property {number} xStart 起点x坐标\r\n * @property {number} yStart 起点y坐标\r\n * @property {number} cpX1 第一个控制点x坐标\r\n * @property {number} cpY1 第一个控制点y坐标\r\n * @property {number} [cpX2] 第二个控制点x坐标，如果不给则为二次贝塞尔曲线\r\n * @property {number} [cpY2] 第二个控制点y坐标，如果不给则为二次贝塞尔曲线\r\n * @property {number} xEnd 终止点x坐标\r\n * @property {number} yEnd 终止点y坐标\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\n\r\ndefine(\r\n    function (require) {\r\n        'use strict';\r\n\r\n        var Base = require('./Base');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/BezierCurve\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var BezierCurve = function(options) {\r\n            this.brushTypeOnly = 'stroke';  // 线条只能描边，填充后果自负\r\n            this.textPosition = 'end';\r\n            Base.call(this, options);\r\n            /**\r\n             * 贝赛尔曲线绘制样式\r\n             * @name module:zrender/shape/BezierCurve#style\r\n             * @type {module:zrender/shape/BezierCurve~IBezierCurveStyle}\r\n             */\r\n            /**\r\n             * 贝赛尔曲线高亮绘制样式\r\n             * @name module:zrender/shape/BezierCurve#highlightStyle\r\n             * @type {module:zrender/shape/BezierCurve~IBezierCurveStyle}\r\n             */\r\n        };\r\n\r\n        BezierCurve.prototype = {\r\n            type: 'bezier-curve',\r\n\r\n            /**\r\n             * 创建贝塞尔曲线路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/BezierCurve~IBezierCurveStyle} style\r\n             */\r\n            buildPath : function(ctx, style) {\r\n                ctx.moveTo(style.xStart, style.yStart);\r\n                if (typeof style.cpX2 != 'undefined'\r\n                    && typeof style.cpY2 != 'undefined'\r\n                ) {\r\n                    ctx.bezierCurveTo(\r\n                        style.cpX1, style.cpY1,\r\n                        style.cpX2, style.cpY2,\r\n                        style.xEnd, style.yEnd\r\n                    );\r\n                }\r\n                else {\r\n                    ctx.quadraticCurveTo(\r\n                        style.cpX1, style.cpY1,\r\n                        style.xEnd, style.yEnd\r\n                    );\r\n                }\r\n            },\r\n\r\n            /**\r\n             * 计算返回贝赛尔曲线包围盒矩形。\r\n             * 该包围盒是直接从四个控制点计算，并非最小包围盒。\r\n             * @param {module:zrender/shape/BezierCurve~IBezierCurveStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function(style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var _minX = Math.min(style.xStart, style.xEnd, style.cpX1);\r\n                var _minY = Math.min(style.yStart, style.yEnd, style.cpY1);\r\n                var _maxX = Math.max(style.xStart, style.xEnd, style.cpX1);\r\n                var _maxY = Math.max(style.yStart, style.yEnd, style.cpY1);\r\n                var _x2 = style.cpX2;\r\n                var _y2 = style.cpY2;\r\n\r\n                if (typeof _x2 != 'undefined'\r\n                    && typeof _y2 != 'undefined'\r\n                ) {\r\n                    _minX = Math.min(_minX, _x2);\r\n                    _minY = Math.min(_minY, _y2);\r\n                    _maxX = Math.max(_maxX, _x2);\r\n                    _maxY = Math.max(_maxY, _y2);\r\n                }\r\n\r\n                var lineWidth = style.lineWidth || 1;\r\n                style.__rect = {\r\n                    x : _minX - lineWidth,\r\n                    y : _minY - lineWidth,\r\n                    width : _maxX - _minX + lineWidth,\r\n                    height : _maxY - _minY + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(BezierCurve, Base);\r\n        return BezierCurve;\r\n    }\r\n);\r\n"
        },
        {
          "id": 30,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
          "index": 30,
          "index2": 28,
          "size": 6763,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../util/shape/Symbol",
              "loc": "13:22-53"
            },
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "../util/shape/Symbol",
              "loc": "15:22-53"
            }
          ],
          "source": "/**\r\n * zrender\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * shape类：大规模散点图图形\r\n * 可配图形属性：\r\n   {\r\n       // 基础属性\r\n       shape  : 'symbol',       // 必须，shape类标识，需要显式指定\r\n       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成\r\n       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中\r\n       invisible : {boolean},   // 默认为false，是否可见\r\n\r\n       // 样式属性，默认状态样式样式属性\r\n       style  : {\r\n           pointList     : {Array},   // 必须，二维数组，二维内容如下\r\n               x         : {number},  // 必须，横坐标\r\n               y         : {number},  // 必须，纵坐标数组\r\n               size      : {number},  // 必须，半宽\r\n               type      : {string=}, // 默认为'circle',图形类型\r\n       },\r\n\r\n       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示\r\n       highlightStyle : {\r\n           // 同style\r\n       }\r\n\r\n       // 交互属性，详见shape.Base\r\n\r\n       // 事件属性，详见shape.Base\r\n   }\r\n */\r\ndefine(function (require) {\r\n    var Base = require('zrenderjs/shape/Base');\r\n    var PolygonShape = require('zrenderjs/shape/Polygon');\r\n    var polygonInstance = new PolygonShape({});\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n\r\n    function Symbol(options) {\r\n        Base.call(this, options);\r\n    }\r\n\r\n    Symbol.prototype =  {\r\n        type : 'symbol',\r\n        /**\r\n         * 创建矩形路径\r\n         * @param {Context2D} ctx Canvas 2D上下文\r\n         * @param {Object} style 样式\r\n         */\r\n        buildPath : function (ctx, style) {\r\n            var pointList = style.pointList;\r\n            var len = pointList.length;\r\n            if (len === 0) {\r\n                return;\r\n            }\r\n\r\n            var subSize = 10000;\r\n            var subSetLength = Math.ceil(len / subSize);\r\n            var sub;\r\n            var subLen;\r\n            var isArray = pointList[0] instanceof Array;\r\n            var size = style.size ? style.size : 2;\r\n            var curSize = size;\r\n            var halfSize = size / 2;\r\n            var PI2 = Math.PI * 2;\r\n            var percent;\r\n            var x;\r\n            var y;\r\n            for (var j = 0; j < subSetLength; j++) {\r\n                ctx.beginPath();\r\n                sub = j * subSize;\r\n                subLen = sub + subSize;\r\n                subLen = subLen > len ? len : subLen;\r\n                for (var i = sub; i < subLen; i++) {\r\n                    if (style.random) {\r\n                        percent = style['randomMap' + (i % 20)] / 100;\r\n                        curSize = size * percent * percent;\r\n                        halfSize = curSize / 2;\r\n                    }\r\n                    if (isArray) {\r\n                        x = pointList[i][0];\r\n                        y = pointList[i][1];\r\n                    }\r\n                    else {\r\n                        x = pointList[i].x;\r\n                        y = pointList[i].y;\r\n                    }\r\n                    if (curSize < 3) {\r\n                        // 小于3像素视觉误差\r\n                        ctx.rect(x - halfSize, y - halfSize, curSize, curSize);\r\n                    }\r\n                    else {\r\n                        // 大于3像素才考虑图形\r\n                        switch (style.iconType) {\r\n                            case 'circle' :\r\n                                ctx.moveTo(x, y);\r\n                                ctx.arc(x, y, halfSize, 0, PI2, true);\r\n                                break;\r\n                            case 'diamond' :\r\n                                ctx.moveTo(x, y - halfSize);\r\n                                ctx.lineTo(x + halfSize / 3, y - halfSize / 3);\r\n                                ctx.lineTo(x + halfSize, y);\r\n                                ctx.lineTo(x + halfSize / 3, y + halfSize / 3);\r\n                                ctx.lineTo(x, y + halfSize);\r\n                                ctx.lineTo(x - halfSize / 3, y + halfSize / 3);\r\n                                ctx.lineTo(x - halfSize, y);\r\n                                ctx.lineTo(x - halfSize / 3, y - halfSize / 3);\r\n                                ctx.lineTo(x, y - halfSize);\r\n                                break;\r\n                            default :\r\n                                ctx.rect(x - halfSize, y - halfSize, curSize, curSize);\r\n                        }\r\n                    }\r\n                }\r\n                ctx.closePath();\r\n                if (j < (subSetLength - 1)) {\r\n                    switch (style.brushType) {\r\n                        case 'both':\r\n                            ctx.fill();\r\n                            style.lineWidth > 0 && ctx.stroke();  // js hint -_-\"\r\n                            break;\r\n                        case 'stroke':\r\n                            style.lineWidth > 0 && ctx.stroke();\r\n                            break;\r\n                        default:\r\n                            ctx.fill();\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /* 像素模式\r\n        buildPath : function (ctx, style) {\r\n            var pointList = style.pointList;\r\n            var rect = this.getRect(style);\r\n            var ratio = window.devicePixelRatio || 1;\r\n            // console.log(rect)\r\n            // var ti = new Date();\r\n            // bbox取整\r\n            rect = {\r\n                x : Math.floor(rect.x),\r\n                y : Math.floor(rect.y),\r\n                width : Math.floor(rect.width),\r\n                height : Math.floor(rect.height)\r\n            };\r\n            var pixels = ctx.getImageData(\r\n                rect.x * ratio, rect.y * ratio,\r\n                rect.width * ratio, rect.height * ratio\r\n            );\r\n            var data = pixels.data;\r\n            var idx;\r\n            var zrColor = require('zrenderjs/tool/color');\r\n            var color = zrColor.toArray(style.color);\r\n            var r = color[0];\r\n            var g = color[1];\r\n            var b = color[2];\r\n            var width = rect.width;\r\n\r\n            for (var i = 1, l = pointList.length; i < l; i++) {\r\n                idx = ((Math.floor(pointList[i][0]) - rect.x) * ratio\r\n                       + (Math.floor(pointList[i][1])- rect.y) * width * ratio * ratio\r\n                      ) * 4;\r\n                data[idx] = r;\r\n                data[idx + 1] = g;\r\n                data[idx + 2] = b;\r\n                data[idx + 3] = 255;\r\n            }\r\n            ctx.putImageData(pixels, rect.x * ratio, rect.y * ratio);\r\n            // console.log(new Date() - ti);\r\n            return;\r\n        },\r\n        */\r\n\r\n        /**\r\n         * 返回矩形区域，用于局部刷新和文字定位\r\n         * @param {Object} style\r\n         */\r\n        getRect : function (style) {\r\n            return style.__rect || polygonInstance.getRect(style);\r\n        },\r\n\r\n        isCover : require('./normalIsCover')\r\n    };\r\n\r\n    zrUtil.inherits(Symbol, Base);\r\n\r\n    return Symbol;\r\n});\r\n"
        },
        {
          "id": 31,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "index": 31,
          "index2": 26,
          "size": 8261,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 30,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Polygon",
              "loc": "36:23-57"
            },
            {
              "moduleId": 35,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "type": "cjs require",
              "userRequest": "./Polygon",
              "loc": "151:23-43"
            },
            {
              "moduleId": 39,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecAnimation.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Polygon",
              "loc": "357:19-53"
            },
            {
              "moduleId": 60,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Polygon",
              "loc": "13:23-57"
            },
            {
              "moduleId": 68,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Polygon",
              "loc": "92:16-50"
            }
          ],
          "source": "/**\r\n * 多边形\r\n * @module zrender/shape/Polygon\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *     var Polygon = require('zrender/shape/Polygon');\r\n *     var shape = new Polygon({\r\n *         style: {\r\n *             // 100x100的正方形\r\n *             pointList: [[0, 0], [100, 0], [100, 100], [0, 100]],\r\n *             color: 'blue'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IPolygonStyle\r\n * @property {string} pointList 多边形顶点数组\r\n * @property {string} [smooth=''] 是否做平滑插值, 平滑算法可以选择 bezier, spline\r\n * @property {number} [smoothConstraint] 平滑约束\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        var Base = require('./Base');\r\n        var smoothSpline = require('./util/smoothSpline');\r\n        var smoothBezier = require('./util/smoothBezier');\r\n        var dashedLineTo = require('./util/dashedLineTo');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Polygon\r\n         * @param {Object} options\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         */\r\n        var Polygon = function (options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 多边形绘制样式\r\n             * @name module:zrender/shape/Polygon#style\r\n             * @type {module:zrender/shape/Polygon~IPolygonStyle}\r\n             */\r\n            /**\r\n             * 多边形高亮绘制样式\r\n             * @name module:zrender/shape/Polygon#highlightStyle\r\n             * @type {module:zrender/shape/Polygon~IPolygonStyle}\r\n             */\r\n        };\r\n\r\n        Polygon.prototype = {\r\n            type: 'polygon',\r\n\r\n            /**\r\n             * 创建多边形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Polygon~IPolygonStyle} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                // 虽然能重用brokenLine，但底层图形基于性能考虑，重复代码减少调用吧\r\n                var pointList = style.pointList;\r\n                // 开始点和结束点重复\r\n                /*\r\n                var start = pointList[0];\r\n                var end = pointList[pointList.length-1];\r\n\r\n                if (start && end) {\r\n                    if (start[0] == end[0] &&\r\n                        start[1] == end[1]) {\r\n                        // 移除最后一个点\r\n                        pointList.pop();\r\n                    }\r\n                }\r\n                */\r\n\r\n                if (pointList.length < 2) {\r\n                    // 少于2个点就不画了~\r\n                    return;\r\n                }\r\n\r\n                if (style.smooth && style.smooth !== 'spline') {\r\n                    var controlPoints = smoothBezier(\r\n                        pointList, style.smooth, true, style.smoothConstraint\r\n                    );\r\n\r\n                    ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                    var cp1;\r\n                    var cp2;\r\n                    var p;\r\n                    var len = pointList.length;\r\n                    for (var i = 0; i < len; i++) {\r\n                        cp1 = controlPoints[i * 2];\r\n                        cp2 = controlPoints[i * 2 + 1];\r\n                        p = pointList[(i + 1) % len];\r\n                        ctx.bezierCurveTo(\r\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\r\n                        );\r\n                    }\r\n                } \r\n                else {\r\n                    if (style.smooth === 'spline') {\r\n                        pointList = smoothSpline(pointList, true);\r\n                    }\r\n\r\n                    if (!style.lineType || style.lineType == 'solid') {\r\n                        // 默认为实线\r\n                        ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                        for (var i = 1, l = pointList.length; i < l; i++) {\r\n                            ctx.lineTo(pointList[i][0], pointList[i][1]);\r\n                        }\r\n                        ctx.lineTo(pointList[0][0], pointList[0][1]);\r\n                    }\r\n                    else if (style.lineType == 'dashed'\r\n                            || style.lineType == 'dotted'\r\n                    ) {\r\n                        var dashLength = \r\n                            style._dashLength\r\n                            || (style.lineWidth || 1) \r\n                               * (style.lineType == 'dashed' ? 5 : 1);\r\n                        style._dashLength = dashLength;\r\n                        ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                        for (var i = 1, l = pointList.length; i < l; i++) {\r\n                            dashedLineTo(\r\n                                ctx,\r\n                                pointList[i - 1][0], pointList[i - 1][1],\r\n                                pointList[i][0], pointList[i][1],\r\n                                dashLength\r\n                            );\r\n                        }\r\n                        dashedLineTo(\r\n                            ctx,\r\n                            pointList[pointList.length - 1][0], \r\n                            pointList[pointList.length - 1][1],\r\n                            pointList[0][0],\r\n                            pointList[0][1],\r\n                            dashLength\r\n                        );\r\n                    }\r\n                }\r\n\r\n                ctx.closePath();\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 计算返回多边形包围盒矩阵\r\n             * @param {module:zrender/shape/Polygon~IPolygonStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var minX =  Number.MAX_VALUE;\r\n                var maxX =  Number.MIN_VALUE;\r\n                var minY = Number.MAX_VALUE;\r\n                var maxY = Number.MIN_VALUE;\r\n\r\n                var pointList = style.pointList;\r\n                for (var i = 0, l = pointList.length; i < l; i++) {\r\n                    if (pointList[i][0] < minX) {\r\n                        minX = pointList[i][0];\r\n                    }\r\n                    if (pointList[i][0] > maxX) {\r\n                        maxX = pointList[i][0];\r\n                    }\r\n                    if (pointList[i][1] < minY) {\r\n                        minY = pointList[i][1];\r\n                    }\r\n                    if (pointList[i][1] > maxY) {\r\n                        maxY = pointList[i][1];\r\n                    }\r\n                }\r\n\r\n                var lineWidth;\r\n                if (style.brushType == 'stroke' || style.brushType == 'fill') {\r\n                    lineWidth = style.lineWidth || 1;\r\n                }\r\n                else {\r\n                    lineWidth = 0;\r\n                }\r\n                \r\n                style.__rect = {\r\n                    x : Math.round(minX - lineWidth / 2),\r\n                    y : Math.round(minY - lineWidth / 2),\r\n                    width : maxX - minX + lineWidth,\r\n                    height : maxY - minY + lineWidth\r\n                };\r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Polygon, Base);\r\n        return Polygon;\r\n    }\r\n);\r\n\r\n"
        },
        {
          "id": 32,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\smoothSpline.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothSpline.js",
          "index": 32,
          "index2": 24,
          "size": 2375,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 31,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "type": "cjs require",
              "userRequest": "./util/smoothSpline",
              "loc": "44:27-57"
            },
            {
              "moduleId": 35,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "type": "cjs require",
              "userRequest": "./util/smoothSpline",
              "loc": "43:27-57"
            }
          ],
          "source": "/**\r\n * Catmull-Rom spline 插值折线\r\n * @module zrender/shape/util/smoothSpline\r\n * @author pissang (https://www.github.com/pissang) \r\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         errorrik (errorrik@gmail.com)\r\n */\r\ndefine(\r\n    function (require) {\r\n        var vector = require('../../tool/vector');\r\n\r\n        /**\r\n         * @inner\r\n         */\r\n        function interpolate(p0, p1, p2, p3, t, t2, t3) {\r\n            var v0 = (p2 - p0) * 0.5;\r\n            var v1 = (p3 - p1) * 0.5;\r\n            return (2 * (p1 - p2) + v0 + v1) * t3 \r\n                    + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\r\n                    + v0 * t + p1;\r\n        }\r\n\r\n        /**\r\n         * @alias module:zrender/shape/util/smoothSpline\r\n         * @param {Array} points 线段顶点数组\r\n         * @param {boolean} isLoop\r\n         * @param {Array} constraint \r\n         * @return {Array}\r\n         */\r\n        return function (points, isLoop, constraint) {\r\n            var len = points.length;\r\n            var ret = [];\r\n\r\n            var distance = 0;\r\n            for (var i = 1; i < len; i++) {\r\n                distance += vector.distance(points[i - 1], points[i]);\r\n            }\r\n            \r\n            var segs = distance / 5;\r\n            segs = segs < len ? len : segs;\r\n            for (var i = 0; i < segs; i++) {\r\n                var pos = i / (segs - 1) * (isLoop ? len : len - 1);\r\n                var idx = Math.floor(pos);\r\n\r\n                var w = pos - idx;\r\n\r\n                var p0;\r\n                var p1 = points[idx % len];\r\n                var p2;\r\n                var p3;\r\n                if (!isLoop) {\r\n                    p0 = points[idx === 0 ? idx : idx - 1];\r\n                    p2 = points[idx > len - 2 ? len - 1 : idx + 1];\r\n                    p3 = points[idx > len - 3 ? len - 1 : idx + 2];\r\n                }\r\n                else {\r\n                    p0 = points[(idx - 1 + len) % len];\r\n                    p2 = points[(idx + 1) % len];\r\n                    p3 = points[(idx + 2) % len];\r\n                }\r\n\r\n                var w2 = w * w;\r\n                var w3 = w * w2;\r\n\r\n                ret.push([\r\n                    interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\r\n                    interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\r\n                ]);\r\n            }\r\n            return ret;\r\n        };\r\n    }\r\n);\r\n"
        },
        {
          "id": 33,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\smoothBezier.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothBezier.js",
          "index": 33,
          "index2": 25,
          "size": 3372,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 31,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
              "type": "cjs require",
              "userRequest": "./util/smoothBezier",
              "loc": "45:27-57"
            },
            {
              "moduleId": 35,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
              "type": "cjs require",
              "userRequest": "./util/smoothBezier",
              "loc": "44:27-57"
            },
            {
              "moduleId": 68,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/util/smoothBezier",
              "loc": "49:23-67"
            }
          ],
          "source": "/**\r\n * 贝塞尔平滑曲线 \r\n * @module zrender/shape/util/smoothBezier\r\n * @author pissang (https://www.github.com/pissang) \r\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         errorrik (errorrik@gmail.com)\r\n */\r\ndefine(\r\n    function (require) {\r\n        var vector = require('../../tool/vector');\r\n\r\n        /**\r\n         * 贝塞尔平滑曲线\r\n         * @alias module:zrender/shape/util/smoothBezier\r\n         * @param {Array} points 线段顶点数组\r\n         * @param {number} smooth 平滑等级, 0-1\r\n         * @param {boolean} isLoop\r\n         * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\r\n         *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\r\n         *                           整个折线的包围盒做一个并集用来约束控制点。\r\n         * @param {Array} 计算出来的控制点数组\r\n         */\r\n        return function (points, smooth, isLoop, constraint) {\r\n            var cps = [];\r\n\r\n            var v = [];\r\n            var v1 = [];\r\n            var v2 = [];\r\n            var prevPoint;\r\n            var nextPoint;\r\n\r\n            var hasConstraint = !!constraint;\r\n            var min, max;\r\n            if (hasConstraint) {\r\n                min = [Infinity, Infinity];\r\n                max = [-Infinity, -Infinity];\r\n                for (var i = 0, len = points.length; i < len; i++) {\r\n                    vector.min(min, min, points[i]);\r\n                    vector.max(max, max, points[i]);\r\n                }\r\n                // 与指定的包围盒做并集\r\n                vector.min(min, min, constraint[0]);\r\n                vector.max(max, max, constraint[1]);\r\n            }\r\n\r\n            for (var i = 0, len = points.length; i < len; i++) {\r\n                var point = points[i];\r\n                var prevPoint;\r\n                var nextPoint;\r\n\r\n                if (isLoop) {\r\n                    prevPoint = points[i ? i - 1 : len - 1];\r\n                    nextPoint = points[(i + 1) % len];\r\n                } \r\n                else {\r\n                    if (i === 0 || i === len - 1) {\r\n                        cps.push(vector.clone(points[i]));\r\n                        continue;\r\n                    } \r\n                    else {\r\n                        prevPoint = points[i - 1];\r\n                        nextPoint = points[i + 1];\r\n                    }\r\n                }\r\n\r\n                vector.sub(v, nextPoint, prevPoint);\r\n\r\n                // use degree to scale the handle length\r\n                vector.scale(v, v, smooth);\r\n\r\n                var d0 = vector.distance(point, prevPoint);\r\n                var d1 = vector.distance(point, nextPoint);\r\n                var sum = d0 + d1;\r\n                if (sum !== 0) {\r\n                    d0 /= sum;\r\n                    d1 /= sum;\r\n                }\r\n\r\n                vector.scale(v1, v, -d0);\r\n                vector.scale(v2, v, d1);\r\n                var cp0 = vector.add([], point, v1);\r\n                var cp1 = vector.add([], point, v2);\r\n                if (hasConstraint) {\r\n                    vector.max(cp0, cp0, min);\r\n                    vector.min(cp0, cp0, max);\r\n                    vector.max(cp1, cp1, min);\r\n                    vector.min(cp1, cp1, max);\r\n                }\r\n                cps.push(cp0);\r\n                cps.push(cp1);\r\n            }\r\n            \r\n            if (isLoop) {\r\n                cps.push(vector.clone(cps.shift()));\r\n            }\r\n\r\n            return cps;\r\n        };\r\n    }\r\n);\r\n"
        },
        {
          "id": 34,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\normalIsCover.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/normalIsCover.js",
          "index": 34,
          "index2": 27,
          "size": 348,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 30,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
              "type": "cjs require",
              "userRequest": "./normalIsCover",
              "loc": "183:18-44"
            }
          ],
          "source": "// 由于大多数shape默认的isCover都是相同的逻辑\r\n// 所以在echarts里临时抽象一个module，用于isCover method\r\n// TODO: 对zrender的isCover和getRect方法进行抽象，重新整理该逻辑\r\n\r\ndefine(function () {\r\n    return function (x, y) {\r\n        var originPos = this.transformCoordToLocal(x, y);\r\n        x = originPos[0];\r\n        y = originPos[1];\r\n\r\n        return this.isCoverRect(x, y);\r\n    };\r\n});\r\n"
        },
        {
          "id": 35,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "index": 35,
          "index2": 29,
          "size": 6258,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Polyline",
              "loc": "14:24-59"
            },
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Polyline",
              "loc": "17:19-54"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Polyline",
              "loc": "12:24-59"
            }
          ],
          "source": "/**\r\n * 折线\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @module zrender/shape/Polyline\r\n * @example\r\n *     var Polyline = require('zrender/shape/Polyline');\r\n *     var shape = new Polyline({\r\n *         style: {\r\n *             pointList: [[0, 0], [100, 100], [100, 0]],\r\n *             smooth: 'bezier',\r\n *             strokeColor: 'purple'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IPolylineStyle\r\n * @property {Array.<number>} pointList 顶点坐标数组\r\n * @property {string|number} [smooth=''] 是否做平滑插值, 平滑算法可以选择 bezier, spline\r\n * @property {number} [smoothConstraint] 平滑约束\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {string} [lineJoin='miter'] 线段连接样式，可以是 miter, round, bevel\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        var Base = require('./Base');\r\n        var smoothSpline = require('./util/smoothSpline');\r\n        var smoothBezier = require('./util/smoothBezier');\r\n        var dashedLineTo = require('./util/dashedLineTo');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Polyline\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Polyline = function(options) {\r\n            this.brushTypeOnly = 'stroke';  // 线条只能描边，填充后果自负\r\n            this.textPosition = 'end';\r\n            Base.call(this, options);\r\n            /**\r\n             * 贝赛尔曲线绘制样式\r\n             * @name module:zrender/shape/Polyline#style\r\n             * @type {module:zrender/shape/Polyline~IPolylineStyle}\r\n             */\r\n            /**\r\n             * 贝赛尔曲线高亮绘制样式\r\n             * @name module:zrender/shape/Polyline#highlightStyle\r\n             * @type {module:zrender/shape/Polyline~IPolylineStyle}\r\n             */\r\n        };\r\n\r\n        Polyline.prototype =  {\r\n            type: 'polyline',\r\n\r\n            /**\r\n             * 创建多边形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Polyline~IPolylineStyle} style\r\n             */\r\n            buildPath : function(ctx, style) {\r\n                var pointList = style.pointList;\r\n                if (pointList.length < 2) {\r\n                    // 少于2个点就不画了~\r\n                    return;\r\n                }\r\n                \r\n                var len = Math.min(\r\n                    style.pointList.length, \r\n                    Math.round(style.pointListLength || style.pointList.length)\r\n                );\r\n                \r\n                if (style.smooth && style.smooth !== 'spline') {\r\n                    if (! style.controlPointList) {\r\n                        this.updateControlPoints(style);\r\n                    }\r\n                    var controlPointList = style.controlPointList;\r\n\r\n                    ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                    var cp1;\r\n                    var cp2;\r\n                    var p;\r\n                    for (var i = 0; i < len - 1; i++) {\r\n                        cp1 = controlPointList[i * 2];\r\n                        cp2 = controlPointList[i * 2 + 1];\r\n                        p = pointList[i + 1];\r\n                        ctx.bezierCurveTo(\r\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\r\n                        );\r\n                    }\r\n                }\r\n                else {\r\n                    if (style.smooth === 'spline') {\r\n                        pointList = smoothSpline(pointList);\r\n                        len = pointList.length;\r\n                    }\r\n                    if (!style.lineType || style.lineType == 'solid') {\r\n                        // 默认为实线\r\n                        ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                        for (var i = 1; i < len; i++) {\r\n                            ctx.lineTo(pointList[i][0], pointList[i][1]);\r\n                        }\r\n                    }\r\n                    else if (style.lineType == 'dashed'\r\n                            || style.lineType == 'dotted'\r\n                    ) {\r\n                        var dashLength = (style.lineWidth || 1) \r\n                                         * (style.lineType == 'dashed' ? 5 : 1);\r\n                        ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                        for (var i = 1; i < len; i++) {\r\n                            dashedLineTo(\r\n                                ctx,\r\n                                pointList[i - 1][0], pointList[i - 1][1],\r\n                                pointList[i][0], pointList[i][1],\r\n                                dashLength\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                return;\r\n            },\r\n\r\n            updateControlPoints: function (style) {\r\n                style.controlPointList = smoothBezier(\r\n                    style.pointList, style.smooth, false, style.smoothConstraint\r\n                );\r\n            },\r\n\r\n            /**\r\n             * 计算返回折线包围盒矩形。\r\n             * @param {IZRenderBezierCurveStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function(style) {\r\n                return require('./Polygon').prototype.getRect(style);\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Polyline, Base);\r\n        return Polyline;\r\n    }\r\n);\r\n"
        },
        {
          "id": 36,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\ShapeBundle.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
          "index": 36,
          "index2": 30,
          "size": 5197,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/ShapeBundle",
              "loc": "15:22-60"
            },
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/ShapeBundle",
              "loc": "16:22-60"
            }
          ],
          "source": "/**\r\n * ShapeBundle 捆绑多个 shape 的 buildPath 方法，但是共用同一个样式\r\n * @author pissang (https://github.com/pissang)\r\n * @module zrender/shape/ShapeBundle\r\n * @example\r\n *     var poly1 = new PolygonShape();\r\n *     var poly2 = new PolygonShape();\r\n *     var poly3 = new PolygonShape();\r\n *     var shapeBundle = new ShapeBundle({\r\n *         style: {\r\n *             shapeList: [poly1, poly2, poly3],\r\n *             color: 'red'\r\n *         }\r\n *     });\r\n *     zr.addShape(shapeBundle);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IShapeBundleStyle\r\n * @property {string} shapeList shape列表\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(function (require) {\r\n\r\n    var Base = require('./Base');\r\n\r\n    var ShapeBundle = function (options) {\r\n        Base.call(this, options);\r\n        /**\r\n         * ShapeBundle绘制样式\r\n         * @name module:zrender/shape/ShapeBundle#style\r\n         * @type {module:zrender/shape/ShapeBundle~IShapeBundleStyle}\r\n         */\r\n        /**\r\n         * ShapeBundle高亮绘制样式\r\n         * @name module:zrender/shape/ShapeBundle#highlightStyle\r\n         * @type {module:zrender/shape/ShapeBundle~IShapeBundleStyle}\r\n         */\r\n    };\r\n\r\n    ShapeBundle.prototype = {\r\n\r\n        constructor: ShapeBundle,\r\n\r\n        type: 'shape-bundle',\r\n\r\n        brush: function (ctx, isHighlight) {\r\n            var style = this.beforeBrush(ctx, isHighlight);\r\n\r\n            ctx.beginPath();\r\n            for (var i = 0; i < style.shapeList.length; i++) {\r\n                var subShape = style.shapeList[i];\r\n                var subShapeStyle = subShape.style;\r\n                if (isHighlight) {\r\n                    subShapeStyle = subShape.getHighlightStyle(\r\n                        subShapeStyle,\r\n                        subShape.highlightStyle || {},\r\n                        subShape.brushTypeOnly\r\n                    );\r\n                }\r\n                subShape.buildPath(ctx, subShapeStyle);\r\n            }\r\n            switch (style.brushType) {\r\n                /* jshint ignore:start */\r\n                case 'both':\r\n                    ctx.fill();\r\n                case 'stroke':\r\n                    style.lineWidth > 0 && ctx.stroke();\r\n                    break;\r\n                /* jshint ignore:end */\r\n                default:\r\n                    ctx.fill();\r\n            }\r\n\r\n            this.drawText(ctx, style, this.style);\r\n\r\n            this.afterBrush(ctx);\r\n        },\r\n\r\n        /**\r\n         * 计算返回多边形包围盒矩阵\r\n         * @param {module:zrender/shape/Polygon~IShapeBundleStyle} style\r\n         * @return {module:zrender/shape/Base~IBoundingRect}\r\n         */\r\n        getRect: function (style) {\r\n            if (style.__rect) {\r\n                return style.__rect;\r\n            }\r\n            var minX = Infinity;\r\n            var maxX = -Infinity;\r\n            var minY = Infinity;\r\n            var maxY = -Infinity;\r\n            for (var i = 0; i < style.shapeList.length; i++) {\r\n                var subShape = style.shapeList[i];\r\n                // TODO Highlight style ?\r\n                var subRect = subShape.getRect(subShape.style);\r\n\r\n                var minX = Math.min(subRect.x, minX);\r\n                var minY = Math.min(subRect.y, minY);\r\n                var maxX = Math.max(subRect.x + subRect.width, maxX);\r\n                var maxY = Math.max(subRect.y + subRect.height, maxY);\r\n            }\r\n\r\n            style.__rect = {\r\n                x: minX,\r\n                y: minY,\r\n                width: maxX - minX,\r\n                height: maxY - minY\r\n            };\r\n\r\n            return style.__rect;\r\n        },\r\n\r\n        isCover: function (x, y) {\r\n            var originPos = this.transformCoordToLocal(x, y);\r\n            x = originPos[0];\r\n            y = originPos[1];\r\n            \r\n            if (this.isCoverRect(x, y)) {\r\n                for (var i = 0; i < this.style.shapeList.length; i++) {\r\n                    var subShape = this.style.shapeList[i];\r\n                    if (subShape.isCover(x, y)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n    };\r\n\r\n    require('../tool/util').inherits(ShapeBundle, Base);\r\n    return ShapeBundle;\r\n}); "
        },
        {
          "id": 37,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\config.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/config.js",
          "index": 37,
          "index2": 31,
          "size": 9119,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "18:19-39"
            },
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "17:19-39"
            },
            {
              "moduleId": 44,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "9:19-39"
            },
            {
              "moduleId": 51,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "21:19-39"
            },
            {
              "moduleId": 52,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "16:19-39"
            },
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "16:19-39"
            },
            {
              "moduleId": 59,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "14:19-39"
            },
            {
              "moduleId": 60,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "16:19-39"
            },
            {
              "moduleId": 64,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "14:19-39"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "../config",
              "loc": "20:19-39"
            }
          ],
          "source": "/**\r\n * echarts默认配置项\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function() {\r\n    // 请原谅我这样写，这显然可以直接返回个对象，但那样的话outline就显示不出来了~~\r\n    var config = {\r\n        // 图表类型\r\n        CHART_TYPE_LINE: 'line',\r\n        CHART_TYPE_BAR: 'bar',\r\n        CHART_TYPE_SCATTER: 'scatter',\r\n        CHART_TYPE_PIE: 'pie',\r\n        CHART_TYPE_RADAR: 'radar',\r\n        CHART_TYPE_VENN: 'venn',\r\n        CHART_TYPE_TREEMAP: 'treemap',\r\n        CHART_TYPE_TREE: 'tree',\r\n        CHART_TYPE_MAP: 'map',\r\n        CHART_TYPE_K: 'k',\r\n        CHART_TYPE_ISLAND: 'island',\r\n        CHART_TYPE_FORCE: 'force',\r\n        CHART_TYPE_CHORD: 'chord',\r\n        CHART_TYPE_GAUGE: 'gauge',\r\n        CHART_TYPE_FUNNEL: 'funnel',\r\n        CHART_TYPE_EVENTRIVER: 'eventRiver',\r\n        CHART_TYPE_WORDCLOUD: 'wordCloud',\r\n        CHART_TYPE_HEATMAP: 'heatmap',\r\n\r\n        // 组件类型\r\n        COMPONENT_TYPE_TITLE: 'title',\r\n        COMPONENT_TYPE_LEGEND: 'legend',\r\n        COMPONENT_TYPE_DATARANGE: 'dataRange',\r\n        COMPONENT_TYPE_DATAVIEW: 'dataView',\r\n        COMPONENT_TYPE_DATAZOOM: 'dataZoom',\r\n        COMPONENT_TYPE_TOOLBOX: 'toolbox',\r\n        COMPONENT_TYPE_TOOLTIP: 'tooltip',\r\n        COMPONENT_TYPE_GRID: 'grid',\r\n        COMPONENT_TYPE_AXIS: 'axis',\r\n        COMPONENT_TYPE_POLAR: 'polar',\r\n        COMPONENT_TYPE_X_AXIS: 'xAxis',\r\n        COMPONENT_TYPE_Y_AXIS: 'yAxis',\r\n        COMPONENT_TYPE_AXIS_CATEGORY: 'categoryAxis',\r\n        COMPONENT_TYPE_AXIS_VALUE: 'valueAxis',\r\n        COMPONENT_TYPE_TIMELINE: 'timeline',\r\n        COMPONENT_TYPE_ROAMCONTROLLER: 'roamController',\r\n\r\n        // 全图默认背景\r\n        backgroundColor: 'rgba(0,0,0,0)',\r\n        \r\n        // 默认色板\r\n        color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed',\r\n                '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0',\r\n                '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700',\r\n                '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'],\r\n\r\n        markPoint: {\r\n            clickable: true,\r\n            symbol: 'pin',         // 标注类型\r\n            symbolSize: 10,        // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\r\n            // symbolRotate: null, // 标注旋转控制\r\n            large: false,\r\n            effect: {\r\n                show: false,\r\n                loop: true,\r\n                period: 15,             // 运动周期，无单位，值越大越慢\r\n                type: 'scale',          // 可用为 scale | bounce\r\n                scaleSize: 2,           // 放大倍数，以markPoint点size为基准\r\n                bounceDistance: 10     // 跳动距离，单位px\r\n                // color: 'gold',\r\n                // shadowColor: 'rgba(255,215,0,0.8)',\r\n                // shadowBlur: 0          // 炫光模糊\r\n            },\r\n            itemStyle: {\r\n                normal: {\r\n                    // color: 各异，\r\n                    // borderColor: 各异,        // 标注边线颜色，优先于color \r\n                    borderWidth: 2,             // 标注边线线宽，单位px，默认为1\r\n                    label: {\r\n                        show: true,\r\n                        // 标签文本格式器，同Tooltip.formatter，不支持回调\r\n                        // formatter: null,\r\n                        position: 'inside'      // 可选为'left'|'right'|'top'|'bottom'\r\n                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                    }\r\n                },\r\n                emphasis: {\r\n                    // color: 各异\r\n                    label: {\r\n                        show: true\r\n                        // 标签文本格式器，同Tooltip.formatter，不支持回调\r\n                        // formatter: null,\r\n                        // position: 'inside'  // 'left'|'right'|'top'|'bottom'\r\n                        // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        markLine: {\r\n            clickable: true,\r\n            // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string\r\n            symbol: ['circle', 'arrow'],\r\n            // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\r\n            symbolSize: [2, 4],\r\n            // 标线起始和结束的symbol旋转控制\r\n            //symbolRotate: null,\r\n            //smooth: false,\r\n            smoothness: 0.2,    // 平滑度\r\n            precision: 2,\r\n            effect: {\r\n                show: false,\r\n                loop: true,\r\n                period: 15,                     // 运动周期，无单位，值越大越慢\r\n                scaleSize: 2                    // 放大倍数，以markLine线lineWidth为基准\r\n                // color: 'gold',\r\n                // shadowColor: 'rgba(255,215,0,0.8)',\r\n                // shadowBlur: lineWidth * 2    // 炫光模糊，默认等于scaleSize计算所得\r\n            },\r\n            // 边捆绑\r\n            bundling: {\r\n                enable: false,\r\n                // [0, 90]\r\n                maxTurningAngle: 45\r\n            },\r\n            itemStyle: {\r\n                normal: {\r\n                    // color: 各异,               // 标线主色，线色，symbol主色\r\n                    // borderColor: 随color,     // 标线symbol边框颜色，优先于color \r\n                    borderWidth: 1.5,           // 标线symbol边框线宽，单位px，默认为2\r\n                    label: {\r\n                        show: true,\r\n                        // 标签文本格式器，同Tooltip.formatter，不支持回调\r\n                        // formatter: null,\r\n                        // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'\r\n                        position: 'end'\r\n                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                    },\r\n                    lineStyle: {\r\n                        // color: 随borderColor, // 主色，线色，优先级高于borderColor和color\r\n                        // width: 随borderWidth, // 优先于borderWidth\r\n                        type: 'dashed'\r\n                        // shadowColor: 'rgba(0,0,0,0)', //默认透明\r\n                        // shadowBlur: 0,\r\n                        // shadowOffsetX: 0,\r\n                        // shadowOffsetY: 0\r\n                    }\r\n                },\r\n                emphasis: {\r\n                    // color: 各异\r\n                    label: {\r\n                        show: false\r\n                        // 标签文本格式器，同Tooltip.formatter，不支持回调\r\n                        // formatter: null,\r\n                        // position: 'inside' // 'left'|'right'|'top'|'bottom'\r\n                        // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE\r\n                    },\r\n                    lineStyle: {}\r\n                }\r\n            }\r\n        },\r\n\r\n        // 主题，主题\r\n        textStyle: {\r\n            decoration: 'none',\r\n            fontFamily: 'Arial, Verdana, sans-serif',\r\n            fontFamily2: '微软雅黑',    // IE8- 字体模糊并且，不支持不同字体混排，额外指定一份\r\n            fontSize: 12,\r\n            fontStyle: 'normal',\r\n            fontWeight: 'normal'\r\n        },\r\n\r\n        EVENT: {\r\n            // -------全局通用\r\n            REFRESH: 'refresh',\r\n            RESTORE: 'restore',\r\n            RESIZE: 'resize',\r\n            CLICK: 'click',\r\n            DBLCLICK: 'dblclick',\r\n            HOVER: 'hover',\r\n            MOUSEOUT: 'mouseout',\r\n            //MOUSEWHEEL: 'mousewheel',\r\n            // -------业务交互逻辑\r\n            DATA_CHANGED: 'dataChanged',\r\n            DATA_ZOOM: 'dataZoom',\r\n            DATA_RANGE: 'dataRange',\r\n            DATA_RANGE_SELECTED: 'dataRangeSelected',\r\n            DATA_RANGE_HOVERLINK: 'dataRangeHoverLink',\r\n            LEGEND_SELECTED: 'legendSelected',\r\n            LEGEND_HOVERLINK: 'legendHoverLink',\r\n            MAP_SELECTED: 'mapSelected',\r\n            PIE_SELECTED: 'pieSelected',\r\n            MAGIC_TYPE_CHANGED: 'magicTypeChanged',\r\n            DATA_VIEW_CHANGED: 'dataViewChanged',\r\n            TIMELINE_CHANGED: 'timelineChanged',\r\n            MAP_ROAM: 'mapRoam',\r\n            FORCE_LAYOUT_END: 'forceLayoutEnd',\r\n            // -------内部通信\r\n            TOOLTIP_HOVER: 'tooltipHover',\r\n            TOOLTIP_IN_GRID: 'tooltipInGrid',\r\n            TOOLTIP_OUT_GRID: 'tooltipOutGrid',\r\n            ROAMCONTROLLER: 'roamController'\r\n        },\r\n        DRAG_ENABLE_TIME: 120,   // 降低图表内元素拖拽敏感度，单位ms，不建议外部干预\r\n        EFFECT_ZLEVEL : 10,       // 特效动画zlevel\r\n        effectBlendAlpha: 0.95,\r\n        // 主题，默认标志图形类型列表\r\n        symbolList: [\r\n          'circle', 'rectangle', 'triangle', 'diamond',\r\n          'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'\r\n        ],\r\n        loadingEffect: 'spin',\r\n        loadingText: '数据读取中...',\r\n        noDataEffect: 'bubble',\r\n        noDataText: '暂无数据',\r\n        // noDataLoadingOption: null,\r\n        // 可计算特性配置，孤岛，提示颜色\r\n        calculable: false,                      // 默认关闭可计算特性\r\n        calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色\r\n        calculableHolderColor: '#ccc',          // 可计算占位提示颜色\r\n        nameConnector: ' & ',\r\n        valueConnector: ': ',\r\n        animation: true,                // 过渡动画是否开启\r\n        addDataAnimation: true,         // 动态数据接口是否开启动画效果\r\n        animationThreshold: 2000,       // 动画元素阀值，产生的图形原素超过2000不出动画\r\n        animationDuration: 2000,        // 过渡动画参数：进入\r\n        animationDurationUpdate: 500,   // 过渡动画参数：更新\r\n        animationEasing: 'ExponentialOut'    //BounceOut\r\n    };\r\n\r\n    return config;\r\n});\r\n"
        },
        {
          "id": 38,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecData.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecData.js",
          "index": 38,
          "index2": 32,
          "size": 3105,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "../util/ecData",
              "loc": "62:17-42"
            },
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../util/ecData",
              "loc": "18:17-42"
            },
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "../util/ecData",
              "loc": "9:17-42"
            },
            {
              "moduleId": 44,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "type": "cjs require",
              "userRequest": "../util/ecData",
              "loc": "10:17-42"
            },
            {
              "moduleId": 51,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "type": "cjs require",
              "userRequest": "../util/ecData",
              "loc": "22:17-42"
            },
            {
              "moduleId": 64,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "../util/ecData",
              "loc": "22:17-42"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "../util/ecData",
              "loc": "69:17-42"
            }
          ],
          "source": "/**\r\n * echarts通用私有数据服务\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function() {\r\n    /**\r\n     * 打包私有数据\r\n     *\r\n     * @param {shape} shape 修改目标\r\n     * @param {Object} series\r\n     * @param {number} seriesIndex\r\n     * @param {number | Object} data\r\n     * @param {number} dataIndex\r\n     * @param {*=} special\r\n     * @param {*=} special2\r\n     */\r\n    function pack(\r\n        shape, series, seriesIndex, data, dataIndex, name, special, special2\r\n    ) {\r\n        var value;\r\n        if (typeof data != 'undefined') {\r\n            value = data.value == null\r\n                ? data\r\n                : data.value;\r\n        }\r\n\r\n        shape._echartsData = {\r\n            '_series' : series,\r\n            '_seriesIndex' : seriesIndex,\r\n            '_data' : data,\r\n            '_dataIndex' : dataIndex,\r\n            '_name' : name,\r\n            '_value' : value,\r\n            '_special' : special,\r\n            '_special2' : special2\r\n        };\r\n        return shape._echartsData;\r\n    }\r\n\r\n    /**\r\n     * 从私有数据中获取特定项\r\n     * @param {shape} shape\r\n     * @param {string} key\r\n     */\r\n    function get(shape, key) {\r\n        var data = shape._echartsData;\r\n        if (!key) {\r\n            return data;\r\n        }\r\n\r\n        switch (key) {\r\n            case 'series' :\r\n            case 'seriesIndex' :\r\n            case 'data' :\r\n            case 'dataIndex' :\r\n            case 'name' :\r\n            case 'value' :\r\n            case 'special' :\r\n            case 'special2' :\r\n                return data && data['_' + key];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 修改私有数据中获取特定项\r\n     * @param {shape} shape\r\n     * @param {string} key\r\n     * @param {*} value\r\n     */\r\n    function set(shape, key, value) {\r\n        shape._echartsData = shape._echartsData || {};\r\n        switch (key) {\r\n            case 'series' :             // 当前系列值\r\n            case 'seriesIndex' :        // 系列数组位置索引\r\n            case 'data' :               // 当前数据值\r\n            case 'dataIndex' :          // 数据数组位置索引\r\n            case 'name' :\r\n            case 'value' :\r\n            case 'special' :\r\n            case 'special2' :\r\n                shape._echartsData['_' + key] = value;\r\n                break;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 私有数据克隆，把source拷贝到target上\r\n     * @param {shape} source 源\r\n     * @param {shape} target 目标\r\n     */\r\n    function clone(source, target) {\r\n        target._echartsData =  {\r\n            '_series' : source._echartsData._series,\r\n            '_seriesIndex' : source._echartsData._seriesIndex,\r\n            '_data' : source._echartsData._data,\r\n            '_dataIndex' : source._echartsData._dataIndex,\r\n            '_name' : source._echartsData._name,\r\n            '_value' : source._echartsData._value,\r\n            '_special' : source._echartsData._special,\r\n            '_special2' : source._echartsData._special2\r\n        };\r\n    }\r\n\r\n    return {\r\n        pack : pack,\r\n        set : set,\r\n        get : get,\r\n        clone : clone\r\n    };\r\n});"
        },
        {
          "id": 39,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecAnimation.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
          "index": 39,
          "index2": 33,
          "size": 18835,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../util/ecAnimation",
              "loc": "19:22-52"
            }
          ],
          "source": "/**\r\n * echarts图表动画基类\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var curveTool = require('zrenderjs/tool/curve');\r\n    \r\n    /**\r\n     * 折线型动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function pointList(zr, oldShape, newShape, duration, easing) {\r\n        var newPointList = newShape.style.pointList;\r\n        var newPointListLen = newPointList.length;\r\n        var oldPointList;\r\n\r\n        if (!oldShape) {        // add\r\n            oldPointList = [];\r\n            if (newShape._orient != 'vertical') {\r\n                var y = newPointList[0][1];\r\n                for (var i = 0; i < newPointListLen; i++) {\r\n                    oldPointList[i] = [newPointList[i][0], y];\r\n                }\r\n            }\r\n            else {\r\n                var x = newPointList[0][0];\r\n                for (var i = 0; i < newPointListLen; i++) {\r\n                    oldPointList[i] = [x, newPointList[i][1]];\r\n                }\r\n            }\r\n\r\n            if (newShape.type == 'half-smooth-polygon') {\r\n                oldPointList[newPointListLen - 1] = zrUtil.clone(newPointList[newPointListLen - 1]);\r\n                oldPointList[newPointListLen - 2] = zrUtil.clone(newPointList[newPointListLen - 2]);\r\n            }\r\n            oldShape = {style : {pointList : oldPointList}};\r\n        }\r\n        \r\n        oldPointList = oldShape.style.pointList;\r\n        var oldPointListLen = oldPointList.length;\r\n        if (oldPointListLen == newPointListLen) {\r\n            newShape.style.pointList = oldPointList;\r\n        }\r\n        else if (oldPointListLen < newPointListLen) {\r\n            // 原来短，新的长，补全\r\n            newShape.style.pointList = oldPointList.concat(newPointList.slice(oldPointListLen));\r\n        }\r\n        else {\r\n            // 原来长，新的短，截断\r\n            newShape.style.pointList = oldPointList.slice(0, newPointListLen);\r\n        }\r\n\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                { pointList: newPointList }\r\n            )\r\n            .during(function () {\r\n                // Updating bezier points\r\n                if (newShape.updateControlPoints) {\r\n                    newShape.updateControlPoints(newShape.style);\r\n                }\r\n            })\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 复制样式\r\n     * \r\n     * @inner\r\n     * @param {Object} target 目标对象\r\n     * @param {Object} source 源对象\r\n     * @param {...string} props 复制的属性列表\r\n     */\r\n    function cloneStyle(target, source) {\r\n        var len = arguments.length;\r\n        for (var i = 2; i < len; i++) {\r\n            var prop = arguments[i];\r\n            target.style[prop] = source.style[prop];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 方型动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function rectangle(zr, oldShape, newShape, duration, easing) {\r\n        var newShapeStyle = newShape.style;\r\n        if (!oldShape) {        // add\r\n            oldShape = {\r\n                position : newShape.position,\r\n                style : {\r\n                    x : newShapeStyle.x,\r\n                    y : newShape._orient == 'vertical'\r\n                        ? newShapeStyle.y + newShapeStyle.height\r\n                        : newShapeStyle.y,\r\n                    width: newShape._orient == 'vertical' \r\n                           ? newShapeStyle.width : 0,\r\n                    height: newShape._orient != 'vertical' \r\n                           ? newShapeStyle.height : 0\r\n                }\r\n            };\r\n        }\r\n        \r\n        var newX = newShapeStyle.x;\r\n        var newY = newShapeStyle.y;\r\n        var newWidth = newShapeStyle.width;\r\n        var newHeight = newShapeStyle.height;\r\n        var newPosition = [newShape.position[0], newShape.position[1]];\r\n        cloneStyle(\r\n            newShape, oldShape,\r\n            'x', 'y', 'width', 'height'\r\n        );\r\n        newShape.position = oldShape.position;\r\n\r\n        zr.addShape(newShape);\r\n        if (newPosition[0] != oldShape.position[0] || newPosition[1] != oldShape.position[1]) {\r\n            zr.animate(newShape.id, '')\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        position: newPosition\r\n                    }\r\n                )\r\n                .start(easing);\r\n        }\r\n        \r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    x: newX,\r\n                    y: newY,\r\n                    width: newWidth,\r\n                    height: newHeight\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 蜡烛动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function candle(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            var y = newShape.style.y;\r\n            oldShape = {style : {y : [y[0], y[0], y[0], y[0]]}};\r\n        }\r\n        \r\n        var newY = newShape.style.y;\r\n        newShape.style.y = oldShape.style.y;\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                { y: newY }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n\r\n    /**\r\n     * 环型动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function ring(zr, oldShape, newShape, duration, easing) {\r\n        var x = newShape.style.x;\r\n        var y = newShape.style.y;\r\n        var r0 = newShape.style.r0;\r\n        var r = newShape.style.r;\r\n        \r\n        newShape.__animating = true;\r\n\r\n        if (newShape._animationAdd != 'r') {\r\n            newShape.style.r0 = 0;\r\n            newShape.style.r = 0;\r\n            newShape.rotation = [Math.PI*2, x, y];\r\n            \r\n            zr.addShape(newShape);\r\n            zr.animate(newShape.id, 'style')\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        r0 : r0,\r\n                        r : r\r\n                    }\r\n                )\r\n                .done(function() {\r\n                    newShape.__animating = false;\r\n                })\r\n                .start(easing);\r\n            zr.animate(newShape.id, '')\r\n                .when(\r\n                    duration,\r\n                    { rotation : [0, x, y] }\r\n                )\r\n                .start(easing);\r\n        }\r\n        else {\r\n            newShape.style.r0 = newShape.style.r;\r\n            \r\n            zr.addShape(newShape);\r\n            zr.animate(newShape.id, 'style')\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        r0 : r0\r\n                    }\r\n                )\r\n                .done(function() {\r\n                    newShape.__animating = false;\r\n                })\r\n                .start(easing);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 扇形动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function sector(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            if (newShape._animationAdd != 'r') {\r\n                oldShape = {\r\n                    style : {\r\n                        startAngle : newShape.style.startAngle,\r\n                        endAngle : newShape.style.startAngle\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                oldShape = {style : {r0 : newShape.style.r}};\r\n            }\r\n        }\r\n        \r\n        var startAngle = newShape.style.startAngle;\r\n        var endAngle = newShape.style.endAngle;\r\n        \r\n        cloneStyle(\r\n            newShape, oldShape,\r\n            'startAngle', 'endAngle'\r\n        );\r\n        \r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    startAngle : startAngle,\r\n                    endAngle : endAngle\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 文本动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function text(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            oldShape = {\r\n                style : {\r\n                    x : newShape.style.textAlign == 'left' \r\n                        ? newShape.style.x + 100\r\n                        : newShape.style.x - 100,\r\n                    y : newShape.style.y\r\n                }\r\n            };\r\n        }\r\n        \r\n        var x = newShape.style.x;\r\n        var y = newShape.style.y;\r\n        \r\n        cloneStyle(\r\n            newShape, oldShape,\r\n            'x', 'y'\r\n        );\r\n        \r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    x : x,\r\n                    y : y\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 多边形动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function polygon(zr, oldShape, newShape, duration, easing) {\r\n        var rect = require('zrenderjs/shape/Polygon').prototype.getRect(newShape.style);\r\n        var x = rect.x + rect.width / 2;\r\n        var y = rect.y + rect.height / 2;\r\n        \r\n        newShape.scale = [0.1, 0.1, x, y];\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, '')\r\n            .when(\r\n                duration,\r\n                {\r\n                    scale : [1, 1, x, y]\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 和弦动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function ribbon(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            oldShape = {\r\n                style : {\r\n                    source0 : 0,\r\n                    source1 : newShape.style.source1 > 0 ? 360 : -360,\r\n                    target0 : 0,\r\n                    target1 : newShape.style.target1 > 0 ? 360 : -360\r\n                }\r\n            };\r\n        }\r\n        \r\n        var source0 = newShape.style.source0;\r\n        var source1 = newShape.style.source1;\r\n        var target0 = newShape.style.target0;\r\n        var target1 = newShape.style.target1;\r\n        \r\n        if (oldShape.style) {\r\n            cloneStyle(\r\n                newShape, oldShape,\r\n                'source0', 'source1', 'target0', 'target1'\r\n            );\r\n        }\r\n        \r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    source0 : source0,\r\n                    source1 : source1,\r\n                    target0 : target0,\r\n                    target1 : target1\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * gaugePointer动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function gaugePointer(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            oldShape = {\r\n                style : {\r\n                    angle : newShape.style.startAngle\r\n                }\r\n            };\r\n        }\r\n        \r\n        var angle = newShape.style.angle;\r\n        newShape.style.angle = oldShape.style.angle;\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    angle : angle\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * icon动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function icon(zr, oldShape, newShape, duration, easing, delay) {\r\n        // 避免markPoint特效取值在动画帧上\r\n        newShape.style._x = newShape.style.x;\r\n        newShape.style._y = newShape.style.y;\r\n        newShape.style._width = newShape.style.width;\r\n        newShape.style._height = newShape.style.height;\r\n\r\n        if (!oldShape) {    // add\r\n            var x = newShape._x || 0;\r\n            var y = newShape._y || 0;\r\n            newShape.scale = [0.01, 0.01, x, y];\r\n            zr.addShape(newShape);\r\n            newShape.__animating = true;\r\n            zr.animate(newShape.id, '')\r\n                .delay(delay)\r\n                .when(\r\n                    duration,\r\n                    {scale : [1, 1, x, y]}\r\n                )\r\n                .done(function() {\r\n                    newShape.__animating = false;\r\n                })\r\n                .start(easing || 'QuinticOut');\r\n        }\r\n        else {              // mod\r\n            rectangle(zr, oldShape, newShape, duration, easing);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * line动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function line(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {\r\n            oldShape = {\r\n                style : {\r\n                    xStart : newShape.style.xStart,\r\n                    yStart : newShape.style.yStart,\r\n                    xEnd : newShape.style.xStart,\r\n                    yEnd : newShape.style.yStart\r\n                }\r\n            };\r\n        }\r\n        \r\n        var xStart = newShape.style.xStart;\r\n        var xEnd = newShape.style.xEnd;\r\n        var yStart = newShape.style.yStart;\r\n        var yEnd = newShape.style.yEnd;\r\n\r\n        cloneStyle(\r\n            newShape, oldShape,\r\n            'xStart', 'xEnd', 'yStart', 'yEnd'\r\n        );\r\n\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    xStart: xStart,\r\n                    xEnd: xEnd,\r\n                    yStart: yStart,\r\n                    yEnd: yEnd\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * markline动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function markline(zr, oldShape, newShape, duration, easing) {\r\n        easing = easing || 'QuinticOut';\r\n        newShape.__animating = true;\r\n        zr.addShape(newShape);\r\n        var newShapeStyle = newShape.style;\r\n\r\n        var animationDone = function () {\r\n            newShape.__animating = false;\r\n        };\r\n        var x0 = newShapeStyle.xStart;\r\n        var y0 = newShapeStyle.yStart;\r\n        var x2 = newShapeStyle.xEnd;\r\n        var y2 = newShapeStyle.yEnd;\r\n        if (newShapeStyle.curveness > 0) {\r\n            newShape.updatePoints(newShapeStyle);\r\n            var obj = { p: 0 };\r\n            var x1 = newShapeStyle.cpX1;\r\n            var y1 = newShapeStyle.cpY1;\r\n            var newXArr = [];\r\n            var newYArr = [];\r\n            var subdivide = curveTool.quadraticSubdivide;\r\n            zr.animation.animate(obj)\r\n                .when(duration, { p: 1 })\r\n                .during(function () {\r\n                    // Calculate subdivided curve\r\n                    subdivide(x0, x1, x2, obj.p, newXArr);\r\n                    subdivide(y0, y1, y2, obj.p, newYArr);\r\n                    newShapeStyle.cpX1 = newXArr[1];\r\n                    newShapeStyle.cpY1 = newYArr[1];\r\n                    newShapeStyle.xEnd = newXArr[2];\r\n                    newShapeStyle.yEnd = newYArr[2];\r\n                    zr.modShape(newShape);\r\n                })\r\n                .done(animationDone)\r\n                .start(easing);\r\n        }\r\n        else {\r\n            zr.animate(newShape.id, 'style')\r\n                .when(0, {\r\n                    xEnd: x0,\r\n                    yEnd: y0\r\n                })\r\n                .when(duration, {\r\n                    xEnd: x2,\r\n                    yEnd: y2\r\n                })\r\n                .done(animationDone)\r\n                .start(easing);\r\n        }\r\n    }\r\n\r\n    return {\r\n        pointList : pointList,\r\n        rectangle : rectangle,\r\n        candle : candle,\r\n        ring : ring,\r\n        sector : sector,\r\n        text : text,\r\n        polygon : polygon,\r\n        ribbon : ribbon,\r\n        gaugePointer : gaugePointer,\r\n        icon : icon,\r\n        line : line,\r\n        markline : markline\r\n    };\r\n});\r\n"
        },
        {
          "id": 40,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "index": 40,
          "index2": 36,
          "size": 16377,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../util/ecEffect",
              "loc": "20:19-46"
            }
          ],
          "source": "/**\r\n * echarts图表特效基类\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ecData = require('../util/ecData');\r\n    \r\n    var CircleShape = require('zrenderjs/shape/Circle');\r\n    var ImageShape = require('zrenderjs/shape/Image');\r\n    var curveTool = require('zrenderjs/tool/curve');\r\n    var IconShape = require('../util/shape/Icon');\r\n    var SymbolShape = require('../util/shape/Symbol');\r\n    var ShapeBundle = require('zrenderjs/shape/ShapeBundle');\r\n    var Polyline = require('zrenderjs/shape/Polyline');\r\n    var vec2 = require('zrenderjs/tool/vector');\r\n\r\n    var canvasSupported = require('zrenderjs/tool/env').canvasSupported;\r\n    \r\n    function point(zr, effectList, shape, zlevel) {\r\n        var effect = shape.effect;\r\n        var color = effect.color || shape.style.strokeColor || shape.style.color;\r\n        var shadowColor = effect.shadowColor || color;\r\n        var size = effect.scaleSize;\r\n        var distance = effect.bounceDistance;\r\n        var shadowBlur = typeof effect.shadowBlur != 'undefined'\r\n                         ? effect.shadowBlur : size;\r\n\r\n        var effectShape;\r\n        if (shape.type !== 'image') {\r\n            effectShape = new IconShape({\r\n                zlevel : zlevel,\r\n                style : {\r\n                    brushType : 'stroke',\r\n                    iconType : shape.style.iconType != 'droplet'\r\n                               ? shape.style.iconType\r\n                               : 'circle',\r\n                    x : shadowBlur + 1, // 线宽\r\n                    y : shadowBlur + 1,\r\n                    n : shape.style.n,\r\n                    width : shape.style._width * size,\r\n                    height : shape.style._height * size,\r\n                    lineWidth : 1,\r\n                    strokeColor : color,\r\n                    shadowColor : shadowColor,\r\n                    shadowBlur : shadowBlur\r\n                },\r\n                draggable : false,\r\n                hoverable : false\r\n            });\r\n            if (shape.style.iconType == 'pin') {\r\n                effectShape.style.y += effectShape.style.height / 2 * 1.5;\r\n            }\r\n\r\n            if (canvasSupported) {  // 提高性能，换成image\r\n                effectShape.style.image = zr.shapeToImage(\r\n                    effectShape, \r\n                    effectShape.style.width + shadowBlur * 2 + 2, \r\n                    effectShape.style.height + shadowBlur * 2 + 2\r\n                ).style.image;\r\n                \r\n                effectShape = new ImageShape({\r\n                    zlevel : effectShape.zlevel,\r\n                    style : effectShape.style,\r\n                    draggable : false,\r\n                    hoverable : false\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            effectShape = new ImageShape({\r\n                zlevel : zlevel,\r\n                style : shape.style,\r\n                draggable : false,\r\n                hoverable : false\r\n            });\r\n        }\r\n        \r\n        ecData.clone(shape, effectShape);\r\n        \r\n        // 改变坐标，不能移到前面\r\n        effectShape.position = shape.position;\r\n        effectList.push(effectShape);\r\n        zr.addShape(effectShape);\r\n        \r\n        var devicePixelRatio = shape.type !== 'image' ? (window.devicePixelRatio || 1) : 1;\r\n        var offset = (effectShape.style.width / devicePixelRatio - shape.style._width) / 2;\r\n        effectShape.style.x = shape.style._x - offset;\r\n        effectShape.style.y = shape.style._y - offset;\r\n\r\n        if (shape.style.iconType == 'pin') {\r\n            effectShape.style.y -= shape.style.height / 2 * 1.5;\r\n        }\r\n\r\n        var duration = (effect.period + Math.random() * 10) * 100;\r\n        \r\n        zr.modShape(\r\n            shape.id, \r\n            { invisible : true}\r\n        );\r\n        \r\n        var centerX = effectShape.style.x + (effectShape.style.width) / 2 / devicePixelRatio;\r\n        var centerY = effectShape.style.y + (effectShape.style.height) / 2 / devicePixelRatio;\r\n\r\n        if (effect.type === 'scale') {\r\n            // 放大效果\r\n            zr.modShape(\r\n                effectShape.id, \r\n                {\r\n                    scale : [0.1, 0.1, centerX, centerY]\r\n                }\r\n            );\r\n            \r\n            zr.animate(effectShape.id, '', effect.loop)\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        scale : [1, 1, centerX, centerY]\r\n                    }\r\n                )\r\n                .done(function() {\r\n                    shape.effect.show = false;\r\n                    zr.delShape(effectShape.id);\r\n                })\r\n                .start();\r\n        }\r\n        else {\r\n            zr.animate(effectShape.id, 'style', effect.loop)\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        y : effectShape.style.y - distance\r\n                    }\r\n                )\r\n                .when(\r\n                    duration * 2,\r\n                    {\r\n                        y : effectShape.style.y\r\n                    }\r\n                )\r\n                .done(function() {\r\n                    shape.effect.show = false;\r\n                    zr.delShape(effectShape.id);\r\n                })\r\n                .start();\r\n        }\r\n        \r\n    }\r\n    \r\n    function largePoint(zr, effectList, shape, zlevel) {\r\n        var effect = shape.effect;\r\n        var color = effect.color || shape.style.strokeColor || shape.style.color;\r\n        var size = effect.scaleSize;\r\n        var shadowColor = effect.shadowColor || color;\r\n        var shadowBlur = typeof effect.shadowBlur != 'undefined'\r\n                         ? effect.shadowBlur : (size * 2);\r\n        var devicePixelRatio = window.devicePixelRatio || 1;\r\n        var effectShape = new SymbolShape({\r\n            zlevel : zlevel,\r\n            position : shape.position,\r\n            scale : shape.scale,\r\n            style : {\r\n                pointList : shape.style.pointList,\r\n                iconType : shape.style.iconType,\r\n                color : color,\r\n                strokeColor : color,\r\n                shadowColor : shadowColor,\r\n                shadowBlur : shadowBlur * devicePixelRatio,\r\n                random : true,\r\n                brushType: 'fill',\r\n                lineWidth:1,\r\n                size : shape.style.size\r\n            },\r\n            draggable : false,\r\n            hoverable : false\r\n        });\r\n        \r\n        effectList.push(effectShape);\r\n        zr.addShape(effectShape);\r\n        zr.modShape(\r\n            shape.id, \r\n            { invisible : true}\r\n        );\r\n        \r\n        var duration = Math.round(effect.period * 100);\r\n        var clip1 = {};\r\n        var clip2 = {};\r\n        for (var i = 0; i < 20; i++) {\r\n            effectShape.style['randomMap' + i] = 0;\r\n            clip1 = {};\r\n            clip1['randomMap' + i] = 100;\r\n            clip2 = {};\r\n            clip2['randomMap' + i] = 0;\r\n            effectShape.style['randomMap' + i] = Math.random() * 100;\r\n            zr.animate(effectShape.id, 'style', true)\r\n                .when(duration, clip1)\r\n                .when(duration * 2, clip2)\r\n                .when(duration * 3, clip1)\r\n                .when(duration * 4, clip1)\r\n                .delay(Math.random() * duration * i)\r\n                //.delay(duration / 15 * (15 - i + 1))\r\n                .start();\r\n            \r\n        }\r\n    }\r\n    \r\n    function line(zr, effectList, shape, zlevel, isLarge) {\r\n        var effect = shape.effect;\r\n        var shapeStyle = shape.style;\r\n        var color = effect.color || shapeStyle.strokeColor || shapeStyle.color;\r\n        var shadowColor = effect.shadowColor || shapeStyle.strokeColor || color;\r\n        var size = shapeStyle.lineWidth * effect.scaleSize;\r\n        var shadowBlur = typeof effect.shadowBlur != 'undefined'\r\n                         ? effect.shadowBlur : size;\r\n\r\n        var effectShape = new CircleShape({\r\n            zlevel : zlevel,\r\n            style : {\r\n                x : shadowBlur,\r\n                y : shadowBlur,\r\n                r : size,\r\n                color : color,\r\n                shadowColor : shadowColor,\r\n                shadowBlur : shadowBlur\r\n            },\r\n            hoverable : false\r\n        });\r\n\r\n        var offset = 0;\r\n        if (canvasSupported && ! isLarge) {  // 提高性能，换成image\r\n            var zlevel = effectShape.zlevel;\r\n            effectShape = zr.shapeToImage(\r\n                effectShape,\r\n                (size + shadowBlur) * 2,\r\n                (size + shadowBlur) * 2\r\n            );\r\n            effectShape.zlevel = zlevel;\r\n            effectShape.hoverable = false;\r\n\r\n            offset = shadowBlur;\r\n        }\r\n\r\n        if (! isLarge) {\r\n            ecData.clone(shape, effectShape);\r\n            // 改变坐标， 不能移到前面\r\n            effectShape.position = shape.position;\r\n            effectList.push(effectShape);\r\n            zr.addShape(effectShape);\r\n        }\r\n\r\n        var effectDone = function () {\r\n            if (! isLarge) {\r\n                shape.effect.show = false;\r\n                zr.delShape(effectShape.id);   \r\n            }\r\n            effectShape.effectAnimator = null;\r\n        };\r\n\r\n        if (shape instanceof Polyline) {\r\n            var distanceList = [0];\r\n            var totalDist = 0;\r\n            var pointList = shapeStyle.pointList;\r\n            var controlPointList = shapeStyle.controlPointList;\r\n            for (var i = 1; i < pointList.length; i++) {\r\n                if (controlPointList) {\r\n                    var cp1 = controlPointList[(i - 1) * 2];\r\n                    var cp2 = controlPointList[(i - 1) * 2 + 1];\r\n                    totalDist += vec2.dist(pointList[i - 1], cp1)\r\n                         + vec2.dist(cp1, cp2)\r\n                         + vec2.dist(cp2, pointList[i]);\r\n                }\r\n                else {\r\n                    totalDist += vec2.dist(pointList[i - 1], pointList[i]);\r\n                }\r\n                distanceList.push(totalDist);\r\n            }\r\n            var obj = { p: 0 };\r\n            var animator = zr.animation.animate(obj, { loop: effect.loop });\r\n\r\n            for (var i = 0; i < distanceList.length; i++) {\r\n                animator.when(distanceList[i] * effect.period, { p: i });\r\n            }\r\n            animator.during(function () {\r\n                var i = Math.floor(obj.p);\r\n                var x, y;\r\n                if (i == pointList.length - 1) {\r\n                    x = pointList[i][0];\r\n                    y = pointList[i][1];\r\n                }\r\n                else {\r\n                    var t = obj.p - i;\r\n                    var p0 = pointList[i];\r\n                    var p1 = pointList[i + 1];\r\n                    if (controlPointList) {\r\n                        var cp1 = controlPointList[i * 2];\r\n                        var cp2 = controlPointList[i * 2 + 1];\r\n                        x = curveTool.cubicAt(\r\n                            p0[0], cp1[0], cp2[0], p1[0], t\r\n                        );\r\n                        y = curveTool.cubicAt(\r\n                            p0[1], cp1[1], cp2[1], p1[1], t\r\n                        );\r\n                    }\r\n                    else {\r\n                        x = (p1[0] - p0[0]) * t + p0[0];\r\n                        y = (p1[1] - p0[1]) * t + p0[1];   \r\n                    }\r\n                }\r\n                effectShape.style.x = x;\r\n                effectShape.style.y = y;\r\n                if (! isLarge) {\r\n                    zr.modShape(effectShape);\r\n                }\r\n            })\r\n            .done(effectDone)\r\n            .start();\r\n\r\n            animator.duration = totalDist * effect.period;\r\n\r\n            effectShape.effectAnimator = animator;\r\n        }\r\n        else {\r\n            var x0 = shapeStyle.xStart - offset;\r\n            var y0 = shapeStyle.yStart - offset;\r\n            var x2 = shapeStyle.xEnd - offset;\r\n            var y2 = shapeStyle.yEnd - offset;\r\n            effectShape.style.x = x0;\r\n            effectShape.style.y = y0;\r\n\r\n            var distance = (x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0);\r\n            var duration = Math.round(Math.sqrt(Math.round(\r\n                distance * effect.period * effect.period\r\n            )));\r\n\r\n            if (shape.style.curveness > 0) {\r\n                var x1 = shapeStyle.cpX1 - offset;\r\n                var y1 = shapeStyle.cpY1 - offset;\r\n                effectShape.effectAnimator = zr.animation.animate(effectShape, { loop: effect.loop })\r\n                    .when(duration, { p: 1 })\r\n                    .during(function (target, t) {\r\n                        effectShape.style.x = curveTool.quadraticAt(\r\n                            x0, x1, x2, t\r\n                        );\r\n                        effectShape.style.y = curveTool.quadraticAt(\r\n                            y0, y1, y2, t\r\n                        );\r\n                        if (! isLarge) {\r\n                            zr.modShape(effectShape);\r\n                        }\r\n                    })\r\n                    .done(effectDone)\r\n                    .start();\r\n            }\r\n            else {\r\n                // 不用 zr.animate，因为在用 ShapeBundle 的时候单个 effectShape 不会\r\n                // 被加到 zrender 中\r\n                effectShape.effectAnimator = zr.animation.animate(effectShape.style, { loop: effect.loop })\r\n                    .when(duration, {\r\n                        x: x2,\r\n                        y: y2\r\n                    })\r\n                    .during(function () {\r\n                        if (! isLarge) {\r\n                            zr.modShape(effectShape);\r\n                        }\r\n                    })\r\n                    .done(effectDone)\r\n                    .start();\r\n            }\r\n            effectShape.effectAnimator.duration = duration;\r\n        }\r\n        return effectShape;\r\n    }\r\n\r\n    function largeLine(zr, effectList, shape, zlevel) {\r\n        var effectShape = new ShapeBundle({\r\n            style: {\r\n                shapeList: []\r\n            },\r\n            zlevel: zlevel,\r\n            hoverable: false\r\n        });\r\n        var shapeList = shape.style.shapeList;\r\n        var effect = shape.effect;\r\n        effectShape.position = shape.position;\r\n\r\n        var maxDuration = 0;\r\n        var subEffectAnimators = [];\r\n        for (var i = 0; i < shapeList.length; i++) {\r\n            shapeList[i].effect = effect;\r\n            var subEffectShape = line(zr, null, shapeList[i], zlevel, true);\r\n            var subEffectAnimator = subEffectShape.effectAnimator;\r\n            effectShape.style.shapeList.push(subEffectShape);\r\n            if (subEffectAnimator.duration > maxDuration) {\r\n                maxDuration = subEffectAnimator.duration;\r\n            }\r\n            if (i === 0) {\r\n                effectShape.style.color = subEffectShape.style.color;\r\n                effectShape.style.shadowBlur = subEffectShape.style.shadowBlur;\r\n                effectShape.style.shadowColor = subEffectShape.style.shadowColor;\r\n            }\r\n            subEffectAnimators.push(subEffectAnimator);\r\n        }\r\n        effectList.push(effectShape);\r\n        zr.addShape(effectShape);\r\n\r\n        var clearAllAnimators = function () {\r\n            for (var i = 0; i < subEffectAnimators.length; i++) {\r\n                subEffectAnimators[i].stop();\r\n            }\r\n        };\r\n        if (maxDuration) {\r\n            effectShape.__dummy = 0;\r\n            // Proxy animator\r\n            var animator = zr.animate(effectShape.id, '', effect.loop)\r\n                .when(maxDuration, {\r\n                    __dummy: 1\r\n                })\r\n                .during(function () {\r\n                    zr.modShape(effectShape);\r\n                })\r\n                .done(function () {\r\n                    shape.effect.show = false;\r\n                    zr.delShape(effectShape.id);\r\n                })\r\n                .start();\r\n            var oldStop = animator.stop;\r\n\r\n            animator.stop = function () {\r\n                clearAllAnimators();\r\n                oldStop.call(this);\r\n            };\r\n        }\r\n    }\r\n\r\n    return {\r\n        point : point,\r\n        largePoint : largePoint,\r\n        line : line,\r\n        largeLine: largeLine\r\n    };\r\n});\r\n"
        },
        {
          "id": 41,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Circle.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
          "index": 41,
          "index2": 34,
          "size": 4026,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Circle",
              "loc": "11:22-55"
            },
            {
              "moduleId": 64,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Circle",
              "loc": "12:22-55"
            }
          ],
          "source": "/**\r\n * 圆形\r\n * @module zrender/shape/Circle\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *   var Circle = require('zrender/shape/Circle');\r\n *   var shape = new Circle({\r\n *       style: {\r\n *           x: 100,\r\n *           y: 100,\r\n *           r: 40,\r\n *           brushType: 'both',\r\n *           color: 'blue',\r\n *           strokeColor: 'red',\r\n *           lineWidth: 3,\r\n *           text: 'Circle'\r\n *       }    \r\n *   });\r\n *   zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} ICircleStyle\r\n * @property {number} x 圆心x坐标\r\n * @property {number} y 圆心y坐标\r\n * @property {number} r 半径\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        'use strict';\r\n\r\n        var Base = require('./Base');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Circle\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Circle = function(options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 圆形绘制样式\r\n             * @name module:zrender/shape/Circle#style\r\n             * @type {module:zrender/shape/Circle~ICircleStyle}\r\n             */\r\n            /**\r\n             * 圆形高亮绘制样式\r\n             * @name module:zrender/shape/Circle#highlightStyle\r\n             * @type {module:zrender/shape/Circle~ICircleStyle}\r\n             */\r\n        };\r\n\r\n        Circle.prototype = {\r\n            type: 'circle',\r\n            /**\r\n             * 创建圆形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Circle~ICircleStyle} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                // Better stroking in ShapeBundle\r\n                ctx.moveTo(style.x + style.r, style.y);\r\n                ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, true);\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 计算返回圆形的包围盒矩形\r\n             * @param {module:zrender/shape/Circle~ICircleStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var lineWidth;\r\n                if (style.brushType == 'stroke' || style.brushType == 'fill') {\r\n                    lineWidth = style.lineWidth || 1;\r\n                }\r\n                else {\r\n                    lineWidth = 0;\r\n                }\r\n                style.__rect = {\r\n                    x : Math.round(style.x - style.r - lineWidth / 2),\r\n                    y : Math.round(style.y - style.r - lineWidth / 2),\r\n                    width : style.r * 2 + lineWidth,\r\n                    height : style.r * 2 + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Circle, Base);\r\n        return Circle;\r\n    }\r\n);\r\n"
        },
        {
          "id": 42,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\env.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/env.js",
          "index": 42,
          "index2": 35,
          "size": 4079,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 40,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/env",
              "loc": "20:26-55"
            },
            {
              "moduleId": 44,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/env",
              "loc": "56:25-54"
            }
          ],
          "source": "/**\r\n * echarts设备环境识别\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author firede[firede@firede.us]\r\n * @desc thanks zepto.\r\n */\r\ndefine(function() {\r\n    // Zepto.js\r\n    // (c) 2010-2013 Thomas Fuchs\r\n    // Zepto.js may be freely distributed under the MIT license.\r\n\r\n    function detect(ua) {\r\n        var os = this.os = {};\r\n        var browser = this.browser = {};\r\n        var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\r\n        var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\r\n        var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\r\n        var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\r\n        var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\r\n        var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\r\n        var touchpad = webos && ua.match(/TouchPad/);\r\n        var kindle = ua.match(/Kindle\\/([\\d.]+)/);\r\n        var silk = ua.match(/Silk\\/([\\d._]+)/);\r\n        var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\r\n        var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\r\n        var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\r\n        var playbook = ua.match(/PlayBook/);\r\n        var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\r\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\r\n        var ie = ua.match(/MSIE ([\\d.]+)/);\r\n        var safari = webkit && ua.match(/Mobile\\//) && !chrome;\r\n        var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\r\n        var ie = ua.match(/MSIE\\s([\\d.]+)/);\r\n\r\n        // Todo: clean this up with a better OS/browser seperation:\r\n        // - discern (more) between multiple browsers on android\r\n        // - decide if kindle fire in silk mode is android or not\r\n        // - Firefox on Android doesn't specify the Android version\r\n        // - possibly devide in os, device and browser hashes\r\n\r\n        if (browser.webkit = !!webkit) browser.version = webkit[1];\r\n\r\n        if (android) os.android = true, os.version = android[2];\r\n        if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\r\n        if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\r\n        if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\r\n        if (webos) os.webos = true, os.version = webos[2];\r\n        if (touchpad) os.touchpad = true;\r\n        if (blackberry) os.blackberry = true, os.version = blackberry[2];\r\n        if (bb10) os.bb10 = true, os.version = bb10[2];\r\n        if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\r\n        if (playbook) browser.playbook = true;\r\n        if (kindle) os.kindle = true, os.version = kindle[1];\r\n        if (silk) browser.silk = true, browser.version = silk[1];\r\n        if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\r\n        if (chrome) browser.chrome = true, browser.version = chrome[1];\r\n        if (firefox) browser.firefox = true, browser.version = firefox[1];\r\n        if (ie) browser.ie = true, browser.version = ie[1];\r\n        if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\r\n        if (webview) browser.webview = true;\r\n        if (ie) browser.ie = true, browser.version = ie[1];\r\n\r\n        os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\r\n            (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\r\n        os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 ||\r\n            (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\r\n            (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\r\n\r\n        return {\r\n            browser: browser,\r\n            os: os,\r\n            // 原生canvas支持，改极端点了\r\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\r\n            canvasSupported : document.createElement('canvas').getContext ? true : false\r\n        };\r\n    }\r\n\r\n    return detect(navigator.userAgent);\r\n});"
        },
        {
          "id": 43,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\accMath.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/accMath.js",
          "index": 43,
          "index2": 37,
          "size": 2091,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../util/accMath",
              "loc": "21:18-44"
            },
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "../util/accMath",
              "loc": "763:26-52"
            },
            {
              "moduleId": 64,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "../util/accMath",
              "loc": "82:26-52"
            }
          ],
          "source": "/**\r\n * 高精度数学运算\r\n */\r\ndefine(function() {\r\n    // 除法函数，用来得到精确的除法结果 \r\n    // 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 \r\n    // 调用：accDiv(arg1,arg2) \r\n    // 返回值：arg1除以arg2的精确结果\r\n    function accDiv(arg1,arg2){\r\n        var s1 = arg1.toString();\r\n        var s2 = arg2.toString(); \r\n        var m = 0;\r\n        try {\r\n            m = s2.split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        try {\r\n            m -= s1.split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        \r\n        return (s1.replace('.', '') - 0) / (s2.replace('.', '') - 0) * Math.pow(10, m);\r\n    }\r\n\r\n    // 乘法函数，用来得到精确的乘法结果\r\n    // 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 \r\n    // 调用：accMul(arg1,arg2) \r\n    // 返回值：arg1乘以arg2的精确结果\r\n    function accMul(arg1, arg2) {\r\n        var s1 = arg1.toString();\r\n        var s2 = arg2.toString();\r\n        var m = 0;\r\n        try {\r\n            m += s1.split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        try {\r\n            m += s2.split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        \r\n        return (s1.replace('.', '') - 0) * (s2.replace('.', '') - 0) / Math.pow(10, m);\r\n    }\r\n\r\n    // 加法函数，用来得到精确的加法结果 \r\n    // 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 \r\n    // 调用：accAdd(arg1,arg2) \r\n    // 返回值：arg1加上arg2的精确结果 \r\n    function accAdd(arg1, arg2) {\r\n        var r1 = 0;\r\n        var r2 = 0;\r\n        try {\r\n            r1 = arg1.toString().split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        try {\r\n            r2 = arg2.toString().split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        \r\n        var m = Math.pow(10, Math.max(r1, r2));\r\n        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m; \r\n    }\r\n\r\n    //减法函数，用来得到精确的减法结果 \r\n    //说明：javascript的减法结果会有误差，在两个浮点数减法的时候会比较明显。这个函数返回较为精确的减法结果。 \r\n    //调用：accSub(arg1,arg2) \r\n    //返回值：arg1减法arg2的精确结果 \r\n    function accSub(arg1,arg2) {\r\n        return accAdd(arg1, -arg2);\r\n    }\r\n\r\n    return {\r\n        accDiv : accDiv,\r\n        accMul : accMul,\r\n        accAdd : accAdd,\r\n        accSub : accSub\r\n    };\r\n});"
        },
        {
          "id": 44,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "index": 44,
          "index2": 40,
          "size": 7851,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../component/base",
              "loc": "22:24-52"
            },
            {
              "moduleId": 51,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "type": "cjs require",
              "userRequest": "./base",
              "loc": "17:15-32"
            },
            {
              "moduleId": 52,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "type": "cjs require",
              "userRequest": "./base",
              "loc": "9:15-32"
            },
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "./base",
              "loc": "9:15-32"
            },
            {
              "moduleId": 59,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "type": "cjs require",
              "userRequest": "./base",
              "loc": "9:15-32"
            },
            {
              "moduleId": 60,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "type": "cjs require",
              "userRequest": "./base",
              "loc": "9:15-32"
            }
          ],
          "source": "/**\r\n * echarts组件基类\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ecConfig = require('../config');\r\n    var ecData = require('../util/ecData');\r\n    var ecQuery = require('../util/ecQuery');\r\n    var number = require('../util/number');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    \r\n    function Base(ecTheme, messageCenter, zr, option, myChart){\r\n        this.ecTheme = ecTheme;\r\n        this.messageCenter = messageCenter;\r\n        this.zr =zr;\r\n        this.option = option;\r\n        this.series = option.series;\r\n        this.myChart = myChart;\r\n        this.component = myChart.component;\r\n\r\n        this.shapeList = [];\r\n        this.effectList = [];\r\n        \r\n        var self = this;\r\n        \r\n        self._onlegendhoverlink = function(param) {\r\n            if (self.legendHoverLink) {\r\n                var targetName = param.target;\r\n                var name;\r\n                for (var i = self.shapeList.length - 1; i >= 0; i--) {\r\n                    name = self.type == ecConfig.CHART_TYPE_PIE\r\n                           || self.type == ecConfig.CHART_TYPE_FUNNEL\r\n                           ? ecData.get(self.shapeList[i], 'name')\r\n                           : (ecData.get(self.shapeList[i], 'series') || {}).name;\r\n                    if (name == targetName \r\n                        && !self.shapeList[i].invisible \r\n                        && !self.shapeList[i].__animating\r\n                    ) {\r\n                        self.zr.addHoverShape(self.shapeList[i]);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        messageCenter && messageCenter.bind(\r\n            ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 基类方法\r\n     */\r\n    Base.prototype = {\r\n        canvasSupported: require('zrenderjs/tool/env').canvasSupported,\r\n        _getZ : function(zWhat) {\r\n            if (this[zWhat] != null) {\r\n                return this[zWhat];\r\n            }\r\n            var opt = this.ecTheme[this.type];\r\n            if (opt && opt[zWhat] != null) {\r\n                return opt[zWhat];\r\n            }\r\n            opt = ecConfig[this.type];\r\n            if (opt && opt[zWhat] != null) {\r\n                return opt[zWhat];\r\n            }\r\n            return 0;\r\n        },\r\n\r\n        /**\r\n         * 获取zlevel基数配置\r\n         */\r\n        getZlevelBase: function () {\r\n            return this._getZ('zlevel');\r\n        },\r\n        \r\n        /**\r\n         * 获取z基数配置\r\n         */\r\n        getZBase: function() {\r\n            return this._getZ('z');\r\n        },\r\n\r\n        /**\r\n         * 参数修正&默认值赋值\r\n         * @param {Object} opt 参数\r\n         *\r\n         * @return {Object} 修正后的参数\r\n         */\r\n        reformOption: function (opt) {\r\n            // 默认配置项动态多级合并，依赖加载的组件选项未被merge到ecTheme里，需要从config里取\r\n            opt = zrUtil.merge(\r\n                       zrUtil.merge(\r\n                           opt || {},\r\n                           zrUtil.clone(this.ecTheme[this.type] || {})\r\n                       ),\r\n                       zrUtil.clone(ecConfig[this.type] || {})\r\n                   );\r\n            this.z = opt.z;\r\n            this.zlevel = opt.zlevel;\r\n            return opt;\r\n        },\r\n        \r\n        /**\r\n         * css类属性数组补全，如padding，margin等~\r\n         */\r\n        reformCssArray: function (p) {\r\n            if (p instanceof Array) {\r\n                switch (p.length + '') {\r\n                    case '4':\r\n                        return p;\r\n                    case '3':\r\n                        return [p[0], p[1], p[2], p[1]];\r\n                    case '2':\r\n                        return [p[0], p[1], p[0], p[1]];\r\n                    case '1':\r\n                        return [p[0], p[0], p[0], p[0]];\r\n                    case '0':\r\n                        return [0, 0, 0, 0];\r\n                }\r\n            }\r\n            else {\r\n                return [p, p, p, p];\r\n            }\r\n        },\r\n        \r\n        getShapeById: function(id) {\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                if (this.shapeList[i].id === id) {\r\n                    return this.shapeList[i];\r\n                }\r\n            }\r\n            return null;\r\n        },\r\n        \r\n        /**\r\n         * 获取自定义和默认配置合并后的字体设置\r\n         */\r\n        getFont: function (textStyle) {\r\n            var finalTextStyle = this.getTextStyle(\r\n                zrUtil.clone(textStyle)\r\n            );\r\n            return finalTextStyle.fontStyle + ' '\r\n                   + finalTextStyle.fontWeight + ' '\r\n                   + finalTextStyle.fontSize + 'px '\r\n                   + finalTextStyle.fontFamily;\r\n        },\r\n\r\n        /**\r\n         * 获取统一主题字体样式\r\n         */\r\n        getTextStyle: function(targetStyle) {\r\n            return zrUtil.merge(\r\n                       zrUtil.merge(\r\n                           targetStyle || {},\r\n                           this.ecTheme.textStyle\r\n                       ),\r\n                       ecConfig.textStyle\r\n                   );\r\n        },\r\n        \r\n        getItemStyleColor: function (itemColor, seriesIndex, dataIndex, data) {\r\n            return typeof itemColor === 'function'\r\n                   ? itemColor.call(\r\n                        this.myChart,\r\n                        {\r\n                            seriesIndex: seriesIndex,\r\n                            series: this.series[seriesIndex],\r\n                            dataIndex: dataIndex,\r\n                            data: data\r\n                        }\r\n                   )\r\n                   : itemColor;\r\n            \r\n        }, \r\n\r\n        /**\r\n         * @parmas {object | number} data 目标data\r\n         * @params {string= | number=} defaultData 无数据时默认返回\r\n         */\r\n        getDataFromOption: function (data, defaultData) {\r\n            return data != null ? (data.value != null ? data.value : data) : defaultData;\r\n        },\r\n        \r\n        // 亚像素优化\r\n        subPixelOptimize: function (position, lineWidth) {\r\n            if (lineWidth % 2 === 1) {\r\n                //position += position === Math.ceil(position) ? 0.5 : 0;\r\n                position = Math.floor(position) + 0.5;\r\n            }\r\n            else {\r\n                position = Math.round(position);\r\n            }\r\n            return position;\r\n        },\r\n        \r\n        // 默认resize\r\n        resize: function () {\r\n            this.refresh && this.refresh();\r\n            this.clearEffectShape && this.clearEffectShape(true);\r\n            var self = this;\r\n            setTimeout(function(){\r\n                self.animationEffect && self.animationEffect();\r\n            },200);\r\n        },\r\n\r\n        /**\r\n         * 清除图形数据，实例仍可用\r\n         */\r\n        clear :function () {\r\n            this.clearEffectShape && this.clearEffectShape();\r\n            this.zr && this.zr.delShape(this.shapeList);\r\n            this.shapeList = [];\r\n        },\r\n\r\n        /**\r\n         * 释放后实例不可用\r\n         */\r\n        dispose: function () {\r\n            this.onbeforDispose && this.onbeforDispose();\r\n            this.clear();\r\n            this.shapeList = null;\r\n            this.effectList = null;\r\n            this.messageCenter && this.messageCenter.unbind(\r\n                ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink\r\n            );\r\n            this.onafterDispose && this.onafterDispose();\r\n        },\r\n        \r\n        query: ecQuery.query,\r\n        deepQuery: ecQuery.deepQuery,\r\n        deepMerge: ecQuery.deepMerge,\r\n        \r\n        parsePercent: number.parsePercent,\r\n        parseCenter: number.parseCenter,\r\n        parseRadius: number.parseRadius,\r\n        numAddCommas: number.addCommas,\r\n\r\n        getPrecision: number.getPrecision\r\n    };\r\n    \r\n    return Base;\r\n});\r\n"
        },
        {
          "id": 45,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecQuery.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecQuery.js",
          "index": 45,
          "index2": 38,
          "size": 2215,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 44,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "type": "cjs require",
              "userRequest": "../util/ecQuery",
              "loc": "11:18-44"
            }
          ],
          "source": "/**\r\n * echarts层级查找方法\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function(require) {\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    \r\n    /**\r\n     * 获取嵌套选项的基础方法\r\n     * 返回optionTarget中位于optionLocation上的值，如果没有定义，则返回undefined\r\n     */\r\n    function query(optionTarget, optionLocation) {\r\n        if (typeof optionTarget == 'undefined') {\r\n            return;\r\n        }\r\n\r\n        if (!optionLocation) {\r\n            return optionTarget;\r\n        }\r\n\r\n        optionLocation = optionLocation.split('.');\r\n        var length = optionLocation.length;\r\n        var curIdx = 0;\r\n        while (curIdx < length) {\r\n            optionTarget = optionTarget[optionLocation[curIdx]];\r\n            if (typeof optionTarget == 'undefined') {\r\n                return;\r\n            }\r\n            curIdx++;\r\n        }\r\n\r\n        return optionTarget;\r\n    }\r\n        \r\n    /**\r\n     * 获取多级控制嵌套属性的基础方法\r\n     * 返回ctrList中优先级最高（最靠前）的非undefined属性，ctrList中均无定义则返回undefined\r\n     */\r\n    function deepQuery(ctrList, optionLocation) {\r\n        var finalOption;\r\n        for (var i = 0, l = ctrList.length; i < l; i++) {\r\n            finalOption = query(ctrList[i], optionLocation);\r\n            if (typeof finalOption != 'undefined') {\r\n                return finalOption;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 获取多级控制嵌套属性的基础方法\r\n     * 根据ctrList中优先级合并产出目标属性\r\n     */\r\n    function deepMerge(ctrList, optionLocation) {\r\n        var finalOption;\r\n        var len = ctrList.length;\r\n        while (len--) {\r\n            var tempOption = query(ctrList[len], optionLocation);\r\n            if (typeof tempOption != 'undefined') {\r\n                if (typeof finalOption == 'undefined') {\r\n                    finalOption = zrUtil.clone(tempOption);\r\n                }\r\n                else {\r\n                    zrUtil.merge(\r\n                        finalOption, tempOption, true\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        \r\n        return finalOption;\r\n    }\r\n    \r\n    return {\r\n        query : query,\r\n        deepQuery : deepQuery,\r\n        deepMerge : deepMerge\r\n    };\r\n});\r\n"
        },
        {
          "id": 46,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\number.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/number.js",
          "index": 46,
          "index2": 39,
          "size": 2235,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 44,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
              "type": "cjs require",
              "userRequest": "../util/number",
              "loc": "12:17-42"
            },
            {
              "moduleId": 58,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\smartLogSteps.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/smartLogSteps.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/smartLogSteps.js",
              "type": "cjs require",
              "userRequest": "./number",
              "loc": "11:17-36"
            }
          ],
          "source": "/**\r\n * echarts数字运算相关\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function() {\r\n    function _trim(str) {\r\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n    }\r\n    \r\n    /**\r\n     * 百分比计算\r\n     */\r\n    function parsePercent(value, maxValue) {\r\n        if (typeof value === 'string') {\r\n            if (_trim(value).match(/%$/)) {\r\n                return parseFloat(value) / 100 * maxValue;\r\n            }\r\n\r\n            return parseFloat(value);\r\n        }\r\n\r\n        return value;\r\n    }\r\n    \r\n    /**\r\n     * 获取中心坐标\r\n     */ \r\n    function parseCenter(zr, center) {\r\n        return [\r\n            parsePercent(center[0], zr.getWidth()),\r\n            parsePercent(center[1], zr.getHeight())\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * 获取自适应半径\r\n     */ \r\n    function parseRadius(zr, radius) {\r\n        // 传数组实现环形图，[内半径，外半径]，传单个则默认为外半径为\r\n        if (!(radius instanceof Array)) {\r\n            radius = [0, radius];\r\n        }\r\n        var zrSize = Math.min(zr.getWidth(), zr.getHeight()) / 2;\r\n        return [\r\n            parsePercent(radius[0], zrSize),\r\n            parsePercent(radius[1], zrSize)\r\n        ];\r\n    }\r\n    \r\n    /**\r\n     * 每三位默认加,格式化\r\n     */\r\n    function addCommas(x) {\r\n        if (isNaN(x)) {\r\n            return '-';\r\n        }\r\n        x = (x + '').split('.');\r\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,') \r\n               + (x.length > 1 ? ('.' + x[1]) : '');\r\n    }\r\n\r\n    /**\r\n     * 获取数字的小数位数\r\n     * @param {number} val\r\n     */\r\n    \r\n    // It is much faster than methods converting number to string as follows \r\n    //      var tmp = val.toString();\r\n    //      return tmp.length - 1 - tmp.indexOf('.');\r\n    // especially when precision is low\r\n    function getPrecision(val) {\r\n        var e = 1;\r\n        var count = 0;\r\n        while (Math.round(val * e) / e !== val) {\r\n            e *= 10;\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n    \r\n    return {\r\n        parsePercent: parsePercent,\r\n        parseCenter: parseCenter,\r\n        parseRadius: parseRadius,\r\n        addCommas: addCommas,\r\n        getPrecision: getPrecision\r\n    };\r\n});"
        },
        {
          "id": 47,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\layout\\EdgeBundling.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
          "index": 47,
          "index2": 43,
          "size": 15154,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 5,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
              "type": "cjs require",
              "userRequest": "../layout/EdgeBundling",
              "loc": "23:23-56"
            }
          ],
          "source": "/**\r\n * Edge bundling laytout\r\n *\r\n * Use MINGLE algorithm\r\n * Multilevel agglomerative edge bundling for visualizing large graphs\r\n *\r\n * @module echarts/layout/EdgeBundling\r\n */\r\ndefine(function (require) {\r\n\r\n    var KDTree = require('../data/KDTree');\r\n    var vec2 = require('zrenderjs/tool/vector');\r\n    var v2Create = vec2.create;\r\n    var v2DistSquare = vec2.distSquare;\r\n    var v2Dist = vec2.dist;\r\n    var v2Copy = vec2.copy;\r\n    var v2Clone = vec2.clone;\r\n\r\n    function squaredDistance(a, b) {\r\n        a = a.array;\r\n        b = b.array;\r\n\r\n        var x = b[0] - a[0];\r\n        var y = b[1] - a[1];\r\n        var z = b[2] - a[2];\r\n        var w = b[3] - a[3];\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n    }\r\n\r\n    function CoarsenedEdge(group) {\r\n        this.points = [\r\n            group.mp0, group.mp1\r\n        ];\r\n\r\n        this.group = group;\r\n    }\r\n\r\n    function Edge(edge) {\r\n        var points = edge.points;\r\n        // Sort on y\r\n        if (\r\n            points[0][1] < points[1][1]\r\n            // If coarsened edge is flipped, the final composition of meet point\r\n            // will be unordered\r\n            || edge instanceof CoarsenedEdge\r\n        ) {\r\n            this.array = [points[0][0], points[0][1], points[1][0], points[1][1]];\r\n            this._startPoint = points[0];\r\n            this._endPoint = points[1];\r\n        }\r\n        else {\r\n            this.array = [points[1][0], points[1][1], points[0][0], points[0][1]];\r\n            this._startPoint = points[1];\r\n            this._endPoint = points[0];\r\n        }\r\n\r\n        this.ink = v2Dist(points[0], points[1]);\r\n\r\n        this.edge = edge;\r\n\r\n        this.group = null;\r\n    }\r\n\r\n    Edge.prototype.getStartPoint = function () {\r\n        return this._startPoint;\r\n    };\r\n\r\n    Edge.prototype.getEndPoint = function () {\r\n        return this._endPoint;\r\n    };\r\n\r\n    function BundledEdgeGroup() {\r\n\r\n        this.edgeList = [];\r\n\r\n        this.mp0 = v2Create();\r\n        this.mp1 = v2Create();\r\n\r\n        this.ink = 0;\r\n    }\r\n\r\n    BundledEdgeGroup.prototype.addEdge = function (edge) {\r\n        edge.group = this;\r\n        this.edgeList.push(edge);\r\n    };\r\n\r\n    BundledEdgeGroup.prototype.removeEdge = function (edge) {\r\n        edge.group = null;\r\n        this.edgeList.splice(this.edgeList.indexOf(edge), 1);\r\n    };\r\n\r\n    /**\r\n     * @constructor\r\n     * @alias module:echarts/layout/EdgeBundling\r\n     */\r\n    function EdgeBundling() {\r\n        this.maxNearestEdge = 6;\r\n        this.maxTurningAngle = Math.PI / 4;\r\n        this.maxIteration = 20;\r\n    }\r\n\r\n    EdgeBundling.prototype = {\r\n        \r\n        constructor: EdgeBundling,\r\n\r\n        run: function (rawEdges) {\r\n            var res = this._iterate(rawEdges);\r\n            var nIterate = 0;\r\n            while (nIterate++ < this.maxIteration) {\r\n                var coarsenedEdges = [];\r\n                for (var i = 0; i < res.groups.length; i++) {\r\n                    coarsenedEdges.push(new CoarsenedEdge(res.groups[i]));\r\n                }\r\n                var newRes = this._iterate(coarsenedEdges);\r\n                if (newRes.savedInk <= 0) {\r\n                    break;\r\n                } else {\r\n                    res = newRes;\r\n                }\r\n            }\r\n\r\n            // Get new edges\r\n            var newEdges = [];\r\n\r\n            function pointApproxEqual(p0, p1) {\r\n                // Use Float32Array may affect the precision\r\n                return v2DistSquare(p0, p1) < 1e-10;\r\n            }\r\n            // Clone all points to make sure all points in edge will not reference to the same array\r\n            // And clean the duplicate points\r\n            function cleanEdgePoints(edgePoints, rawEdgePoints) {\r\n                var res = [];\r\n                var off = 0;\r\n                for (var i = 0; i < edgePoints.length; i++) {\r\n                    if (! (off > 0 && pointApproxEqual(edgePoints[i], res[off - 1]))) {\r\n                        res[off++] = v2Clone(edgePoints[i]);\r\n                    }\r\n                }\r\n                // Edge has been reversed\r\n                if (rawEdgePoints[0] && !pointApproxEqual(res[0], rawEdgePoints[0])) {\r\n                    res = res.reverse();\r\n                }\r\n                return res;\r\n            }\r\n\r\n            var buildNewEdges = function (groups, fromEdgePoints) {\r\n                var newEdgePoints;\r\n                for (var i = 0; i < groups.length; i++) {\r\n                    var group = groups[i];\r\n                    if (\r\n                        group.edgeList[0]\r\n                        && (group.edgeList[0].edge instanceof CoarsenedEdge)\r\n                    ) {\r\n                        var newGroups = [];\r\n                        for (var j = 0; j < group.edgeList.length; j++) {\r\n                            newGroups.push(group.edgeList[j].edge.group);\r\n                        }\r\n                        if (! fromEdgePoints) {\r\n                            newEdgePoints = [];\r\n                        } else {\r\n                            newEdgePoints = fromEdgePoints.slice();\r\n                        }\r\n                        newEdgePoints.unshift(group.mp0);\r\n                        newEdgePoints.push(group.mp1);\r\n                        buildNewEdges(newGroups, newEdgePoints);\r\n                    } else {\r\n                        // console.log(group.edgeList.length);\r\n                        for (var j = 0; j < group.edgeList.length; j++) {\r\n                            var edge = group.edgeList[j];\r\n                            if (! fromEdgePoints) {\r\n                                newEdgePoints = [];\r\n                            } else {\r\n                                newEdgePoints = fromEdgePoints.slice();\r\n                            }\r\n                            newEdgePoints.unshift(group.mp0);\r\n                            newEdgePoints.push(group.mp1);\r\n                            newEdgePoints.unshift(edge.getStartPoint());\r\n                            newEdgePoints.push(edge.getEndPoint());\r\n                            newEdges.push({\r\n                                points: cleanEdgePoints(newEdgePoints, edge.edge.points),\r\n                                rawEdge: edge.edge\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            buildNewEdges(res.groups);\r\n\r\n            return newEdges;\r\n        },\r\n\r\n        _iterate: function (rawEdges) {\r\n            var edges = [];\r\n            var groups = [];\r\n            var totalSavedInk = 0;\r\n            for (var i = 0; i < rawEdges.length; i++) {\r\n                var edge = new Edge(rawEdges[i]);\r\n                edges.push(edge);\r\n            }\r\n\r\n            var tree = new KDTree(edges, 4);\r\n\r\n            var nearests = [];\r\n\r\n            var _mp0 = v2Create();\r\n            var _mp1 = v2Create();\r\n            var _newGroupInk = 0;\r\n            var mp0 = v2Create();\r\n            var mp1 = v2Create();\r\n            var newGroupInk = 0;\r\n            for (var i = 0; i < edges.length; i++) {\r\n                var edge = edges[i];\r\n                if (edge.group) {\r\n                    // Edge have been groupped\r\n                    continue;\r\n                }\r\n                tree.nearestN(\r\n                    edge, this.maxNearestEdge,\r\n                    squaredDistance, nearests\r\n                );\r\n                var maxSavedInk = 0;\r\n                var mostSavingInkEdge = null;\r\n                var lastCheckedGroup = null;\r\n                for (var j = 0; j < nearests.length; j++) {\r\n                    var nearest = nearests[j];\r\n                    var savedInk = 0;\r\n                    if (nearest.group) {\r\n                        if (nearest.group !== lastCheckedGroup) {\r\n                            lastCheckedGroup = nearest.group;\r\n                            _newGroupInk = this._calculateGroupEdgeInk(\r\n                                nearest.group, edge, _mp0, _mp1\r\n                            );\r\n                            savedInk = nearest.group.ink + edge.ink - _newGroupInk;\r\n                        }\r\n                    }\r\n                    else {\r\n                        _newGroupInk = this._calculateEdgeEdgeInk(\r\n                            edge, nearest, _mp0, _mp1\r\n                        );\r\n                        savedInk = nearest.ink + edge.ink - _newGroupInk;\r\n                    }\r\n                    if (savedInk > maxSavedInk) {\r\n                        maxSavedInk = savedInk;\r\n                        mostSavingInkEdge = nearest;\r\n                        v2Copy(mp1, _mp1);\r\n                        v2Copy(mp0, _mp0);\r\n                        newGroupInk = _newGroupInk;\r\n                    }\r\n                }\r\n                if (mostSavingInkEdge) {\r\n                    totalSavedInk += maxSavedInk;\r\n                    var group;\r\n                    if (! mostSavingInkEdge.group) {\r\n                        group = new BundledEdgeGroup();\r\n                        groups.push(group);\r\n                        group.addEdge(mostSavingInkEdge);\r\n                    }\r\n                    group = mostSavingInkEdge.group;\r\n                    // Use the meet point and group ink calculated before\r\n                    v2Copy(group.mp0, mp0);\r\n                    v2Copy(group.mp1, mp1);\r\n                    group.ink = newGroupInk;\r\n                    mostSavingInkEdge.group.addEdge(edge);\r\n                }\r\n                else {\r\n                    var group = new BundledEdgeGroup();\r\n                    groups.push(group);\r\n                    v2Copy(group.mp0, edge.getStartPoint());\r\n                    v2Copy(group.mp1, edge.getEndPoint());\r\n                    group.ink = edge.ink;\r\n                    group.addEdge(edge);\r\n                }\r\n            }\r\n\r\n            return {\r\n                groups: groups,\r\n                edges: edges,\r\n                savedInk: totalSavedInk\r\n            };\r\n        },\r\n\r\n        _calculateEdgeEdgeInk: (function () {\r\n            var startPointSet = [];\r\n            var endPointSet = [];\r\n            return function (e0, e1, mp0, mp1) {\r\n                startPointSet[0] = e0.getStartPoint();\r\n                startPointSet[1] = e1.getStartPoint();\r\n                endPointSet[0] = e0.getEndPoint();\r\n                endPointSet[1] = e1.getEndPoint();\r\n\r\n                this._calculateMeetPoints(\r\n                    startPointSet, endPointSet, mp0, mp1\r\n                );\r\n                var ink = v2Dist(startPointSet[0], mp0)\r\n                    + v2Dist(mp0, mp1)\r\n                    + v2Dist(mp1, endPointSet[0])\r\n                    + v2Dist(startPointSet[1], mp0)\r\n                    + v2Dist(mp1, endPointSet[1]);\r\n\r\n                return ink;\r\n            };\r\n        })(),\r\n\r\n        _calculateGroupEdgeInk: function (group, edgeTryAdd, mp0, mp1) {\r\n            var startPointSet = [];\r\n            var endPointSet = [];\r\n            for (var i = 0; i < group.edgeList.length; i++) {\r\n                var edge = group.edgeList[i];\r\n                startPointSet.push(edge.getStartPoint());\r\n                endPointSet.push(edge.getEndPoint());\r\n            }\r\n            startPointSet.push(edgeTryAdd.getStartPoint());\r\n            endPointSet.push(edgeTryAdd.getEndPoint());\r\n\r\n            this._calculateMeetPoints(\r\n                startPointSet, endPointSet, mp0, mp1\r\n            );\r\n\r\n            var ink = v2Dist(mp0, mp1);\r\n            for (var i = 0; i < startPointSet.length; i++) {\r\n                ink += v2Dist(startPointSet[i], mp0)\r\n                    + v2Dist(endPointSet[i], mp1);\r\n            }\r\n\r\n            return ink;\r\n        },\r\n\r\n        /**\r\n         * Calculating the meet points\r\n         * @method\r\n         * @param {Array} startPointSet Start points set of bundled edges\r\n         * @param {Array} endPointSet End points set of bundled edges\r\n         * @param {Array.<number>} mp0 Output meet point 0\r\n         * @param {Array.<number>} mp1 Output meet point 1\r\n         */\r\n        _calculateMeetPoints: (function () {\r\n            var cp0 = v2Create();\r\n            var cp1 = v2Create();\r\n            return function (startPointSet, endPointSet, mp0, mp1) {\r\n                vec2.set(cp0, 0, 0);\r\n                vec2.set(cp1, 0, 0);\r\n                var len = startPointSet.length;\r\n                // Calculate the centroid of start points set\r\n                for (var i = 0; i < len; i++) {\r\n                    vec2.add(cp0, cp0, startPointSet[i]);\r\n                }\r\n                vec2.scale(cp0, cp0, 1 / len);\r\n\r\n                // Calculate the centroid of end points set\r\n                len = endPointSet.length;\r\n                for (var i = 0; i < len; i++) {\r\n                    vec2.add(cp1, cp1, endPointSet[i]);\r\n                }\r\n                vec2.scale(cp1, cp1, 1 / len);\r\n\r\n                this._limitTurningAngle(\r\n                    startPointSet, cp0, cp1, mp0\r\n                );\r\n                this._limitTurningAngle(\r\n                    endPointSet, cp1, cp0, mp1\r\n                );\r\n            };\r\n        })(),\r\n\r\n        _limitTurningAngle: (function () {\r\n            var v10 = v2Create();\r\n            var vTmp = v2Create();\r\n            var project = v2Create();\r\n            var tmpOut = v2Create();\r\n            return function (pointSet, p0, p1, out) {\r\n                // Limit the max turning angle\r\n                var maxTurningAngleCos = Math.cos(this.maxTurningAngle);\r\n                var maxTurningAngleTan = Math.tan(this.maxTurningAngle);\r\n\r\n                vec2.sub(v10, p0, p1);\r\n                vec2.normalize(v10, v10);\r\n\r\n                // Simply copy the centroid point if no need to turn the angle\r\n                vec2.copy(out, p0);\r\n\r\n                var maxMovement = 0;\r\n                for (var i = 0; i < pointSet.length; i++) {\r\n                    var p = pointSet[i];\r\n                    vec2.sub(vTmp, p, p0);\r\n                    var len = vec2.len(vTmp);\r\n                    vec2.scale(vTmp, vTmp, 1 / len);\r\n                    var turningAngleCos = vec2.dot(vTmp, v10);\r\n                    // Turning angle is to large\r\n                    if (turningAngleCos < maxTurningAngleCos) {\r\n                        // Calculat p's project point on vector p1-p0 \r\n                        // and distance to the vector\r\n                        vec2.scaleAndAdd(\r\n                            project, p0, v10, len * turningAngleCos\r\n                        );\r\n                        var distance = v2Dist(project, p);\r\n\r\n                        // Use the max turning angle to calculate the new meet point\r\n                        var d = distance / maxTurningAngleTan;\r\n                        vec2.scaleAndAdd(tmpOut, project, v10, -d);\r\n\r\n                        var movement = v2DistSquare(tmpOut, p0);\r\n                        if (movement > maxMovement) {\r\n                            maxMovement = movement;\r\n                            vec2.copy(out, tmpOut);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        })()\r\n    };\r\n\r\n    return EdgeBundling;\r\n});"
        },
        {
          "id": 48,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\data\\KDTree.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/data/KDTree.js",
          "index": 48,
          "index2": 42,
          "size": 7954,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\layout\\EdgeBundling.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 47,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\layout\\EdgeBundling.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
              "type": "cjs require",
              "userRequest": "../data/KDTree",
              "loc": "11:17-42"
            }
          ],
          "source": "/**\r\n * K-Dimension Tree\r\n *\r\n * @module echarts/data/KDTree\r\n * @author Yi Shen(https://github.com/pissang)\r\n */\r\ndefine(function (require) {\r\n\r\n    var quickSelect = require('./quickSelect');\r\n\r\n    function Node(axis, data) {\r\n        this.left = null;\r\n        this.right = null;\r\n        this.axis = axis;\r\n\r\n        this.data = data;\r\n    }\r\n\r\n    /**\r\n     * @constructor\r\n     * @alias module:echarts/data/KDTree\r\n     * @param {Array} points List of points.\r\n     * each point needs an array property to repesent the actual data\r\n     * @param {Number} [dimension]\r\n     *        Point dimension.\r\n     *        Default will use the first point's length as dimensiont\r\n     */\r\n    var KDTree = function (points, dimension) {\r\n        if (!points.length) {\r\n            return;\r\n        }\r\n\r\n        if (!dimension) {\r\n            dimension = points[0].array.length;\r\n        }\r\n        this.dimension = dimension;\r\n        this.root = this._buildTree(points, 0, points.length - 1, 0);\r\n\r\n        // Use one stack to avoid allocation \r\n        // each time searching the nearest point\r\n        this._stack = [];\r\n        // Again avoid allocating a new array\r\n        // each time searching nearest N points\r\n        this._nearstNList = [];\r\n    };\r\n\r\n    /**\r\n     * Resursively build the tree\r\n     */\r\n    KDTree.prototype._buildTree = function (points, left, right, axis) {\r\n        if (right < left) {\r\n            return null;\r\n        }\r\n\r\n        var medianIndex = Math.floor((left + right) / 2);\r\n        medianIndex = quickSelect(\r\n            points, left, right, medianIndex,\r\n            function (a, b) {\r\n                return a.array[axis] - b.array[axis];\r\n            }\r\n        );\r\n        var median = points[medianIndex];\r\n\r\n        var node = new Node(axis, median);\r\n\r\n        axis = (axis + 1) % this.dimension;\r\n        if (right > left) {\r\n            node.left = this._buildTree(points, left, medianIndex - 1, axis);\r\n            node.right = this._buildTree(points, medianIndex + 1, right, axis);   \r\n        }\r\n\r\n        return node;\r\n    };\r\n\r\n    /**\r\n     * Find nearest point\r\n     * @param  {Array} target Target point\r\n     * @param  {Function} squaredDistance Squared distance function\r\n     * @return {Array} Nearest point\r\n     */\r\n    KDTree.prototype.nearest = function (target, squaredDistance) {\r\n        var curr = this.root;\r\n        var stack = this._stack;\r\n        var idx = 0;\r\n        var minDist = Infinity;\r\n        var nearestNode = null;\r\n        if (curr.data !== target) {\r\n            minDist = squaredDistance(curr.data, target);\r\n            nearestNode = curr;\r\n        }\r\n\r\n        if (target.array[curr.axis] < curr.data.array[curr.axis]) {\r\n            // Left first\r\n            curr.right && (stack[idx++] = curr.right);\r\n            curr.left && (stack[idx++] = curr.left);\r\n        }\r\n        else {\r\n            // Right first\r\n            curr.left && (stack[idx++] = curr.left);\r\n            curr.right && (stack[idx++] = curr.right);\r\n        }\r\n\r\n        while (idx--) {\r\n            curr = stack[idx];\r\n            var currDist = target.array[curr.axis] - curr.data.array[curr.axis];\r\n            var isLeft = currDist < 0;\r\n            var needsCheckOtherSide = false;\r\n            currDist = currDist * currDist;\r\n            // Intersecting right hyperplane with minDist hypersphere\r\n            if (currDist < minDist) {\r\n                currDist = squaredDistance(curr.data, target);\r\n                if (currDist < minDist && curr.data !== target) {\r\n                    minDist = currDist;\r\n                    nearestNode = curr;\r\n                }\r\n                needsCheckOtherSide = true;\r\n            }\r\n            if (isLeft) {\r\n                if (needsCheckOtherSide) {\r\n                    curr.right && (stack[idx++] = curr.right);\r\n                }\r\n                // Search in the left area\r\n                curr.left && (stack[idx++] = curr.left);\r\n            }\r\n            else {\r\n                if (needsCheckOtherSide) {\r\n                    curr.left && (stack[idx++] = curr.left);\r\n                }\r\n                // Search the right area\r\n                curr.right && (stack[idx++] = curr.right);\r\n            }\r\n        }\r\n\r\n        return nearestNode.data;\r\n    };\r\n\r\n    KDTree.prototype._addNearest = function (found, dist, node) {\r\n        var nearestNList = this._nearstNList;\r\n\r\n        // Insert to the right position\r\n        // Sort from small to large\r\n        for (var i = found - 1; i > 0; i--) {\r\n            if (dist >= nearestNList[i - 1].dist) {                \r\n                break;\r\n            }\r\n            else {\r\n                nearestNList[i].dist = nearestNList[i - 1].dist;\r\n                nearestNList[i].node = nearestNList[i - 1].node;\r\n            }\r\n        }\r\n\r\n        nearestNList[i].dist = dist;\r\n        nearestNList[i].node = node;\r\n    };\r\n\r\n    /**\r\n     * Find nearest N points\r\n     * @param  {Array} target Target point\r\n     * @param  {number} N\r\n     * @param  {Function} squaredDistance Squared distance function\r\n     * @param  {Array} [output] Output nearest N points\r\n     */\r\n    KDTree.prototype.nearestN = function (target, N, squaredDistance, output) {\r\n        if (N <= 0) {\r\n            output.length = 0;\r\n            return output;\r\n        }\r\n\r\n        var curr = this.root;\r\n        var stack = this._stack;\r\n        var idx = 0;\r\n\r\n        var nearestNList = this._nearstNList;\r\n        for (var i = 0; i < N; i++) {\r\n            // Allocate\r\n            if (!nearestNList[i]) {\r\n                nearestNList[i] = {};\r\n            }\r\n            nearestNList[i].dist = 0;\r\n            nearestNList[i].node = null;\r\n        }\r\n        var currDist = squaredDistance(curr.data, target);\r\n\r\n        var found = 0;\r\n        if (curr.data !== target) {\r\n            found++;\r\n            this._addNearest(found, currDist, curr);\r\n        }\r\n\r\n        if (target.array[curr.axis] < curr.data.array[curr.axis]) {\r\n            // Left first\r\n            curr.right && (stack[idx++] = curr.right);\r\n            curr.left && (stack[idx++] = curr.left);\r\n        }\r\n        else {\r\n            // Right first\r\n            curr.left && (stack[idx++] = curr.left);\r\n            curr.right && (stack[idx++] = curr.right);\r\n        }\r\n\r\n        while (idx--) {\r\n            curr = stack[idx];\r\n            var currDist = target.array[curr.axis] - curr.data.array[curr.axis];\r\n            var isLeft = currDist < 0;\r\n            var needsCheckOtherSide = false;\r\n            currDist = currDist * currDist;\r\n            // Intersecting right hyperplane with minDist hypersphere\r\n            if (found < N || currDist < nearestNList[found - 1].dist) {\r\n                currDist = squaredDistance(curr.data, target);\r\n                if (\r\n                    (found < N || currDist < nearestNList[found - 1].dist)\r\n                    && curr.data !== target\r\n                ) {\r\n                    if (found < N) {\r\n                        found++;\r\n                    }\r\n                    this._addNearest(found, currDist, curr);\r\n                }\r\n                needsCheckOtherSide = true;\r\n            }\r\n            if (isLeft) {\r\n                if (needsCheckOtherSide) {\r\n                    curr.right && (stack[idx++] = curr.right);\r\n                }\r\n                // Search in the left area\r\n                curr.left && (stack[idx++] = curr.left);\r\n            }\r\n            else {\r\n                if (needsCheckOtherSide) {\r\n                    curr.left && (stack[idx++] = curr.left);\r\n                }\r\n                // Search the right area\r\n                curr.right && (stack[idx++] = curr.right);\r\n            }\r\n        }\r\n\r\n        // Copy to output\r\n        for (var i = 0; i < found; i++) {\r\n            output[i] = nearestNList[i].node.data;\r\n        }\r\n        output.length = found;\r\n\r\n        return output;\r\n    };\r\n\r\n    return KDTree;\r\n});"
        },
        {
          "id": 49,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\data\\quickSelect.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/data/quickSelect.js",
          "index": 49,
          "index2": 41,
          "size": 2339,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\data\\KDTree.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 48,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\data\\KDTree.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/data/KDTree.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/data/KDTree.js",
              "type": "cjs require",
              "userRequest": "./quickSelect",
              "loc": "9:22-46"
            }
          ],
          "source": "/**\r\n * Quick select n-th element in an array.\r\n *\r\n * Note: it will change the elements placement in array.\r\n *\r\n * @module echarts/data/quickSelect\r\n * @author Yi Shen(https://github.com/pissang)\r\n */\r\ndefine(function (require) {\r\n\r\n    function defaultCompareFunc(a, b) {\r\n        return a - b;\r\n    }\r\n\r\n    function swapElement(list, idx0, idx1) {\r\n        var tmp = list[idx0];\r\n        list[idx0] = list[idx1];\r\n        list[idx1] = tmp;\r\n    }\r\n\r\n    function select(list, left, right, nth, compareFunc) {\r\n        var pivotIdx = left;\r\n        while (right > left) {\r\n            var pivotIdx = Math.round((right + left) / 2);\r\n            var pivotValue = list[pivotIdx];\r\n            // Swap pivot to the end\r\n            swapElement(list, pivotIdx, right);\r\n            pivotIdx = left;\r\n            for (var i = left; i <= right - 1; i++) {\r\n                if (compareFunc(pivotValue, list[i]) >= 0) {\r\n                    swapElement(list, i, pivotIdx);\r\n                    pivotIdx++;\r\n                }\r\n            }\r\n            swapElement(list, right, pivotIdx);\r\n\r\n            if (pivotIdx === nth) {\r\n                return pivotIdx;\r\n            } else if (pivotIdx < nth) {\r\n                left = pivotIdx + 1;\r\n            } else {\r\n                right = pivotIdx - 1;\r\n            }\r\n        }\r\n        // Left == right\r\n        return left;\r\n    }\r\n\r\n    /**\r\n     * @alias module:echarts/data/quickSelect\r\n     * @param {Array} list\r\n     * @param {number} [left]\r\n     * @param {number} [right]\r\n     * @param {number} nth\r\n     * @param {Function} [compareFunc]\r\n     * @example\r\n     *     var quickSelect = require('echarts/data/quickSelect');\r\n     *     var list = [5, 2, 1, 4, 3]\r\n     *     quickSelect(list, 3);\r\n     *     quickSelect(list, 0, 3, 1, function (a, b) {return a - b});\r\n     *\r\n     * @return {number}\r\n     */\r\n    function quickSelect(list, left, right, nth, compareFunc) {\r\n        if (arguments.length <= 3) {\r\n            nth = left;\r\n            if (arguments.length == 2) {\r\n                compareFunc = defaultCompareFunc;\r\n            } else {\r\n                compareFunc = right;\r\n            }\r\n            left = 0;\r\n            right = list.length - 1;\r\n        }\r\n        return select(list, left, right, nth, compareFunc);\r\n    }\r\n    \r\n    return quickSelect;\r\n});"
        },
        {
          "id": 50,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Rectangle.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
          "index": 50,
          "index2": 45,
          "size": 7506,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Rectangle",
              "loc": "12:25-61"
            },
            {
              "moduleId": 52,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Rectangle",
              "loc": "14:25-61"
            },
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Rectangle",
              "loc": "14:25-61"
            },
            {
              "moduleId": 59,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Rectangle",
              "loc": "12:25-61"
            },
            {
              "moduleId": 60,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Rectangle",
              "loc": "12:25-61"
            }
          ],
          "source": "/**\r\n * 矩形\r\n * @module zrender/shape/Rectangle\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com) , \r\n *         strwind (@劲风FEI)\r\n * @example\r\n *     var Rectangle = require('zrender/shape/Rectangle');\r\n *     var shape = new Rectangle({\r\n *         style: {\r\n *             x: 0,\r\n *             y: 0,\r\n *             width: 100,\r\n *             height: 100,\r\n *             radius: 20\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IRectangleStyle\r\n * @property {number} x 左上角x坐标\r\n * @property {number} y 左上角y坐标\r\n * @property {number} width 宽度\r\n * @property {number} height 高度\r\n * @property {number|Array.<number>} radius 矩形圆角，可以用数组分别指定四个角的圆角\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        var Base = require('./Base');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/Rectangle\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Rectangle = function (options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 矩形绘制样式\r\n             * @name module:zrender/shape/Rectangle#style\r\n             * @type {module:zrender/shape/Rectangle~IRectangleStyle}\r\n             */\r\n            /**\r\n             * 矩形高亮绘制样式\r\n             * @name module:zrender/shape/Rectangle#highlightStyle\r\n             * @type {module:zrender/shape/Rectangle~IRectangleStyle}\r\n             */\r\n        };\r\n\r\n        Rectangle.prototype =  {\r\n            type: 'rectangle',\r\n\r\n            _buildRadiusPath: function (ctx, style) {\r\n                // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\r\n                // r缩写为1         相当于 [1, 1, 1, 1]\r\n                // r缩写为[1]       相当于 [1, 1, 1, 1]\r\n                // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\r\n                // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\r\n                var x = style.x;\r\n                var y = style.y;\r\n                var width = style.width;\r\n                var height = style.height;\r\n                var r = style.radius;\r\n                var r1; \r\n                var r2; \r\n                var r3; \r\n                var r4;\r\n                  \r\n                if (typeof r === 'number') {\r\n                    r1 = r2 = r3 = r4 = r;\r\n                }\r\n                else if (r instanceof Array) {\r\n                    if (r.length === 1) {\r\n                        r1 = r2 = r3 = r4 = r[0];\r\n                    }\r\n                    else if (r.length === 2) {\r\n                        r1 = r3 = r[0];\r\n                        r2 = r4 = r[1];\r\n                    }\r\n                    else if (r.length === 3) {\r\n                        r1 = r[0];\r\n                        r2 = r4 = r[1];\r\n                        r3 = r[2];\r\n                    }\r\n                    else {\r\n                        r1 = r[0];\r\n                        r2 = r[1];\r\n                        r3 = r[2];\r\n                        r4 = r[3];\r\n                    }\r\n                }\r\n                else {\r\n                    r1 = r2 = r3 = r4 = 0;\r\n                }\r\n                \r\n                var total;\r\n                if (r1 + r2 > width) {\r\n                    total = r1 + r2;\r\n                    r1 *= width / total;\r\n                    r2 *= width / total;\r\n                }\r\n                if (r3 + r4 > width) {\r\n                    total = r3 + r4;\r\n                    r3 *= width / total;\r\n                    r4 *= width / total;\r\n                }\r\n                if (r2 + r3 > height) {\r\n                    total = r2 + r3;\r\n                    r2 *= height / total;\r\n                    r3 *= height / total;\r\n                }\r\n                if (r1 + r4 > height) {\r\n                    total = r1 + r4;\r\n                    r1 *= height / total;\r\n                    r4 *= height / total;\r\n                }\r\n                ctx.moveTo(x + r1, y);\r\n                ctx.lineTo(x + width - r2, y);\r\n                r2 !== 0 && ctx.quadraticCurveTo(\r\n                    x + width, y, x + width, y + r2\r\n                );\r\n                ctx.lineTo(x + width, y + height - r3);\r\n                r3 !== 0 && ctx.quadraticCurveTo(\r\n                    x + width, y + height, x + width - r3, y + height\r\n                );\r\n                ctx.lineTo(x + r4, y + height);\r\n                r4 !== 0 && ctx.quadraticCurveTo(\r\n                    x, y + height, x, y + height - r4\r\n                );\r\n                ctx.lineTo(x, y + r1);\r\n                r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\r\n            },\r\n            \r\n            /**\r\n             * 创建矩形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {Object} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                if (!style.radius) {\r\n                    ctx.moveTo(style.x, style.y);\r\n                    ctx.lineTo(style.x + style.width, style.y);\r\n                    ctx.lineTo(style.x + style.width, style.y + style.height);\r\n                    ctx.lineTo(style.x, style.y + style.height);\r\n                    ctx.lineTo(style.x, style.y);\r\n                    // ctx.rect(style.x, style.y, style.width, style.height);\r\n                }\r\n                else {\r\n                    this._buildRadiusPath(ctx, style);\r\n                }\r\n                ctx.closePath();\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 计算返回矩形包围盒矩阵\r\n             * @param {module:zrender/shape/Rectangle~IRectangleStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function(style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var lineWidth;\r\n                if (style.brushType == 'stroke' || style.brushType == 'fill') {\r\n                    lineWidth = style.lineWidth || 1;\r\n                }\r\n                else {\r\n                    lineWidth = 0;\r\n                }\r\n                style.__rect = {\r\n                    x : Math.round(style.x - lineWidth / 2),\r\n                    y : Math.round(style.y - lineWidth / 2),\r\n                    width : style.width + lineWidth,\r\n                    height : style.height + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Rectangle, Base);\r\n        return Rectangle;\r\n    }\r\n);\r\n"
        },
        {
          "id": 51,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "index": 51,
          "index2": 53,
          "size": 13662,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "../component/axis",
              "loc": "14:4-32"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "../component/axis",
              "loc": "16:4-32"
            }
          ],
          "source": "/**\r\n * echarts组件类： 坐标轴\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * 直角坐标系中坐标轴数组，数组中每一项代表一条横轴（纵轴）坐标轴。\r\n * 标准（1.0）中规定最多同时存在2条横轴和2条纵轴\r\n *    单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时则默认第一条安放于底部，第二天安放于顶部\r\n *    单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时则默认第一条安放于左侧，第二天安放于右侧。\r\n * 坐标轴有两种类型，类目型和数值型（区别详见axis）：\r\n *    横轴通常为类目型，但条形图时则横轴为数值型，散点图时则横纵均为数值型\r\n *    纵轴通常为数值型，但条形图时则纵轴为类目型。\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n\r\n    var LineShape = require('zrenderjs/shape/Line');\r\n\r\n    var ecConfig = require('../config');\r\n    var ecData = require('../util/ecData');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrColor = require('zrenderjs/tool/color');\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 图表选项\r\n     *     @param {string=} option.xAxis.type 坐标轴类型，横轴默认为类目型'category'\r\n     *     @param {string=} option.yAxis.type 坐标轴类型，纵轴默认为类目型'value'\r\n     * @param {Object} component 组件\r\n     * @param {string} axisType 横走or纵轴\r\n     */\r\n    function Axis(ecTheme, messageCenter, zr, option, myChart, axisType) {\r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this.axisType = axisType;\r\n        this._axisList = [];\r\n\r\n        this.refresh(option);\r\n    }\r\n\r\n    Axis.prototype = {\r\n        type: ecConfig.COMPONENT_TYPE_AXIS,\r\n        axisBase: {\r\n            // 轴线\r\n            _buildAxisLine: function () {\r\n                var lineWidth = this.option.axisLine.lineStyle.width;\r\n                var halfLineWidth = lineWidth / 2;\r\n                var axShape = {\r\n                    _axisShape: 'axisLine',\r\n                    zlevel: this.getZlevelBase(),\r\n                    z: this.getZBase() + 3,\r\n                    hoverable: false\r\n                };\r\n                var grid = this.grid;\r\n                switch (this.option.position) {\r\n                    case 'left' :\r\n                        axShape.style = {\r\n                            xStart: grid.getX() - halfLineWidth,\r\n                            yStart: grid.getYend(),\r\n                            xEnd: grid.getX() - halfLineWidth,\r\n                            yEnd: grid.getY(),\r\n                            lineCap: 'round'\r\n                        };\r\n                        break;\r\n                    case 'right' :\r\n                        axShape.style = {\r\n                            xStart: grid.getXend() + halfLineWidth,\r\n                            yStart: grid.getYend(),\r\n                            xEnd: grid.getXend() + halfLineWidth,\r\n                            yEnd: grid.getY(),\r\n                            lineCap: 'round'\r\n                        };\r\n                        break;\r\n                    case 'bottom' :\r\n                        axShape.style = {\r\n                            xStart: grid.getX(),\r\n                            yStart: grid.getYend() + halfLineWidth,\r\n                            xEnd: grid.getXend(),\r\n                            yEnd: grid.getYend() + halfLineWidth,\r\n                            lineCap: 'round'\r\n                        };\r\n                        break;\r\n                    case 'top' :\r\n                        axShape.style = {\r\n                            xStart: grid.getX(),\r\n                            yStart: grid.getY() - halfLineWidth,\r\n                            xEnd: grid.getXend(),\r\n                            yEnd: grid.getY() - halfLineWidth,\r\n                            lineCap: 'round'\r\n                        };\r\n                        break;\r\n                }\r\n                var style = axShape.style;\r\n                if (this.option.name !== '') { // 别帮我代码规范\r\n                    style.text = this.option.name;\r\n                    style.textPosition = this.option.nameLocation;\r\n                    style.textFont = this.getFont(this.option.nameTextStyle);\r\n                    if (this.option.nameTextStyle.align) {\r\n                        style.textAlign = this.option.nameTextStyle.align;\r\n                    }\r\n                    if (this.option.nameTextStyle.baseline) {\r\n                        style.textBaseline = this.option.nameTextStyle.baseline;\r\n                    }\r\n                    if (this.option.nameTextStyle.color) {\r\n                        style.textColor = this.option.nameTextStyle.color;\r\n                    }\r\n                }\r\n                style.strokeColor = this.option.axisLine.lineStyle.color;\r\n\r\n                style.lineWidth = lineWidth;\r\n                // 亚像素优化\r\n                if (this.isHorizontal()) {\r\n                    // 横向布局，优化y\r\n                    style.yStart\r\n                        = style.yEnd\r\n                        = this.subPixelOptimize(style.yEnd, lineWidth);\r\n                }\r\n                else {\r\n                    // 纵向布局，优化x\r\n                    style.xStart\r\n                        = style.xEnd\r\n                        = this.subPixelOptimize(style.xEnd, lineWidth);\r\n                }\r\n\r\n                style.lineType = this.option.axisLine.lineStyle.type;\r\n\r\n                axShape = new LineShape(axShape);\r\n                this.shapeList.push(axShape);\r\n            },\r\n\r\n            _axisLabelClickable: function(clickable, axShape) {\r\n                if (clickable) {\r\n                    ecData.pack(\r\n                        axShape, undefined, -1, undefined, -1, axShape.style.text\r\n                    );\r\n                    axShape.hoverable = true;\r\n                    axShape.clickable = true;\r\n                    axShape.highlightStyle = {\r\n                        color: zrColor.lift(axShape.style.color, 1),\r\n                        brushType: 'fill'\r\n                    };\r\n                    return axShape;\r\n                }\r\n                else {\r\n                    return axShape;\r\n                }\r\n            },\r\n\r\n            refixAxisShape: function(zeroX, zeroY) {\r\n                if (!this.option.axisLine.onZero) {\r\n                    return;\r\n                }\r\n                var tickLength;\r\n                if (this.isHorizontal() && zeroY != null) {\r\n                    // 横向布局调整纵向y\r\n                    for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                        if (this.shapeList[i]._axisShape === 'axisLine') {\r\n                            this.shapeList[i].style.yStart\r\n                                = this.shapeList[i].style.yEnd\r\n                                = this.subPixelOptimize(\r\n                                    zeroY, this.shapeList[i].stylelineWidth\r\n                                );\r\n                            this.zr.modShape(this.shapeList[i].id);\r\n                        }\r\n                        else if (this.shapeList[i]._axisShape === 'axisTick') {\r\n                            tickLength = this.shapeList[i].style.yEnd\r\n                                         - this.shapeList[i].style.yStart;\r\n                            this.shapeList[i].style.yStart = zeroY - tickLength;\r\n                            this.shapeList[i].style.yEnd = zeroY;\r\n                            this.zr.modShape(this.shapeList[i].id);\r\n                        }\r\n                    }\r\n                }\r\n                if (!this.isHorizontal() && zeroX != null) {\r\n                    // 纵向布局调整横向x\r\n                    for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                        if (this.shapeList[i]._axisShape === 'axisLine') {\r\n                            this.shapeList[i].style.xStart\r\n                                = this.shapeList[i].style.xEnd\r\n                                = this.subPixelOptimize(\r\n                                    zeroX, this.shapeList[i].stylelineWidth\r\n                                );\r\n                            this.zr.modShape(this.shapeList[i].id);\r\n                        }\r\n                        else if (this.shapeList[i]._axisShape === 'axisTick') {\r\n                            tickLength = this.shapeList[i].style.xEnd\r\n                                         - this.shapeList[i].style.xStart;\r\n                            this.shapeList[i].style.xStart = zeroX;\r\n                            this.shapeList[i].style.xEnd = zeroX + tickLength;\r\n                            this.zr.modShape(this.shapeList[i].id);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n\r\n            getPosition: function () {\r\n                return this.option.position;\r\n            },\r\n\r\n            isHorizontal: function() {\r\n                return this.option.position === 'bottom' || this.option.position === 'top';\r\n            }\r\n        },\r\n        /**\r\n         * 参数修正&默认值赋值，重载基类方法\r\n         * @param {Object} opt 参数\r\n         */\r\n        reformOption: function (opt) {\r\n            // 不写或传了个空数值默认为数值轴\r\n            if (!opt || (opt instanceof Array && opt.length === 0)) {\r\n                opt = [ { type: ecConfig.COMPONENT_TYPE_AXIS_VALUE } ];\r\n            }\r\n            else if (!(opt instanceof Array)){\r\n                opt = [opt];\r\n            }\r\n\r\n            // 最多两条，其他参数忽略\r\n            if (opt.length > 2) {\r\n                opt = [opt[0], opt[1]];\r\n            }\r\n\r\n            if (this.axisType === 'xAxis') {\r\n                // 横轴位置默认配置\r\n                if (!opt[0].position            // 没配置或配置错\r\n                    || (opt[0].position != 'bottom' && opt[0].position != 'top')\r\n                ) {\r\n                    opt[0].position = 'bottom';\r\n                }\r\n                if (opt.length > 1) {\r\n                    opt[1].position = opt[0].position === 'bottom' ? 'top' : 'bottom';\r\n                }\r\n\r\n                for (var i = 0, l = opt.length; i < l; i++) {\r\n                    // 坐标轴类型，横轴默认为类目型'category'\r\n                    opt[i].type = opt[i].type || 'category';\r\n                    // 标识轴类型&索引\r\n                    opt[i].xAxisIndex = i;\r\n                    opt[i].yAxisIndex = -1;\r\n                }\r\n            }\r\n            else {\r\n                // 纵轴位置默认配置\r\n                if (!opt[0].position            // 没配置或配置错\r\n                    || (opt[0].position != 'left'  && opt[0].position != 'right')\r\n                ) {\r\n                    opt[0].position = 'left';\r\n                }\r\n\r\n                if (opt.length > 1) {\r\n                    opt[1].position = opt[0].position === 'left' ? 'right' : 'left';\r\n                }\r\n\r\n                for (var i = 0, l = opt.length; i < l; i++) {\r\n                    // 坐标轴类型，纵轴默认为数值型'value'\r\n                    opt[i].type = opt[i].type || 'value';\r\n                    // 标识轴类型&索引\r\n                    opt[i].xAxisIndex = -1;\r\n                    opt[i].yAxisIndex = i;\r\n                }\r\n            }\r\n\r\n            return opt;\r\n        },\r\n\r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption) {\r\n            var axisOption;\r\n            if (newOption) {\r\n                this.option = newOption;\r\n                if (this.axisType === 'xAxis') {\r\n                    this.option.xAxis = this.reformOption(newOption.xAxis);\r\n                    axisOption = this.option.xAxis;\r\n                }\r\n                else {\r\n                    this.option.yAxis = this.reformOption(newOption.yAxis);\r\n                    axisOption = this.option.yAxis;\r\n                }\r\n                this.series = newOption.series;\r\n            }\r\n\r\n            var CategoryAxis = require('./categoryAxis');\r\n            var ValueAxis = require('./valueAxis');\r\n            var len = Math.max((axisOption && axisOption.length || 0), this._axisList.length);\r\n            for (var i = 0; i < len; i++) {\r\n                if (this._axisList[i]   // 已有实例\r\n                    && newOption        // 非空刷新\r\n                    && (!axisOption[i] || this._axisList[i].type != axisOption[i].type) // 类型不匹配\r\n                ) {\r\n                    this._axisList[i].dispose && this._axisList[i].dispose();\r\n                    this._axisList[i] = false;\r\n                }\r\n\r\n                if (this._axisList[i]) {\r\n                    this._axisList[i].refresh && this._axisList[i].refresh(\r\n                        axisOption ? axisOption[i] : false,\r\n                        this.series\r\n                    );\r\n                }\r\n                else if (axisOption && axisOption[i]) {\r\n                    this._axisList[i] = axisOption[i].type === 'category'\r\n                        ? new CategoryAxis(\r\n                               this.ecTheme, this.messageCenter, this.zr,\r\n                               axisOption[i], this.myChart, this.axisBase\r\n                           )\r\n                        : new ValueAxis(\r\n                               this.ecTheme, this.messageCenter, this.zr,\r\n                               axisOption[i], this.myChart, this.axisBase,\r\n                               this.series\r\n                        );\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 根据值换算位置\r\n         * @param {number} idx 坐标轴索引0~1\r\n         */\r\n        getAxis: function (idx) {\r\n            return this._axisList[idx];\r\n        },\r\n\r\n        getAxisCount: function () {\r\n            return this._axisList.length;\r\n        },\r\n\r\n        clear: function () {\r\n            for (var i = 0, l = this._axisList.length; i < l; i++) {\r\n                this._axisList[i].dispose && this._axisList[i].dispose();\r\n            }\r\n            this._axisList = [];\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(Axis, Base);\r\n\r\n    require('../component').define('axis', Axis);\r\n\r\n    return Axis;\r\n});\r\n"
        },
        {
          "id": 52,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "index": 52,
          "index2": 48,
          "size": 32791,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 51,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "type": "cjs require",
              "userRequest": "./categoryAxis",
              "loc": "287:31-56"
            }
          ],
          "source": "/**\r\n * echarts组件： 类目轴\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n    \r\n    // 图形依赖\r\n    var TextShape = require('zrenderjs/shape/Text');\r\n    var LineShape = require('zrenderjs/shape/Line');\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n    \r\n    var ecConfig = require('../config');\r\n    // 类目轴\r\n    ecConfig.categoryAxis =  {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 0,                       // 二级层叠\r\n        show: true,\r\n        position: 'bottom',    // 位置\r\n        name: '',              // 坐标轴名字，默认为空\r\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\r\n        nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式\r\n        boundaryGap: true,     // 类目起始和结束两端空白策略\r\n        axisLine: {            // 坐标轴线\r\n            show: true,        // 默认显示，属性show控制显示与否\r\n            onZero: true,\r\n            lineStyle: {       // 属性lineStyle控制线条样式\r\n                color: '#48b',\r\n                width: 2,\r\n                type: 'solid'\r\n            }\r\n        },\r\n        axisTick: {            // 坐标轴小标记\r\n            show: true,        // 属性show控制显示与否，默认不显示\r\n            interval: 'auto',\r\n            inside: false,    // 控制小标记是否在grid里 \r\n            // onGap: null,\r\n            length :5,         // 属性length控制线长\r\n            lineStyle: {       // 属性lineStyle控制线条样式\r\n                color: '#333',\r\n                width: 1\r\n            }\r\n        },\r\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\r\n            show: true,\r\n            interval: 'auto',\r\n            rotate: 0,\r\n            margin: 8,\r\n            // clickable: false,\r\n            // formatter: null,\r\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\r\n                color: '#333'\r\n            }\r\n        },\r\n        splitLine: {           // 分隔线\r\n            show: true,        // 默认显示，属性show控制显示与否\r\n            // onGap: null,\r\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\r\n                color: ['#ccc'],\r\n                width: 1,\r\n                type: 'solid'\r\n            }\r\n        },\r\n        splitArea: {           // 分隔区域\r\n            show: false,       // 默认不显示，属性show控制显示与否\r\n            // onGap: null,\r\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\r\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\r\n            }\r\n        }\r\n    };\r\n\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrArea = require('zrenderjs/tool/area');\r\n    \r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 类目轴参数\r\n     * @param {Grid} component 组件\r\n     */\r\n    function CategoryAxis(ecTheme, messageCenter, zr, option, myChart, axisBase) {\r\n        if (option.data.length < 1) {\r\n            console.error('option.data.length < 1.');\r\n            return;\r\n        }\r\n        \r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n        \r\n        this.grid = this.component.grid;\r\n        \r\n        for (var method in axisBase) {\r\n            this[method] = axisBase[method];\r\n        }\r\n        \r\n        this.refresh(option);\r\n    }\r\n    \r\n    CategoryAxis.prototype = {\r\n        type : ecConfig.COMPONENT_TYPE_AXIS_CATEGORY,\r\n        _getReformedLabel : function (idx) {\r\n            var data = this.getDataFromOption(this.option.data[idx]);\r\n            var formatter = this.option.data[idx].formatter \r\n                            || this.option.axisLabel.formatter;\r\n            if (formatter) {\r\n                if (typeof formatter == 'function') {\r\n                    data = formatter.call(this.myChart, data);\r\n                }\r\n                else if (typeof formatter == 'string') {\r\n                    data = formatter.replace('{value}', data);\r\n                }\r\n            }\r\n            return data;\r\n        },\r\n        \r\n        /**\r\n         * 计算标签显示挑选间隔\r\n         */\r\n        _getInterval : function () {\r\n            var interval   = this.option.axisLabel.interval;\r\n            if (interval == 'auto') {\r\n                // 麻烦的自适应计算\r\n                var fontSize = this.option.axisLabel.textStyle.fontSize;\r\n                var data = this.option.data;\r\n                var dataLength = this.option.data.length;\r\n\r\n                if (this.isHorizontal()) {\r\n                    // 横向\r\n                    if (dataLength > 3) {\r\n                        var gap = this.getGap();\r\n                        var isEnough = false;\r\n                        var labelSpace;\r\n                        var labelSize;\r\n                        var step = Math.floor(0.5 / gap);\r\n                        step = step < 1 ? 1 : step;\r\n                        interval = Math.floor(15 / gap);\r\n                        while (!isEnough && interval < dataLength) {\r\n                            interval += step;\r\n                            isEnough = true;\r\n                            labelSpace = Math.floor(gap * interval); // 标签左右至少间隔为3px\r\n                            for (var i = Math.floor((dataLength - 1)/ interval) * interval; \r\n                                 i >= 0; i -= interval\r\n                             ) {\r\n                                if (this.option.axisLabel.rotate !== 0) {\r\n                                    // 有旋转\r\n                                    labelSize = fontSize;\r\n                                }\r\n                                else if (data[i].textStyle) {\r\n                                    labelSize = zrArea.getTextWidth(\r\n                                        this._getReformedLabel(i),\r\n                                        this.getFont(\r\n                                            zrUtil.merge(\r\n                                                data[i].textStyle,\r\n                                                this.option.axisLabel.textStyle\r\n                                           )\r\n                                        )\r\n                                    );\r\n                                }\r\n                                else {\r\n                                    /*\r\n                                    labelSize = zrArea.getTextWidth(\r\n                                        this._getReformedLabel(i),\r\n                                        font\r\n                                    );\r\n                                    */\r\n                                    // 不定义data级特殊文本样式，用fontSize优化getTextWidth\r\n                                    var label = this._getReformedLabel(i) + '';\r\n                                    var wLen = (label.match(/\\w/g) || '').length;\r\n                                    var oLen = label.length - wLen;\r\n                                    labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;\r\n                                }\r\n\r\n                                if (labelSpace < labelSize) {\r\n                                    // 放不下，中断循环让interval++\r\n                                    isEnough = false;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // 少于3个则全部显示\r\n                        interval = 1;\r\n                    }\r\n                }\r\n                else {\r\n                    // 纵向\r\n                    if (dataLength > 3) {\r\n                        var gap = this.getGap();\r\n                        interval = Math.floor(11 / gap);\r\n                        // 标签上下至少间隔为3px\r\n                        while ((gap * interval - 6) < fontSize\r\n                                && interval < dataLength\r\n                        ) {\r\n                            interval++;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // 少于3个则全部显示\r\n                        interval = 1;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // 用户自定义间隔，支持funtion\r\n                interval = typeof interval == 'function' ? 1 : (interval - 0 + 1);\r\n            }\r\n\r\n            return interval;\r\n        },\r\n        \r\n        /**\r\n         * 绘制图形\r\n         */\r\n        _buildShape : function () {\r\n            // 标签显示的挑选间隔\r\n            this._interval = this._getInterval();\r\n            if (!this.option.show) {\r\n                return;\r\n            }\r\n            this.option.splitArea.show && this._buildSplitArea();\r\n            this.option.splitLine.show && this._buildSplitLine();\r\n            this.option.axisLine.show && this._buildAxisLine();\r\n            this.option.axisTick.show && this._buildAxisTick();\r\n            this.option.axisLabel.show && this._buildAxisLabel();\r\n\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                this.zr.addShape(this.shapeList[i]);\r\n            }\r\n        },\r\n\r\n        // 小标记\r\n        _buildAxisTick : function () {\r\n            var axShape;\r\n            var data       = this.option.data;\r\n            var dataLength = this.option.data.length;\r\n            var tickOption = this.option.axisTick;\r\n            var length     = tickOption.length;\r\n            var color      = tickOption.lineStyle.color;\r\n            var lineWidth  = tickOption.lineStyle.width;\r\n            var intervalFunction = typeof tickOption.interval == 'function'\r\n                                   ? tickOption.interval \r\n                                   : tickOption.interval == 'auto'\r\n                                     ? typeof this.option.axisLabel.interval == 'function'\r\n                                       ? this.option.axisLabel.interval : false\r\n                                     : false;\r\n            var interval   = intervalFunction\r\n                             ? 1\r\n                             : tickOption.interval == 'auto' \r\n                               ? this._interval\r\n                               : (tickOption.interval - 0 + 1);\r\n            var onGap      = tickOption.onGap;\r\n            var optGap     = onGap \r\n                             ? (this.getGap() / 2) \r\n                             : typeof onGap == 'undefined'\r\n                                   ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)\r\n                                   : 0;\r\n            var startIndex = optGap > 0 ? -interval : 0;                       \r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var yPosition = this.option.position == 'bottom'\r\n                        ? (tickOption.inside \r\n                           ? (this.grid.getYend() - length - 1) : (this.grid.getYend() + 1))\r\n                        : (tickOption.inside \r\n                           ? (this.grid.getY() + 1) : (this.grid.getY() - length - 1));\r\n                var x;\r\n                for (var i = startIndex; i < dataLength; i += interval) {\r\n                    if (intervalFunction && !intervalFunction(i, data[i])) {\r\n                        // 回调并且回调返回false则跳过渲染\r\n                        continue;\r\n                    }\r\n                    // 亚像素优化\r\n                    x = this.subPixelOptimize(\r\n                        this.getCoordByIndex(i) + (i >= 0 ? optGap : 0), lineWidth\r\n                    );\r\n                    axShape = {\r\n                        _axisShape : 'axisTick',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable : false,\r\n                        style : {\r\n                            xStart : x,\r\n                            yStart : yPosition,\r\n                            xEnd : x,\r\n                            yEnd : yPosition + length,\r\n                            strokeColor : color,\r\n                            lineWidth : lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n            else {\r\n                // 纵向\r\n                var xPosition = this.option.position == 'left'\r\n                    ? (tickOption.inside \r\n                       ? (this.grid.getX() + 1) : (this.grid.getX() - length - 1))\r\n                    : (tickOption.inside \r\n                       ? (this.grid.getXend() - length - 1) : (this.grid.getXend() + 1));\r\n                        \r\n                var y;\r\n                for (var i = startIndex; i < dataLength; i += interval) {\r\n                    if (intervalFunction && !intervalFunction(i, data[i])) {\r\n                        // 回调并且回调返回false则中断渲染\r\n                        continue;\r\n                    }\r\n                    // 亚像素优化\r\n                    y = this.subPixelOptimize(\r\n                        this.getCoordByIndex(i) - (i >= 0 ? optGap : 0), lineWidth\r\n                    );\r\n                    axShape = {\r\n                        _axisShape : 'axisTick',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable : false,\r\n                        style : {\r\n                            xStart : xPosition,\r\n                            yStart : y,\r\n                            xEnd : xPosition + length,\r\n                            yEnd : y,\r\n                            strokeColor : color,\r\n                            lineWidth : lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n        },\r\n\r\n        // 坐标轴文本\r\n        _buildAxisLabel : function () {\r\n            var axShape;\r\n            var data       = this.option.data;\r\n            var dataLength = this.option.data.length;\r\n            var labelOption = this.option.axisLabel;\r\n            var rotate     = labelOption.rotate;\r\n            var margin     = labelOption.margin;\r\n            var clickable  = labelOption.clickable;\r\n            var textStyle  = labelOption.textStyle;\r\n            var intervalFunction = typeof labelOption.interval == 'function'\r\n                                   ? labelOption.interval : false;\r\n            var dataTextStyle;\r\n\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var yPosition;\r\n                var baseLine;\r\n                if (this.option.position == 'bottom') {\r\n                    yPosition = this.grid.getYend() + margin;\r\n                    baseLine = 'top';\r\n                }\r\n                else {\r\n                    yPosition = this.grid.getY() - margin;\r\n                    baseLine = 'bottom';\r\n                }\r\n\r\n                for (var i = 0; i < dataLength; i += this._interval) {\r\n                    if ((intervalFunction && !intervalFunction(i, data[i])) \r\n                        // 回调并且回调返回false则中断渲染\r\n                        || this._getReformedLabel(i) === '' // 空文本优化\r\n                    ) {\r\n                        continue;\r\n                    }\r\n                    dataTextStyle = zrUtil.merge(\r\n                        data[i].textStyle || {},\r\n                        textStyle\r\n                    );\r\n                    axShape = {\r\n                        // shape : 'text',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase() + 3,\r\n                        hoverable : false,\r\n                        style : {\r\n                            x : this.getCoordByIndex(i),\r\n                            y : yPosition,\r\n                            color : dataTextStyle.color,\r\n                            text : this._getReformedLabel(i),\r\n                            textFont : this.getFont(dataTextStyle),\r\n                            textAlign : dataTextStyle.align || 'center',\r\n                            textBaseline : dataTextStyle.baseline || baseLine\r\n                        }\r\n                    };\r\n                    if (rotate) {\r\n                        axShape.style.textAlign = rotate > 0\r\n                                                  ? (this.option.position == 'bottom'\r\n                                                    ? 'right' : 'left')\r\n                                                  : (this.option.position == 'bottom'\r\n                                                    ? 'left' : 'right');\r\n                        axShape.rotation = [\r\n                            rotate * Math.PI / 180,\r\n                            axShape.style.x,\r\n                            axShape.style.y\r\n                        ];\r\n                    }\r\n                    this.shapeList.push(new TextShape(\r\n                        this._axisLabelClickable(clickable, axShape)\r\n                    ));\r\n                }\r\n            }\r\n            else {\r\n                // 纵向\r\n                var xPosition;\r\n                var align;\r\n                if (this.option.position == 'left') {\r\n                    xPosition = this.grid.getX() - margin;\r\n                    align = 'right';\r\n                }\r\n                else {\r\n                    xPosition = this.grid.getXend() + margin;\r\n                    align = 'left';\r\n                }\r\n\r\n                for (var i = 0; i < dataLength; i += this._interval) {\r\n                    if ((intervalFunction && !intervalFunction(i, data[i])) \r\n                        // 回调并且回调返回false则中断渲染\r\n                        || this._getReformedLabel(i) === '' // 空文本优化\r\n                    ) {\r\n                        continue;\r\n                    }\r\n                    dataTextStyle = zrUtil.merge(\r\n                        data[i].textStyle || {},\r\n                        textStyle\r\n                    );\r\n                    axShape = {\r\n                        // shape : 'text',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase() + 3,\r\n                        hoverable : false,\r\n                        style : {\r\n                            x : xPosition,\r\n                            y : this.getCoordByIndex(i),\r\n                            color : dataTextStyle.color,\r\n                            text : this._getReformedLabel(i),\r\n                            textFont : this.getFont(dataTextStyle),\r\n                            textAlign : dataTextStyle.align || align,\r\n                            textBaseline : dataTextStyle.baseline \r\n                                           || (i === 0 && this.option.name !== '')\r\n                                               ? 'bottom'\r\n                                               : (i == (dataLength - 1) \r\n                                                  && this.option.name !== '')\r\n                                                 ? 'top'\r\n                                                 : 'middle'\r\n                        }\r\n                    };\r\n                    \r\n                    if (rotate) {\r\n                        axShape.rotation = [\r\n                            rotate * Math.PI / 180,\r\n                            axShape.style.x,\r\n                            axShape.style.y\r\n                        ];\r\n                    }\r\n                    this.shapeList.push(new TextShape(\r\n                        this._axisLabelClickable(clickable, axShape)\r\n                    ));\r\n                }\r\n            }\r\n        },\r\n        \r\n        _buildSplitLine : function () {\r\n            var axShape;\r\n            var data        = this.option.data;\r\n            var dataLength  = this.option.data.length;\r\n            var sLineOption = this.option.splitLine;\r\n            var lineType    = sLineOption.lineStyle.type;\r\n            var lineWidth   = sLineOption.lineStyle.width;\r\n            var color       = sLineOption.lineStyle.color;\r\n            color = color instanceof Array ? color : [color];\r\n            var colorLength = color.length;\r\n            \r\n            // splitLine随axisLable\r\n            var intervalFunction = typeof this.option.axisLabel.interval == 'function'\r\n                                   ? this.option.axisLabel.interval : false;\r\n\r\n            var onGap      = sLineOption.onGap;\r\n            var optGap     = onGap \r\n                             ? (this.getGap() / 2) \r\n                             : typeof onGap == 'undefined'\r\n                                   ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)\r\n                                   : 0;\r\n            dataLength -= (onGap || (typeof onGap == 'undefined' && this.option.boundaryGap)) \r\n                          ? 1 : 0;\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var sy = this.grid.getY();\r\n                var ey = this.grid.getYend();\r\n                var x;\r\n\r\n                for (var i = 0; i < dataLength; i += this._interval) {\r\n                    if (intervalFunction && !intervalFunction(i, data[i])) {\r\n                        // 回调并且回调返回false则跳过渲染\r\n                        continue;\r\n                    }\r\n                    // 亚像素优化\r\n                    x = this.subPixelOptimize(\r\n                        this.getCoordByIndex(i) + optGap, lineWidth\r\n                    );\r\n                    axShape = {\r\n                        // shape : 'line',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable : false,\r\n                        style : {\r\n                            xStart : x,\r\n                            yStart : sy,\r\n                            xEnd : x,\r\n                            yEnd : ey,\r\n                            strokeColor : color[(i / this._interval) % colorLength],\r\n                            lineType : lineType,\r\n                            lineWidth : lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n\r\n            }\r\n            else {\r\n                // 纵向\r\n                var sx = this.grid.getX();\r\n                var ex = this.grid.getXend();\r\n                var y;\r\n\r\n                for (var i = 0; i < dataLength; i += this._interval) {\r\n                    if (intervalFunction && !intervalFunction(i, data[i])) {\r\n                        // 回调并且回调返回false则跳过渲染\r\n                        continue;\r\n                    }\r\n                    // 亚像素优化\r\n                    y = this.subPixelOptimize(\r\n                        this.getCoordByIndex(i) - optGap, lineWidth\r\n                    );\r\n                    axShape = {\r\n                        // shape : 'line',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable : false,\r\n                        style : {\r\n                            xStart : sx,\r\n                            yStart : y,\r\n                            xEnd : ex,\r\n                            yEnd : y,\r\n                            strokeColor : color[(i / this._interval) % colorLength],\r\n                            lineType : lineType,\r\n                            lineWidth : lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n        },\r\n\r\n        _buildSplitArea : function () {\r\n            var axShape;\r\n            var data        = this.option.data;\r\n            var sAreaOption = this.option.splitArea;\r\n            var color = sAreaOption.areaStyle.color;\r\n            if (!(color instanceof Array)) {\r\n                // 非数组一律认为是单一颜色的字符串，单一颜色则用一个背景，颜色错误不负责啊！！！\r\n                axShape = {\r\n                    // shape : 'rectangle',\r\n                    zlevel: this.getZlevelBase(),\r\n                    z: this.getZBase(),\r\n                    hoverable : false,\r\n                    style : {\r\n                        x : this.grid.getX(),\r\n                        y : this.grid.getY(),\r\n                        width : this.grid.getWidth(),\r\n                        height : this.grid.getHeight(),\r\n                        color : color\r\n                        // type : this.option.splitArea.areaStyle.type,\r\n                    }\r\n                };\r\n                this.shapeList.push(new RectangleShape(axShape));\r\n            }\r\n            else {\r\n                // 多颜色\r\n                var colorLength = color.length;\r\n                var dataLength  = this.option.data.length;\r\n\r\n                // splitArea随axisLable\r\n                var intervalFunction = typeof this.option.axisLabel.interval == 'function'\r\n                                       ? this.option.axisLabel.interval : false;\r\n        \r\n                var onGap      = sAreaOption.onGap;\r\n                var optGap     = onGap \r\n                                 ? (this.getGap() / 2) \r\n                                 : typeof onGap == 'undefined'\r\n                                       ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)\r\n                                       : 0;\r\n                if (this.isHorizontal()) {\r\n                    // 横向\r\n                    var y = this.grid.getY();\r\n                    var height = this.grid.getHeight();\r\n                    var lastX = this.grid.getX();\r\n                    var curX;\r\n    \r\n                    for (var i = 0; i <= dataLength; i += this._interval) {\r\n                        if (intervalFunction && !intervalFunction(i, data[i]) && i < dataLength) {\r\n                            // 回调并且回调返回false则跳过渲染\r\n                            continue;\r\n                        }\r\n                        curX = i < dataLength\r\n                               ? (this.getCoordByIndex(i) + optGap)\r\n                               : this.grid.getXend();\r\n                        axShape = {\r\n                            // shape : 'rectangle',\r\n                            zlevel: this.getZlevelBase(),\r\n                            z: this.getZBase(),\r\n                            hoverable : false,\r\n                            style : {\r\n                                x : lastX,\r\n                                y : y,\r\n                                width : curX - lastX,\r\n                                height : height,\r\n                                color : color[(i / this._interval) % colorLength]\r\n                                // type : this.option.splitArea.areaStyle.type,\r\n                            }\r\n                        };\r\n                        this.shapeList.push(new RectangleShape(axShape));\r\n                        lastX = curX;\r\n                    }\r\n                }\r\n                else {\r\n                    // 纵向\r\n                    var x = this.grid.getX();\r\n                    var width = this.grid.getWidth();\r\n                    var lastYend = this.grid.getYend();\r\n                    var curY;\r\n    \r\n                    for (var i = 0; i <= dataLength; i += this._interval) {\r\n                        if (intervalFunction && !intervalFunction(i, data[i]) && i < dataLength) {\r\n                            // 回调并且回调返回false则跳过渲染\r\n                            continue;\r\n                        }\r\n                        curY = i < dataLength\r\n                               ? (this.getCoordByIndex(i) - optGap)\r\n                               : this.grid.getY();\r\n                        axShape = {\r\n                            // shape : 'rectangle',\r\n                            zlevel: this.getZlevelBase(),\r\n                            z: this.getZBase(),\r\n                            hoverable : false,\r\n                            style : {\r\n                                x : x,\r\n                                y : curY,\r\n                                width : width,\r\n                                height : lastYend - curY,\r\n                                color : color[(i / this._interval) % colorLength]\r\n                                // type : this.option.splitArea.areaStyle.type\r\n                            }\r\n                        };\r\n                        this.shapeList.push(new RectangleShape(axShape));\r\n                        lastYend = curY;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh : function (newOption) {\r\n            if (newOption) {\r\n                this.option = this.reformOption(newOption);\r\n                // 通用字体设置\r\n                this.option.axisLabel.textStyle = this.getTextStyle(\r\n                    this.option.axisLabel.textStyle\r\n                );\r\n            }\r\n            this.clear();\r\n            this._buildShape();\r\n        },\r\n\r\n        /**\r\n         * 返回间隔\r\n         */\r\n        getGap : function () {\r\n            var dataLength = this.option.data.length;\r\n            var total = this.isHorizontal()\r\n                        ? this.grid.getWidth()\r\n                        : this.grid.getHeight();\r\n            if (this.option.boundaryGap) {              // 留空\r\n                return total / dataLength;\r\n            }\r\n            else {                                      // 顶头\r\n                return total / (dataLength > 1 ? (dataLength - 1) : 1);\r\n            }\r\n        },\r\n\r\n        // 根据值换算位置\r\n        getCoord : function (value) {\r\n            var data = this.option.data;\r\n            var dataLength = data.length;\r\n            var gap = this.getGap();\r\n            var position = this.option.boundaryGap ? (gap / 2) : 0;\r\n\r\n            for (var i = 0; i < dataLength; i++) {\r\n                if (this.getDataFromOption(data[i]) == value) {\r\n                    if (this.isHorizontal()) {\r\n                        // 横向\r\n                        position = this.grid.getX() + position;\r\n                    }\r\n                    else {\r\n                        // 纵向\r\n                        position = this.grid.getYend() - position;\r\n                    }\r\n                    \r\n                    return position;\r\n                    // Math.floor可能引起一些偏差，但性能会更好\r\n                    /* 准确更重要\r\n                    return (i === 0 || i == dataLength - 1)\r\n                           ? position\r\n                           : Math.floor(position);\r\n                    */\r\n                }\r\n                position += gap;\r\n            }\r\n        },\r\n\r\n        // 根据类目轴数据索引换算位置\r\n        getCoordByIndex : function (dataIndex) {\r\n            if (dataIndex < 0) {\r\n                if (this.isHorizontal()) {\r\n                    return this.grid.getX();\r\n                }\r\n                else {\r\n                    return this.grid.getYend();\r\n                }\r\n            }\r\n            else if (dataIndex > this.option.data.length - 1) {\r\n                if (this.isHorizontal()) {\r\n                    return this.grid.getXend();\r\n                }\r\n                else {\r\n                    return this.grid.getY();\r\n                }\r\n            }\r\n            else {\r\n                var gap = this.getGap();\r\n                var position = this.option.boundaryGap ? (gap / 2) : 0;\r\n                position += dataIndex * gap;\r\n                \r\n                if (this.isHorizontal()) {\r\n                    // 横向\r\n                    position = this.grid.getX() + position;\r\n                }\r\n                else {\r\n                    // 纵向\r\n                    position = this.grid.getYend() - position;\r\n                }\r\n                \r\n                return position;\r\n                /* 准确更重要\r\n                return (dataIndex === 0 || dataIndex == this.option.data.length - 1)\r\n                       ? position\r\n                       : Math.floor(position);\r\n                */\r\n            }\r\n        },\r\n\r\n        // 根据类目轴数据索引换算类目轴名称\r\n        getNameByIndex : function (dataIndex) {\r\n            return this.getDataFromOption(this.option.data[dataIndex]);\r\n        },\r\n        \r\n        // 根据类目轴名称换算类目轴数据索引\r\n        getIndexByName : function (name) {\r\n            var data = this.option.data;\r\n            var dataLength = data.length;\r\n\r\n            for (var i = 0; i < dataLength; i++) {\r\n                if (this.getDataFromOption(data[i]) == name) {\r\n                    return i;\r\n                }\r\n            }\r\n            \r\n            return -1;\r\n        },\r\n        \r\n        // 根据位置换算值\r\n        getValueFromCoord : function() {\r\n            return '';\r\n        },\r\n\r\n        /**\r\n         * 根据类目轴数据索引返回是否为主轴线\r\n         * @param {number} dataIndex 类目轴数据索引\r\n         * @return {boolean} 是否为主轴\r\n         */\r\n        isMainAxis : function (dataIndex) {\r\n            return dataIndex % this._interval === 0;\r\n        }\r\n    };\r\n    \r\n    zrUtil.inherits(CategoryAxis, Base);\r\n    \r\n    require('../component').define('categoryAxis', CategoryAxis);\r\n    \r\n    return CategoryAxis;\r\n});"
        },
        {
          "id": 53,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Text.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
          "index": 53,
          "index2": 46,
          "size": 7484,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 52,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Text",
              "loc": "12:20-51"
            },
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/shape/Text",
              "loc": "12:20-51"
            }
          ],
          "source": "/**\r\n * @module zrender/shape/Text\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *     var Text = require('zrender/shape/Text');\r\n *     var shape = new Text({\r\n *         style: {\r\n *             text: 'Label',\r\n *             x: 100,\r\n *             y: 100,\r\n *             textFont: '14px Arial'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} ITextStyle\r\n * @property {number} x 横坐标\r\n * @property {number} y 纵坐标\r\n * @property {string} text 文本内容\r\n * @property {number} [maxWidth=null] 最大宽度限制\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textAlign] 可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n */\r\n\r\ndefine(\r\n    function (require) {\r\n        var area = require('../tool/area');\r\n        var Base = require('./Base');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/Text\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Text = function (options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 文字绘制样式\r\n             * @name module:zrender/shape/Text#style\r\n             * @type {module:zrender/shape/Text~ITextStyle}\r\n             */\r\n            /**\r\n             * 文字高亮绘制样式\r\n             * @name module:zrender/shape/Text#highlightStyle\r\n             * @type {module:zrender/shape/Text~ITextStyle}\r\n             */\r\n        };\r\n\r\n        Text.prototype =  {\r\n            type: 'text',\r\n\r\n            brush : function (ctx, isHighlight) {\r\n                var style = this.style;\r\n                if (isHighlight) {\r\n                    // 根据style扩展默认高亮样式\r\n                    style = this.getHighlightStyle(\r\n                        style, this.highlightStyle || {}\r\n                    );\r\n                }\r\n                \r\n                if (typeof(style.text) == 'undefined' || style.text === false) {\r\n                    return;\r\n                }\r\n\r\n                ctx.save();\r\n                this.doClip(ctx);\r\n\r\n                this.setContext(ctx, style);\r\n\r\n                // 设置transform\r\n                this.setTransform(ctx);\r\n\r\n                if (style.textFont) {\r\n                    ctx.font = style.textFont;\r\n                }\r\n                ctx.textAlign = style.textAlign || 'start';\r\n                ctx.textBaseline = style.textBaseline || 'middle';\r\n\r\n                var text = (style.text + '').split('\\n');\r\n                var lineHeight = area.getTextHeight('国', style.textFont);\r\n                var rect = this.getRect(style);\r\n                var x = style.x;\r\n                var y;\r\n                if (style.textBaseline == 'top') {\r\n                    y = rect.y;\r\n                }\r\n                else if (style.textBaseline == 'bottom') {\r\n                    y = rect.y + lineHeight;\r\n                }\r\n                else {\r\n                    y = rect.y + lineHeight / 2;\r\n                }\r\n                \r\n                for (var i = 0, l = text.length; i < l; i++) {\r\n                    if (style.maxWidth) {\r\n                        switch (style.brushType) {\r\n                            case 'fill':\r\n                                ctx.fillText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                                break;\r\n                            case 'stroke':\r\n                                ctx.strokeText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                                break;\r\n                            case 'both':\r\n                                ctx.fillText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                                ctx.strokeText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                                break;\r\n                            default:\r\n                                ctx.fillText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                        }\r\n                    }\r\n                    else {\r\n                        switch (style.brushType) {\r\n                            case 'fill':\r\n                                ctx.fillText(text[i], x, y);\r\n                                break;\r\n                            case 'stroke':\r\n                                ctx.strokeText(text[i], x, y);\r\n                                break;\r\n                            case 'both':\r\n                                ctx.fillText(text[i], x, y);\r\n                                ctx.strokeText(text[i], x, y);\r\n                                break;\r\n                            default:\r\n                                ctx.fillText(text[i], x, y);\r\n                        }\r\n                    }\r\n                    y += lineHeight;\r\n                }\r\n\r\n                ctx.restore();\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 返回文字包围盒矩形\r\n             * @param {module:zrender/shape/Text~ITextStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var width = area.getTextWidth(style.text, style.textFont);\r\n                var height = area.getTextHeight(style.text, style.textFont);\r\n                \r\n                var textX = style.x;                 // 默认start == left\r\n                if (style.textAlign == 'end' || style.textAlign == 'right') {\r\n                    textX -= width;\r\n                }\r\n                else if (style.textAlign == 'center') {\r\n                    textX -= (width / 2);\r\n                }\r\n\r\n                var textY;\r\n                if (style.textBaseline == 'top') {\r\n                    textY = style.y;\r\n                }\r\n                else if (style.textBaseline == 'bottom') {\r\n                    textY = style.y - height;\r\n                }\r\n                else {\r\n                    // middle\r\n                    textY = style.y - height / 2;\r\n                }\r\n\r\n                style.__rect = {\r\n                    x : textX,\r\n                    y : textY,\r\n                    width : width,\r\n                    height : height\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Text, Base);\r\n        return Text;\r\n    }\r\n);\r\n\r\n"
        },
        {
          "id": 54,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/component.js",
          "index": 54,
          "index2": 47,
          "size": 666,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 51,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "type": "cjs require",
              "userRequest": "../component",
              "loc": "342:4-27"
            },
            {
              "moduleId": 52,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
              "type": "cjs require",
              "userRequest": "../component",
              "loc": "801:4-27"
            },
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "../component",
              "loc": "944:4-27"
            },
            {
              "moduleId": 59,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
              "type": "cjs require",
              "userRequest": "../component",
              "loc": "181:4-27"
            },
            {
              "moduleId": 60,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "type": "cjs require",
              "userRequest": "../component",
              "loc": "317:35-58"
            },
            {
              "moduleId": 60,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "type": "cjs require",
              "userRequest": "../component",
              "loc": "1241:4-27"
            }
          ],
          "source": "/**\r\n * echart组件库\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (/*require*/) {     // component\r\n    var self = {};\r\n\r\n    var _componentLibrary = {};     // echart组件库\r\n\r\n    /**\r\n     * 定义图形实现\r\n     * @param {Object} name\r\n     * @param {Object} clazz 图形实现\r\n     */\r\n    self.define = function (name, clazz) {\r\n        _componentLibrary[name] = clazz;\r\n        return self;\r\n    };\r\n\r\n    /**\r\n     * 获取图形实现\r\n     * @param {Object} name\r\n     */\r\n    self.get = function (name) {\r\n        return _componentLibrary[name];\r\n    };\r\n    \r\n    return self;\r\n});"
        },
        {
          "id": 55,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "index": 55,
          "index2": 52,
          "size": 37530,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 51,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
              "type": "cjs require",
              "userRequest": "./valueAxis",
              "loc": "288:28-50"
            }
          ],
          "source": "/**\r\n * echarts组件： 数值轴\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n\r\n    // 图形依赖\r\n    var TextShape = require('zrenderjs/shape/Text');\r\n    var LineShape = require('zrenderjs/shape/Line');\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n\r\n    var ecConfig = require('../config');\r\n    // 数值型坐标轴默认参数\r\n    ecConfig.valueAxis = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 0,                       // 二级层叠\r\n        show: true,\r\n        position: 'left',      // 位置\r\n        name: '',              // 坐标轴名字，默认为空\r\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\r\n        nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式\r\n        boundaryGap: [0, 0],   // 数值起始和结束两端空白策略\r\n        // min: null,          // 最小值\r\n        // max: null,          // 最大值\r\n        // scale: false,       // 脱离0值比例，放大聚焦到最终_min，_max区间\r\n        // splitNumber: 5,        // 分割段数，默认为5\r\n        axisLine: {            // 坐标轴线\r\n            show: true,        // 默认显示，属性show控制显示与否\r\n            onZero: true,\r\n            lineStyle: {       // 属性lineStyle控制线条样式\r\n                color: '#48b',\r\n                width: 2,\r\n                type: 'solid'\r\n            }\r\n        },\r\n        axisTick: {            // 坐标轴小标记\r\n            show: false,       // 属性show控制显示与否，默认不显示\r\n            inside: false,     // 控制小标记是否在grid里\r\n            length :5,         // 属性length控制线长\r\n            lineStyle: {       // 属性lineStyle控制线条样式\r\n                color: '#333',\r\n                width: 1\r\n            }\r\n        },\r\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\r\n            show: true,\r\n            rotate: 0,\r\n            margin: 8,\r\n            // clickable: false,\r\n            // formatter: null,\r\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\r\n                color: '#333'\r\n            }\r\n        },\r\n        splitLine: {           // 分隔线\r\n            show: true,        // 默认显示，属性show控制显示与否\r\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\r\n                color: ['#ccc'],\r\n                width: 1,\r\n                type: 'solid'\r\n            }\r\n        },\r\n        splitArea: {           // 分隔区域\r\n            show: false,       // 默认不显示，属性show控制显示与否\r\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\r\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\r\n            }\r\n        }\r\n    };\r\n\r\n    var ecDate = require('../util/date');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 类目轴参数\r\n     * @param {Object} component 组件\r\n     * @param {Array} series 数据对象\r\n     */\r\n    function ValueAxis(ecTheme, messageCenter, zr, option, myChart, axisBase, series) {\r\n        if (!series || series.length === 0) {\r\n            console.err('option.series.length == 0.');\r\n            return;\r\n        }\r\n\r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this.series = series;\r\n        this.grid = this.component.grid;\r\n\r\n        for (var method in axisBase) {\r\n            this[method] = axisBase[method];\r\n        }\r\n\r\n        this.refresh(option, series);\r\n    }\r\n\r\n    ValueAxis.prototype = {\r\n        type: ecConfig.COMPONENT_TYPE_AXIS_VALUE,\r\n\r\n        _buildShape: function () {\r\n            this._hasData = false;\r\n            this._calculateValue();\r\n            if (!this._hasData || !this.option.show) {\r\n                return;\r\n            }\r\n\r\n            this.option.splitArea.show && this._buildSplitArea();\r\n            this.option.splitLine.show && this._buildSplitLine();\r\n            this.option.axisLine.show && this._buildAxisLine();\r\n            this.option.axisTick.show && this._buildAxisTick();\r\n            this.option.axisLabel.show && this._buildAxisLabel();\r\n\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                this.zr.addShape(this.shapeList[i]);\r\n            }\r\n        },\r\n\r\n        // 小标记\r\n        _buildAxisTick: function () {\r\n            var axShape;\r\n            var data       = this._valueList;\r\n            var dataLength = this._valueList.length;\r\n            var tickOption = this.option.axisTick;\r\n            var length     = tickOption.length;\r\n            var color      = tickOption.lineStyle.color;\r\n            var lineWidth  = tickOption.lineStyle.width;\r\n\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var yPosition = this.option.position === 'bottom'\r\n                        ? (tickOption.inside\r\n                           ? (this.grid.getYend() - length - 1) : (this.grid.getYend()) + 1)\r\n                        : (tickOption.inside\r\n                           ? (this.grid.getY() + 1) : (this.grid.getY() - length - 1));\r\n                var x;\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    // 亚像素优化\r\n                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);\r\n                    axShape = {\r\n                        _axisShape: 'axisTick',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable: false,\r\n                        style: {\r\n                            xStart: x,\r\n                            yStart: yPosition,\r\n                            xEnd: x,\r\n                            yEnd: yPosition + length,\r\n                            strokeColor: color,\r\n                            lineWidth: lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n            else {\r\n                // 纵向\r\n                var xPosition = this.option.position === 'left'\r\n                    ? (tickOption.inside\r\n                       ? (this.grid.getX() + 1) : (this.grid.getX() - length - 1))\r\n                    : (tickOption.inside\r\n                       ? (this.grid.getXend() - length - 1) : (this.grid.getXend() + 1));\r\n\r\n                var y;\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    // 亚像素优化\r\n                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);\r\n                    axShape = {\r\n                        _axisShape: 'axisTick',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable: false,\r\n                        style: {\r\n                            xStart: xPosition,\r\n                            yStart: y,\r\n                            xEnd: xPosition + length,\r\n                            yEnd: y,\r\n                            strokeColor: color,\r\n                            lineWidth: lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n        },\r\n\r\n        // 坐标轴文本\r\n        _buildAxisLabel: function () {\r\n            var axShape;\r\n            var data       = this._valueList;\r\n            var dataLength = this._valueList.length;\r\n            var rotate     = this.option.axisLabel.rotate;\r\n            var margin     = this.option.axisLabel.margin;\r\n            var clickable  = this.option.axisLabel.clickable;\r\n            var textStyle  = this.option.axisLabel.textStyle;\r\n\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var yPosition;\r\n                var baseLine;\r\n                if (this.option.position === 'bottom') {\r\n                    yPosition = this.grid.getYend() + margin;\r\n                    baseLine = 'top';\r\n                }\r\n                else {\r\n                    yPosition = this.grid.getY() - margin;\r\n                    baseLine = 'bottom';\r\n                }\r\n\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    axShape = {\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase() +3,\r\n                        hoverable: false,\r\n                        style: {\r\n                            x: this.getCoord(data[i]),\r\n                            y: yPosition,\r\n                            color: typeof textStyle.color === 'function'\r\n                                   ? textStyle.color(data[i]) : textStyle.color,\r\n                            text: this._valueLabel[i],\r\n                            textFont: this.getFont(textStyle),\r\n                            textAlign: textStyle.align || 'center',\r\n                            textBaseline: textStyle.baseline || baseLine\r\n                        }\r\n                    };\r\n                    if (rotate) {\r\n                        axShape.style.textAlign = rotate > 0\r\n                                                  ? (this.option.position === 'bottom'\r\n                                                    ? 'right' : 'left')\r\n                                                  : (this.option.position === 'bottom'\r\n                                                    ? 'left' : 'right');\r\n                        axShape.rotation = [\r\n                            rotate * Math.PI / 180,\r\n                            axShape.style.x,\r\n                            axShape.style.y\r\n                        ];\r\n                    }\r\n                    this.shapeList.push(new TextShape(\r\n                        this._axisLabelClickable(clickable, axShape)\r\n                    ));\r\n                }\r\n            }\r\n            else {\r\n                // 纵向\r\n                var xPosition;\r\n                var align;\r\n                if (this.option.position === 'left') {\r\n                    xPosition = this.grid.getX() - margin;\r\n                    align = 'right';\r\n                }\r\n                else {\r\n                    xPosition = this.grid.getXend() + margin;\r\n                    align = 'left';\r\n                }\r\n\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    axShape = {\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase() + 3,\r\n                        hoverable: false,\r\n                        style: {\r\n                            x: xPosition,\r\n                            y: this.getCoord(data[i]),\r\n                            color: typeof textStyle.color === 'function'\r\n                                   ? textStyle.color(data[i]) : textStyle.color,\r\n                            text: this._valueLabel[i],\r\n                            textFont: this.getFont(textStyle),\r\n                            textAlign: textStyle.align || align,\r\n                            textBaseline: textStyle.baseline\r\n                                          || (\r\n                                              (i === 0 && this.option.name !== '')\r\n                                              ? 'bottom'\r\n                                                : (i === dataLength - 1 && this.option.name !== '') ? 'top' : 'middle'\r\n                                          )\r\n                        }\r\n                    };\r\n\r\n                    if (rotate) {\r\n                        axShape.rotation = [\r\n                            rotate * Math.PI / 180,\r\n                            axShape.style.x,\r\n                            axShape.style.y\r\n                        ];\r\n                    }\r\n                    this.shapeList.push(new TextShape(\r\n                        this._axisLabelClickable(clickable, axShape)\r\n                    ));\r\n                }\r\n            }\r\n        },\r\n\r\n        _buildSplitLine: function () {\r\n            var axShape;\r\n            var data        = this._valueList;\r\n            var dataLength  = this._valueList.length;\r\n            var sLineOption = this.option.splitLine;\r\n            var lineType    = sLineOption.lineStyle.type;\r\n            var lineWidth   = sLineOption.lineStyle.width;\r\n            var color       = sLineOption.lineStyle.color;\r\n            color = color instanceof Array ? color : [color];\r\n            var colorLength = color.length;\r\n\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var sy = this.grid.getY();\r\n                var ey = this.grid.getYend();\r\n                var x;\r\n\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    // 亚像素优化\r\n                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);\r\n                    axShape = {\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable: false,\r\n                        style: {\r\n                            xStart: x,\r\n                            yStart: sy,\r\n                            xEnd: x,\r\n                            yEnd: ey,\r\n                            strokeColor: color[i % colorLength],\r\n                            lineType: lineType,\r\n                            lineWidth: lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n\r\n            }\r\n            else {\r\n                // 纵向\r\n                var sx = this.grid.getX();\r\n                var ex = this.grid.getXend();\r\n                var y;\r\n\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    // 亚像素优化\r\n                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);\r\n                    axShape = {\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable: false,\r\n                        style: {\r\n                            xStart: sx,\r\n                            yStart: y,\r\n                            xEnd: ex,\r\n                            yEnd: y,\r\n                            strokeColor: color[i % colorLength],\r\n                            lineType: lineType,\r\n                            lineWidth: lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n        },\r\n\r\n        _buildSplitArea: function () {\r\n            var axShape;\r\n            var color = this.option.splitArea.areaStyle.color;\r\n\r\n            if (!(color instanceof Array)) {\r\n                // 非数组一律认为是单一颜色的字符串，单一颜色则用一个背景，颜色错误不负责啊！！！\r\n                axShape = {\r\n                    zlevel: this.getZlevelBase(),\r\n                    z: this.getZBase(),\r\n                    hoverable: false,\r\n                    style: {\r\n                        x: this.grid.getX(),\r\n                        y: this.grid.getY(),\r\n                        width: this.grid.getWidth(),\r\n                        height: this.grid.getHeight(),\r\n                        color: color\r\n                        // type: this.option.splitArea.areaStyle.type,\r\n                    }\r\n                };\r\n                this.shapeList.push(new RectangleShape(axShape));\r\n            }\r\n            else {\r\n                // 多颜色\r\n                var colorLength = color.length;\r\n                var data        = this._valueList;\r\n                var dataLength  = this._valueList.length;\r\n\r\n                if (this.isHorizontal()) {\r\n                    // 横向\r\n                    var y = this.grid.getY();\r\n                    var height = this.grid.getHeight();\r\n                    var lastX = this.grid.getX();\r\n                    var curX;\r\n\r\n                    for (var i = 0; i <= dataLength; i++) {\r\n                        curX = i < dataLength\r\n                               ? this.getCoord(data[i])\r\n                               : this.grid.getXend();\r\n                        axShape = {\r\n                            zlevel: this.getZlevelBase(),\r\n                            z: this.getZBase(),\r\n                            hoverable: false,\r\n                            style: {\r\n                                x: lastX,\r\n                                y: y,\r\n                                width: curX - lastX,\r\n                                height: height,\r\n                                color: color[i % colorLength]\r\n                                // type: this.option.splitArea.areaStyle.type,\r\n                            }\r\n                        };\r\n                        this.shapeList.push(new RectangleShape(axShape));\r\n                        lastX = curX;\r\n                    }\r\n                }\r\n                else {\r\n                    // 纵向\r\n                    var x = this.grid.getX();\r\n                    var width = this.grid.getWidth();\r\n                    var lastYend = this.grid.getYend();\r\n                    var curY;\r\n\r\n                    for (var i = 0; i <= dataLength; i++) {\r\n                        curY = i < dataLength\r\n                               ? this.getCoord(data[i])\r\n                               : this.grid.getY();\r\n                        axShape = {\r\n                            zlevel: this.getZlevelBase(),\r\n                            z: this.getZBase(),\r\n                            hoverable: false,\r\n                            style: {\r\n                                x: x,\r\n                                y: curY,\r\n                                width: width,\r\n                                height: lastYend - curY,\r\n                                color: color[i % colorLength]\r\n                                // type: this.option.splitArea.areaStyle.type\r\n                            }\r\n                        };\r\n                        this.shapeList.push(new RectangleShape(axShape));\r\n                        lastYend = curY;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 极值计算\r\n         */\r\n        _calculateValue: function () {\r\n            if (isNaN(this.option.min - 0) || isNaN(this.option.max - 0)) {\r\n                // 有一个没指定都得算\r\n                // 数据整形\r\n                var data = {};          // 整形后数据抽取\r\n                var xIdx;\r\n                var yIdx;\r\n                var legend = this.component.legend;\r\n                for (var i = 0, l = this.series.length; i < l; i++) {\r\n                    if (this.series[i].type != ecConfig.CHART_TYPE_LINE\r\n                        && this.series[i].type != ecConfig.CHART_TYPE_BAR\r\n                        && this.series[i].type != ecConfig.CHART_TYPE_SCATTER\r\n                        && this.series[i].type != ecConfig.CHART_TYPE_K\r\n                        && this.series[i].type != ecConfig.CHART_TYPE_EVENTRIVER\r\n                    ) {\r\n                        // 非坐标轴支持的不算极值\r\n                        continue;\r\n                    }\r\n                    // 请允许我写开，跟上面一个不是一样东西\r\n                    if (legend && !legend.isSelected(this.series[i].name)){\r\n                        continue;\r\n                    }\r\n\r\n                    // 不指定默认为第一轴线\r\n                    xIdx = this.series[i].xAxisIndex || 0;\r\n                    yIdx = this.series[i].yAxisIndex || 0;\r\n                    if ((this.option.xAxisIndex != xIdx)\r\n                        && (this.option.yAxisIndex != yIdx)\r\n                    ) {\r\n                        // 不是自己的数据不计算极值\r\n                        continue;\r\n                    }\r\n\r\n                    this._calculSum(data, i);\r\n                }\r\n\r\n                // 找极值\r\n                var oriData;            // 原始数据\r\n                for (var i in data){\r\n                    oriData = data[i];\r\n                    for (var j = 0, k = oriData.length; j < k; j++) {\r\n                        if (!isNaN(oriData[j])){\r\n                            this._hasData = true;\r\n                            this._min = oriData[j];\r\n                            this._max = oriData[j];\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (this._hasData) {\r\n                        break;\r\n                    }\r\n                }\r\n                for (var i in data){\r\n                    oriData = data[i];\r\n                    for (var j = 0, k = oriData.length; j < k; j++) {\r\n                        if (!isNaN(oriData[j])){\r\n                            this._min = Math.min(this._min, oriData[j]);\r\n                            this._max = Math.max(this._max, oriData[j]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // console.log(this._min,this._max,'vvvvv111111',this.option.type)\r\n                // log情况暂时禁用boundaryGap。\r\n                var boundaryGap = this.option.type !== 'log' ? this.option.boundaryGap : [0, 0];\r\n                var gap = Math.abs(this._max - this._min);\r\n                this._min = isNaN(this.option.min - 0)\r\n                       ? (this._min - Math.abs(gap * boundaryGap[0]))\r\n                       : (this.option.min - 0);    // 指定min忽略boundaryGay[0]\r\n\r\n                this._max = isNaN(this.option.max - 0)\r\n                       ? (this._max + Math.abs(gap * boundaryGap[1]))\r\n                       : (this.option.max - 0);    // 指定max忽略boundaryGay[1]\r\n                if (this._min === this._max) {\r\n                    if (this._max === 0) {\r\n                        // 修复全0数据\r\n                        this._max = 1;\r\n                    }\r\n                    // 修复最大值==最小值时数据整形\r\n                    else if (this._max > 0) {\r\n                        this._min = this._max / this.option.splitNumber != null ? this.option.splitNumber : 5;\r\n                    }\r\n                    else { // this._max < 0\r\n                        this._max = this._max / this.option.splitNumber != null ? this.option.splitNumber : 5;\r\n                    }\r\n                }\r\n\r\n                if (this.option.type === 'time') {\r\n                    this._reformTimeValue();\r\n                }\r\n                else if (this.option.type === 'log') {\r\n                    this._reformLogValue();\r\n                }\r\n                else {\r\n                    this._reformValue(this.option.scale);\r\n                }\r\n            }\r\n            else {\r\n                this._hasData = true;\r\n                // 用户指定min max就不多管闲事了\r\n                this._min = this.option.min - 0;    // 指定min忽略boundaryGay[0]\r\n                this._max = this.option.max - 0;    // 指定max忽略boundaryGay[1]\r\n\r\n                if (this.option.type === 'time') {\r\n                    this._reformTimeValue();\r\n                }\r\n                else if (this.option.type === 'log') {\r\n                    this._reformLogValue();\r\n                }\r\n                else {\r\n                    this._customerValue();\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 内部使用，计算某系列下的堆叠和\r\n         */\r\n        _calculSum: function (data, i) {\r\n            var key = this.series[i].name || 'kener';\r\n            var value;\r\n            var oriData;\r\n            if (!this.series[i].stack) {\r\n                data[key] = data[key] || [];\r\n                if (this.series[i].type != ecConfig.CHART_TYPE_EVENTRIVER) {\r\n                    oriData = this.series[i].data;\r\n                    for (var j = 0, k = oriData.length; j < k; j++) {\r\n                        value = this.getDataFromOption(oriData[j]);\r\n                        if (this.series[i].type === ecConfig.CHART_TYPE_K) {\r\n                            data[key].push(value[0]);\r\n                            data[key].push(value[1]);\r\n                            data[key].push(value[2]);\r\n                            data[key].push(value[3]);\r\n                        }\r\n                        else if (value instanceof Array) {\r\n                            // scatter 、 不等距 line bar\r\n                            if (this.option.xAxisIndex != -1) {\r\n                                data[key].push(\r\n                                    this.option.type != 'time'\r\n                                    ? value[0] : ecDate.getNewDate(value[0])\r\n                                );\r\n                            }\r\n                            if (this.option.yAxisIndex != -1) {\r\n                                data[key].push(\r\n                                    this.option.type != 'time'\r\n                                    ? value[1] : ecDate.getNewDate(value[1])\r\n                                );\r\n                            }\r\n                        }\r\n                        else {\r\n                            data[key].push(value);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // eventRiver\r\n                    oriData = this.series[i].data;\r\n                    for (var j = 0, k = oriData.length; j < k; j++) {\r\n                        var evolution = oriData[j].evolution;\r\n                        for (var m = 0, n = evolution.length; m < n; m++) {\r\n                            data[key].push(ecDate.getNewDate(evolution[m].time));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // 堆积数据，需要区分正负向堆积\r\n                var keyP = '__Magic_Key_Positive__' + this.series[i].stack;\r\n                var keyN = '__Magic_Key_Negative__' + this.series[i].stack;\r\n                data[keyP] = data[keyP] || [];\r\n                data[keyN] = data[keyN] || [];\r\n                data[key] = data[key] || [];  // scale下还需要记录每一个量\r\n                oriData = this.series[i].data;\r\n                for (var j = 0, k = oriData.length; j < k; j++) {\r\n                    value = this.getDataFromOption(oriData[j]);\r\n                    if (value === '-') {\r\n                        continue;\r\n                    }\r\n                    value = value - 0;\r\n                    if (value >= 0) {\r\n                        if (data[keyP][j] != null) {\r\n                            data[keyP][j] += value;\r\n                        }\r\n                        else {\r\n                            data[keyP][j] = value;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (data[keyN][j] != null) {\r\n                            data[keyN][j] += value;\r\n                        }\r\n                        else {\r\n                            data[keyN][j] = value;\r\n                        }\r\n                    }\r\n                    if (this.option.scale) {\r\n                        data[key].push(value);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 找到原始数据的极值后根据选项整形最终 this._min / this._max / this._valueList\r\n         * 如果你不知道这个“整形”的用义，请不要试图去理解和修改这个方法！找我也没用，我相信我已经记不起来！\r\n         * 如果你有更简洁的数学推导欢迎重写，后果自负~\r\n         *\r\n         * by kener.linfeng@gmail.com 2013-1-8\r\n         * --------\r\n         * 感谢谢世威(https://github.com/i6ma)，终于有人改这个方法了\r\n         * by Kener 2014-11-6\r\n         */\r\n        _reformValue: function (scale) {\r\n            var smartSteps = require('../util/smartSteps');\r\n            var splitNumber = this.option.splitNumber;\r\n\r\n            // 非scale下双正，修正最小值为0\r\n            if (!scale && this._min >= 0 && this._max >= 0) {\r\n                this._min = 0;\r\n            }\r\n            // 非scale下双负，修正最大值为0\r\n            if (!scale && this._min <= 0 && this._max <= 0) {\r\n                this._max = 0;\r\n            }\r\n\r\n            var stepOpt = smartSteps(this._min, this._max, splitNumber);\r\n            splitNumber = splitNumber != null ? splitNumber : stepOpt.secs;\r\n            //this.option.splitNumber = splitNumber;\r\n            this._min = stepOpt.min;\r\n            this._max = stepOpt.max;\r\n            this._valueList = stepOpt.pnts;\r\n            this._reformLabelData();\r\n        },\r\n\r\n        /**\r\n         * 格式化时间值\r\n         */\r\n        _reformTimeValue : function() {\r\n            var splitNumber = this.option.splitNumber != null ? this.option.splitNumber : 5;\r\n\r\n            // 最优解\r\n            var curValue = ecDate.getAutoFormatter(this._min, this._max, splitNumber);\r\n            // 目标\r\n            var formatter = curValue.formatter;\r\n            var gapValue = curValue.gapValue;\r\n\r\n            this._valueList = [ecDate.getNewDate(this._min)];\r\n            var startGap;\r\n            switch (formatter) {\r\n                case 'week' :\r\n                    startGap = ecDate.nextMonday(this._min);\r\n                    break;\r\n                case 'month' :\r\n                    startGap = ecDate.nextNthOnMonth(this._min, 1);\r\n                    break;\r\n                case 'quarter' :\r\n                    startGap = ecDate.nextNthOnQuarterYear(this._min, 1);\r\n                    break;\r\n                case 'half-year' :\r\n                    startGap = ecDate.nextNthOnHalfYear(this._min, 1);\r\n                    break;\r\n                case 'year' :\r\n                    startGap = ecDate.nextNthOnYear(this._min, 1);\r\n                    break;\r\n                default :\r\n                    // 大于2小时需要考虑时区不能直接取整\r\n                    if (gapValue <= 3600000 * 2) {\r\n                        startGap = (Math.floor(this._min / gapValue) + 1) * gapValue;\r\n                    }\r\n                    else {\r\n                        startGap = ecDate.getNewDate(this._min - (-gapValue));\r\n                        startGap.setHours(Math.round(startGap.getHours() / 6) * 6);\r\n                        startGap.setMinutes(0);\r\n                        startGap.setSeconds(0);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            if (startGap - this._min < gapValue / 2) {\r\n                startGap -= -gapValue;\r\n            }\r\n\r\n            // console.log(startGap,gapValue,this._min, this._max,formatter)\r\n            curValue = ecDate.getNewDate(startGap);\r\n            splitNumber *= 1.5;\r\n            while (splitNumber-- >= 0) {\r\n                if (formatter == 'month'\r\n                    || formatter == 'quarter'\r\n                    || formatter == 'half-year'\r\n                    || formatter == 'year'\r\n                ) {\r\n                    curValue.setDate(1);\r\n                }\r\n                if (this._max - curValue < gapValue / 2) {\r\n                    break;\r\n                }\r\n                this._valueList.push(curValue);\r\n                curValue = ecDate.getNewDate(curValue - (-gapValue));\r\n            }\r\n            this._valueList.push(ecDate.getNewDate(this._max));\r\n\r\n            this._reformLabelData((function (formatterStr) {\r\n                return function (value) {\r\n                    return ecDate.format(formatterStr, value);\r\n                };\r\n            })(formatter));\r\n        },\r\n\r\n        _customerValue: function () {\r\n            var accMath = require('../util/accMath');\r\n            var splitNumber = this.option.splitNumber != null ? this.option.splitNumber : 5;\r\n            var splitGap = (this._max - this._min) / splitNumber;\r\n\r\n            this._valueList = [];\r\n            for (var i = 0; i <= splitNumber; i++) {\r\n                this._valueList.push(accMath.accAdd(this._min, accMath.accMul(splitGap, i)));\r\n            }\r\n            this._reformLabelData();\r\n        },\r\n\r\n        _reformLogValue: function() {\r\n            // log数轴本质就是缩放，相当于默认this.option.scale === true，所以不修正_min和_max到0。\r\n            var thisOption = this.option;\r\n            var result = require('../util/smartLogSteps')({\r\n                dataMin: this._min,\r\n                dataMax: this._max,\r\n                logPositive: thisOption.logPositive,\r\n                logLabelBase: thisOption.logLabelBase,\r\n                splitNumber: thisOption.splitNumber\r\n            });\r\n\r\n            this._min = result.dataMin;\r\n            this._max = result.dataMax;\r\n            this._valueList = result.tickList;\r\n            // {value2Coord: {Function}, coord2Value: {Function}}\r\n            this._dataMappingMethods = result.dataMappingMethods;\r\n\r\n            this._reformLabelData(result.labelFormatter);\r\n        },\r\n\r\n        _reformLabelData: function (innerFormatter) {\r\n            this._valueLabel = [];\r\n            var formatter = this.option.axisLabel.formatter;\r\n            if (formatter) {\r\n                for (var i = 0, l = this._valueList.length; i < l; i++) {\r\n                    if (typeof formatter === 'function') {\r\n                        this._valueLabel.push(\r\n                            innerFormatter\r\n                                ? formatter.call(this.myChart, this._valueList[i], innerFormatter)\r\n                                : formatter.call(this.myChart, this._valueList[i])\r\n                        );\r\n                    }\r\n                    else if (typeof formatter === 'string') {\r\n                        this._valueLabel.push(\r\n                            innerFormatter\r\n                                ? ecDate.format(formatter, this._valueList[i])\r\n                                : formatter.replace('{value}',this._valueList[i])\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0, l = this._valueList.length; i < l; i++) {\r\n                    this._valueLabel.push(\r\n                        innerFormatter\r\n                            ? innerFormatter(this._valueList[i])\r\n                            : this.numAddCommas(this._valueList[i]) // 每三位默认加,格式化\r\n                    );\r\n                }\r\n            }\r\n        },\r\n\r\n        getExtremum: function () {\r\n            this._calculateValue();\r\n            var dataMappingMethods = this._dataMappingMethods;\r\n            return {\r\n                min: this._min,\r\n                max: this._max,\r\n                dataMappingMethods: dataMappingMethods\r\n                    ? zrUtil.merge({}, dataMappingMethods) : null\r\n            };\r\n        },\r\n\r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption, newSeries) {\r\n            if (newOption) {\r\n                this.option = this.reformOption(newOption);\r\n                // 通用字体设置\r\n                this.option.axisLabel.textStyle = zrUtil.merge(\r\n                    this.option.axisLabel.textStyle || {},\r\n                    this.ecTheme.textStyle\r\n                );\r\n                this.series = newSeries;\r\n            }\r\n            if (this.zr) {   // 数值轴的另外一个功能只是用来计算极值\r\n                this.clear();\r\n                this._buildShape();\r\n            }\r\n        },\r\n\r\n        // 根据值换算位置\r\n        getCoord: function (value) {\r\n            if (this._dataMappingMethods) {\r\n                value = this._dataMappingMethods.value2Coord(value);\r\n            }\r\n\r\n            value = value < this._min ? this._min : value;\r\n            value = value > this._max ? this._max : value;\r\n\r\n            var result;\r\n            if (!this.isHorizontal()) {\r\n                // 纵向\r\n                result = this.grid.getYend()\r\n                         - (value - this._min)\r\n                           / (this._max - this._min)\r\n                           * this.grid.getHeight();\r\n            }\r\n            else {\r\n                // 横向\r\n                result = this.grid.getX()\r\n                         + (value - this._min)\r\n                           / (this._max - this._min)\r\n                           * this.grid.getWidth();\r\n            }\r\n\r\n            return result;\r\n            // Math.floor可能引起一些偏差，但性能会更好\r\n            /* 准确更重要\r\n            return (value === this._min || value === this._max)\r\n                   ? result\r\n                   : Math.floor(result);\r\n            */\r\n        },\r\n\r\n        // 根据值换算绝对大小\r\n        getCoordSize: function (value) {\r\n            if (!this.isHorizontal()) {\r\n                // 纵向\r\n                return Math.abs(value / (this._max - this._min) * this.grid.getHeight());\r\n            }\r\n            else {\r\n                // 横向\r\n                return Math.abs(value / (this._max - this._min) * this.grid.getWidth());\r\n            }\r\n        },\r\n\r\n        // 根据位置换算值\r\n        getValueFromCoord: function(coord) {\r\n            var result;\r\n\r\n            if (!this.isHorizontal()) {\r\n                // 纵向\r\n                coord = coord < this.grid.getY() ? this.grid.getY() : coord;\r\n                coord = coord > this.grid.getYend() ? this.grid.getYend() : coord;\r\n                result = this._max\r\n                         - (coord - this.grid.getY())\r\n                           / this.grid.getHeight()\r\n                           * (this._max - this._min);\r\n            }\r\n            else {\r\n                // 横向\r\n                coord = coord < this.grid.getX() ? this.grid.getX() : coord;\r\n                coord = coord > this.grid.getXend() ? this.grid.getXend() : coord;\r\n                result = this._min\r\n                         + (coord - this.grid.getX())\r\n                           / this.grid.getWidth()\r\n                           * (this._max - this._min);\r\n            }\r\n\r\n            if (this._dataMappingMethods) {\r\n                result = this._dataMappingMethods.coord2Value(result);\r\n            }\r\n\r\n            return result.toFixed(2) - 0;\r\n        },\r\n\r\n        isMaindAxis : function (value) {\r\n            for (var i = 0, l = this._valueList.length; i < l; i++) {\r\n                if (this._valueList[i] === value) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ValueAxis, Base);\r\n\r\n    require('../component').define('valueAxis', ValueAxis);\r\n\r\n    return ValueAxis;\r\n});\r\n\r\n"
        },
        {
          "id": 56,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\date.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/date.js",
          "index": 56,
          "index2": 49,
          "size": 5788,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "../util/date",
              "loc": "75:17-40"
            },
            {
              "moduleId": 60,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
              "type": "cjs require",
              "userRequest": "../util/date",
              "loc": "44:17-40"
            }
          ],
          "source": "/**\r\n * echarts日期运算格式化相关\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function() {\r\n    var _timeGap = [\r\n        {formatter: 'hh : mm : ss', value: 1000},               // 1s\r\n        {formatter: 'hh : mm : ss', value: 1000 * 5},           // 5s\r\n        {formatter: 'hh : mm : ss', value: 1000 * 10},          // 10s\r\n        {formatter: 'hh : mm : ss', value: 1000 * 15},          // 15s\r\n        {formatter: 'hh : mm : ss', value: 1000 * 30},          // 30s\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000},          // 1m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000 * 5},      // 5m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000 * 10},     // 10m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000 * 15},     // 15m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000 * 30},     // 30m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 3600000},        // 1h\r\n        {formatter: 'hh : mm\\nMM - dd', value: 3600000 * 2},    // 2h\r\n        {formatter: 'hh : mm\\nMM - dd', value: 3600000 * 6},    // 6h\r\n        {formatter: 'hh : mm\\nMM - dd', value: 3600000 * 12},   // 12h\r\n        {formatter: 'MM - dd\\nyyyy', value: 3600000 * 24},      // 1d\r\n        {formatter: 'week', value: 3600000 * 24 * 7},           // 7d\r\n        {formatter: 'month', value: 3600000 * 24 * 31},         // 1M\r\n        {formatter: 'quarter', value: 3600000 * 24 * 380 / 4},  // 3M\r\n        {formatter: 'half-year', value: 3600000 * 24 * 380 / 2},// 6M\r\n        {formatter: 'year', value: 3600000 * 24 * 380}          // 1Y\r\n    ];\r\n    \r\n    /**\r\n     * 获取最佳formatter\r\n     * @params {number} min 最小值\r\n     * @params {number} max 最大值\r\n     * @params {=number} splitNumber 分隔段数\r\n     */\r\n    function getAutoFormatter(min, max, splitNumber) {\r\n        splitNumber = splitNumber > 1 ? splitNumber : 2;\r\n        // 最优解\r\n        var curValue;\r\n        var totalGap;\r\n        // 目标\r\n        var formatter;\r\n        var gapValue;\r\n        for (var i = 0, l = _timeGap.length; i < l; i++) {\r\n            curValue = _timeGap[i].value;\r\n            totalGap = Math.ceil(max / curValue) * curValue \r\n                       - Math.floor(min / curValue) * curValue;\r\n            if (Math.round(totalGap / curValue) <= splitNumber * 1.2) {\r\n                formatter =  _timeGap[i].formatter;\r\n                gapValue = _timeGap[i].value;\r\n                // console.log(formatter, gapValue,i);\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (formatter == null) {\r\n            formatter = 'year';\r\n            curValue = 3600000 * 24 * 367;\r\n            totalGap = Math.ceil(max / curValue) * curValue \r\n                       - Math.floor(min / curValue) * curValue;\r\n            gapValue = Math.round(totalGap / (splitNumber - 1) / curValue) * curValue;\r\n        }\r\n        \r\n        return {\r\n            formatter: formatter,\r\n            gapValue: gapValue\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * 一位数字补0 \r\n     */\r\n    function s2d (v) {\r\n        return v < 10 ? ('0' + v) : v;\r\n    }\r\n    \r\n    /**\r\n     * 百分比计算\r\n     */\r\n    function format(formatter, value) {\r\n        if (formatter == 'week' \r\n            || formatter == 'month' \r\n            || formatter == 'quarter' \r\n            || formatter == 'half-year'\r\n            || formatter == 'year'\r\n        ) {\r\n            formatter = 'MM - dd\\nyyyy';\r\n        }\r\n            \r\n        var date = getNewDate(value);\r\n        var y = date.getFullYear();\r\n        var M = date.getMonth() + 1;\r\n        var d = date.getDate();\r\n        var h = date.getHours();\r\n        var m = date.getMinutes();\r\n        var s = date.getSeconds();\r\n        \r\n        formatter = formatter.replace('MM', s2d(M));\r\n        formatter = formatter.toLowerCase();\r\n        formatter = formatter.replace('yyyy', y);\r\n        formatter = formatter.replace('yy', y % 100);\r\n        formatter = formatter.replace('dd', s2d(d));\r\n        formatter = formatter.replace('d', d);\r\n        formatter = formatter.replace('hh', s2d(h));\r\n        formatter = formatter.replace('h', h);\r\n        formatter = formatter.replace('mm', s2d(m));\r\n        formatter = formatter.replace('m', m);\r\n        formatter = formatter.replace('ss', s2d(s));\r\n        formatter = formatter.replace('s', s);\r\n\r\n        return formatter;\r\n    }\r\n    \r\n    function nextMonday(value) {\r\n        value = getNewDate(value);\r\n        value.setDate(value.getDate() + 8 - value.getDay());\r\n        return value;\r\n    }\r\n    \r\n    function nextNthPerNmonth(value, nth, nmon) {\r\n        value = getNewDate(value);\r\n        value.setMonth(Math.ceil((value.getMonth() + 1) / nmon) * nmon);\r\n        value.setDate(nth);\r\n        return value;\r\n    }\r\n    \r\n    function nextNthOnMonth(value, nth) {\r\n        return nextNthPerNmonth(value, nth, 1);\r\n    }\r\n    \r\n    function nextNthOnQuarterYear(value, nth) {\r\n        return nextNthPerNmonth(value, nth, 3);\r\n    }\r\n    \r\n    function nextNthOnHalfYear(value, nth) {\r\n        return nextNthPerNmonth(value, nth, 6);\r\n    }\r\n    \r\n    function nextNthOnYear(value, nth) {\r\n        return nextNthPerNmonth(value, nth, 12);\r\n    }\r\n    \r\n    function getNewDate(value) {\r\n        return value instanceof Date\r\n               ? value\r\n               : new Date(typeof value == 'string' ? value.replace(/-/g, '/') : value);\r\n    }\r\n    \r\n    return {\r\n        getAutoFormatter: getAutoFormatter,\r\n        getNewDate: getNewDate,\r\n        format: format,\r\n        nextMonday: nextMonday,\r\n        nextNthPerNmonth: nextNthPerNmonth,\r\n        nextNthOnMonth: nextNthOnMonth,\r\n        nextNthOnQuarterYear: nextNthOnQuarterYear,\r\n        nextNthOnHalfYear: nextNthOnHalfYear,\r\n        nextNthOnYear : nextNthOnYear\r\n    };\r\n});"
        },
        {
          "id": 57,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\smartSteps.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/smartSteps.js",
          "index": 57,
          "index2": 50,
          "size": 18862,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "../util/smartSteps",
              "loc": "667:29-58"
            }
          ],
          "source": "\r\n/**\r\n * echarts 值轴分段刻度计算方法\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @author xieshiwei (谢世威, i6ma@i6ma.com)\r\n *\r\n */\r\n\r\n\r\n/**\r\n * 最值、跨度、步长取近似值\r\n * 注意：不适用于高精度需求，或者很多位有效数字的情况！！！\r\n * @function    smartSteps\r\n * @param       {Number}    min             最小值\r\n * @param       {Number}    max             最大值\r\n * @param       {Number}    [section]       段数只能是 [0, 99] 的整数，段数为 0 或者不指定段数时，将自动调整段数\r\n * @param       {Object}    [opts]          其它扩展参数\r\n * @param       {Array}     opts.steps      自定义步长备选值，如 [10, 12, 15, 20, 25, 30, 40, 50, 60, 80] ，但必须 => [10, 99]\r\n * @return      {Object}    {min: 新最小值, max: 新最大值, secs: 分段数, step: 每段长, fix: 小数保留位数, pnts: [分段结果]}\r\n */\r\ndefine(function() {\r\n\r\n\r\n\r\nvar mySteps     = [10, 20, 25, 50];\r\nvar mySections  = [4, 5, 6];\r\n\r\nvar custOpts;\r\nvar custSteps;\r\nvar custSecs;\r\nvar minLocked;\r\nvar maxLocked;\r\n\r\nvar MT          = Math;\r\nvar MATH_ROUND  = MT.round;\r\nvar MATH_FLOOR  = MT.floor;\r\nvar MATH_CEIL   = MT.ceil;\r\nvar MATH_ABS    = MT.abs;\r\n\r\n\r\nfunction MATH_LOG(n) {return MT.log(MATH_ABS(n)) / MT.LN10;}\r\nfunction MATH_POW(n) {return MT.pow(10, n);}\r\nfunction MATH_ISINT(n) {return n === MATH_FLOOR(n);}\r\n\r\n\r\nfunction smartSteps(min, max, section, opts) {\r\n    // 拿公共变量来接收 opts.steps 这个参数，就不用带着参数层层传递了，注意在函数的最终出口处释放这个值\r\n    custOpts    = opts || {};\r\n    custSteps   = custOpts.steps || mySteps;\r\n    custSecs    = custOpts.secs || mySections;\r\n    section     = MATH_ROUND(+section || 0) % 99;           // 段数限定在 [0, 99] ，0 则自适应\r\n    min         = +min || 0;\r\n    max         = +max || 0;\r\n    minLocked   = maxLocked = 0;\r\n    if ('min' in custOpts) {\r\n        min     = +custOpts.min || 0;\r\n        minLocked = 1;\r\n    }\r\n    if ('max' in custOpts) {\r\n        max     = +custOpts.max || 0;\r\n        maxLocked = 1;\r\n    }\r\n    if (min > max) {max = [min, min = max][0];}             // 最值交换\r\n    var span    = max - min;\r\n    if (minLocked && maxLocked) {\r\n        return bothLocked(min, max, section);               // 两个最值同时被锁定，注意差值为 0 的情况\r\n    }\r\n    if (span < (section || 5)) {                            // 跨度值小于要分的段数，步长将会小于 1\r\n        if (MATH_ISINT(min) && MATH_ISINT(max)) {           // 步长小于 1 同时两个最值都是整数，特别处理\r\n            return forInteger(min, max, section);           // 也要考虑差值为 0 的情况\r\n        }\r\n        else if (span === 0) {                              // 非整数且跨度为 0 的情况\r\n            return forSpan0(min, max, section);\r\n        }\r\n    }\r\n    return coreCalc(min, max, section);                     // 非特殊情况的计算，须确保 min < max\r\n}\r\n\r\n\r\n\r\n/**\r\n * 构造返回值，处理小数精度等问题\r\n * @param   {Number}    newMin      最小值\r\n * @param   {Number}    newMax      最大值\r\n * @param   {Number}    section     分段数\r\n * @param   {Number}    [expon]     计算量级\r\n * @return  {Object}                同 smartSteps\r\n */\r\nfunction makeResult(newMin, newMax, section, expon) {\r\n    expon       = expon || 0;                               // 这是中间计算量级，受步长增长、特别是最值锁定的影响，可能会小于基准量级，因为整数部分被过度放大\r\n    var expStep = expNum((newMax - newMin) / section, -1);\r\n    var expMin  = expNum(newMin, -1, 1);                    // 锁定的最值有效数位可能很多，需要全精度保留\r\n    var expMax  = expNum(newMax, -1);\r\n    var minExp  = MT.min(expStep.e, expMin.e, expMax.e);    // 这个值实际上就是各值整数部分尾部多余的 0 的个数\r\n    if (expMin.c === 0) {                                   // 0 可以有任意多个尾0\r\n        minExp  = MT.min(expStep.e, expMax.e);\r\n    } else if (expMax.c === 0) {\r\n        minExp  = MT.min(expStep.e, expMin.e);\r\n    }\r\n    expFixTo(expStep, {c: 0, e: minExp});\r\n    expFixTo(expMin, expStep, 1);\r\n    expFixTo(expMax, expStep);\r\n    expon      += minExp;                                   // 最终的基准量级，在这个量级下，各值刚好能表示成整数\r\n    newMin      = expMin.c;\r\n    newMax      = expMax.c;\r\n    var step    = (newMax - newMin) / section;\r\n    var zoom    = MATH_POW(expon);\r\n    var fixTo   = 0;\r\n    var points  = [];\r\n    for (var i  = section + 1; i--;) {                      // 因为点数比段数多 1\r\n        points[i] = (newMin + step * i) * zoom;             // 如果不涉及小数问题，这里就直接使用数值型\r\n    }\r\n    if (expon   < 0) {\r\n        fixTo   = decimals(zoom);                           // 前面已经去掉了各值尾部多余的 0 ，所以 zoom 的小数位就是最终的 fix 位数\r\n        step    = +(step * zoom).toFixed(fixTo);            // toFixed 处理长尾小数问题，如：0.2 * 0.1 = 0.020000000000000004\r\n        newMin  = +(newMin * zoom).toFixed(fixTo);\r\n        newMax  = +(newMax * zoom).toFixed(fixTo);\r\n        for (var i = points.length; i--;) {\r\n            points[i] = points[i].toFixed(fixTo);           // 为保证小数点对齐，统一转为字符型\r\n            +points[i] === 0 && (points[i] = '0');          // 0.000 不好看\r\n        }\r\n    }\r\n    else {\r\n        newMin *= zoom;\r\n        newMax *= zoom;\r\n        step   *= zoom;\r\n    }\r\n    custSecs    = 0;\r\n    custSteps   = 0;\r\n    custOpts    = 0;\r\n    // 这些公共变量可能持用了对用户参数的引用，这里是函数的最终出口，释放引用\r\n\r\n    return {\r\n        min:    newMin,                 // 新最小值\r\n        max:    newMax,                 // 新最大值\r\n        secs:   section,                // 分段数\r\n        step:   step,                   // 每段长\r\n        fix:    fixTo,                  // 小数保留位数，0 则为整数\r\n        exp:    expon,                  // 基准量级，并非原值所在的量级，而是说在这个量级下，各值能表示成整数\r\n        pnts:   points                  // 分段结果，整数都是数值型，小数时为了对齐小数点，都是字符型，但其中 0 不带小数点，即没有 \"0.000\"\r\n    };\r\n}\r\n\r\n\r\n\r\n/**\r\n * 量级计数法 表示数值，不适用于很大或者很小的数，0 更不行\r\n * @param       {Number}    num             原数\r\n * @param       {Number}    [digit = 2]     精度位数，必须 => [1, 9]\r\n * @param       {Boolean}   [byFloor = 0]   默认为 0 表示近似值不小于原值，置 1 表示近似值不大于原值\r\n * @return      {Object}    {c: c, e: e}    c e 都是整数，c * 10 ^ e 即为原值的近似数\r\n * @description             返回值应该更详细一点：{c: c, e: e, d: d, n: n} ，其中 d 是 c 的位数，n = c * 10 ^ e ，不过目前好像不太有用\r\n */\r\nfunction expNum(num, digit, byFloor) {\r\n    digit       = MATH_ROUND(digit % 10) || 2;\r\n    if (digit   < 0) {                                      // 全精度位数\r\n        if (MATH_ISINT(num)) {                              // 整数的全精度位数，要去掉尾 0 ，但 0 也是整数，要专门留一位精度\r\n            digit = ('' + MATH_ABS(num)).replace(/0+$/, '').length || 1;\r\n        }\r\n        else {                                              // 小数的全精度位数，要去掉首 0\r\n            num = num.toFixed(15).replace(/0+$/, '');       // toFixed 处理长尾小数\r\n            digit = num.replace('.', '').replace(/^[-0]+/, '').length;\r\n            num = +num;                                     // '' + 0.0000001 会得到 '1e-7'\r\n        }\r\n    }\r\n    var expon   = MATH_FLOOR(MATH_LOG(num)) - digit + 1;\r\n    var cNum    = +(num * MATH_POW(-expon)).toFixed(15) || 0;   // toFixed 处理长尾小数问题\r\n    cNum        = byFloor ? MATH_FLOOR(cNum) : MATH_CEIL(cNum); // 向上取整可能发生进位，使精度位数增加 1\r\n    !cNum && (expon = 0);\r\n    if (('' + MATH_ABS(cNum)).length > digit) {                 // 整数位数判断，字符串法比对数法快近一倍\r\n        expon  += 1;\r\n        cNum   /= 10;\r\n    }\r\n    return {\r\n        c: cNum,\r\n        e: expon\r\n    };\r\n}\r\n\r\n\r\n/**\r\n * 将前者的指数对齐到后者，如果前者量级较小，就是强制加大指数，值误差可能严重放大，甚至值变为 0\r\n */\r\nfunction expFixTo(expnum1, expnum2, byFloor) {\r\n    var deltaExp    = expnum2.e - expnum1.e;\r\n    if (deltaExp) {\r\n        expnum1.e  += deltaExp;                             // 指数减小时，只需将整数部分相应放大\r\n        expnum1.c  *= MATH_POW(-deltaExp);                  // 指数增加时，整数部分将缩小，就涉及 floor ceil 取整和变 0 问题\r\n        expnum1.c   = byFloor ? MATH_FLOOR(expnum1.c) : MATH_CEIL(expnum1.c);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * 将两个量级数的指数对齐到较小者\r\n */\r\nfunction expFixMin(expnum1, expnum2, byFloor) {\r\n    if (expnum1.e < expnum2.e) {\r\n        expFixTo(expnum2, expnum1, byFloor);\r\n    }\r\n    else {\r\n        expFixTo(expnum1, expnum2, byFloor);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * 基于量级计数法，对原值的整数部分取近似，不适用于负数和 0\r\n * @param       {Number}    num             原值\r\n * @param       {Array}     [rounds]        在取近似时，提供预置选项，近似到 rounds 中的某项\r\n * @return      {Object}    expNum          2 位精度的量级计数法对象，不小于原值\r\n */\r\nfunction getCeil(num, rounds) {\r\n    rounds      = rounds || mySteps;\r\n    num         = expNum(num);                              // 2 位精度量级计数法\r\n    var cNum    = num.c;\r\n    var i       = 0;\r\n    while (cNum > rounds[i]) {                              // 在预置的近似数中，找到不小于目标 cNum 的项\r\n        i++;\r\n    }\r\n    if (!rounds[i]) {                                       // 如果没找到合适的预置项，一定是目标值大于全部的预置项\r\n        cNum   /= 10;                                       // 将目标值缩小 10 倍，重找一次定能命中\r\n        num.e  += 1;\r\n        i       = 0;\r\n        while (cNum > rounds[i]) {\r\n            i++;\r\n        }\r\n    }\r\n    num.c       = rounds[i];\r\n    return num;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * 基于量级计数法的计算，必须 min < max\r\n */\r\nfunction coreCalc(min, max, section) {\r\n    var step;\r\n    var secs    = section || +custSecs.slice(-1);\r\n    var expStep = getCeil((max - min) / secs, custSteps);   // 这是可能的最小步长，以它的量级作为后续计算的基准量级，以保证整数计算特性\r\n    var expSpan = expNum(max - min);                        // 2 位精度的最值跨度，过高的精度意味着有效数位更多\r\n    var expMin  = expNum(min, -1, 1);                       // 最小值向下近似，以涵盖原最小值\r\n    var expMax  = expNum(max, -1);     // 最大值向上近似，参数 -1 表示保留全精度，因为要注意 min = 10000001, max = 10000002 等情况\r\n    expFixTo(expSpan, expStep);                             // 指数对齐\r\n    expFixTo(expMin, expStep, 1);                           // 经过指数对齐，原最大值、最小值都有可能变为 0\r\n    expFixTo(expMax, expStep);\r\n    if (!section) {\r\n        secs    = look4sections(expMin, expMax);\r\n    }\r\n    else {\r\n        step    = look4step(expMin, expMax, secs);\r\n    }\r\n\r\n    // 如果原最值都是整数，尽量让输出值也保持整数，但原最值跨 0 的则不调整\r\n    if (MATH_ISINT(min) && MATH_ISINT(max) && min * max >= 0) {\r\n        if (max - min < secs) {                             // 再次出现跨度小于段数\r\n            return forInteger(min, max, secs);\r\n        }\r\n        secs = tryForInt(min, max, section, expMin, expMax, secs);\r\n    }\r\n    var arrMM   = cross0(min, max, expMin.c, expMax.c);\r\n    expMin.c    = arrMM[0];\r\n    expMax.c    = arrMM[1];\r\n    if (minLocked || maxLocked) {\r\n        singleLocked(min, max, expMin, expMax);\r\n    }\r\n    return makeResult(expMin.c, expMax.c, secs, expMax.e);\r\n}\r\n\r\n\r\n\r\n/**\r\n * 在预置的可选段数中，找出一个合适的值，让跨度误差尽量小\r\n */\r\nfunction look4sections(expMin, expMax) {\r\n    var section;\r\n    var tmpStep, tmpMin, tmpMax;\r\n    var reference   = [];\r\n    for (var i      = custSecs.length; i--;) {              // 逐步减小段数，步长就会渐大\r\n        section     = custSecs[i];\r\n        tmpStep     = getCeil((expMax.c - expMin.c) / section, custSteps);\r\n        tmpStep     = tmpStep.c * MATH_POW(tmpStep.e);      // 步长都用常规整数参与计算\r\n        tmpMin      = MATH_FLOOR(expMin.c / tmpStep) * tmpStep;\r\n        tmpMax      = MATH_CEIL(expMax.c / tmpStep) * tmpStep;\r\n        reference[i] = {\r\n            min:    tmpMin,\r\n            max:    tmpMax,\r\n            step:   tmpStep,\r\n            span:   tmpMax - tmpMin                         // 步长的误差被 段数 成倍放大，可能会给跨度造成更大的误差，使最后的段数大于预置的最大值\r\n        };\r\n    }\r\n    reference.sort(function (a, b) {\r\n        var delta = a.span - b.span;                        // 分段调整之后的跨度，一定不小于原跨度，所以越小越好\r\n        if (delta === 0) {\r\n            delta = a.step - b.step;                        // 跨度相同时，步长小者胜出\r\n        }\r\n        return delta;\r\n    });\r\n    reference   = reference[0];\r\n    section     = reference.span / reference.step;\r\n    expMin.c    = reference.min;\r\n    expMax.c    = reference.max;\r\n    return section < 3 ? section * 2 : section;             // 如果最终步长比最小步长大得多，段数就可能变得很小\r\n}\r\n\r\n\r\n/**\r\n * 指定段数，在预置的可选步长中，找出一个合适的值，让 步长 * 段数 积刚好涵盖原最大值与最小值\r\n */\r\nfunction look4step(expMin, expMax, secs) {\r\n    var span;\r\n    var tmpMax;\r\n    var tmpMin      = expMax.c;\r\n    var tmpStep     = (expMax.c - expMin.c) / secs - 1;\r\n    while (tmpMin   > expMin.c) {\r\n        tmpStep     = getCeil(tmpStep + 1, custSteps);\r\n        tmpStep     = tmpStep.c * MATH_POW(tmpStep.e);\r\n        span        = tmpStep * secs;\r\n        tmpMax      = MATH_CEIL(expMax.c / tmpStep) * tmpStep;\r\n        tmpMin      = tmpMax - span;                        // 优先保证 max 端的误差最小，试看原 min 值能否被覆盖到\r\n    }\r\n    var deltaMin    = expMin.c - tmpMin;                    // 上面的计算可能会让 min 端的误差更大，下面尝试均衡误差\r\n    var deltaMax    = tmpMax - expMax.c;\r\n    var deltaDelta  = deltaMin - deltaMax;\r\n    if (deltaDelta  > tmpStep * 1.1) {                      // 当 min 端的误差比 max 端大很多时，考虑将 tmpMin tmpMax 同时上移\r\n        deltaDelta  = MATH_ROUND(deltaDelta / tmpStep / 2) * tmpStep;\r\n        tmpMin     += deltaDelta;\r\n        tmpMax     += deltaDelta;\r\n    }\r\n    expMin.c   = tmpMin;\r\n    expMax.c   = tmpMax;\r\n    return tmpStep;\r\n}\r\n\r\n\r\n/**\r\n * 原最值都是整数时，尝试让输出也保持整数\r\n */\r\nfunction tryForInt(min, max, section, expMin, expMax, secs) {\r\n    var span = expMax.c - expMin.c;\r\n    var step = span / secs * MATH_POW(expMax.e);\r\n    if (!MATH_ISINT(step)) {                                // 原最值都是整数，但计算步长可能出现小数，如 2.5\r\n        step = MATH_FLOOR(step);                            // 步长总是要尽量小，以减小跨度误差，所以 2.5 可能被调整为 2 或者 3\r\n        span = step * secs;\r\n        if (span < max - min) {\r\n            step += 1;\r\n            span = step * secs;\r\n            if (!section && (step * (secs - 1) >= (max - min))) {\r\n                secs -= 1;\r\n                span = step * secs;\r\n            }\r\n        }\r\n        if (span >= max - min) {\r\n            var delta   = span - (max - min);               // 误差均衡\r\n            expMin.c    = MATH_ROUND(min - delta / 2);\r\n            expMax.c    = MATH_ROUND(max + delta / 2);\r\n            expMin.e    = 0;\r\n            expMax.e    = 0;\r\n        }\r\n    }\r\n    return secs;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * 整数情况下，跨度小于段数的处理\r\n */\r\nfunction forInteger(min, max, section) {\r\n    section     = section || 5;\r\n    if (minLocked) {\r\n        max     = min + section;                            // min max 没有写错，因为 min locked 所以 max 在 min 上浮动\r\n    }\r\n    else if (maxLocked) {\r\n        min     = max - section;\r\n    }\r\n    else {\r\n        var delta   = section - (max - min);                // 没有端点锁定时，向上下延展跨度\r\n        var newMin  = MATH_ROUND(min - delta / 2);\r\n        var newMax  = MATH_ROUND(max + delta / 2);\r\n        var arrMM   = cross0(min, max, newMin, newMax);     // 避免跨 0\r\n        min         = arrMM[0];\r\n        max         = arrMM[1];\r\n    }\r\n    return makeResult(min, max, section);\r\n}\r\n\r\n\r\n/**\r\n * 非整数情况下，跨度为 0 的处理\r\n */\r\nfunction forSpan0(min, max, section) {\r\n    section     = section || 5;\r\n    // delta 一定不为 0 ，因为 min === max === 0 的情况会进入 forInteger 分支\r\n    var delta   = MT.min(MATH_ABS(max / section), section) / 2.1;\r\n    if (minLocked) {\r\n        max     = min + delta;                              // min max 没有写错，因为 min locked 所以 max 在 min 上浮动\r\n    }\r\n    else if (maxLocked) {\r\n        min     = max - delta;\r\n    }\r\n    else {                                                  // 以最值为中心，上下各延展一小段\r\n        min     = min - delta;\r\n        max     = max + delta;\r\n    }\r\n    return coreCalc(min, max, section);\r\n}\r\n\r\n\r\n/**\r\n * 当原始最值都在 0 的同侧时，让输出也保持在 0 的同侧\r\n */\r\nfunction cross0(min, max, newMin, newMax) {\r\n    if (min >= 0 && newMin < 0) {\r\n        newMax -= newMin;\r\n        newMin  = 0;\r\n    }\r\n    else if (max <= 0 && newMax > 0) {\r\n        newMin -= newMax;\r\n        newMax  = 0;\r\n    }\r\n    return [newMin, newMax];\r\n}\r\n\r\n\r\n/**\r\n * 取一个数的小数位数\r\n * @param   {Number}    num         原数值\r\n * @return  {Number}    decimals    整数则返回 0 ，小数则返回小数点后的位数\r\n */\r\nfunction decimals(num) {\r\n    num = (+num).toFixed(15).split('.');                    // String(0.0000001) 会得到 '1e-7'\r\n    return num.pop().replace(/0+$/, '').length;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * 单个最值锁定处理，只是在原计算的基础上，锁定一个，平移另一个\r\n */\r\nfunction singleLocked(min, max, emin, emax) {\r\n    if (minLocked) {\r\n        var expMin  = expNum(min, 4, 1);                    // 4 位精度向下近似\r\n        if (emin.e  - expMin.e > 6) {                       // 如果锁定值的量级远小于基准量级，认为锁定失败，强置为 0\r\n            expMin  = {c: 0, e: emin.e};\r\n        }\r\n        expFixMin(emin, expMin);                            // 将指数与量级较小者对齐\r\n        expFixMin(emax, expMin);\r\n        emax.c     += expMin.c - emin.c;                    // 最大值平移\r\n        emin.c      = expMin.c;                             // 最小值锁定\r\n    }\r\n    else if (maxLocked) {\r\n        var expMax  = expNum(max, 4);                       // 4 位精度向上近似\r\n        if (emax.e  - expMax.e > 6) {                       // 如果锁定值的量级远小于基准量级，认为锁定失败，强置为 0\r\n            expMax  = {c: 0, e: emax.e};\r\n        }\r\n        expFixMin(emin, expMax);                            // 将指数与量级较小者对齐\r\n        expFixMin(emax, expMax);\r\n        emin.c     += expMax.c - emax.c;                    // 最小值平移\r\n        emax.c      = expMax.c;                             // 最大值锁定\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * 最小值和最大值同时被锁定的情况在这里，其它地方只考虑单边最值锁定\r\n * @param   {Number}    min         锁定的最小值\r\n * @param   {Number}    max         锁定的最大值\r\n * @param   {Number}    [section]   段数\r\n * @return  {Object}                同 smartSteps\r\n */\r\nfunction bothLocked(min, max, section) {\r\n    var trySecs     = section ? [section] : custSecs;\r\n    var span        = max - min;\r\n    if (span       === 0) {                                 // 最大最小值都锁定到同一个值上，认为锁定失败\r\n        max         = expNum(max, 3);                       // 3 位精度向上近似\r\n        section     = trySecs[0];\r\n        max.c       = MATH_ROUND(max.c + section / 2);\r\n        return makeResult(max.c - section, max.c, section, max.e);\r\n    }\r\n    if (MATH_ABS(max / span) < 1e-6) {                      // 如果锁定值远小于跨度，也认为锁定失败，强置为 0\r\n        max         = 0;\r\n    }\r\n    if (MATH_ABS(min / span) < 1e-6) {\r\n        min         = 0;\r\n    }\r\n    var step, deltaSpan, score;\r\n    var scoreS      = [[5, 10], [10, 2], [50, 10], [100, 2]];\r\n    var reference   = [];\r\n    var debugLog    = [];\r\n    var expSpan     = expNum((max - min), 3);               // 3 位精度向上近似\r\n    var expMin      = expNum(min, -1, 1);\r\n    var expMax      = expNum(max, -1);\r\n    expFixTo(expMin, expSpan, 1);\r\n    expFixTo(expMax, expSpan);\r\n    span            = expMax.c - expMin.c;\r\n    expSpan.c       = span;\r\n    \r\n    for (var i      = trySecs.length; i--;) {\r\n        section     = trySecs[i];\r\n        step        = MATH_CEIL(span / section);\r\n        deltaSpan   = step * section - span;\r\n        score       = (deltaSpan + 3) * 3;                  // 误差越大得分越高\r\n        score      += (section - trySecs[0] + 2) * 2;       // 分段越多得分越高\r\n        if (section % 5 === 0) {                            // 段数为 5 可以减分\r\n            score  -= 10;\r\n        }\r\n        for (var j  = scoreS.length; j--;) {                // 好的步长是最重要的减分项\r\n            if (step % scoreS[j][0] === 0) {\r\n                score /= scoreS[j][1];\r\n            }\r\n        }\r\n        debugLog[i] = [section, step, deltaSpan, score].join();\r\n        reference[i] = {\r\n            secs:   section,\r\n            step:   step,\r\n            delta:  deltaSpan,\r\n            score:  score\r\n        };\r\n    }\r\n    //console.log(debugLog);\r\n    reference.sort(function (a, b) {return a.score - b.score;});\r\n    reference   = reference[0];\r\n    expMin.c    = MATH_ROUND(expMin.c - reference.delta / 2);\r\n    expMax.c    = MATH_ROUND(expMax.c + reference.delta / 2);\r\n    return makeResult(expMin.c, expMax.c, reference.secs, expSpan.e);\r\n}\r\n\r\n\r\n\r\n\r\nreturn smartSteps;\r\n});\r\n\r\n\r\n\r\n"
        },
        {
          "id": 58,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\smartLogSteps.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/smartLogSteps.js",
          "index": 58,
          "index2": 51,
          "size": 16048,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 55,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
              "type": "cjs require",
              "userRequest": "../util/smartLogSteps",
              "loc": "777:25-57"
            }
          ],
          "source": "/**\r\n * Echarts, logarithmic axis reform\r\n *\r\n * @author sushuang (sushuang@baidu.com),\r\n *         Ievgenii (@Ievgeny, ievgeny@zoomdata.com)\r\n */\r\n\r\ndefine(function(require) {\r\n\r\n    // Reference\r\n    var number = require('./number');\r\n    var Mt = Math;\r\n    var mathLog = Mt.log;\r\n    var mathPow = Mt.pow;\r\n    var mathAbs = Mt.abs;\r\n    var mathCeil = Mt.ceil;\r\n    var mathFloor = Mt.floor;\r\n\r\n    // Constant\r\n    var LOG_BASE = Mt.E; // It is not necessary to specify log base,\r\n                         // because log(logBase, x) = ln(x) / ln(logBase),\r\n                         // thus final result (axis tick location) is only determined by ln(x).\r\n    var LN10 = Mt.LN10;\r\n    var LN2 = Mt.LN2;\r\n    var LN2D10 = LN2 / LN10;\r\n    var EPSILON = 1e-9;\r\n    var DEFAULT_SPLIT_NUMBER = 5;\r\n    var MIN_BASE_10_SPLIT_NUMBER = 2;\r\n    var SUPERSCRIPTS = {\r\n        '0': '⁰',\r\n        '1': '¹',\r\n        '2': '²',\r\n        '3': '³',\r\n        '4': '⁴',\r\n        '5': '⁵',\r\n        '6': '⁶',\r\n        '7': '⁷',\r\n        '8': '⁸',\r\n        '9': '⁹',\r\n        '-': '⁻'\r\n    };\r\n\r\n    // Static variable\r\n    var logPositive;\r\n    var logLabelBase;\r\n    var logLabelMode; // enumeration:\r\n                      // 'plain' (i.e. axis labels are shown like 10000)\r\n                      // 'exponent' (i.e. axis labels are shown like 10²)\r\n    var lnBase;\r\n    var custOpts;\r\n    var splitNumber;\r\n    var logMappingOffset;\r\n    var absMin;\r\n    var absMax;\r\n    var tickList;\r\n\r\n    /**\r\n     * Test cases:\r\n     * [2, 4, 8, 16, 32, 64, 128]\r\n     * [0.01, 0.1, 10, 100, 1000] logLabelBase: 3\r\n     * [0.01, 0.1, 10, 100, 1000] logLabelBase: -12\r\n     * [-2, -4, -8, -16, -32, -64, -128] logLabelBase: 3\r\n     * [2, 4, 8, 16, '-', 64, 128]\r\n     * [2, 4, 8, 16, 32, 64]\r\n     * [2, 4, 8, 16, 32]\r\n     * [0.00000256, 0.0016, 0.04, 0.2]\r\n     * [0.1, 1, 10, 100, 1000, 10000, 100000, 1000000] splitNumber: 3\r\n     * [1331, 3434, 500, 1, 1212, 4]\r\n     * [0.14, 2, 45, 1001, 200, 0.33, 10001]\r\n     * [0.00001, 0.00005]\r\n     * [0.00001, 0.00005] boundaryGap: [0.2, 0.4]\r\n     * [0.001, 2, -45, 1001, 200, 0.33, 10000]\r\n     * [0.00000001, 0.00000012]\r\n     * [0.000000000000001]\r\n     * [0.00000001, 0.00000001]\r\n     * [3, 3]\r\n     * [12, -3, 47, 19]\r\n     * [12, -3, 47, 19] logPositive: false\r\n     * [-2, -4, -8, -16, -32, -64, -128]\r\n     * [-2, -4, -8, -16, -32, -64]\r\n     * [2, 4, 8, 16, 32] boundaryGap: [0.2, 0.4]\r\n     * []\r\n     * [0]\r\n     * [10, 10, 10]\r\n     * [0.00003, 0.00003, 0.00003]\r\n     * [0.00001, 0.00001, 0.00001]\r\n     * [-0.00001, -0.00001, -0.00001]\r\n     * ['-', '-']\r\n     * ['-', 10]\r\n     * logarithmic axis in scatter (try dataZoom)\r\n     * logarithmic axis width dataZoom component (try xAxis and yAxis)\r\n     */\r\n\r\n    /**\r\n     * Main function. Return data object with values for axis building.\r\n     *\r\n     * @public\r\n     * @param {Object} [opts] Configurable options\r\n     * @param {number} opts.dataMin data Minimum\r\n     * @param {number} opts.dataMax data Maximum\r\n     * @param {number=} opts.logPositive Logarithmic sign. If not specified, it will be auto-detected.\r\n     * @param {number=} opts.logLabelBase Logaithmic base in axis label.\r\n     *                                    If not specified, it will be set to 10 (and use 2 for detail)\r\n     * @param {number=} opts.splitNumber Number of sections perfered.\r\n     * @return {Object} {\r\n     *                      dataMin: New min,\r\n     *                      dataMax: New max,\r\n     *                      tickList: [Array of tick data]\r\n     *                      logPositive: Type of data sign\r\n     *                      dataMappingMethods: [Set of logarithmic methods]\r\n     *                  }\r\n     */\r\n    function smartLogSteps(opts) {\r\n        clearStaticVariables();\r\n        custOpts = opts || {};\r\n\r\n        reformSetting();\r\n        makeTicksList();\r\n\r\n        return [\r\n            makeResult(),\r\n            clearStaticVariables()\r\n        ][0];\r\n    }\r\n\r\n    /**\r\n     * All of static variables must be clear here.\r\n     */\r\n    function clearStaticVariables() {\r\n        logPositive = custOpts = logMappingOffset = lnBase =\r\n        absMin = absMax = splitNumber = tickList = logLabelBase = logLabelMode = null;\r\n    }\r\n\r\n    /**\r\n     * Determine sign (logPositive, negative) of data set, if not specified.\r\n     * Reform min and max of data.\r\n     */\r\n    function reformSetting() {\r\n        // Settings of log label base\r\n        logLabelBase = custOpts.logLabelBase;\r\n        if (logLabelBase == null) {\r\n            logLabelMode = 'plain';\r\n            logLabelBase = 10;\r\n            lnBase = LN10;\r\n        }\r\n        else {\r\n            logLabelBase = +logLabelBase;\r\n            if (logLabelBase < 1) { // log base less than 1 is not supported.\r\n                logLabelBase = 10;\r\n            }\r\n            logLabelMode = 'exponent';\r\n            lnBase = mathLog(logLabelBase);\r\n        }\r\n\r\n        // Settings of split number\r\n        splitNumber = custOpts.splitNumber;\r\n        splitNumber == null && (splitNumber = DEFAULT_SPLIT_NUMBER);\r\n\r\n        // Setting of data min and max\r\n        var dataMin = parseFloat(custOpts.dataMin);\r\n        var dataMax = parseFloat(custOpts.dataMax);\r\n\r\n        if (!isFinite(dataMin) && !isFinite(dataMax)) {\r\n            dataMin = dataMax = 1;\r\n        }\r\n        else if (!isFinite(dataMin)) {\r\n            dataMin = dataMax;\r\n        }\r\n        else if (!isFinite(dataMax)) {\r\n            dataMax = dataMin;\r\n        }\r\n        else if (dataMin > dataMax) {\r\n            dataMax = [dataMin, dataMin = dataMax][0]; // Exchange min, max.\r\n        }\r\n\r\n        // Settings of log positive\r\n        logPositive = custOpts.logPositive;\r\n        // If not specified, determine sign by data.\r\n        if (logPositive == null) {\r\n            // LogPositive is false when dataMax <= 0 && dataMin < 0.\r\n            // LogPositive is true when dataMin >= 0.\r\n            // LogPositive is true when dataMax >= 0 && dataMin < 0 (singular points may exists)\r\n            logPositive = dataMax > 0 || dataMin === 0;\r\n        }\r\n\r\n        // Settings of absMin and absMax, which must be greater than 0.\r\n        absMin = logPositive ? dataMin : -dataMax;\r\n        absMax = logPositive ? dataMax : -dataMin;\r\n        // FIXME\r\n        // If there is any data item less then zero, it is suppose to be igonred and min should be re-calculated.\r\n        // But it is difficult to do that in current code stucture.\r\n        // So refactor of xxAxis.js is desired.\r\n        absMin < EPSILON && (absMin = EPSILON);\r\n        absMax < EPSILON && (absMax = EPSILON);\r\n    }\r\n\r\n    /**\r\n     * Make tick list.\r\n     */\r\n    function makeTicksList() {\r\n        tickList = [];\r\n\r\n        // Estimate max exponent and min exponent\r\n        var maxDataLog = fixAccurate(mathLog(absMax) / lnBase);\r\n        var minDataLog = fixAccurate(mathLog(absMin) / lnBase);\r\n        var maxExpon = mathCeil(maxDataLog);\r\n        var minExpon = mathFloor(minDataLog);\r\n        var spanExpon = maxExpon - minExpon;\r\n        var spanDataLog = maxDataLog - minDataLog;\r\n\r\n        if (logLabelMode === 'exponent') {\r\n            baseAnalysis();\r\n        }\r\n        else { // logLabelMode === 'plain', we will self-adapter\r\n            !(\r\n                spanExpon <= MIN_BASE_10_SPLIT_NUMBER\r\n                && splitNumber > MIN_BASE_10_SPLIT_NUMBER\r\n            )\r\n                ? baseAnalysis() : detailAnalysis();\r\n        }\r\n\r\n        // In this situation, only draw base-10 ticks.\r\n        // Base-10 ticks: 10^h (i.e. 0.01, 0.1, 1, 10, 100, ...)\r\n        function baseAnalysis() {\r\n            if (spanExpon < splitNumber) {\r\n                splitNumber = spanExpon;\r\n            }\r\n            // Suppose:\r\n            //      spanExpon > splitNumber\r\n            //      stepExpon := floor(spanExpon / splitNumber)\r\n            //      splitNumberFloat := spanExpon / stepExpon\r\n            // There are tow expressions which are identically-true:\r\n            //      splitNumberFloat - splitNumber <= 1\r\n            //      stepExpon * ceil(splitNumberFloat) - spanExpon <= stepExpon\r\n            // So we can calculate as follows:\r\n            var stepExpon = mathFloor(fixAccurate(spanExpon / splitNumber));\r\n\r\n            // Put the plot in the middle of the min, max.\r\n            var splitNumberAdjust = mathCeil(fixAccurate(spanExpon / stepExpon));\r\n            var spanExponAdjust = stepExpon * splitNumberAdjust;\r\n            var halfDiff = (spanExponAdjust - spanDataLog) / 2;\r\n            var minExponAdjust = mathFloor(fixAccurate(minDataLog - halfDiff));\r\n\r\n            if (aroundZero(minExponAdjust - minDataLog)) {\r\n                minExponAdjust -= 1;\r\n            }\r\n\r\n            // Build logMapping offset\r\n            logMappingOffset = -minExponAdjust * lnBase;\r\n\r\n            // Build tickList\r\n            for (var n = minExponAdjust; n - stepExpon <= maxDataLog; n += stepExpon) {\r\n                tickList.push(mathPow(logLabelBase, n));\r\n            }\r\n        }\r\n\r\n        // In this situation, base-2|10 ticks are used to make detailed split.\r\n        // Base-2|10 ticks: 10^h * 2^k (i.e. 0.1, 0.2, 0.4, 1, 2, 4, 10, 20, 40),\r\n        // where k in [0, 1, 2].\r\n        // Because LN2 * 3 < LN10 and LN2 * 4 > LN10, k should be less than 3.\r\n        // And when k === 3, the tick is too close to that of k === 0, which looks weird.\r\n        // So we do not use 3.\r\n        function detailAnalysis() {\r\n            // Find max exponent and min exponent.\r\n            // Calculate base on 3-hexadecimal (0, 1, 2, 10, 11, 12, 20).\r\n            var minDecimal = toDecimalFrom4Hex(minExpon, 0);\r\n            var endDecimal = minDecimal + 2;\r\n            while (\r\n                minDecimal < endDecimal\r\n                && toH(minDecimal + 1) + toK(minDecimal + 1) * LN2D10 < minDataLog\r\n            ) {\r\n                minDecimal++;\r\n            }\r\n            var maxDecimal = toDecimalFrom4Hex(maxExpon, 0);\r\n            var endDecimal = maxDecimal - 2; // maxDecimal is greater than 4\r\n            while (\r\n                maxDecimal > endDecimal\r\n                && toH(maxDecimal - 1) + toK(maxDecimal - 1) * LN2D10 > maxDataLog\r\n            ) {\r\n                maxDecimal--;\r\n            }\r\n\r\n            // Build logMapping offset\r\n            logMappingOffset = -(toH(minDecimal) * LN10 + toK(minDecimal) * LN2);\r\n\r\n            // Build logMapping tickList\r\n            for (var i = minDecimal; i <= maxDecimal; i++) {\r\n                var h = toH(i);\r\n                var k = toK(i);\r\n                tickList.push(mathPow(10, h) * mathPow(2, k));\r\n            }\r\n        }\r\n\r\n        // Convert to decimal number from 4-hexadecimal number,\r\n        // where h, k means: if there is a 4-hexadecimal numer 23, then h is 2, k is 3.\r\n        // h can be any integer (notice: h can be greater than 10 or less than 0),\r\n        // and k belongs to [0, 1, 2, 3].\r\n        function toDecimalFrom4Hex(h, k) {\r\n            return h * 3 + k;\r\n        }\r\n\r\n        function toK(decimal) {\r\n            return decimal - toH(decimal) * 3; // Can not calculate by '%'\r\n        }\r\n\r\n        function toH(decimal) {\r\n            return mathFloor(fixAccurate(decimal / 3));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Make result\r\n     */\r\n    function makeResult() {\r\n        var resultTickList = [];\r\n        for (var i = 0, len = tickList.length; i < len; i++) {\r\n            resultTickList[i] = (logPositive ? 1 : -1) * tickList[i];\r\n        }\r\n        !logPositive && resultTickList.reverse();\r\n\r\n        var dataMappingMethods = makeDataMappingMethods();\r\n        var value2Coord = dataMappingMethods.value2Coord;\r\n\r\n        var newDataMin = value2Coord(resultTickList[0]);\r\n        var newDataMax = value2Coord(resultTickList[resultTickList.length - 1]);\r\n\r\n        if (newDataMin === newDataMax) {\r\n            newDataMin -= 1;\r\n            newDataMax += 1;\r\n        }\r\n\r\n        return {\r\n            dataMin: newDataMin,\r\n            dataMax: newDataMax,\r\n            tickList: resultTickList,\r\n            logPositive: logPositive,\r\n            labelFormatter: makeLabelFormatter(),\r\n            dataMappingMethods: dataMappingMethods\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Make axis label formatter.\r\n     */\r\n    function makeLabelFormatter() {\r\n        if (logLabelMode === 'exponent') { // For label style like 3⁴.\r\n            // Static variables should be fixed in the scope of the methods.\r\n            var myLogLabelBase = logLabelBase;\r\n            var myLnBase = lnBase;\r\n\r\n            return function (value) {\r\n                if (!isFinite(parseFloat(value))) {\r\n                    return '';\r\n                }\r\n                var sign = '';\r\n                if (value < 0) {\r\n                    value = -value;\r\n                    sign = '-';\r\n                }\r\n                return sign + myLogLabelBase + makeSuperscriptExponent(mathLog(value) / myLnBase);\r\n            };\r\n        }\r\n        else {\r\n            return function (value) { // Normal style like 0.001, 10,000,0\r\n                if (!isFinite(parseFloat(value))) {\r\n                    return '';\r\n                }\r\n                return number.addCommas(formatNumber(value));\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Make calculate methods.\r\n     */\r\n    function makeDataMappingMethods() {\r\n        // Static variables should be fixed in the scope of the methods.\r\n        var myLogPositive = logPositive;\r\n        var myLogMappingOffset = logMappingOffset;\r\n\r\n        return {\r\n            value2Coord: function (x) {\r\n                if (x == null || isNaN(x) || !isFinite(x)) {\r\n                    return x;\r\n                }\r\n                x = parseFloat(x); // to number\r\n                if (!isFinite(x)) {\r\n                    x = EPSILON;\r\n                }\r\n                else if (myLogPositive && x < EPSILON) {\r\n                    // FIXME\r\n                    // It is suppose to be ignore, but not be set to EPSILON. See comments above.\r\n                    x = EPSILON;\r\n                }\r\n                else if (!myLogPositive && x > -EPSILON) {\r\n                    x = -EPSILON;\r\n                }\r\n                x = mathAbs(x);\r\n                return (myLogPositive ? 1 : -1) * (mathLog(x) + myLogMappingOffset);\r\n            },\r\n            coord2Value: function (x) {\r\n                if (x == null || isNaN(x) || !isFinite(x)) {\r\n                    return x;\r\n                }\r\n                x = parseFloat(x); // to number\r\n                if (!isFinite(x)) {\r\n                    x = EPSILON;\r\n                }\r\n                return myLogPositive\r\n                    ? mathPow(LOG_BASE, x - myLogMappingOffset)\r\n                    : -mathPow(LOG_BASE, -x + myLogMappingOffset);\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * For example, Math.log(1000) / Math.LN10 get the result of 2.9999999999999996, rather than 3.\r\n     * This method trys to fix it.\r\n     * (accMath.div can not fix this problem yet.)\r\n     */\r\n    function fixAccurate(result) {\r\n        return +Number(+result).toFixed(14);\r\n    }\r\n\r\n    /**\r\n     * Avoid show float number like '1e-9', '-1e-10', ...\r\n     * @return {string}\r\n     */\r\n    function formatNumber(num) {\r\n        return Number(num).toFixed(15).replace(/\\.?0*$/, '');\r\n    }\r\n\r\n    /**\r\n     * Make superscript exponent\r\n     */\r\n    function makeSuperscriptExponent(exponent) {\r\n        exponent = formatNumber(Math.round(exponent)); // Do not support float superscript.\r\n                                                       // (because I can not find superscript style of '.')\r\n        var result = [];\r\n        for (var i = 0, len = exponent.length; i < len; i++) {\r\n            var cha = exponent.charAt(i);\r\n            result.push(SUPERSCRIPTS[cha] || '');\r\n        }\r\n        return result.join('');\r\n    }\r\n\r\n    /**\r\n     * Decide whether near zero\r\n     */\r\n    function aroundZero(val) {\r\n        return val > -EPSILON && val < EPSILON;\r\n    }\r\n\r\n    return smartLogSteps;\r\n});\r\n"
        },
        {
          "id": 59,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "index": 59,
          "index2": 54,
          "size": 6138,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "../component/grid",
              "loc": "15:4-32"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "../component/grid",
              "loc": "17:4-32"
            }
          ],
          "source": "/**\r\n * echarts组件： 网格\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n    \r\n    // 图形依赖\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n    \r\n    var ecConfig = require('../config');\r\n    // 网格\r\n    ecConfig.grid = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 0,                       // 二级层叠\r\n        x: 80,\r\n        y: 60,\r\n        x2: 80,\r\n        y2: 60,\r\n        // width: {totalWidth} - x - x2,\r\n        // height: {totalHeight} - y - y2,\r\n        backgroundColor: 'rgba(0,0,0,0)',\r\n        borderWidth: 1,\r\n        borderColor: '#ccc'\r\n    };\r\n\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 图表选项\r\n     *      @param {number=} option.grid.x 直角坐标系内绘图网格起始横坐标，数值单位px\r\n     *      @param {number=} option.grid.y 直角坐标系内绘图网格起始纵坐标，数值单位px\r\n     *      @param {number=} option.grid.width 直角坐标系内绘图网格宽度，数值单位px\r\n     *      @param {number=} option.grid.height 直角坐标系内绘图网格高度，数值单位px\r\n     */\r\n    function Grid(ecTheme, messageCenter, zr, option, myChart) {\r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this.refresh(option);\r\n    }\r\n    \r\n    Grid.prototype = {\r\n        type: ecConfig.COMPONENT_TYPE_GRID,\r\n\r\n        getX: function () {\r\n            return this._x;\r\n        },\r\n\r\n        getY: function () {\r\n            return this._y;\r\n        },\r\n\r\n        getWidth: function () {\r\n            return this._width;\r\n        },\r\n\r\n        getHeight: function () {\r\n            return this._height;\r\n        },\r\n\r\n        getXend: function () {\r\n            return this._x + this._width;\r\n        },\r\n\r\n        getYend: function () {\r\n            return this._y + this._height;\r\n        },\r\n\r\n        getArea: function () {\r\n            return {\r\n                x: this._x,\r\n                y: this._y,\r\n                width: this._width,\r\n                height: this._height\r\n            };\r\n        },\r\n        \r\n        getBbox: function() {\r\n            return [\r\n                [ this._x, this._y ],\r\n                [ this.getXend(), this.getYend() ]\r\n            ];\r\n        },\r\n        \r\n        /**\r\n         * 实在找不到合适的地方做了，各种粗暴的写法~ -_-\r\n         */\r\n        refixAxisShape: function(component) {\r\n            var zeroX;\r\n            var zeroY;\r\n            var axisList = component.xAxis._axisList.concat(\r\n                component.yAxis ? component.yAxis._axisList : []\r\n            );\r\n            var len = axisList.length;\r\n            var axis;\r\n            while (len--) {\r\n                axis = axisList[len];\r\n                if (axis.type == ecConfig.COMPONENT_TYPE_AXIS_VALUE \r\n                    && axis._min < 0  \r\n                    && axis._max >= 0\r\n                ) {\r\n                    axis.isHorizontal()\r\n                    ? (zeroX = axis.getCoord(0))\r\n                    : (zeroY = axis.getCoord(0));\r\n                }\r\n            }\r\n            if (typeof zeroX != 'undefined' || typeof zeroY != 'undefined') {\r\n                len = axisList.length;\r\n                while (len--) {\r\n                    axisList[len].refixAxisShape(zeroX, zeroY);\r\n                }\r\n            }\r\n        },\r\n        \r\n        refresh: function (newOption) {\r\n            if (newOption\r\n                || this._zrWidth != this.zr.getWidth() \r\n                || this._zrHeight != this.zr.getHeight()\r\n            ) {\r\n                this.clear();\r\n                this.option = newOption || this.option;\r\n                this.option.grid = this.reformOption(this.option.grid);\r\n    \r\n                var gridOption = this.option.grid;\r\n                this._zrWidth = this.zr.getWidth();\r\n                this._zrHeight = this.zr.getHeight();\r\n                this._x = this.parsePercent(gridOption.x, this._zrWidth);\r\n                this._y = this.parsePercent(gridOption.y, this._zrHeight);\r\n                var x2 = this.parsePercent(gridOption.x2, this._zrWidth);\r\n                var y2 = this.parsePercent(gridOption.y2, this._zrHeight);\r\n                \r\n    \r\n                if (typeof gridOption.width == 'undefined') {\r\n                    this._width = this._zrWidth - this._x - x2;\r\n                }\r\n                else {\r\n                    this._width = this.parsePercent(gridOption.width, this._zrWidth);\r\n                }\r\n                this._width = this._width <= 0 ? 10 : this._width;\r\n    \r\n                if (typeof gridOption.height == 'undefined') {\r\n                    this._height = this._zrHeight - this._y - y2;\r\n                }\r\n                else {\r\n                    this._height = this.parsePercent(gridOption.height, this._zrHeight);\r\n                }\r\n                this._height = this._height <= 0 ? 10 : this._height;\r\n                \r\n                this._x = this.subPixelOptimize(this._x, gridOption.borderWidth);\r\n                this._y = this.subPixelOptimize(this._y, gridOption.borderWidth);\r\n    \r\n                this.shapeList.push(new RectangleShape({\r\n                    zlevel: this.getZlevelBase(),\r\n                    z: this.getZBase(),\r\n                    hoverable: false,\r\n                    style: {\r\n                        x: this._x,\r\n                        y: this._y,\r\n                        width: this._width,\r\n                        height: this._height,\r\n                        brushType: gridOption.borderWidth > 0 ? 'both' : 'fill',\r\n                        color: gridOption.backgroundColor,\r\n                        strokeColor: gridOption.borderColor,\r\n                        lineWidth: gridOption.borderWidth\r\n                        // type: this.option.splitArea.areaStyle.type,\r\n                    }\r\n                }));\r\n                this.zr.addShape(this.shapeList[0]);\r\n            }\r\n        }\r\n    };\r\n    \r\n    zrUtil.inherits(Grid, Base);\r\n    \r\n    require('../component').define('grid', Grid);\r\n    \r\n    return Grid;\r\n});"
        },
        {
          "id": 60,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "index": 60,
          "index2": 55,
          "size": 47872,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "../component/dataZoom",
              "loc": "16:4-36"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "../component/dataZoom",
              "loc": "18:4-36"
            }
          ],
          "source": "/**\r\n * echarts组件：数据区域缩放\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n\r\n    // 图形依赖\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n    var PolygonShape = require('zrenderjs/shape/Polygon');\r\n    var IconShape = require('../util/shape/Icon');\r\n\r\n    var ecConfig = require('../config');\r\n    // 区域缩放控制器\r\n    ecConfig.dataZoom = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 4,                       // 二级层叠\r\n        show: false,\r\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\r\n                                   // 'horizontal' ¦ 'vertical'\r\n        // x: {number},            // 水平安放位置，默认为根据grid参数适配，可选为：\r\n                                   // {number}（x坐标，单位px）\r\n        // y: {number},            // 垂直安放位置，默认为根据grid参数适配，可选为：\r\n                                   // {number}（y坐标，单位px）\r\n        // width: {number},        // 指定宽度，横向布局时默认为根据grid参数适配\r\n        // height: {number},       // 指定高度，纵向布局时默认为根据grid参数适配\r\n        backgroundColor: 'rgba(0,0,0,0)',       // 背景颜色\r\n        dataBackgroundColor: '#eee',            // 数据背景颜色\r\n        fillerColor: 'rgba(144,197,237,0.2)',   // 填充颜色\r\n        handleColor: 'rgba(70,130,180,0.8)',    // 手柄颜色\r\n        handleSize: 8,\r\n        showDetail: true,\r\n        // xAxisIndex: [],         // 默认控制所有横向类目\r\n        // yAxisIndex: [],         // 默认控制所有横向类目\r\n        // start: 0,               // 默认为0\r\n        // end: 100,               // 默认为全部 100%\r\n        realtime: true\r\n        // zoomLock: false         // 是否锁定选择区域大小\r\n    };\r\n\r\n    var ecDate = require('../util/date');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 图表参数\r\n     * @param {Object} component 组件\r\n     */\r\n    function DataZoom(ecTheme, messageCenter, zr, option, myChart) {\r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        var self = this;\r\n        self._ondrift = function (dx, dy) {\r\n            return self.__ondrift(this, dx, dy);\r\n        };\r\n        self._ondragend = function () {\r\n            return self.__ondragend();\r\n        };\r\n\r\n        this._fillerSize = 30;       // 控件大小，水平布局为高，纵向布局为宽\r\n        // this._fillerShae;            // 填充\r\n        // this._startShape;            // 起始手柄\r\n        // this._endShape;              // 结束手柄\r\n        // this._startFrameShape;       // 起始特效边框\r\n        // this._endFrameShape;         // 结束特效边框\r\n        // this._syncTicket;\r\n        this._isSilence = false;\r\n        this._zoom = {};\r\n        // this._originalData;\r\n\r\n        this.option.dataZoom = this.reformOption(this.option.dataZoom);\r\n        this.zoomOption = this.option.dataZoom;\r\n        this._handleSize = this.zoomOption.handleSize;\r\n        if (!this.myChart.canvasSupported) {\r\n            // 不支持Canvas的强制关闭实时动画\r\n            this.zoomOption.realtime = false;\r\n        }\r\n\r\n        // 位置参数，通过计算所得x, y, width, height\r\n        this._location = this._getLocation();\r\n        // 缩放参数\r\n        this._zoom =  this._getZoom();\r\n        this._backupData();\r\n\r\n        if (this.option.dataZoom.show) {\r\n            this._buildShape();\r\n        }\r\n        this._syncData();\r\n    }\r\n\r\n    DataZoom.prototype = {\r\n        type : ecConfig.COMPONENT_TYPE_DATAZOOM,\r\n        _buildShape : function () {\r\n            this._buildBackground();\r\n            this._buildFiller();\r\n            this._buildHandle();\r\n            this._buildFrame();\r\n\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                this.zr.addShape(this.shapeList[i]);\r\n            }\r\n            this._syncFrameShape();\r\n        },\r\n\r\n        /**\r\n         * 根据选项计算实体的位置坐标\r\n         */\r\n        _getLocation : function () {\r\n            var x;\r\n            var y;\r\n            var width;\r\n            var height;\r\n            var grid = this.component.grid;\r\n\r\n            // 不指定则根据grid适配\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                // 水平布局\r\n                width = this.zoomOption.width || grid.getWidth();\r\n                height = this.zoomOption.height || this._fillerSize;\r\n                x = this.zoomOption.x != null ? this.zoomOption.x : grid.getX();\r\n                y = this.zoomOption.y != null ? this.zoomOption.y : (this.zr.getHeight() - height - 2);\r\n            }\r\n            else {\r\n                // 垂直布局\r\n                width = this.zoomOption.width || this._fillerSize;\r\n                height = this.zoomOption.height || grid.getHeight();\r\n                x = this.zoomOption.x != null ? this.zoomOption.x : 2;\r\n                y = this.zoomOption.y != null ? this.zoomOption.y : grid.getY();\r\n            }\r\n\r\n            return {\r\n                x : x,\r\n                y : y,\r\n                width : width,\r\n                height : height\r\n            };\r\n        },\r\n\r\n        /**\r\n         * 计算缩放参数\r\n         * 修正单坐标轴只传对象为数组。\r\n         */\r\n        _getZoom : function () {\r\n            var series = this.option.series;\r\n            var xAxis = this.option.xAxis;\r\n            if (xAxis && !(xAxis instanceof Array)) {\r\n                xAxis = [xAxis];\r\n                this.option.xAxis = xAxis;\r\n            }\r\n            var yAxis = this.option.yAxis;\r\n            if (yAxis && !(yAxis instanceof Array)) {\r\n                yAxis = [yAxis];\r\n                this.option.yAxis = yAxis;\r\n            }\r\n\r\n            var zoomSeriesIndex = [];\r\n            var xAxisIndex;\r\n            var yAxisIndex;\r\n\r\n            var zOptIdx = this.zoomOption.xAxisIndex;\r\n            if (xAxis && zOptIdx == null) {\r\n                xAxisIndex = [];\r\n                for (var i = 0, l = xAxis.length; i < l; i++) {\r\n                    // 横纵默认为类目轴\r\n                    if (xAxis[i].type == 'category' || xAxis[i].type == null) {\r\n                        xAxisIndex.push(i);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (zOptIdx instanceof Array) {\r\n                    xAxisIndex = zOptIdx;\r\n                }\r\n                else if (zOptIdx != null) {\r\n                    xAxisIndex = [zOptIdx];\r\n                }\r\n                else {\r\n                    xAxisIndex = [];\r\n                }\r\n            }\r\n\r\n            zOptIdx = this.zoomOption.yAxisIndex;\r\n            if (yAxis && zOptIdx == null) {\r\n                yAxisIndex = [];\r\n                for (var i = 0, l = yAxis.length; i < l; i++) {\r\n                    if (yAxis[i].type == 'category') {\r\n                        yAxisIndex.push(i);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (zOptIdx instanceof Array) {\r\n                    yAxisIndex = zOptIdx;\r\n                }\r\n                else if (zOptIdx != null) {\r\n                    yAxisIndex = [zOptIdx];\r\n                }\r\n                else {\r\n                    yAxisIndex = [];\r\n                }\r\n            }\r\n\r\n            // 找到缩放控制的所有series\r\n            var serie;\r\n            for (var i = 0, l = series.length; i < l; i++) {\r\n                serie = series[i];\r\n                if (serie.type != ecConfig.CHART_TYPE_LINE\r\n                    && serie.type != ecConfig.CHART_TYPE_BAR\r\n                    && serie.type != ecConfig.CHART_TYPE_SCATTER\r\n                    && serie.type != ecConfig.CHART_TYPE_K\r\n                ) {\r\n                    continue;\r\n                }\r\n                for (var j = 0, k = xAxisIndex.length; j < k; j++) {\r\n                    if (xAxisIndex[j] == (serie.xAxisIndex || 0)) {\r\n                        zoomSeriesIndex.push(i);\r\n                        break;\r\n                    }\r\n                }\r\n                for (var j = 0, k = yAxisIndex.length; j < k; j++) {\r\n                    if (yAxisIndex[j] == (serie.yAxisIndex || 0)) {\r\n                        zoomSeriesIndex.push(i);\r\n                        break;\r\n                    }\r\n                }\r\n                // 不指定接管坐标轴，则散点图、双数值轴折线图柱形图都被纳入接管范围\r\n                if (this.zoomOption.xAxisIndex == null\r\n                    && this.zoomOption.yAxisIndex == null\r\n                    && serie.data\r\n                    && this.getDataFromOption(serie.data[0]) instanceof Array\r\n                    && (serie.type == ecConfig.CHART_TYPE_SCATTER\r\n                        || serie.type == ecConfig.CHART_TYPE_LINE\r\n                        || serie.type == ecConfig.CHART_TYPE_BAR)\r\n                ) {\r\n                    zoomSeriesIndex.push(i);\r\n                }\r\n            }\r\n\r\n            var start = this._zoom.start != null\r\n                        ? this._zoom.start\r\n                        : (this.zoomOption.start != null ? this.zoomOption.start : 0);\r\n            var end = this._zoom.end != null\r\n                      ? this._zoom.end\r\n                      : (this.zoomOption.end != null ? this.zoomOption.end : 100);\r\n\r\n            if (start > end) {\r\n                // 大小颠倒自动翻转\r\n                start = start + end;\r\n                end = start - end;\r\n                start = start - end;\r\n            }\r\n            var size = Math.round(\r\n                (end - start) / 100\r\n                * (\r\n                    this.zoomOption.orient == 'horizontal'\r\n                    ? this._location.width : this._location.height\r\n                )\r\n            );\r\n            return {\r\n                start : start,\r\n                end : end,\r\n                start2 : 0,\r\n                end2 : 100,\r\n                size : size,\r\n                xAxisIndex : xAxisIndex,\r\n                yAxisIndex : yAxisIndex,\r\n                seriesIndex : zoomSeriesIndex,\r\n                scatterMap : this._zoom.scatterMap || {}\r\n            };\r\n        },\r\n\r\n        _backupData : function () {\r\n            this._originalData = {\r\n                xAxis : {},\r\n                yAxis : {},\r\n                series : {}\r\n            };\r\n            var xAxis = this.option.xAxis;\r\n            var xAxisIndex = this._zoom.xAxisIndex;\r\n            for (var i = 0, l = xAxisIndex.length; i < l; i++) {\r\n                this._originalData.xAxis[xAxisIndex[i]] = xAxis[xAxisIndex[i]].data;\r\n            }\r\n\r\n            var yAxis = this.option.yAxis;\r\n            var yAxisIndex = this._zoom.yAxisIndex;\r\n            for (var i = 0, l = yAxisIndex.length; i < l; i++) {\r\n                this._originalData.yAxis[yAxisIndex[i]] = yAxis[yAxisIndex[i]].data;\r\n            }\r\n\r\n            var series = this.option.series;\r\n            var seriesIndex = this._zoom.seriesIndex;\r\n            var serie;\r\n            for (var i = 0, l = seriesIndex.length; i < l; i++) {\r\n                serie = series[seriesIndex[i]];\r\n                this._originalData.series[seriesIndex[i]] = serie.data;\r\n                if (serie.data\r\n                    && this.getDataFromOption(serie.data[0]) instanceof Array\r\n                    && (serie.type == ecConfig.CHART_TYPE_SCATTER\r\n                        || serie.type == ecConfig.CHART_TYPE_LINE\r\n                        || serie.type == ecConfig.CHART_TYPE_BAR)\r\n                ) {\r\n                    this._backupScale();\r\n                    this._calculScatterMap(seriesIndex[i]);\r\n                }\r\n            }\r\n        },\r\n\r\n        // 不止是scatter，双数值轴也使用此方法\r\n        _calculScatterMap : function (seriesIndex) {\r\n            this._zoom.scatterMap = this._zoom.scatterMap || {};\r\n            this._zoom.scatterMap[seriesIndex] = this._zoom.scatterMap[seriesIndex] || {};\r\n            var componentLibrary = require('../component');\r\n            // x轴极值\r\n            var Axis = componentLibrary.get('axis');\r\n            var axisOption = zrUtil.clone(this.option.xAxis);\r\n            if (axisOption[0].type == 'category') {\r\n                axisOption[0].type = 'value';\r\n            }\r\n            // axisOption[0].scale = true;\r\n            // axisOption[0].boundary = [0, 0];\r\n            if (axisOption[1] && axisOption[1].type == 'category') {\r\n                axisOption[1].type = 'value';\r\n            }\r\n\r\n            var vAxis = new Axis(\r\n                this.ecTheme,\r\n                null,   // messageCenter\r\n                false,  // this.zr\r\n                {\r\n                    xAxis: axisOption,\r\n                    series : this.option.series\r\n                },\r\n                this,\r\n                'xAxis'\r\n            );\r\n            var axisIndex = this.option.series[seriesIndex].xAxisIndex || 0;\r\n            this._zoom.scatterMap[seriesIndex].x = vAxis.getAxis(axisIndex).getExtremum();\r\n            vAxis.dispose();\r\n\r\n            // y轴极值\r\n            axisOption = zrUtil.clone(this.option.yAxis);\r\n            if (axisOption[0].type == 'category') {\r\n                axisOption[0].type = 'value';\r\n            }\r\n            // axisOption[0].scale = true;\r\n            // axisOption[1].boundary = [0, 0];\r\n            if (axisOption[1] && axisOption[1].type == 'category') {\r\n                axisOption[1].type = 'value';\r\n            }\r\n            vAxis = new Axis(\r\n                this.ecTheme,\r\n                null,   // messageCenter\r\n                false,  // this.zr\r\n                {\r\n                    yAxis: axisOption,\r\n                    series : this.option.series\r\n                },\r\n                this,\r\n                'yAxis'\r\n            );\r\n            axisIndex = this.option.series[seriesIndex].yAxisIndex || 0;\r\n            this._zoom.scatterMap[seriesIndex].y = vAxis.getAxis(axisIndex).getExtremum();\r\n            vAxis.dispose();\r\n            // console.log(this._zoom.scatterMap);\r\n        },\r\n\r\n        _buildBackground : function () {\r\n            var width = this._location.width;\r\n            var height = this._location.height;\r\n\r\n            // 背景\r\n            this.shapeList.push(new RectangleShape({\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                hoverable :false,\r\n                style : {\r\n                    x : this._location.x,\r\n                    y : this._location.y,\r\n                    width : width,\r\n                    height : height,\r\n                    color : this.zoomOption.backgroundColor\r\n                }\r\n            }));\r\n\r\n            // 数据阴影\r\n            var maxLength = 0;\r\n            var xAxis = this._originalData.xAxis;\r\n            var xAxisIndex = this._zoom.xAxisIndex;\r\n            for (var i = 0, l = xAxisIndex.length; i < l; i++) {\r\n                maxLength = Math.max(\r\n                    maxLength, xAxis[xAxisIndex[i]].length\r\n                );\r\n            }\r\n            var yAxis = this._originalData.yAxis;\r\n            var yAxisIndex = this._zoom.yAxisIndex;\r\n            for (var i = 0, l = yAxisIndex.length; i < l; i++) {\r\n                maxLength = Math.max(\r\n                    maxLength, yAxis[yAxisIndex[i]].length\r\n                );\r\n            }\r\n\r\n            var seriesIndex = this._zoom.seriesIndex[0];\r\n            var data = this._originalData.series[seriesIndex];\r\n            var maxValue = Number.MIN_VALUE;\r\n            var minValue = Number.MAX_VALUE;\r\n            var value;\r\n            for (var i = 0, l = data.length; i < l; i++) {\r\n                value = this.getDataFromOption(data[i], 0);\r\n                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {\r\n                    value = value[1];   // 收盘价\r\n                }\r\n                if (isNaN(value)) {\r\n                    value = 0;\r\n                }\r\n                maxValue = Math.max(maxValue, value);\r\n                minValue = Math.min(minValue, value);\r\n            }\r\n            var valueRange = maxValue - minValue;\r\n\r\n            var pointList = [];\r\n            var x = width / (maxLength - (maxLength > 1 ? 1 : 0));\r\n            var y = height / (maxLength - (maxLength > 1 ? 1 : 0));\r\n            var step = 1;\r\n            if (this.zoomOption.orient == 'horizontal' && x < 1) {\r\n                step = Math.floor(maxLength * 3 / width);\r\n            }\r\n            else if (this.zoomOption.orient == 'vertical' && y < 1){\r\n                step = Math.floor(maxLength * 3 / height);\r\n            }\r\n\r\n            for (var i = 0, l = maxLength; i < l; i += step) {\r\n                value = this.getDataFromOption(data[i], 0);\r\n                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {\r\n                    value = value[1];   // 收盘价\r\n                }\r\n                if (isNaN(value)) {\r\n                    value = 0;\r\n                }\r\n                if (this.zoomOption.orient == 'horizontal') {\r\n                    pointList.push([\r\n                        this._location.x + x * i,\r\n                        this._location.y + height - 1 - Math.round(\r\n                            (value - minValue) / valueRange * (height - 10)\r\n                        )\r\n                    ]);\r\n                }\r\n                else {\r\n                    pointList.push([\r\n                        this._location.x + 1 + Math.round(\r\n                            (value - minValue) / valueRange * (width - 10)\r\n                        ),\r\n                        this._location.y + y * (l - i - 1)\r\n                    ]);\r\n                }\r\n            }\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                pointList.push([\r\n                    this._location.x + width,\r\n                    this._location.y + height\r\n                ]);\r\n                pointList.push([\r\n                    this._location.x, this._location.y + height\r\n                ]);\r\n            }\r\n            else {\r\n                pointList.push([\r\n                    this._location.x, this._location.y\r\n                ]);\r\n                pointList.push([\r\n                    this._location.x, this._location.y + height\r\n                ]);\r\n            }\r\n\r\n            this.shapeList.push(new PolygonShape({\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                style : {\r\n                    pointList : pointList,\r\n                    color : this.zoomOption.dataBackgroundColor\r\n                },\r\n                hoverable : false\r\n            }));\r\n        },\r\n\r\n        /**\r\n         * 构建填充物\r\n         */\r\n        _buildFiller : function () {\r\n            this._fillerShae = {\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                draggable : true,\r\n                ondrift : this._ondrift,\r\n                ondragend : this._ondragend,\r\n                _type : 'filler'\r\n            };\r\n\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                // 横向\r\n                this._fillerShae.style = {\r\n                    x : this._location.x\r\n                        + Math.round(this._zoom.start / 100 * this._location.width)\r\n                        + this._handleSize,\r\n                    y : this._location.y,\r\n                    width : this._zoom.size - this._handleSize * 2,\r\n                    height : this._location.height,\r\n                    color : this.zoomOption.fillerColor,\r\n                    // strokeColor : '#fff', // this.zoomOption.handleColor,\r\n                    // lineWidth: 2,\r\n                    text : ':::',\r\n                    textPosition : 'inside'\r\n                };\r\n            }\r\n            else {\r\n                // 纵向\r\n                this._fillerShae.style ={\r\n                    x : this._location.x,\r\n                    y : this._location.y\r\n                        + Math.round(this._zoom.start / 100 * this._location.height)\r\n                        + this._handleSize,\r\n                    width :  this._location.width,\r\n                    height : this._zoom.size - this._handleSize * 2,\r\n                    color : this.zoomOption.fillerColor,\r\n                    // strokeColor : '#fff', // this.zoomOption.handleColor,\r\n                    // lineWidth: 2,\r\n                    text : '::',\r\n                    textPosition : 'inside'\r\n                };\r\n            }\r\n\r\n            this._fillerShae.highlightStyle = {\r\n                brushType: 'fill',\r\n                color : 'rgba(0,0,0,0)'\r\n                /*\r\n                color : require('zrenderjs/tool/color').alpha(\r\n                            this._fillerShae.style.color, 0\r\n                        )\r\n                */\r\n            };\r\n            this._fillerShae = new RectangleShape(this._fillerShae);\r\n            this.shapeList.push(this._fillerShae);\r\n        },\r\n\r\n        /**\r\n         * 构建拖拽手柄\r\n         */\r\n        _buildHandle : function () {\r\n            var detail = this.zoomOption.showDetail ? this._getDetail() : {start: '',end: ''};\r\n            this._startShape = {\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                draggable : true,\r\n                style : {\r\n                    iconType: 'rectangle',\r\n                    x: this._location.x,\r\n                    y: this._location.y,\r\n                    width: this._handleSize,\r\n                    height: this._handleSize,\r\n                    color: this.zoomOption.handleColor,\r\n                    text: '=',\r\n                    textPosition: 'inside'\r\n                },\r\n                highlightStyle: {\r\n                    text: detail.start,\r\n                    brushType: 'fill',\r\n                    textPosition: 'left'\r\n                },\r\n                ondrift: this._ondrift,\r\n                ondragend: this._ondragend\r\n            };\r\n\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                this._startShape.style.height = this._location.height;\r\n                this._endShape = zrUtil.clone(this._startShape);\r\n\r\n                this._startShape.style.x = this._fillerShae.style.x - this._handleSize,\r\n                this._endShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;\r\n                this._endShape.highlightStyle.text = detail.end;\r\n                this._endShape.highlightStyle.textPosition = 'right';\r\n            }\r\n            else {\r\n                this._startShape.style.width = this._location.width;\r\n                this._endShape = zrUtil.clone(this._startShape);\r\n\r\n                this._startShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;\r\n                this._startShape.highlightStyle.textPosition = 'bottom';\r\n\r\n                this._endShape.style.y = this._fillerShae.style.y - this._handleSize;\r\n                this._endShape.highlightStyle.text = detail.end;\r\n                this._endShape.highlightStyle.textPosition = 'top';\r\n            }\r\n            this._startShape = new IconShape(this._startShape);\r\n            this._endShape = new IconShape(this._endShape);\r\n            this.shapeList.push(this._startShape);\r\n            this.shapeList.push(this._endShape);\r\n        },\r\n\r\n        /**\r\n         * 构建特效边框\r\n         */\r\n        _buildFrame : function () {\r\n            // 特效框线，亚像素优化\r\n            var x = this.subPixelOptimize(this._location.x, 1);\r\n            var y = this.subPixelOptimize(this._location.y, 1);\r\n            this._startFrameShape = {\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                hoverable :false,\r\n                style : {\r\n                    x : x,\r\n                    y : y,\r\n                    width : this._location.width - (x > this._location.x ? 1 : 0),\r\n                    height : this._location.height - (y > this._location.y ? 1 : 0),\r\n                    lineWidth: 1,\r\n                    brushType: 'stroke',\r\n                    strokeColor : this.zoomOption.handleColor\r\n                }\r\n            };\r\n            this._endFrameShape = zrUtil.clone(this._startFrameShape);\r\n\r\n            this._startFrameShape = new RectangleShape(this._startFrameShape);\r\n            this._endFrameShape = new RectangleShape(this._endFrameShape);\r\n            this.shapeList.push(this._startFrameShape);\r\n            this.shapeList.push(this._endFrameShape);\r\n            return;\r\n        },\r\n\r\n        _syncHandleShape : function () {\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                this._startShape.style.x = this._fillerShae.style.x - this._handleSize;\r\n                this._endShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;\r\n\r\n                this._zoom.start = (\r\n                    this._startShape.style.x - this._location.x\r\n                ) / this._location.width * 100;\r\n                this._zoom.end = (\r\n                    this._endShape.style.x + this._handleSize - this._location.x\r\n                ) / this._location.width * 100;\r\n            }\r\n            else {\r\n                this._startShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;\r\n                this._endShape.style.y = this._fillerShae.style.y - this._handleSize;\r\n\r\n                this._zoom.start = (\r\n                    this._location.y + this._location.height\r\n                    - this._startShape.style.y\r\n                ) / this._location.height * 100;\r\n                this._zoom.end = (\r\n                    this._location.y + this._location.height\r\n                    - this._endShape.style.y - this._handleSize\r\n                ) / this._location.height * 100;\r\n            }\r\n            this.zr.modShape(this._startShape.id);\r\n            this.zr.modShape(this._endShape.id);\r\n\r\n            // 同步边框\r\n            this._syncFrameShape();\r\n\r\n            this.zr.refreshNextFrame();\r\n        },\r\n\r\n        _syncFillerShape : function () {\r\n            var a;\r\n            var b;\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                a = this._startShape.style.x;\r\n                b = this._endShape.style.x;\r\n                this._fillerShae.style.x = Math.min(a, b) + this._handleSize;\r\n                this._fillerShae.style.width = Math.abs(a - b) - this._handleSize;\r\n                this._zoom.start = (\r\n                    Math.min(a, b) - this._location.x\r\n                ) / this._location.width * 100;\r\n                this._zoom.end = (\r\n                    Math.max(a, b) + this._handleSize - this._location.x\r\n                ) / this._location.width * 100;\r\n            }\r\n            else {\r\n                a = this._startShape.style.y;\r\n                b = this._endShape.style.y;\r\n                this._fillerShae.style.y = Math.min(a, b) + this._handleSize;\r\n                this._fillerShae.style.height = Math.abs(a - b) - this._handleSize;\r\n                this._zoom.start = (\r\n                    this._location.y + this._location.height - Math.max(a, b)\r\n                ) / this._location.height * 100;\r\n                this._zoom.end = (\r\n                    this._location.y + this._location.height - Math.min(a, b) - this._handleSize\r\n                ) / this._location.height * 100;\r\n            }\r\n\r\n            this.zr.modShape(this._fillerShae.id);\r\n\r\n            // 同步边框\r\n            this._syncFrameShape();\r\n\r\n            this.zr.refreshNextFrame();\r\n        },\r\n\r\n        _syncFrameShape : function () {\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                this._startFrameShape.style.width =\r\n                    this._fillerShae.style.x - this._location.x;\r\n                this._endFrameShape.style.x =\r\n                    this._fillerShae.style.x + this._fillerShae.style.width;\r\n                this._endFrameShape.style.width =\r\n                    this._location.x + this._location.width - this._endFrameShape.style.x;\r\n            }\r\n            else {\r\n                this._startFrameShape.style.y =\r\n                    this._fillerShae.style.y + this._fillerShae.style.height;\r\n                this._startFrameShape.style.height =\r\n                    this._location.y + this._location.height - this._startFrameShape.style.y;\r\n                this._endFrameShape.style.height =\r\n                    this._fillerShae.style.y - this._location.y;\r\n            }\r\n\r\n            this.zr.modShape(this._startFrameShape.id);\r\n            this.zr.modShape(this._endFrameShape.id);\r\n        },\r\n\r\n        _syncShape : function () {\r\n            if (!this.zoomOption.show) {\r\n                // 没有伸缩控件\r\n                return;\r\n            }\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                this._startShape.style.x = this._location.x\r\n                                           + this._zoom.start / 100 * this._location.width;\r\n                this._endShape.style.x   = this._location.x\r\n                                           + this._zoom.end / 100 * this._location.width\r\n                                           - this._handleSize;\r\n\r\n                this._fillerShae.style.x     = this._startShape.style.x + this._handleSize;\r\n                this._fillerShae.style.width = this._endShape.style.x\r\n                                               - this._startShape.style.x\r\n                                               - this._handleSize;\r\n            }\r\n            else {\r\n                this._startShape.style.y = this._location.y + this._location.height\r\n                                           - this._zoom.start / 100 * this._location.height;\r\n                this._endShape.style.y   = this._location.y + this._location.height\r\n                                           - this._zoom.end / 100 * this._location.height\r\n                                           - this._handleSize;\r\n\r\n                this._fillerShae.style.y      = this._endShape.style.y + this._handleSize;\r\n                this._fillerShae.style.height = this._startShape.style.y\r\n                                                - this._endShape.style.y\r\n                                                - this._handleSize;\r\n            }\r\n\r\n            this.zr.modShape(this._startShape.id);\r\n            this.zr.modShape(this._endShape.id);\r\n            this.zr.modShape(this._fillerShae.id);\r\n            // 同步边框\r\n            this._syncFrameShape();\r\n            this.zr.refresh();\r\n        },\r\n\r\n         _syncData : function (dispatchNow) {\r\n            var target;\r\n            var start;\r\n            var end;\r\n            var length;\r\n            var data;\r\n\r\n            for (var key in this._originalData) {\r\n                target = this._originalData[key];\r\n                for (var idx in target) {\r\n                    data = target[idx];\r\n                    if (data == null) {\r\n                        continue;\r\n                    }\r\n                    length = data.length;\r\n                    start = Math.floor(this._zoom.start / 100 * length);\r\n                    end = Math.ceil(this._zoom.end / 100 * length);\r\n\r\n                    if (!(this.getDataFromOption(data[0]) instanceof Array)\r\n                        || this.option[key][idx].type == ecConfig.CHART_TYPE_K\r\n                    ) {\r\n                        this.option[key][idx].data = data.slice(start, end);\r\n                    }\r\n                    else {\r\n                        // 散点图，双数值轴折线图柱形图特殊处理\r\n                        // axis.data[0]不会是Array，所以axis的情况不会走进这个分支\r\n                        this._setScale();\r\n                        this.option[key][idx].data = this._synScatterData(idx, data);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!this._isSilence && (this.zoomOption.realtime || dispatchNow)) {\r\n                this.messageCenter.dispatch(\r\n                    ecConfig.EVENT.DATA_ZOOM,\r\n                    null,\r\n                    {zoom: this._zoom},\r\n                    this.myChart\r\n                );\r\n            }\r\n\r\n            //this.zoomOption.start = this._zoom.start;\r\n            //this.zoomOption.end = this._zoom.end;\r\n        },\r\n\r\n        _synScatterData : function (seriesIndex, data) {\r\n            if (this._zoom.start === 0\r\n                && this._zoom.end == 100\r\n                && this._zoom.start2 === 0\r\n                && this._zoom.end2 == 100\r\n            ) {\r\n                return data;\r\n            }\r\n            var newData = [];\r\n            var scale = this._zoom.scatterMap[seriesIndex];\r\n            var total;\r\n            var xStart;\r\n            var xEnd;\r\n            var yStart;\r\n            var yEnd;\r\n\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                total = scale.x.max - scale.x.min;\r\n                xStart = this._zoom.start / 100 * total + scale.x.min;\r\n                xEnd = this._zoom.end / 100 * total + scale.x.min;\r\n\r\n                total = scale.y.max - scale.y.min;\r\n                yStart = this._zoom.start2 / 100 * total + scale.y.min;\r\n                yEnd = this._zoom.end2 / 100 * total + scale.y.min;\r\n            }\r\n            else {\r\n                total = scale.x.max - scale.x.min;\r\n                xStart = this._zoom.start2 / 100 * total + scale.x.min;\r\n                xEnd = this._zoom.end2 / 100 * total + scale.x.min;\r\n\r\n                total = scale.y.max - scale.y.min;\r\n                yStart = this._zoom.start / 100 * total + scale.y.min;\r\n                yEnd = this._zoom.end / 100 * total + scale.y.min;\r\n            }\r\n\r\n            var dataMappingMethods;\r\n            if (dataMappingMethods = scale.x.dataMappingMethods) {\r\n                xStart = dataMappingMethods.coord2Value(xStart);\r\n                xEnd = dataMappingMethods.coord2Value(xEnd);\r\n            }\r\n            if (dataMappingMethods = scale.y.dataMappingMethods) {\r\n                yStart = dataMappingMethods.coord2Value(yStart);\r\n                yEnd = dataMappingMethods.coord2Value(yEnd);\r\n            }\r\n\r\n            // console.log(xStart,xEnd,yStart,yEnd);\r\n\r\n            var value;\r\n            for (var i = 0, l = data.length; i < l; i++) {\r\n                value = data[i].value || data[i];\r\n                if (value[0] >= xStart\r\n                    && value[0] <= xEnd\r\n                    && value[1] >= yStart\r\n                    && value[1] <= yEnd\r\n                ) {\r\n                    newData.push(data[i]);\r\n                }\r\n            }\r\n\r\n            return newData;\r\n        },\r\n\r\n        /**\r\n         * 发生缩放后修改axis的scale\r\n         */\r\n        _setScale: function() {\r\n            var needScale = this._zoom.start !== 0\r\n                            || this._zoom.end !== 100\r\n                            || this._zoom.start2 !== 0\r\n                            || this._zoom.end2 !== 100;\r\n            var axis = {\r\n                xAxis : this.option.xAxis,\r\n                yAxis : this.option.yAxis\r\n            };\r\n            for (var key in axis) {\r\n                for (var i = 0, l = axis[key].length; i < l; i++) {\r\n                    axis[key][i].scale = needScale || axis[key][i]._scale;\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 备份可能存在的scale设置\r\n         */\r\n        _backupScale: function() {\r\n            var axis = {\r\n                xAxis : this.option.xAxis,\r\n                yAxis : this.option.yAxis\r\n            };\r\n            for (var key in axis) {\r\n                for (var i = 0, l = axis[key].length; i < l; i++) {\r\n                    axis[key][i]._scale = axis[key][i].scale;\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 获取当前定位\r\n         */\r\n        _getDetail : function () {\r\n            var key = ['xAxis', 'yAxis'];\r\n            for (var i = 0, l = key.length; i < l; i++) {\r\n                var target = this._originalData[key[i]];\r\n                for (var idx in target) {\r\n                    var data = target[idx];\r\n                    if (data == null) {\r\n                        continue;\r\n                    }\r\n                    var length = data.length;\r\n                    var start = Math.floor(this._zoom.start / 100 * length);\r\n                    var end = Math.ceil(this._zoom.end / 100 * length);\r\n                    end -= end > 0 ? 1 : 0;\r\n                    return {\r\n                        start : this.getDataFromOption(data[start]),\r\n                        end : this.getDataFromOption(data[end])\r\n                    };\r\n                }\r\n            }\r\n\r\n            key = this.zoomOption.orient == 'horizontal' ? 'xAxis' : 'yAxis';\r\n            var seriesIndex = this._zoom.seriesIndex[0];\r\n            var axisIndex = this.option.series[seriesIndex][key + 'Index'] || 0;\r\n            var axisType = this.option[key][axisIndex].type;\r\n            var min = this._zoom.scatterMap[seriesIndex][key.charAt(0)].min;\r\n            var max = this._zoom.scatterMap[seriesIndex][key.charAt(0)].max;\r\n            var gap = max - min;\r\n\r\n            if (axisType == 'value') {\r\n                return {\r\n                    start : min + gap * this._zoom.start / 100,\r\n                    end : min + gap * this._zoom.end / 100\r\n                };\r\n            }\r\n            else if (axisType == 'time') {\r\n                // 最优解\r\n                max = min + gap * this._zoom.end / 100;\r\n                min = min + gap * this._zoom.start / 100;\r\n                var formatter = ecDate.getAutoFormatter(min, max).formatter;\r\n                return {\r\n                    start : ecDate.format(formatter, min),\r\n                    end : ecDate.format(formatter, max)\r\n                };\r\n            }\r\n\r\n            return {\r\n                start : '',\r\n                end : ''\r\n            };\r\n        },\r\n\r\n        /**\r\n         * 拖拽范围控制\r\n         */\r\n        __ondrift : function (shape, dx, dy) {\r\n            if (this.zoomOption.zoomLock) {\r\n                // zoomLock时把handle转成filler的拖拽\r\n                shape = this._fillerShae;\r\n            }\r\n\r\n            var detailSize = shape._type == 'filler' ? this._handleSize : 0;\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                if (shape.style.x + dx - detailSize <= this._location.x) {\r\n                    shape.style.x = this._location.x + detailSize;\r\n                }\r\n                else if (shape.style.x + dx + shape.style.width + detailSize\r\n                         >= this._location.x + this._location.width\r\n                ) {\r\n                    shape.style.x = this._location.x + this._location.width\r\n                                - shape.style.width - detailSize;\r\n                }\r\n                else {\r\n                    shape.style.x += dx;\r\n                }\r\n            }\r\n            else {\r\n                if (shape.style.y + dy - detailSize <= this._location.y) {\r\n                    shape.style.y = this._location.y + detailSize;\r\n                }\r\n                else if (shape.style.y + dy + shape.style.height + detailSize\r\n                         >= this._location.y + this._location.height\r\n                ) {\r\n                    shape.style.y = this._location.y + this._location.height\r\n                                - shape.style.height - detailSize;\r\n                }\r\n                else {\r\n                    shape.style.y += dy;\r\n                }\r\n            }\r\n\r\n            if (shape._type == 'filler') {\r\n                this._syncHandleShape();\r\n            }\r\n            else {\r\n                this._syncFillerShape();\r\n            }\r\n\r\n            if (this.zoomOption.realtime) {\r\n                this._syncData();\r\n            }\r\n\r\n            if (this.zoomOption.showDetail) {\r\n                var detail = this._getDetail();\r\n                this._startShape.style.text = this._startShape.highlightStyle.text = detail.start;\r\n                this._endShape.style.text = this._endShape.highlightStyle.text = detail.end;\r\n                this._startShape.style.textPosition = this._startShape.highlightStyle.textPosition;\r\n                this._endShape.style.textPosition = this._endShape.highlightStyle.textPosition;\r\n            }\r\n            return true;\r\n        },\r\n\r\n        __ondragend : function () {\r\n            if (this.zoomOption.showDetail) {\r\n                this._startShape.style.text = this._endShape.style.text = '=';\r\n                this._startShape.style.textPosition = this._endShape.style.textPosition = 'inside';\r\n                this.zr.modShape(this._startShape.id);\r\n                this.zr.modShape(this._endShape.id);\r\n                this.zr.refreshNextFrame();\r\n            }\r\n            this.isDragend = true;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽出去\r\n         */\r\n        ondragend : function (param, status) {\r\n            if (!this.isDragend || !param.target) {\r\n                // 没有在当前实例上发生拖拽行为则直接返回\r\n                return;\r\n            }\r\n\r\n            !this.zoomOption.realtime && this._syncData();\r\n\r\n            // 别status = {}赋值啊！！\r\n            status.dragOut = true;\r\n            status.dragIn = true;\r\n            if (!this._isSilence && !this.zoomOption.realtime) {\r\n                this.messageCenter.dispatch(\r\n                    ecConfig.EVENT.DATA_ZOOM,\r\n                    null,\r\n                    {zoom: this._zoom},\r\n                    this.myChart\r\n                );\r\n            }\r\n            status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍\r\n            // 处理完拖拽事件后复位\r\n            this.isDragend = false;\r\n\r\n            return;\r\n        },\r\n\r\n        ondataZoom : function (param, status) {\r\n            status.needRefresh = true;\r\n            return;\r\n        },\r\n\r\n        absoluteZoom : function (param) {\r\n            this._zoom.start = param.start;\r\n            this._zoom.end = param.end;\r\n            this._zoom.start2 = param.start2;\r\n            this._zoom.end2 = param.end2;\r\n            this._syncShape();\r\n            this._syncData(true);\r\n            return;\r\n        },\r\n\r\n        rectZoom : function (param) {\r\n            if (!param) {\r\n                // 重置拖拽\r\n                //this.zoomOption.start =\r\n                //this.zoomOption.start2 =\r\n                this._zoom.start = this._zoom.start2 = 0;\r\n\r\n                //this.zoomOption.end =\r\n                //this.zoomOption.end2 =\r\n                this._zoom.end = this._zoom.end2 = 100;\r\n\r\n                this._syncShape();\r\n                this._syncData(true);\r\n                return this._zoom;\r\n            }\r\n            var gridArea = this.component.grid.getArea();\r\n            var rect = {\r\n                x : param.x,\r\n                y : param.y,\r\n                width : param.width,\r\n                height : param.height\r\n            };\r\n            // 修正方向框选\r\n            if (rect.width < 0) {\r\n                rect.x += rect.width;\r\n                rect.width = -rect.width;\r\n            }\r\n            if (rect.height < 0) {\r\n                rect.y += rect.height;\r\n                rect.height = -rect.height;\r\n            }\r\n            // console.log(rect,this._zoom);\r\n\r\n            // 剔除无效缩放\r\n            if (rect.x > gridArea.x + gridArea.width || rect.y > gridArea.y + gridArea.height) {\r\n                return false; // 无效缩放\r\n            }\r\n\r\n            // 修正框选超出\r\n            if (rect.x < gridArea.x) {\r\n                rect.x = gridArea.x;\r\n            }\r\n            if (rect.x + rect.width > gridArea.x + gridArea.width) {\r\n                rect.width = gridArea.x + gridArea.width - rect.x;\r\n            }\r\n            if (rect.y + rect.height > gridArea.y + gridArea.height) {\r\n                rect.height = gridArea.y + gridArea.height - rect.y;\r\n            }\r\n\r\n            var total;\r\n            var sdx = (rect.x - gridArea.x) / gridArea.width;\r\n            var edx = 1 - (rect.x + rect.width - gridArea.x) / gridArea.width;\r\n            var sdy = 1 - (rect.y + rect.height - gridArea.y) / gridArea.height;\r\n            var edy = (rect.y - gridArea.y) / gridArea.height;\r\n            // console.log('this',sdy,edy,this._zoom.start,this._zoom.end)\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                total = this._zoom.end - this._zoom.start;\r\n                this._zoom.start += total * sdx;\r\n                this._zoom.end -= total * edx;\r\n\r\n                total = this._zoom.end2 - this._zoom.start2;\r\n                this._zoom.start2 += total * sdy;\r\n                this._zoom.end2 -= total * edy;\r\n            }\r\n            else {\r\n                total = this._zoom.end - this._zoom.start;\r\n                this._zoom.start += total * sdy;\r\n                this._zoom.end -= total * edy;\r\n\r\n                total = this._zoom.end2 - this._zoom.start2;\r\n                this._zoom.start2 += total * sdx;\r\n                this._zoom.end2 -= total * edx;\r\n            }\r\n            //console.log(this._zoom.start,this._zoom.end,this._zoom.start2,this._zoom.end2)\r\n            //this.zoomOption.start = this._zoom.start;\r\n            //this.zoomOption.end = this._zoom.end;\r\n            //this.zoomOption.start2 = this._zoom.start2;\r\n            //this.zoomOption.end2 = this._zoom.end2;\r\n            //console.log(rect,gridArea,this._zoom,total)\r\n            this._syncShape();\r\n            this._syncData(true);\r\n            return this._zoom;\r\n        },\r\n\r\n        syncBackupData : function (curOption) {\r\n            var start;\r\n            var target = this._originalData['series'];\r\n            var curSeries = curOption.series;\r\n            var curData;\r\n            for (var i = 0, l = curSeries.length; i < l; i++) {\r\n                curData = curSeries[i].data || curSeries[i].eventList;\r\n                if (target[i]) {\r\n                    // dataZoom接管的\r\n                    start = Math.floor(this._zoom.start / 100 * target[i].length);\r\n                }\r\n                else {\r\n                    // 非dataZoom接管\r\n                    start = 0;\r\n                }\r\n                for (var j = 0, k = curData.length; j < k; j++) {\r\n                    //optionBackup.series[i].data[j + start] = curData[j];\r\n                    if (target[i]) {\r\n                        // 同步内部备份\r\n                        target[i][j + start] = curData[j];\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        syncOption : function(magicOption) {\r\n            this.silence(true);\r\n            this.option = magicOption;\r\n            this.option.dataZoom = this.reformOption(this.option.dataZoom);\r\n            this.zoomOption = this.option.dataZoom;\r\n            if (!this.myChart.canvasSupported) {\r\n                // 不支持Canvas的强制关闭实时动画\r\n                this.zoomOption.realtime = false;\r\n            }\r\n\r\n            this.clear();\r\n            // 位置参数，通过计算所得x, y, width, height\r\n            this._location = this._getLocation();\r\n            // 缩放参数\r\n            this._zoom =  this._getZoom();\r\n\r\n            this._backupData();\r\n            if (this.option.dataZoom && this.option.dataZoom.show) {\r\n                this._buildShape();\r\n            }\r\n            this._syncData();\r\n\r\n            this.silence(false);\r\n        },\r\n\r\n        silence : function (s) {\r\n            this._isSilence = s;\r\n        },\r\n\r\n        getRealDataIndex : function (sIdx, dIdx) {\r\n            if (!this._originalData || (this._zoom.start === 0 && this._zoom.end == 100)) {\r\n                return dIdx;\r\n            }\r\n            var sreies = this._originalData.series;\r\n            if (sreies[sIdx]) {\r\n                return Math.floor(this._zoom.start / 100 * sreies[sIdx].length) + dIdx;\r\n            }\r\n            return -1;\r\n        },\r\n\r\n        /**\r\n         * 避免dataZoom带来两次refresh，不设refresh接口，resize重复一下buildshape逻辑\r\n         */\r\n        resize : function () {\r\n            this.clear();\r\n\r\n            // 位置参数，通过计算所得x, y, width, height\r\n            this._location = this._getLocation();\r\n            // 缩放参数\r\n            this._zoom =  this._getZoom();\r\n\r\n            if (this.option.dataZoom.show) {\r\n                this._buildShape();\r\n            }\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(DataZoom, Base);\r\n\r\n    require('../component').define('dataZoom', DataZoom);\r\n\r\n    return DataZoom;\r\n});\r\n"
        },
        {
          "id": 61,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart.js",
          "index": 61,
          "index2": 56,
          "size": 644,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 4,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "../chart",
              "loc": "950:4-23"
            },
            {
              "moduleId": 64,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "../chart",
              "loc": "248:4-23"
            },
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "../chart",
              "loc": "1055:4-23"
            }
          ],
          "source": "/**\r\n * echart图表库\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n */\r\ndefine(function (/*require*/) {     //chart\r\n    var self = {};\r\n\r\n    var _chartLibrary = {};         //echart图表库\r\n\r\n    /**\r\n     * 定义图形实现\r\n     * @param {Object} name\r\n     * @param {Object} clazz 图形实现\r\n     */\r\n    self.define = function (name, clazz) {\r\n        _chartLibrary[name] = clazz;\r\n        return self;\r\n    };\r\n\r\n    /**\r\n     * 获取图形实现\r\n     * @param {Object} name\r\n     */\r\n    self.get = function (name) {\r\n        return _chartLibrary[name];\r\n    };\r\n\r\n    return self;\r\n});"
        },
        {
          "id": 62,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "name": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "index": 62,
          "index2": 59,
          "size": 281,
          "cacheable": true,
          "built": true,
          "optional": true,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
              "type": "context element",
              "userRequest": "./base.js"
            }
          ],
          "source": "var cbs = [], \n\tdata;\nmodule.exports = function(cb) {\n\tif(cbs) cbs.push(cb);\n\telse cb(data);\n}\nrequire.ensure([], function(require) {\n\tdata = require(\"!!./base.js\");\n\tvar callbacks = cbs;\n\tcbs = null;\n\tfor(var i = 0, l = callbacks.length; i < l; i++) {\n\t\tcallbacks[i](data);\n\t}\n});"
        },
        {
          "id": 63,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "name": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "index": 63,
          "index2": 62,
          "size": 283,
          "cacheable": true,
          "built": true,
          "optional": true,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
              "type": "context element",
              "userRequest": "./island.js"
            }
          ],
          "source": "var cbs = [], \n\tdata;\nmodule.exports = function(cb) {\n\tif(cbs) cbs.push(cb);\n\telse cb(data);\n}\nrequire.ensure([], function(require) {\n\tdata = require(\"!!./island.js\");\n\tvar callbacks = cbs;\n\tcbs = null;\n\tfor(var i = 0, l = callbacks.length; i < l; i++) {\n\t\tcallbacks[i](data);\n\t}\n});"
        },
        {
          "id": 66,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "name": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "index": 66,
          "index2": 65,
          "size": 281,
          "cacheable": true,
          "built": true,
          "optional": true,
          "prefetched": false,
          "chunks": [
            2
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 2,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
              "type": "context element",
              "userRequest": "./line.js"
            }
          ],
          "source": "var cbs = [], \n\tdata;\nmodule.exports = function(cb) {\n\tif(cbs) cbs.push(cb);\n\telse cb(data);\n}\nrequire.ensure([], function(require) {\n\tdata = require(\"!!./line.js\");\n\tvar callbacks = cbs;\n\tcbs = null;\n\tfor(var i = 0, l = callbacks.length; i < l; i++) {\n\t\tcallbacks[i](data);\n\t}\n});"
        }
      ],
      "filteredModules": 0,
      "loc": "4:1-38:3",
      "origins": [
        {
          "moduleId": 1,
          "module": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\echart.js",
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\echart.js",
          "moduleName": "./echart.js",
          "loc": "4:1-38:3",
          "name": null,
          "reasons": []
        }
      ]
    },
    {
      "id": 3,
      "rendered": true,
      "initial": false,
      "entry": false,
      "extraAsync": false,
      "size": 42701,
      "names": [],
      "files": [
        "3.bundle.js",
        "3.bundle.js.map"
      ],
      "hash": "0bc9bd86732d8280c556",
      "parents": [
        2
      ],
      "modules": [
        {
          "id": 4,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "index": 4,
          "index2": 57,
          "size": 42701,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            3
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 3,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
              "module": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
              "type": "cjs require",
              "userRequest": "!!./bar.js",
              "loc": "8:8-29"
            }
          ],
          "source": "/**\r\n * echarts图表类：柱形图\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ChartBase = require('./base');\r\n    \r\n    // 图形依赖\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n    // 组件依赖\r\n    require('../component/axis');\r\n    require('../component/grid');\r\n    require('../component/dataZoom');\r\n    \r\n    var ecConfig = require('../config');\r\n    // 柱形图默认参数\r\n    ecConfig.bar = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 2,                       // 二级层叠\r\n        clickable: true,\r\n        legendHoverLink: true,\r\n        // stack: null\r\n        xAxisIndex: 0,\r\n        yAxisIndex: 0,\r\n        barMinHeight: 0,          // 最小高度改为0\r\n        // barWidth: null,        // 默认自适应\r\n        barGap: '30%',            // 柱间距离，默认为柱形宽度的30%，可设固定值\r\n        barCategoryGap: '20%',    // 类目间柱形距离，默认为类目间距的20%，可设固定值\r\n        itemStyle: {\r\n            normal: {\r\n                // color: '各异',\r\n                barBorderColor: '#fff',       // 柱条边线\r\n                barBorderRadius: 0,           // 柱条边线圆角，单位px，默认为0\r\n                barBorderWidth: 0,            // 柱条边线线宽，单位px，默认为1\r\n                label: {\r\n                    show: false\r\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\r\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\r\n                    //           'inside'|'left'|'right'|'top'|'bottom'\r\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                }\r\n            },\r\n            emphasis: {\r\n                // color: '各异',\r\n                barBorderColor: '#fff',            // 柱条边线\r\n                barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0\r\n                barBorderWidth: 0,                 // 柱条边线线宽，单位px，默认为1\r\n                label: {\r\n                    show: false\r\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\r\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\r\n                    //           'inside'|'left'|'right'|'top'|'bottom'\r\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    var ecData = require('../util/ecData');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrColor = require('zrenderjs/tool/color');\r\n    \r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} series 数据\r\n     * @param {Object} component 组件\r\n     */\r\n    function Bar(ecTheme, messageCenter, zr, option, myChart){\r\n        // 图表基类\r\n        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n        \r\n        this.refresh(option);\r\n    }\r\n    \r\n    Bar.prototype = {\r\n        type: ecConfig.CHART_TYPE_BAR,\r\n        /**\r\n         * 绘制图形\r\n         */\r\n        _buildShape: function () {\r\n            this._buildPosition();\r\n        },\r\n        \r\n        _buildNormal: function(seriesArray, maxDataLength, locationMap, xMarkMap, orient) {\r\n            var series = this.series;\r\n            // 确定类目轴和数值轴，同一方向随便找一个即可\r\n            var seriesIndex = locationMap[0][0];\r\n            var serie = series[seriesIndex];\r\n            var isHorizontal = orient == 'horizontal';\r\n            var xAxis = this.component.xAxis;\r\n            var yAxis = this.component.yAxis;\r\n            var categoryAxis = isHorizontal \r\n                               ? xAxis.getAxis(serie.xAxisIndex)\r\n                               : yAxis.getAxis(serie.yAxisIndex);\r\n            var valueAxis;  // 数值轴各异\r\n\r\n            var size = this._mapSize(categoryAxis, locationMap);\r\n            var gap = size.gap;\r\n            var barGap = size.barGap;\r\n            var barWidthMap = size.barWidthMap;\r\n            var barMaxWidthMap = size.barMaxWidthMap;\r\n            var barWidth = size.barWidth;                   // 自适应宽度\r\n            var barMinHeightMap = size.barMinHeightMap;\r\n            var barHeight;\r\n            var curBarWidth;\r\n            var interval = size.interval;\r\n\r\n            var x;\r\n            var y;\r\n            var lastP; // 正向堆积处理\r\n            var baseP;\r\n            var lastN; // 负向堆积处理\r\n            var baseN;\r\n            var barShape;\r\n            var data;\r\n            var value;\r\n            var islandR = this.deepQuery([this.ecTheme, ecConfig], 'island.r');\r\n            for (var i = 0, l = maxDataLength; i < l; i++) {\r\n                if (categoryAxis.getNameByIndex(i) == null) {\r\n                    // 系列数据超出类目轴长度\r\n                    break;\r\n                }\r\n                isHorizontal\r\n                    ? (x = categoryAxis.getCoordByIndex(i) - gap / 2)\r\n                    : (y = categoryAxis.getCoordByIndex(i) + gap / 2);\r\n\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    // 堆积数据用第一条valueAxis\r\n                    var yAxisIndex = series[locationMap[j][0]].yAxisIndex || 0;\r\n                    var xAxisIndex = series[locationMap[j][0]].xAxisIndex || 0;\r\n                    valueAxis = isHorizontal \r\n                                ? yAxis.getAxis(yAxisIndex)\r\n                                : xAxis.getAxis(xAxisIndex);\r\n                    baseP = lastP = baseN = lastN = valueAxis.getCoord(0);\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                                || {\r\n                                                    min: Number.POSITIVE_INFINITY,\r\n                                                    max: Number.NEGATIVE_INFINITY,\r\n                                                    sum: 0,\r\n                                                    counter: 0,\r\n                                                    average: 0\r\n                                                };\r\n                        curBarWidth = Math.min(\r\n                            barMaxWidthMap[seriesIndex] || Number.MAX_VALUE,\r\n                            barWidthMap[seriesIndex] || barWidth\r\n                        );\r\n                        if (value === '-') {\r\n                            // 空数据在做完后补充拖拽提示框\r\n                            continue;\r\n                        }\r\n                        if (value > 0) {\r\n                            // 正向堆积\r\n                            barHeight = m > 0 \r\n                                        ? valueAxis.getCoordSize(value)\r\n                                        : (\r\n                                            isHorizontal\r\n                                            ? (baseP - valueAxis.getCoord(value))\r\n                                            : (valueAxis.getCoord(value) - baseP)\r\n                                        );\r\n                            // 非堆积数据最小高度有效\r\n                            if (n === 1 && barMinHeightMap[seriesIndex] > barHeight) {\r\n                                barHeight = barMinHeightMap[seriesIndex];\r\n                            }\r\n                            if (isHorizontal) {\r\n                                lastP -= barHeight;\r\n                                y = lastP;\r\n                            }\r\n                            else {\r\n                                x = lastP;\r\n                                lastP += barHeight;\r\n                            }\r\n                        }\r\n                        else if (value < 0){\r\n                            // 负向堆积\r\n                            barHeight = m > 0 \r\n                                        ? valueAxis.getCoordSize(value)\r\n                                        : (\r\n                                            isHorizontal\r\n                                            ? (valueAxis.getCoord(value) - baseN)\r\n                                            : (baseN - valueAxis.getCoord(value))\r\n                                        );\r\n                            // 非堆积数据最小高度有效\r\n                            if (n === 1 && barMinHeightMap[seriesIndex] > barHeight) {\r\n                                barHeight = barMinHeightMap[seriesIndex];\r\n                            }\r\n                            if (isHorizontal) {\r\n                                y = lastN;\r\n                                lastN += barHeight;\r\n                            }\r\n                            else {\r\n                                lastN -= barHeight;\r\n                                x = lastN;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // 0值\r\n                            barHeight = 0;\r\n                            // 最小高度无效\r\n                            if (isHorizontal) {\r\n                                lastP -= barHeight;\r\n                                y = lastP;\r\n                            }\r\n                            else {\r\n                                x = lastP;\r\n                                lastP += barHeight;\r\n                            }\r\n                        }\r\n                        xMarkMap[seriesIndex][i] = isHorizontal\r\n                                                   ? (x + curBarWidth / 2) \r\n                                                   : (y - curBarWidth / 2);\r\n                        if (xMarkMap[seriesIndex].min > value) {\r\n                            xMarkMap[seriesIndex].min = value;\r\n                            if (isHorizontal) {\r\n                                xMarkMap[seriesIndex].minY = y;\r\n                                xMarkMap[seriesIndex].minX = xMarkMap[seriesIndex][i];\r\n                            }\r\n                            else {\r\n                                xMarkMap[seriesIndex].minX = x + barHeight;\r\n                                xMarkMap[seriesIndex].minY = xMarkMap[seriesIndex][i];\r\n                            }\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max < value) {\r\n                            xMarkMap[seriesIndex].max = value;\r\n                            if (isHorizontal) {\r\n                                xMarkMap[seriesIndex].maxY = y;\r\n                                xMarkMap[seriesIndex].maxX = xMarkMap[seriesIndex][i];\r\n                            }\r\n                            else {\r\n                                xMarkMap[seriesIndex].maxX = x + barHeight;\r\n                                xMarkMap[seriesIndex].maxY = xMarkMap[seriesIndex][i];\r\n                            }\r\n                            \r\n                        }\r\n                        xMarkMap[seriesIndex].sum += value;\r\n                        xMarkMap[seriesIndex].counter++;\r\n                        \r\n                        if (i % interval === 0) {\r\n                            barShape = this._getBarItem(\r\n                                seriesIndex, i,\r\n                                categoryAxis.getNameByIndex(i),\r\n                                x,\r\n                                y - (isHorizontal ? 0 : curBarWidth),\r\n                                isHorizontal ? curBarWidth : barHeight,\r\n                                isHorizontal ? barHeight : curBarWidth,\r\n                                isHorizontal ? 'vertical' : 'horizontal'\r\n                            );\r\n                            this.shapeList.push(new RectangleShape(barShape));\r\n                        }\r\n                    }\r\n\r\n                    // 补充空数据的拖拽提示框\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        curBarWidth = Math.min(\r\n                            barMaxWidthMap[seriesIndex] || Number.MAX_VALUE,\r\n                            barWidthMap[seriesIndex] || barWidth\r\n                        );\r\n                        if (value != '-') {\r\n                            // 只关心空数据\r\n                            continue;\r\n                        }\r\n\r\n                        if (this.deepQuery([data, serie, this.option], 'calculable')) {\r\n                            if (isHorizontal) {\r\n                                lastP -= islandR;\r\n                                y = lastP;\r\n                            }\r\n                            else {\r\n                                x = lastP;\r\n                                lastP += islandR;\r\n                            }\r\n                            \r\n                            barShape = this._getBarItem(\r\n                                seriesIndex, i,\r\n                                categoryAxis.getNameByIndex(i),\r\n                                x,\r\n                                y - (isHorizontal ? 0 : curBarWidth),\r\n                                isHorizontal ? curBarWidth : islandR,\r\n                                isHorizontal ? islandR : curBarWidth,\r\n                                isHorizontal ? 'vertical' : 'horizontal'\r\n                            );\r\n                            barShape.hoverable = false;\r\n                            barShape.draggable = false;\r\n                            barShape.style.lineWidth = 1;\r\n                            barShape.style.brushType = 'stroke';\r\n                            barShape.style.strokeColor = serie.calculableHolderColor\r\n                                                         || this.ecTheme.calculableHolderColor\r\n                                                         || ecConfig.calculableHolderColor;\r\n\r\n                            this.shapeList.push(new RectangleShape(barShape));\r\n                        }\r\n                    }\r\n                    isHorizontal\r\n                        ? (x += (curBarWidth + barGap))\r\n                        : (y -= (curBarWidth + barGap));\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, isHorizontal ? 'y' : 'x');\r\n        },\r\n        /**\r\n         * 构建类目轴为水平方向的柱形图系列\r\n         */\r\n        _buildHorizontal: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            return this._buildNormal(\r\n                seriesArray, maxDataLength, locationMap, xMarkMap, 'horizontal'\r\n            );\r\n        },\r\n\r\n        /**\r\n         * 构建类目轴为垂直方向的柱形图系列\r\n         */\r\n        _buildVertical: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            return this._buildNormal(\r\n                seriesArray, maxDataLength, locationMap, xMarkMap, 'vertical'\r\n            );\r\n        },\r\n        \r\n        /**\r\n         * 构建双数值轴柱形图\r\n         */\r\n        _buildOther: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            var series = this.series;\r\n            \r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                    var seriesIndex = locationMap[j][m];\r\n                    var serie = series[seriesIndex];\r\n                    var xAxisIndex = serie.xAxisIndex || 0;\r\n                    var xAxis = this.component.xAxis.getAxis(xAxisIndex);\r\n                    var baseX = xAxis.getCoord(0);\r\n                    var yAxisIndex = serie.yAxisIndex || 0;\r\n                    var yAxis = this.component.yAxis.getAxis(yAxisIndex);\r\n                    var baseY = yAxis.getCoord(0);\r\n                    \r\n                    xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                            || {\r\n                                                min0: Number.POSITIVE_INFINITY,\r\n                                                min1: Number.POSITIVE_INFINITY,\r\n                                                max0: Number.NEGATIVE_INFINITY,\r\n                                                max1: Number.NEGATIVE_INFINITY,\r\n                                                sum0: 0,\r\n                                                sum1: 0,\r\n                                                counter0: 0,\r\n                                                counter1: 0,\r\n                                                average0: 0,\r\n                                                average1: 0\r\n                                            };\r\n\r\n                    for (var i = 0, l = serie.data.length; i < l; i++) {\r\n                        var data = serie.data[i];\r\n                        var value = this.getDataFromOption(data, '-');\r\n                        if (!(value instanceof Array)) {\r\n                            continue;\r\n                        }\r\n                        \r\n                        var x = xAxis.getCoord(value[0]);\r\n                        var y = yAxis.getCoord(value[1]);\r\n                        \r\n                        var queryTarget = [data, serie];\r\n                        var barWidth = this.deepQuery(queryTarget, 'barWidth') || 10; // 默认柱形\r\n                        var barHeight = this.deepQuery(queryTarget, 'barHeight');\r\n                        var orient;\r\n                        var barShape;\r\n                        \r\n                        if (barHeight != null) {\r\n                            // 条形图\r\n                            orient = 'horizontal';\r\n                            \r\n                            if (value[0] > 0) {\r\n                                // 正向\r\n                                barWidth = x - baseX;\r\n                                x -= barWidth;\r\n                            }\r\n                            else if (value[0] < 0){\r\n                                // 负向\r\n                                barWidth = baseX - x;\r\n                            }\r\n                            else {\r\n                                // 0值\r\n                                barWidth = 0;\r\n                            }\r\n                            \r\n                            barShape = this._getBarItem(\r\n                                seriesIndex, i,\r\n                                value[0],\r\n                                x, \r\n                                y - barHeight / 2,\r\n                                barWidth,\r\n                                barHeight,\r\n                                orient\r\n                            );\r\n                        }\r\n                        else {\r\n                            // 柱形\r\n                            orient = 'vertical';\r\n                            \r\n                            if (value[1] > 0) {\r\n                            // 正向\r\n                                barHeight = baseY - y;\r\n                            }\r\n                            else if (value[1] < 0){\r\n                                // 负向\r\n                                barHeight = y - baseY;\r\n                                y -= barHeight;\r\n                            }\r\n                            else {\r\n                                // 0值\r\n                                barHeight = 0;\r\n                            }\r\n                            barShape = this._getBarItem(\r\n                                seriesIndex, i,\r\n                                value[0],\r\n                                x - barWidth / 2, \r\n                                y,\r\n                                barWidth,\r\n                                barHeight,\r\n                                orient\r\n                            );\r\n                        }\r\n                        this.shapeList.push(new RectangleShape(barShape));\r\n                        \r\n                        \r\n                        x = xAxis.getCoord(value[0]);\r\n                        y = yAxis.getCoord(value[1]);\r\n                        if (xMarkMap[seriesIndex].min0 > value[0]) {\r\n                            xMarkMap[seriesIndex].min0 = value[0];\r\n                            xMarkMap[seriesIndex].minY0 = y;\r\n                            xMarkMap[seriesIndex].minX0 = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max0 < value[0]) {\r\n                            xMarkMap[seriesIndex].max0 = value[0];\r\n                            xMarkMap[seriesIndex].maxY0 = y;\r\n                            xMarkMap[seriesIndex].maxX0 = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum0 += value[0];\r\n                        xMarkMap[seriesIndex].counter0++;\r\n                        \r\n                        if (xMarkMap[seriesIndex].min1 > value[1]) {\r\n                            xMarkMap[seriesIndex].min1 = value[1];\r\n                            xMarkMap[seriesIndex].minY1 = y;\r\n                            xMarkMap[seriesIndex].minX1 = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max1 < value[1]) {\r\n                            xMarkMap[seriesIndex].max1 = value[1];\r\n                            xMarkMap[seriesIndex].maxY1 = y;\r\n                            xMarkMap[seriesIndex].maxX1 = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum1 += value[1];\r\n                        xMarkMap[seriesIndex].counter1++;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, 'xy');\r\n        },\r\n        \r\n        /**\r\n         * 我真是自找麻烦啊，为啥要允许系列级个性化最小宽度和高度啊！！！\r\n         * @param {CategoryAxis} categoryAxis 类目坐标轴，需要知道类目间隔大小\r\n         * @param {Array} locationMap 整形数据的系列索引\r\n         */\r\n        _mapSize: function (categoryAxis, locationMap, ignoreUserDefined) {\r\n            var res = this._findSpecialBarSzie(locationMap, ignoreUserDefined);\r\n            var barWidthMap = res.barWidthMap;\r\n            var barMaxWidthMap = res.barMaxWidthMap;\r\n            var barMinHeightMap = res.barMinHeightMap;\r\n            var sBarWidthCounter = res.sBarWidthCounter;    // 用户指定\r\n            var sBarWidthTotal = res.sBarWidthTotal;        // 用户指定\r\n            var barGap = res.barGap;\r\n            var barCategoryGap = res.barCategoryGap;\r\n            \r\n            var gap;\r\n            var barWidth;\r\n            var interval = 1;\r\n            if (locationMap.length != sBarWidthCounter) {\r\n                // 至少存在一个自适应宽度的柱形图\r\n                if (!ignoreUserDefined) {\r\n                    gap = typeof barCategoryGap === 'string' && barCategoryGap.match(/%$/)\r\n                          // 百分比\r\n                          ? ((categoryAxis.getGap() * (100 - parseFloat(barCategoryGap)) / 100).toFixed(2) - 0)\r\n                          // 数值\r\n                          : (categoryAxis.getGap() - barCategoryGap);\r\n                    if (typeof barGap === 'string' && barGap.match(/%$/)) {\r\n                        barGap = parseFloat(barGap) / 100;\r\n                        barWidth = +(\r\n                            (gap - sBarWidthTotal) / (\r\n                                (locationMap.length - 1) * barGap + locationMap.length - sBarWidthCounter\r\n                            )\r\n                        ).toFixed(2);\r\n                        barGap = barWidth * barGap;\r\n                    }\r\n                    else {\r\n                        barGap = parseFloat(barGap);\r\n                        barWidth = +(\r\n                            (gap - sBarWidthTotal - barGap * (locationMap.length - 1)) / (\r\n                                locationMap.length - sBarWidthCounter\r\n                            )\r\n                        ).toFixed(2);\r\n                    }\r\n                    // 无法满足用户定义的宽度设计，忽略用户宽度，打回重做\r\n                    if (barWidth <= 0) {\r\n                        return this._mapSize(categoryAxis, locationMap, true);\r\n                    }\r\n                }\r\n                else {\r\n                    // 忽略用户定义的宽度设定\r\n                    gap = categoryAxis.getGap();\r\n                    barGap = 0;\r\n                    barWidth = +(gap / locationMap.length).toFixed(2);\r\n                    // 已经忽略用户定义的宽度设定依然还无法满足显示，只能硬来了;\r\n                    if (barWidth <= 0) {\r\n                        interval = Math.floor(locationMap.length / gap);\r\n                        barWidth = 1;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // 全是自定义宽度，barGap无效，系列间隔决定barGap\r\n                gap = sBarWidthCounter > 1\r\n                      ? (typeof barCategoryGap === 'string' && barCategoryGap.match(/%$/))\r\n                          // 百分比\r\n                          ? +(categoryAxis.getGap() * (100 - parseFloat(barCategoryGap)) / 100).toFixed(2)\r\n                          // 数值\r\n                          : (categoryAxis.getGap() - barCategoryGap)\r\n                      // 只有一个\r\n                      : sBarWidthTotal;\r\n                barWidth = 0;\r\n                barGap = sBarWidthCounter > 1 \r\n                         ? +((gap - sBarWidthTotal) / (sBarWidthCounter - 1)).toFixed(2)\r\n                         : 0;\r\n                if (barGap < 0) {\r\n                    // 无法满足用户定义的宽度设计，忽略用户宽度，打回重做\r\n                    return this._mapSize(categoryAxis, locationMap, true);\r\n                }\r\n            }\r\n            \r\n            // 检查是否满足barMaxWidthMap\r\n            \r\n            return this._recheckBarMaxWidth(\r\n                locationMap,\r\n                barWidthMap, barMaxWidthMap, barMinHeightMap,\r\n                gap,   // 总宽度\r\n                barWidth, barGap, interval\r\n            );\r\n        },\r\n        \r\n        /**\r\n         * 计算堆积下用户特殊指定的各种size \r\n         */\r\n        _findSpecialBarSzie: function(locationMap, ignoreUserDefined) {\r\n            var series = this.series;\r\n            var barWidthMap = {};\r\n            var barMaxWidthMap = {};\r\n            var barMinHeightMap = {};\r\n            var sBarWidth;              // 用户指定\r\n            var sBarMaxWidth;           // 用户指定\r\n            var sBarWidthCounter = 0;   // 用户指定\r\n            var sBarWidthTotal = 0;     // 用户指定\r\n            var barGap;\r\n            var barCategoryGap;\r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                var hasFound = {\r\n                    barWidth: false,\r\n                    barMaxWidth: false\r\n                };\r\n                for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                    var seriesIndex = locationMap[j][m];\r\n                    var queryTarget = series[seriesIndex];\r\n                    if (!ignoreUserDefined) {\r\n                        if (!hasFound.barWidth) {\r\n                            sBarWidth = this.query(queryTarget, 'barWidth');\r\n                            if (sBarWidth != null) {\r\n                                // 同一堆积第一个生效barWidth\r\n                                barWidthMap[seriesIndex] = sBarWidth;\r\n                                sBarWidthTotal += sBarWidth;\r\n                                sBarWidthCounter++;\r\n                                hasFound.barWidth = true;\r\n                                // 复位前面同一堆积但没被定义的\r\n                                for (var ii = 0, ll = m; ii < ll; ii++) {\r\n                                    var pSeriesIndex = locationMap[j][ii];\r\n                                    barWidthMap[pSeriesIndex] = sBarWidth;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            barWidthMap[seriesIndex] = sBarWidth;   // 用找到的一个\r\n                        }\r\n                        \r\n                        if (!hasFound.barMaxWidth) {\r\n                            sBarMaxWidth = this.query(queryTarget, 'barMaxWidth');\r\n                            if (sBarMaxWidth != null) {\r\n                                // 同一堆积第一个生效barMaxWidth\r\n                                barMaxWidthMap[seriesIndex] = sBarMaxWidth;\r\n                                hasFound.barMaxWidth = true;\r\n                                // 复位前面同一堆积但没被定义的\r\n                                for (var ii = 0, ll = m; ii < ll; ii++) {\r\n                                    var pSeriesIndex = locationMap[j][ii];\r\n                                    barMaxWidthMap[pSeriesIndex] = sBarMaxWidth;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            barMaxWidthMap[seriesIndex] = sBarMaxWidth;   // 用找到的一个\r\n                        }\r\n                    }\r\n\r\n                    barMinHeightMap[seriesIndex] = this.query(queryTarget, 'barMinHeight');\r\n                    barGap = barGap != null ? barGap : this.query(queryTarget, 'barGap');\r\n                    barCategoryGap = barCategoryGap != null \r\n                                     ? barCategoryGap : this.query(queryTarget, 'barCategoryGap');\r\n                }\r\n            }\r\n            \r\n            return {\r\n                barWidthMap: barWidthMap,\r\n                barMaxWidthMap: barMaxWidthMap,\r\n                barMinHeightMap: barMinHeightMap,\r\n                sBarWidth: sBarWidth,\r\n                sBarMaxWidth: sBarMaxWidth,\r\n                sBarWidthCounter: sBarWidthCounter,\r\n                sBarWidthTotal: sBarWidthTotal,\r\n                barGap: barGap,\r\n                barCategoryGap: barCategoryGap\r\n            };\r\n        },\r\n        \r\n        /**\r\n         * 检查是否满足barMaxWidthMap \r\n         */\r\n        _recheckBarMaxWidth: function(\r\n                locationMap,\r\n                barWidthMap, barMaxWidthMap, barMinHeightMap,\r\n                gap,   // 总宽度\r\n                barWidth, barGap, interval\r\n        ) {\r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                var seriesIndex = locationMap[j][0];\r\n                if (barMaxWidthMap[seriesIndex] && barMaxWidthMap[seriesIndex] < barWidth) {\r\n                    // 不满足最大宽度\r\n                    gap -= barWidth - barMaxWidthMap[seriesIndex]; // 总宽度减少\r\n                }\r\n            }\r\n            \r\n            return {\r\n                barWidthMap: barWidthMap,\r\n                barMaxWidthMap: barMaxWidthMap,\r\n                barMinHeightMap: barMinHeightMap ,\r\n                gap: gap,   // 总宽度\r\n                barWidth: barWidth,\r\n                barGap: barGap,\r\n                interval: interval\r\n            };\r\n        },\r\n        \r\n        /**\r\n         * 生成最终图形数据\r\n         */\r\n        _getBarItem: function (seriesIndex, dataIndex, name, x, y, width, height, orient) {\r\n            var series = this.series;\r\n            var barShape;\r\n            var serie = series[seriesIndex];\r\n            var data = serie.data[dataIndex];\r\n            // 多级控制\r\n            var defaultColor = this._sIndex2ColorMap[seriesIndex];\r\n            var queryTarget = [data, serie];\r\n            \r\n            var normal = this.deepMerge(queryTarget, 'itemStyle.normal');\r\n            var emphasis = this.deepMerge(queryTarget, 'itemStyle.emphasis');\r\n            var normalBorderWidth = normal.barBorderWidth;\r\n            \r\n            barShape = {\r\n                zlevel: serie.zlevel,\r\n                z: serie.z,\r\n                clickable: this.deepQuery(queryTarget, 'clickable'),\r\n                style: {\r\n                    x: x,\r\n                    y: y,\r\n                    width: width,\r\n                    height: height,\r\n                    brushType: 'both',\r\n                    color: this.getItemStyleColor(\r\n                        this.deepQuery(queryTarget, 'itemStyle.normal.color') || defaultColor,\r\n                        seriesIndex, dataIndex, data\r\n                    ),\r\n                    radius: normal.barBorderRadius,\r\n                    lineWidth: normalBorderWidth,\r\n                    strokeColor: normal.barBorderColor\r\n                },\r\n                highlightStyle: {\r\n                    color: this.getItemStyleColor(\r\n                        this.deepQuery(queryTarget, 'itemStyle.emphasis.color'),\r\n                        seriesIndex, dataIndex, data\r\n                    ),\r\n                    radius: emphasis.barBorderRadius,\r\n                    lineWidth: emphasis.barBorderWidth,\r\n                    strokeColor: emphasis.barBorderColor\r\n                },\r\n                _orient: orient\r\n            };\r\n            var barShapeStyle = barShape.style;\r\n            barShape.highlightStyle.color = barShape.highlightStyle.color\r\n                            || (typeof barShapeStyle.color === 'string'\r\n                                ? zrColor.lift(barShapeStyle.color, -0.3)\r\n                                : barShapeStyle.color\r\n                               );\r\n            //亚像素优化\r\n            barShapeStyle.x = Math.floor(barShapeStyle.x);\r\n            barShapeStyle.y = Math.floor(barShapeStyle.y);\r\n            barShapeStyle.height = Math.ceil(barShapeStyle.height);\r\n            barShapeStyle.width = Math.ceil(barShapeStyle.width);\r\n            // 考虑线宽的显示优化\r\n            if (normalBorderWidth > 0\r\n                && barShapeStyle.height > normalBorderWidth\r\n                && barShapeStyle.width > normalBorderWidth\r\n            ) {\r\n                barShapeStyle.y += normalBorderWidth / 2;\r\n                barShapeStyle.height -= normalBorderWidth;\r\n                barShapeStyle.x += normalBorderWidth / 2;\r\n                barShapeStyle.width -= normalBorderWidth;\r\n            }\r\n            else {\r\n                // 太小了或者线宽小于0，废了边线\r\n                barShapeStyle.brushType = 'fill';\r\n            }\r\n            \r\n            barShape.highlightStyle.textColor = barShape.highlightStyle.color;\r\n            \r\n            barShape = this.addLabel(barShape, serie, data, name, orient);\r\n            var barShapeStyleList = [                    // normal emphasis都需要检查\r\n                barShapeStyle,\r\n                barShape.highlightStyle\r\n            ];\r\n            for (var i = 0, l = barShapeStyleList.length; i < l; i++) {\r\n                var textPosition = barShapeStyleList[i].textPosition;\r\n                if (textPosition === 'insideLeft'\r\n                    || textPosition === 'insideRight'\r\n                    || textPosition === 'insideTop'\r\n                    || textPosition === 'insideBottom'\r\n                ) {\r\n                    var gap = 5;\r\n                    switch (textPosition) {\r\n                        case 'insideLeft':\r\n                            barShapeStyleList[i].textX = barShapeStyle.x + gap;\r\n                            barShapeStyleList[i].textY = barShapeStyle.y + barShapeStyle.height / 2;\r\n                            barShapeStyleList[i].textAlign = 'left';\r\n                            barShapeStyleList[i].textBaseline = 'middle';\r\n                            break;\r\n                        case 'insideRight':\r\n                            barShapeStyleList[i].textX = barShapeStyle.x + barShapeStyle.width - gap;\r\n                            barShapeStyleList[i].textY = barShapeStyle.y + barShapeStyle.height / 2;\r\n                            barShapeStyleList[i].textAlign = 'right';\r\n                            barShapeStyleList[i].textBaseline = 'middle';\r\n                            break;\r\n                        case 'insideTop':\r\n                            barShapeStyleList[i].textX = barShapeStyle.x + barShapeStyle.width / 2;\r\n                            barShapeStyleList[i].textY = barShapeStyle.y + gap / 2;\r\n                            barShapeStyleList[i].textAlign = 'center';\r\n                            barShapeStyleList[i].textBaseline = 'top';\r\n                            break;\r\n                        case 'insideBottom':\r\n                            barShapeStyleList[i].textX = barShapeStyle.x + barShapeStyle.width / 2;\r\n                            barShapeStyleList[i].textY = barShapeStyle.y + barShapeStyle.height - gap / 2;\r\n                            barShapeStyleList[i].textAlign = 'center';\r\n                            barShapeStyleList[i].textBaseline = 'bottom';\r\n                            break;\r\n                    }\r\n                    barShapeStyleList[i].textPosition = 'specific';\r\n                    barShapeStyleList[i].textColor = barShapeStyleList[i].textColor || '#fff';\r\n                }\r\n            }\r\n            \r\n\r\n            if (this.deepQuery([data, serie, this.option],'calculable')) {\r\n                this.setCalculable(barShape);\r\n                barShape.draggable = true;\r\n            }\r\n\r\n            ecData.pack(\r\n                barShape,\r\n                series[seriesIndex], seriesIndex,\r\n                series[seriesIndex].data[dataIndex], dataIndex,\r\n                name\r\n            );\r\n\r\n            return barShape;\r\n        },\r\n\r\n        // 位置转换\r\n        getMarkCoord: function (seriesIndex, mpData) {\r\n            var serie = this.series[seriesIndex];\r\n            var xMarkMap = this.xMarkMap[seriesIndex];\r\n            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);\r\n            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);\r\n            var dataIndex;\r\n            var pos;\r\n            if (mpData.type\r\n                && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')\r\n            ) {\r\n                // 特殊值内置支持\r\n                var valueIndex = mpData.valueIndex != null \r\n                                 ? mpData.valueIndex \r\n                                 : xMarkMap.maxX0 != null \r\n                                   ? '1' : '';\r\n                pos = [\r\n                    xMarkMap[mpData.type + 'X' + valueIndex],\r\n                    xMarkMap[mpData.type + 'Y' + valueIndex],\r\n                    xMarkMap[mpData.type + 'Line' + valueIndex],\r\n                    xMarkMap[mpData.type + valueIndex]\r\n                ];\r\n            }\r\n            else if (xMarkMap.isHorizontal) {\r\n                // 横向\r\n                dataIndex = typeof mpData.xAxis === 'string' && xAxis.getIndexByName\r\n                            ? xAxis.getIndexByName(mpData.xAxis)\r\n                            : (mpData.xAxis || 0);\r\n                \r\n                var x = xMarkMap[dataIndex];\r\n                x = x != null\r\n                    ? x \r\n                    : typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex\r\n                      ? xAxis.getCoordByIndex(mpData.xAxis || 0)\r\n                      : xAxis.getCoord(mpData.xAxis || 0);\r\n                \r\n                pos = [x, yAxis.getCoord(mpData.yAxis || 0)];\r\n            }\r\n            else {\r\n                // 纵向\r\n                dataIndex = typeof mpData.yAxis === 'string' && yAxis.getIndexByName\r\n                            ? yAxis.getIndexByName(mpData.yAxis)\r\n                            : (mpData.yAxis || 0);\r\n                \r\n                var y = xMarkMap[dataIndex];\r\n                y = y != null\r\n                    ? y\r\n                    : typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex\r\n                      ? yAxis.getCoordByIndex(mpData.yAxis || 0)\r\n                      : yAxis.getCoord(mpData.yAxis || 0);\r\n                \r\n                pos = [xAxis.getCoord(mpData.xAxis || 0), y];\r\n            }\r\n            \r\n            return pos;\r\n        },\r\n        \r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption) {\r\n            if (newOption) {\r\n                this.option = newOption;\r\n                this.series = newOption.series;\r\n            }\r\n            \r\n            this.backupShapeList();\r\n            this._buildShape();\r\n        },\r\n        \r\n        /**\r\n         * 动态数据增加动画 \r\n         */\r\n        addDataAnimation: function (params, done) {\r\n            var series = this.series;\r\n            var aniMap = {}; // seriesIndex索引参数\r\n            for (var i = 0, l = params.length; i < l; i++) {\r\n                aniMap[params[i][0]] = params[i];\r\n            }\r\n            var x;\r\n            var dx;\r\n            var y;\r\n            var dy;\r\n            var serie;\r\n            var seriesIndex;\r\n            var dataIndex;\r\n\r\n            var aniCount = 0;\r\n            function animationDone() {\r\n                aniCount--;\r\n                if (aniCount === 0) {\r\n                    done && done();\r\n                }\r\n            }\r\n            for (var i = this.shapeList.length - 1; i >= 0; i--) {\r\n                seriesIndex = ecData.get(this.shapeList[i], 'seriesIndex');\r\n                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {\r\n                    // 有数据删除才有移动的动画\r\n                    if (this.shapeList[i].type === 'rectangle') {\r\n                        // 主动画\r\n                        dataIndex = ecData.get(this.shapeList[i], 'dataIndex');\r\n                        serie = series[seriesIndex];\r\n                        if (aniMap[seriesIndex][2] && dataIndex === serie.data.length - 1) {\r\n                            // 队头加入删除末尾\r\n                            this.zr.delShape(this.shapeList[i].id);\r\n                            continue;\r\n                        }\r\n                        else if (!aniMap[seriesIndex][2] && dataIndex === 0) {\r\n                            // 队尾加入删除头部\r\n                            this.zr.delShape(this.shapeList[i].id);\r\n                            continue;\r\n                        }\r\n                        if (this.shapeList[i]._orient === 'horizontal') {\r\n                            // 条形图\r\n                            dy = this.component.yAxis.getAxis(serie.yAxisIndex || 0).getGap();\r\n                            y = aniMap[seriesIndex][2] ? -dy : dy;\r\n                            x = 0;\r\n                        }\r\n                        else {\r\n                            // 柱形图\r\n                            dx = this.component.xAxis.getAxis(serie.xAxisIndex || 0).getGap();\r\n                            x = aniMap[seriesIndex][2] ? dx : -dx;\r\n                            y = 0;\r\n                        }\r\n                        this.shapeList[i].position = [0, 0];\r\n\r\n                        aniCount++;\r\n                        this.zr.animate(this.shapeList[i].id, '')\r\n                            .when(\r\n                                this.query(this.option, 'animationDurationUpdate'),\r\n                                { position: [x, y] }\r\n                            )\r\n                            .done(animationDone)\r\n                            .start();\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // 没有动画\r\n            if (!aniCount) {\r\n                done && done();\r\n            }\r\n        }\r\n    };\r\n    \r\n    zrUtil.inherits(Bar, ChartBase);\r\n    \r\n    // 图表注册\r\n    require('../chart').define('bar', Bar);\r\n    \r\n    return Bar;\r\n});"
        }
      ],
      "filteredModules": 0,
      "loc": "7:0-14:2",
      "origins": [
        {
          "moduleId": 3,
          "module": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "loc": "7:0-14:2",
          "name": null,
          "reasons": []
        }
      ]
    },
    {
      "id": 4,
      "rendered": true,
      "initial": false,
      "entry": false,
      "extraAsync": false,
      "size": 10668,
      "names": [],
      "files": [
        "4.bundle.js",
        "4.bundle.js.map"
      ],
      "hash": "1fe11eb407f4cb33b6f4",
      "parents": [
        2
      ],
      "modules": [
        {
          "id": 64,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "index": 64,
          "index2": 61,
          "size": 8317,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            4
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 63,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "!!./island.js",
              "loc": "8:8-32"
            }
          ],
          "source": "/**\r\n * echarts组件：孤岛数据\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ChartBase = require('./base');\r\n    \r\n    // 图形依赖\r\n    var CircleShape = require('zrenderjs/shape/Circle');\r\n    \r\n    var ecConfig = require('../config');\r\n    ecConfig.island = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 5,                       // 二级层叠\r\n        r: 15,\r\n        calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%\r\n    };\r\n\r\n    var ecData = require('../util/ecData');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrEvent = require('zrenderjs/tool/event');\r\n    \r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 图表选项\r\n     */\r\n    function Island(ecTheme, messageCenter, zr, option, myChart) {\r\n        // 图表基类\r\n        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this._nameConnector;\r\n        this._valueConnector;\r\n        this._zrHeight = this.zr.getHeight();\r\n        this._zrWidth = this.zr.getWidth();\r\n\r\n        var self = this;\r\n        /**\r\n         * 滚轮改变孤岛数据值\r\n         */\r\n        self.shapeHandler.onmousewheel = function (param) {\r\n            var shape = param.target;\r\n\r\n            var event = param.event;\r\n            var delta = zrEvent.getDelta(event);\r\n            delta = delta > 0 ? (-1) : 1;\r\n            shape.style.r -= delta;\r\n            shape.style.r = shape.style.r < 5 ? 5 : shape.style.r;\r\n\r\n            var value = ecData.get(shape, 'value');\r\n            var dvalue = value * self.option.island.calculateStep;\r\n            value = dvalue > 1\r\n                    ? (Math.round(value - dvalue * delta))\r\n                    : +(value - dvalue * delta).toFixed(2);\r\n\r\n            var name = ecData.get(shape, 'name');\r\n            shape.style.text = name + ':' + value;\r\n\r\n            ecData.set(shape, 'value', value);\r\n            ecData.set(shape, 'name', name);\r\n\r\n            self.zr.modShape(shape.id);\r\n            self.zr.refreshNextFrame();\r\n            zrEvent.stop(event);\r\n        };\r\n    }\r\n    \r\n    Island.prototype = {\r\n        type: ecConfig.CHART_TYPE_ISLAND,\r\n        /**\r\n         * 孤岛合并\r\n         *\r\n         * @param {string} tarShapeIndex 目标索引\r\n         * @param {Object} srcShape 源目标，合入目标后删除\r\n         */\r\n        _combine: function (tarShape, srcShape) {\r\n            var zrColor = require('zrenderjs/tool/color');\r\n            var accMath = require('../util/accMath');\r\n            var value = accMath.accAdd(\r\n                            ecData.get(tarShape, 'value'),\r\n                            ecData.get(srcShape, 'value')\r\n                        );\r\n            var name = ecData.get(tarShape, 'name')\r\n                       + this._nameConnector\r\n                       + ecData.get(srcShape, 'name');\r\n\r\n            tarShape.style.text = name + this._valueConnector + value;\r\n\r\n            ecData.set(tarShape, 'value', value);\r\n            ecData.set(tarShape, 'name', name);\r\n            tarShape.style.r = this.option.island.r;\r\n            tarShape.style.color = zrColor.mix(\r\n                tarShape.style.color,\r\n                srcShape.style.color\r\n            );\r\n        },\r\n\r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption) {\r\n            if (newOption) {\r\n                newOption.island = this.reformOption(newOption.island);\r\n                this.option = newOption;\r\n    \r\n                this._nameConnector = this.option.nameConnector;\r\n                this._valueConnector = this.option.valueConnector;\r\n            }\r\n        },\r\n        \r\n        getOption: function () {\r\n            return this.option;\r\n        },\r\n\r\n        resize: function () {\r\n            var newWidth = this.zr.getWidth();\r\n            var newHieght = this.zr.getHeight();\r\n            var xScale = newWidth / (this._zrWidth || newWidth);\r\n            var yScale = newHieght / (this._zrHeight || newHieght);\r\n            if (xScale === 1 && yScale === 1) {\r\n                return;\r\n            }\r\n            this._zrWidth = newWidth;\r\n            this._zrHeight = newHieght;\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                this.zr.modShape(\r\n                    this.shapeList[i].id,\r\n                    {\r\n                        style: {\r\n                            x: Math.round(this.shapeList[i].style.x * xScale),\r\n                            y: Math.round(this.shapeList[i].style.y * yScale)\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n        },\r\n\r\n        add: function (shape) {\r\n            var name = ecData.get(shape, 'name');\r\n            var value = ecData.get(shape, 'value');\r\n            var seriesName = ecData.get(shape, 'series') != null\r\n                             ? ecData.get(shape, 'series').name\r\n                             : '';\r\n            var font = this.getFont(this.option.island.textStyle);\r\n            var islandOption = this.option.island;\r\n            var islandShape = {\r\n                zlevel: islandOption.zlevel,\r\n                z: islandOption.z,\r\n                style: {\r\n                    x: shape.style.x,\r\n                    y: shape.style.y,\r\n                    r: this.option.island.r,\r\n                    color: shape.style.color || shape.style.strokeColor,\r\n                    text: name + this._valueConnector + value,\r\n                    textFont: font\r\n                },\r\n                draggable: true,\r\n                hoverable: true,\r\n                onmousewheel: this.shapeHandler.onmousewheel,\r\n                _type: 'island'\r\n            };\r\n            if (islandShape.style.color === '#fff') {\r\n                islandShape.style.color = shape.style.strokeColor;\r\n            }\r\n            this.setCalculable(islandShape);\r\n            islandShape.dragEnableTime = 0;\r\n            ecData.pack(\r\n                islandShape,\r\n                {name:seriesName}, -1,\r\n                value, -1,\r\n                name\r\n            );\r\n            islandShape = new CircleShape(islandShape);\r\n            this.shapeList.push(islandShape);\r\n            this.zr.addShape(islandShape);\r\n        },\r\n\r\n        del: function (shape) {\r\n            this.zr.delShape(shape.id);\r\n            var newShapeList = [];\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                if (this.shapeList[i].id != shape.id) {\r\n                    newShapeList.push(this.shapeList[i]);\r\n                }\r\n            }\r\n            this.shapeList = newShapeList;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽进来， 重载基类方法\r\n         */\r\n        ondrop: function (param, status) {\r\n            if (!this.isDrop || !param.target) {\r\n                // 没有在当前实例上发生拖拽行为则直接返回\r\n                return;\r\n            }\r\n            // 拖拽产生孤岛数据合并\r\n            var target = param.target;      // 拖拽安放目标\r\n            var dragged = param.dragged;    // 当前被拖拽的图形对象\r\n\r\n            this._combine(target, dragged);\r\n            this.zr.modShape(target.id);\r\n\r\n            status.dragIn = true;\r\n\r\n            // 处理完拖拽事件后复位\r\n            this.isDrop = false;\r\n\r\n            return;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽出去， 重载基类方法\r\n         */\r\n        ondragend: function (param, status) {\r\n            var target = param.target;      // 拖拽安放目标\r\n            if (!this.isDragend) {\r\n                // 拖拽的不是孤岛数据，如果没有图表接受孤岛数据，需要新增孤岛数据\r\n                if (!status.dragIn) {\r\n                    target.style.x = zrEvent.getX(param.event);\r\n                    target.style.y = zrEvent.getY(param.event);\r\n                    this.add(target);\r\n                    status.needRefresh = true;\r\n                }\r\n            }\r\n            else {\r\n                // 拖拽的是孤岛数据，如果有图表接受了孤岛数据，需要删除孤岛数据\r\n                if (status.dragIn) {\r\n                    this.del(target);\r\n                    status.needRefresh = true;\r\n                }\r\n            }\r\n\r\n            // 处理完拖拽事件后复位\r\n            this.isDragend = false;\r\n\r\n            return;\r\n        }\r\n    };\r\n    \r\n    zrUtil.inherits(Island, ChartBase);\r\n    \r\n    // 图表注册\r\n    require('../chart').define('island', Island);\r\n    \r\n    return Island;\r\n});"
        },
        {
          "id": 65,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\event.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/event.js",
          "index": 65,
          "index2": 60,
          "size": 2351,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            4
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 64,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
              "type": "cjs require",
              "userRequest": "zrenderjs/tool/event",
              "loc": "24:18-49"
            }
          ],
          "source": "/**\r\n * 事件辅助类\r\n * @module zrender/tool/event\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n */\r\ndefine(\r\n    function(require) {\r\n\r\n        'use strict';\r\n\r\n        var Eventful = require('../mixin/Eventful');\r\n\r\n        /**\r\n        * 提取鼠标（手指）x坐标\r\n        * @memberOf module:zrender/tool/event\r\n        * @param  {Event} e 事件.\r\n        * @return {number} 鼠标（手指）x坐标.\r\n        */\r\n        function getX(e) {\r\n            return typeof e.zrenderX != 'undefined' && e.zrenderX\r\n                   || typeof e.offsetX != 'undefined' && e.offsetX\r\n                   || typeof e.layerX != 'undefined' && e.layerX\r\n                   || typeof e.clientX != 'undefined' && e.clientX;\r\n        }\r\n\r\n        /**\r\n        * 提取鼠标y坐标\r\n        * @memberOf module:zrender/tool/event\r\n        * @param  {Event} e 事件.\r\n        * @return {number} 鼠标（手指）y坐标.\r\n        */\r\n        function getY(e) {\r\n            return typeof e.zrenderY != 'undefined' && e.zrenderY\r\n                   || typeof e.offsetY != 'undefined' && e.offsetY\r\n                   || typeof e.layerY != 'undefined' && e.layerY\r\n                   || typeof e.clientY != 'undefined' && e.clientY;\r\n        }\r\n\r\n        /**\r\n        * 提取鼠标滚轮变化\r\n        * @memberOf module:zrender/tool/event\r\n        * @param  {Event} e 事件.\r\n        * @return {number} 滚轮变化，正值说明滚轮是向上滚动，如果是负值说明滚轮是向下滚动\r\n        */\r\n        function getDelta(e) {\r\n            return typeof e.zrenderDelta != 'undefined' && e.zrenderDelta\r\n                   || typeof e.wheelDelta != 'undefined' && e.wheelDelta\r\n                   || typeof e.detail != 'undefined' && -e.detail;\r\n        }\r\n\r\n        /**\r\n         * 停止冒泡和阻止默认行为\r\n         * @memberOf module:zrender/tool/event\r\n         * @method\r\n         * @param {Event} e : event对象\r\n         */\r\n        var stop = typeof window.addEventListener === 'function'\r\n            ? function (e) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                e.cancelBubble = true;\r\n            }\r\n            : function (e) {\r\n                e.returnValue = false;\r\n                e.cancelBubble = true;\r\n            };\r\n        \r\n        return {\r\n            getX : getX,\r\n            getY : getY,\r\n            getDelta : getDelta,\r\n            stop : stop,\r\n            // 做向上兼容\r\n            Dispatcher : Eventful\r\n        };\r\n    }\r\n);\r\n"
        }
      ],
      "filteredModules": 0,
      "loc": "7:0-14:2",
      "origins": [
        {
          "moduleId": 63,
          "module": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "loc": "7:0-14:2",
          "name": null,
          "reasons": []
        }
      ]
    },
    {
      "id": 5,
      "rendered": true,
      "initial": false,
      "entry": false,
      "extraAsync": false,
      "size": 48648,
      "names": [],
      "files": [
        "5.bundle.js",
        "5.bundle.js.map"
      ],
      "hash": "67f32c9f52500925d812",
      "parents": [
        2
      ],
      "modules": [
        {
          "id": 67,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "index": 67,
          "index2": 64,
          "size": 45576,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            5
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 66,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "!!./line.js",
              "loc": "8:8-30"
            }
          ],
          "source": "/**\r\n * echarts图表类：折线图\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ChartBase = require('./base');\r\n    \r\n    // 图形依赖\r\n    var PolylineShape = require('zrenderjs/shape/Polyline');\r\n    var IconShape = require('../util/shape/Icon');\r\n    var HalfSmoothPolygonShape = require('../util/shape/HalfSmoothPolygon');\r\n    // 组件依赖\r\n    require('../component/axis');\r\n    require('../component/grid');\r\n    require('../component/dataZoom');\r\n    \r\n    var ecConfig = require('../config');\r\n    // 折线图默认参数\r\n    ecConfig.line = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 2,                       // 二级层叠\r\n        clickable: true,\r\n        legendHoverLink: true,\r\n        // stack: null\r\n        xAxisIndex: 0,\r\n        yAxisIndex: 0,\r\n        // 'nearest', 'min', 'max', 'average'\r\n        dataFilter: 'nearest',\r\n        itemStyle: {\r\n            normal: {\r\n                // color: 各异,\r\n                label: {\r\n                    show: false\r\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\r\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\r\n                    //           'inside'|'left'|'right'|'top'|'bottom'\r\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                },\r\n                lineStyle: {\r\n                    width: 2,\r\n                    type: 'solid',\r\n                    shadowColor: 'rgba(0,0,0,0)', //默认透明\r\n                    shadowBlur: 0,\r\n                    shadowOffsetX: 0,\r\n                    shadowOffsetY: 0\r\n                }\r\n            },\r\n            emphasis: {\r\n                // color: 各异,\r\n                label: {\r\n                    show: false\r\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\r\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\r\n                    //           'inside'|'left'|'right'|'top'|'bottom'\r\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                }\r\n            }\r\n        },\r\n        // smooth: false,\r\n        // symbol: null,         // 拐点图形类型\r\n        symbolSize: 2,           // 拐点图形大小\r\n        // symbolRotate: null,   // 拐点图形旋转控制\r\n        showAllSymbol: false     // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\r\n    };\r\n\r\n    var ecData = require('../util/ecData');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrColor = require('zrenderjs/tool/color');\r\n    \r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} series 数据\r\n     * @param {Object} component 组件\r\n     */\r\n    function Line(ecTheme, messageCenter, zr, option, myChart){\r\n        // 图表基类\r\n        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this.refresh(option);\r\n    }\r\n    \r\n    Line.prototype = {\r\n        type: ecConfig.CHART_TYPE_LINE,\r\n        /**\r\n         * 绘制图形\r\n         */\r\n        _buildShape: function () {\r\n            this.finalPLMap = {}; // 完成的point list(PL)\r\n            this._buildPosition();\r\n        },\r\n\r\n        /**\r\n         * 构建类目轴为水平方向的折线图系列\r\n         */\r\n        _buildHorizontal: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            var series = this.series;\r\n            // 确定类目轴和数值轴，同一方向随便找一个即可\r\n            var seriesIndex = locationMap[0][0];\r\n            var serie = series[seriesIndex];\r\n            var categoryAxis = this.component.xAxis.getAxis(serie.xAxisIndex || 0);\r\n            var valueAxis;  // 数值轴各异\r\n\r\n            var x;\r\n            var y;\r\n            var lastYP; // 正向堆积处理\r\n            var baseYP;\r\n            var lastYN; // 负向堆积处理\r\n            var baseYN;\r\n            //var this.finalPLMap = {}; // 完成的point list(PL)\r\n            var curPLMap = {};   // 正在记录的point list(PL)\r\n            var data;\r\n            var value;\r\n            for (var i = 0, l = maxDataLength; i < l; i++) {\r\n                if (categoryAxis.getNameByIndex(i) == null) {\r\n                    // 系列数据超出类目轴长度\r\n                    break;\r\n                }\r\n                x = categoryAxis.getCoordByIndex(i);\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    // 堆积数据用第一条valueAxis\r\n                    valueAxis = this.component.yAxis.getAxis(\r\n                        series[locationMap[j][0]].yAxisIndex || 0\r\n                    );\r\n                    baseYP = lastYP = baseYN = lastYN = valueAxis.getCoord(0);\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];\r\n                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                                || {\r\n                                                    min: Number.POSITIVE_INFINITY,\r\n                                                    max: Number.NEGATIVE_INFINITY,\r\n                                                    sum: 0,\r\n                                                    counter: 0,\r\n                                                    average: 0\r\n                                                };\r\n                        if (value === '-') {\r\n                            // 空数据则把正在记录的curPLMap添加到finalPLMap中\r\n                            if (curPLMap[seriesIndex].length > 0) {\r\n                                this.finalPLMap[seriesIndex] =\r\n                                    this.finalPLMap[seriesIndex] || [];\r\n\r\n                                this.finalPLMap[seriesIndex].push(\r\n                                    curPLMap[seriesIndex]\r\n                                );\r\n\r\n                                curPLMap[seriesIndex] = [];\r\n                            }\r\n                            continue;\r\n                        }\r\n                        //y = valueAxis.getCoord(value);\r\n                        if (value >= 0) {\r\n                            // 正向堆积\r\n                            lastYP -= m > 0\r\n                                      ? valueAxis.getCoordSize(value)\r\n                                      : (baseYP - valueAxis.getCoord(value));\r\n                            y = lastYP;\r\n                        }\r\n                        else if (value < 0){\r\n                            // 负向堆积\r\n                            lastYN += m > 0 \r\n                                      ? valueAxis.getCoordSize(value)\r\n                                      : (valueAxis.getCoord(value) - baseYN);\r\n                            y = lastYN;\r\n                        }\r\n                        curPLMap[seriesIndex].push(\r\n                            [x, y, i, categoryAxis.getNameByIndex(i), x, baseYP]\r\n                        );\r\n                        \r\n                        if (xMarkMap[seriesIndex].min > value) {\r\n                            xMarkMap[seriesIndex].min = value;\r\n                            xMarkMap[seriesIndex].minY = y;\r\n                            xMarkMap[seriesIndex].minX = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max < value) {\r\n                            xMarkMap[seriesIndex].max = value;\r\n                            xMarkMap[seriesIndex].maxY = y;\r\n                            xMarkMap[seriesIndex].maxX = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum += value;\r\n                        xMarkMap[seriesIndex].counter++;\r\n                    }\r\n                }\r\n                // 补充空数据的拖拽提示\r\n                lastYP = this.component.grid.getY();\r\n                var symbolSize;\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        if (value != '-') {\r\n                            // 只关心空数据\r\n                            continue;\r\n                        }\r\n                        if (this.deepQuery([data, serie, this.option], 'calculable')) {\r\n                            symbolSize = this.deepQuery(\r\n                                [data, serie],\r\n                                'symbolSize'\r\n                            );\r\n                            lastYP += symbolSize * 2 + 5;\r\n                            y = lastYP;\r\n                            this.shapeList.push(this._getCalculableItem(\r\n                                seriesIndex, i, categoryAxis.getNameByIndex(i),\r\n                                x, y, 'horizontal'\r\n                            ));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // 把剩余未完成的curPLMap全部添加到finalPLMap中\r\n            for (var sId in curPLMap) {\r\n                if (curPLMap[sId].length > 0) {\r\n                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];\r\n                    this.finalPLMap[sId].push(curPLMap[sId]);\r\n                    curPLMap[sId] = [];\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, 'y');\r\n            \r\n            this._buildBorkenLine(seriesArray, this.finalPLMap, categoryAxis, 'horizontal');\r\n        },\r\n\r\n        /**\r\n         * 构建类目轴为垂直方向的折线图系列\r\n         */\r\n        _buildVertical: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            var series = this.series;\r\n            // 确定类目轴和数值轴，同一方向随便找一个即可\r\n            var seriesIndex = locationMap[0][0];\r\n            var serie = series[seriesIndex];\r\n            var categoryAxis = this.component.yAxis.getAxis(serie.yAxisIndex || 0);\r\n            var valueAxis;  // 数值轴各异\r\n\r\n            var x;\r\n            var y;\r\n            var lastXP; // 正向堆积处理\r\n            var baseXP;\r\n            var lastXN; // 负向堆积处理\r\n            var baseXN;\r\n            //var this.finalPLMap = {}; // 完成的point list(PL)\r\n            var curPLMap = {};   // 正在记录的point list(PL)\r\n            var data;\r\n            var value;\r\n            for (var i = 0, l = maxDataLength; i < l; i++) {\r\n                if (categoryAxis.getNameByIndex(i) == null) {\r\n                    // 系列数据超出类目轴长度\r\n                    break;\r\n                }\r\n                y = categoryAxis.getCoordByIndex(i);\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    // 堆积数据用第一条valueAxis\r\n                    valueAxis = this.component.xAxis.getAxis(\r\n                        series[locationMap[j][0]].xAxisIndex || 0\r\n                    );\r\n                    baseXP = lastXP = baseXN = lastXN = valueAxis.getCoord(0);\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];\r\n                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                                || {\r\n                                                    min: Number.POSITIVE_INFINITY,\r\n                                                    max: Number.NEGATIVE_INFINITY,\r\n                                                    sum: 0,\r\n                                                    counter: 0,\r\n                                                    average: 0\r\n                                                };\r\n                        if (value === '-') {\r\n                            // 空数据则把正在记录的curPLMap添加到finalPLMap中\r\n                            if (curPLMap[seriesIndex].length > 0) {\r\n                                this.finalPLMap[seriesIndex] =\r\n                                    this.finalPLMap[seriesIndex] || [];\r\n\r\n                                this.finalPLMap[seriesIndex].push(\r\n                                    curPLMap[seriesIndex]\r\n                                );\r\n\r\n                                curPLMap[seriesIndex] = [];\r\n                            }\r\n                            continue;\r\n                        }\r\n                        //x = valueAxis.getCoord(value);\r\n                        if (value >= 0) {\r\n                            // 正向堆积\r\n                            lastXP += m > 0\r\n                                      ? valueAxis.getCoordSize(value)\r\n                                      : (valueAxis.getCoord(value) - baseXP);\r\n                            x = lastXP;\r\n                        }\r\n                        else if (value < 0){\r\n                            // 负向堆积\r\n                            lastXN -= m > 0\r\n                                      ? valueAxis.getCoordSize(value)\r\n                                      : (baseXN - valueAxis.getCoord(value));\r\n                            x = lastXN;\r\n                        }\r\n                        curPLMap[seriesIndex].push(\r\n                            [x, y, i, categoryAxis.getNameByIndex(i), baseXP, y]\r\n                        );\r\n                        \r\n                        if (xMarkMap[seriesIndex].min > value) {\r\n                            xMarkMap[seriesIndex].min = value;\r\n                            xMarkMap[seriesIndex].minX = x;\r\n                            xMarkMap[seriesIndex].minY = y;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max < value) {\r\n                            xMarkMap[seriesIndex].max = value;\r\n                            xMarkMap[seriesIndex].maxX = x;\r\n                            xMarkMap[seriesIndex].maxY = y;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum += value;\r\n                        xMarkMap[seriesIndex].counter++;\r\n                    }\r\n                }\r\n                // 补充空数据的拖拽提示\r\n                lastXP = this.component.grid.getXend();\r\n                var symbolSize;\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        if (value != '-') {\r\n                            // 只关心空数据\r\n                            continue;\r\n                        }\r\n                        if (this.deepQuery([data, serie, this.option], 'calculable')) {\r\n                            symbolSize = this.deepQuery(\r\n                                [data, serie],\r\n                                'symbolSize'\r\n                            );\r\n                            lastXP -= symbolSize * 2 + 5;\r\n                            x = lastXP;\r\n                            this.shapeList.push(this._getCalculableItem(\r\n                                seriesIndex, i, categoryAxis.getNameByIndex(i),\r\n                                x, y, 'vertical'\r\n                            ));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 把剩余未完成的curPLMap全部添加到finalPLMap中\r\n            for (var sId in curPLMap) {\r\n                if (curPLMap[sId].length > 0) {\r\n                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];\r\n                    this.finalPLMap[sId].push(curPLMap[sId]);\r\n                    curPLMap[sId] = [];\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, 'x');\r\n            \r\n            this._buildBorkenLine(seriesArray, this.finalPLMap, categoryAxis, 'vertical');\r\n        },\r\n\r\n        /**\r\n         * 构建双数值轴折线图 \r\n         */\r\n        _buildOther: function(seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            var series = this.series;\r\n            var curPLMap = {};   // 正在记录的point list(PL)\r\n            var xAxis;\r\n            \r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                    var seriesIndex = locationMap[j][m];\r\n                    var serie = series[seriesIndex];\r\n                    xAxis = this.component.xAxis.getAxis(serie.xAxisIndex || 0);\r\n                    var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex || 0);\r\n                    var baseY = yAxis.getCoord(0);\r\n                    \r\n                    curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];\r\n                    xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                            || {\r\n                                                min0: Number.POSITIVE_INFINITY,\r\n                                                min1: Number.POSITIVE_INFINITY,\r\n                                                max0: Number.NEGATIVE_INFINITY,\r\n                                                max1: Number.NEGATIVE_INFINITY,\r\n                                                sum0: 0,\r\n                                                sum1: 0,\r\n                                                counter0: 0,\r\n                                                counter1: 0,\r\n                                                average0: 0,\r\n                                                average1: 0\r\n                                            };\r\n                    \r\n                    for (var i = 0, l = serie.data.length; i < l; i++) {\r\n                        var data = serie.data[i];\r\n                        var value = this.getDataFromOption(data, '-');\r\n                        if (!(value instanceof Array)) {\r\n                            continue;\r\n                        }\r\n                        \r\n                        var x = xAxis.getCoord(value[0]);\r\n                        var y = yAxis.getCoord(value[1]);\r\n                        curPLMap[seriesIndex].push(\r\n                            // x, y, dataIndex, name, 填充用\r\n                            [x, y, i, value[0], x, baseY]\r\n                        );\r\n                        \r\n                        if (xMarkMap[seriesIndex].min0 > value[0]) {\r\n                            xMarkMap[seriesIndex].min0 = value[0];\r\n                            xMarkMap[seriesIndex].minY0 = y;\r\n                            xMarkMap[seriesIndex].minX0 = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max0 < value[0]) {\r\n                            xMarkMap[seriesIndex].max0 = value[0];\r\n                            xMarkMap[seriesIndex].maxY0 = y;\r\n                            xMarkMap[seriesIndex].maxX0 = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum0 += value[0];\r\n                        xMarkMap[seriesIndex].counter0++;\r\n                        \r\n                        if (xMarkMap[seriesIndex].min1 > value[1]) {\r\n                            xMarkMap[seriesIndex].min1 = value[1];\r\n                            xMarkMap[seriesIndex].minY1 = y;\r\n                            xMarkMap[seriesIndex].minX1 = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max1 < value[1]) {\r\n                            xMarkMap[seriesIndex].max1 = value[1];\r\n                            xMarkMap[seriesIndex].maxY1 = y;\r\n                            xMarkMap[seriesIndex].maxX1 = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum1 += value[1];\r\n                        xMarkMap[seriesIndex].counter1++;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // 把剩余未完成的curPLMap全部添加到finalPLMap中\r\n            for (var sId in curPLMap) {\r\n                if (curPLMap[sId].length > 0) {\r\n                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];\r\n                    this.finalPLMap[sId].push(curPLMap[sId]);\r\n                    curPLMap[sId] = [];\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, 'xy');\r\n            \r\n            this._buildBorkenLine(seriesArray, this.finalPLMap, xAxis, 'other');\r\n        },\r\n        \r\n        /**\r\n         * 生成折线和折线上的拐点\r\n         */\r\n        _buildBorkenLine: function (seriesArray, pointList, categoryAxis, curOrient) {\r\n            var orient = curOrient == 'other' ? 'horizontal' : curOrient;\r\n            var series = this.series;\r\n            var data;\r\n            \r\n            // 堆积层叠需求，反顺序构建\r\n            for (var sIdx = seriesArray.length - 1; sIdx >= 0; sIdx--) {\r\n                var seriesIndex = seriesArray[sIdx];\r\n                var serie = series[seriesIndex];\r\n                var seriesPL = pointList[seriesIndex];\r\n                if (serie.type === this.type && seriesPL != null) {\r\n                    var bbox = this._getBbox(seriesIndex, orient);\r\n                    var defaultColor = this._sIndex2ColorMap[seriesIndex];\r\n                    // 折线相关，多级控制\r\n                    var lineWidth = this.query(\r\n                        serie, 'itemStyle.normal.lineStyle.width'\r\n                    );\r\n                    var lineType = this.query(\r\n                        serie, 'itemStyle.normal.lineStyle.type'\r\n                    );\r\n                    var lineColor = this.query(\r\n                        serie, 'itemStyle.normal.lineStyle.color'\r\n                    );\r\n                    var normalColor = this.getItemStyleColor(\r\n                        this.query(serie, 'itemStyle.normal.color'), seriesIndex, -1\r\n                    );\r\n\r\n                    // 填充相关\r\n                    var isFill = this.query(serie, 'itemStyle.normal.areaStyle') != null;\r\n                    var fillNormalColor = this.query(\r\n                        serie, 'itemStyle.normal.areaStyle.color'\r\n                    );\r\n\r\n                    for (var i = 0, l = seriesPL.length; i < l; i++) {\r\n                        var singlePL = seriesPL[i];\r\n                        var isLarge = curOrient != 'other' && this._isLarge(orient, singlePL);\r\n                        if (!isLarge) { // 非大数据模式才显示拐点symbol\r\n                            for (var j = 0, k = singlePL.length; j < k; j++) {\r\n                                data = serie.data[singlePL[j][2]];\r\n                                if (this.deepQuery([data, serie, this.option], 'calculable') // 可计算\r\n                                    || this.deepQuery([data, serie], 'showAllSymbol')        // 全显示\r\n                                    || (categoryAxis.type === 'categoryAxis'                 // 主轴非空\r\n                                        && categoryAxis.isMainAxis(singlePL[j][2])\r\n                                        && this.deepQuery([data, serie], 'symbol') != 'none'\r\n                                       )\r\n                                ) {\r\n                                    this.shapeList.push(this._getSymbol(\r\n                                        seriesIndex,\r\n                                        singlePL[j][2], // dataIndex\r\n                                        singlePL[j][3], // name\r\n                                        singlePL[j][0], // x\r\n                                        singlePL[j][1], // y\r\n                                        orient\r\n                                    ));\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            // 大数据模式截取pointList\r\n                            singlePL = this._getLargePointList(\r\n                                orient, singlePL, serie.dataFilter\r\n                            );\r\n                        }\r\n\r\n                        // 折线图\r\n                        var polylineShape = new PolylineShape({\r\n                            zlevel: serie.zlevel,\r\n                            z: serie.z,\r\n                            style: {\r\n                                miterLimit: lineWidth,\r\n                                pointList: singlePL,\r\n                                strokeColor: lineColor\r\n                                             || normalColor \r\n                                             || defaultColor,\r\n                                lineWidth: lineWidth,\r\n                                lineType: lineType,\r\n                                smooth: this._getSmooth(serie.smooth),\r\n                                smoothConstraint: bbox,\r\n                                shadowColor: this.query(\r\n                                  serie,\r\n                                  'itemStyle.normal.lineStyle.shadowColor'\r\n                                ),\r\n                                shadowBlur: this.query(\r\n                                  serie,\r\n                                  'itemStyle.normal.lineStyle.shadowBlur'\r\n                                ),\r\n                                shadowOffsetX: this.query(\r\n                                  serie,\r\n                                  'itemStyle.normal.lineStyle.shadowOffsetX'\r\n                                ),\r\n                                shadowOffsetY: this.query(\r\n                                  serie,\r\n                                  'itemStyle.normal.lineStyle.shadowOffsetY'\r\n                                )\r\n                            },\r\n                            hoverable: false,\r\n                            _main: true,\r\n                            _seriesIndex: seriesIndex,\r\n                            _orient: orient\r\n                        });\r\n                        \r\n                        ecData.pack(\r\n                            polylineShape,\r\n                            series[seriesIndex], seriesIndex,\r\n                            0, i, series[seriesIndex].name\r\n                        );\r\n                        \r\n                        this.shapeList.push(polylineShape);\r\n                        \r\n                        if (isFill) {\r\n                            var halfSmoothPolygonShape = new HalfSmoothPolygonShape({\r\n                                zlevel: serie.zlevel,\r\n                                z: serie.z,\r\n                                style: {\r\n                                    miterLimit: lineWidth,\r\n                                    pointList: zrUtil.clone(singlePL).concat([\r\n                                        [\r\n                                            singlePL[singlePL.length - 1][4],\r\n                                            singlePL[singlePL.length - 1][5]\r\n                                        ],\r\n                                        [\r\n                                            singlePL[0][4],\r\n                                            singlePL[0][5]\r\n                                        ]\r\n                                    ]),\r\n                                    brushType: 'fill',\r\n                                    smooth: this._getSmooth(serie.smooth),\r\n                                    smoothConstraint: bbox,\r\n                                    color: fillNormalColor\r\n                                           ? fillNormalColor\r\n                                           : zrColor.alpha(defaultColor,0.5)\r\n                                },\r\n                                highlightStyle: {\r\n                                    brushType: 'fill'\r\n                                },\r\n                                hoverable: false,\r\n                                _main: true,\r\n                                _seriesIndex: seriesIndex,\r\n                                _orient: orient\r\n                            });\r\n                            ecData.pack(\r\n                                halfSmoothPolygonShape,\r\n                                series[seriesIndex], seriesIndex,\r\n                                0, i, series[seriesIndex].name\r\n                            );\r\n                            this.shapeList.push(halfSmoothPolygonShape);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        _getBbox: function(seriesIndex, orient) {\r\n            var bbox = this.component.grid.getBbox();\r\n            var xMarkMap = this.xMarkMap[seriesIndex];\r\n            if (xMarkMap.minX0 != null) {\r\n                return [\r\n                    [\r\n                        Math.min(xMarkMap.minX0, xMarkMap.maxX0, xMarkMap.minX1, xMarkMap.maxX1),\r\n                        Math.min(xMarkMap.minY0, xMarkMap.maxY0, xMarkMap.minY1, xMarkMap.maxY1)\r\n                    ],\r\n                    [\r\n                        Math.max(xMarkMap.minX0, xMarkMap.maxX0, xMarkMap.minX1, xMarkMap.maxX1),\r\n                        Math.max(xMarkMap.minY0, xMarkMap.maxY0, xMarkMap.minY1, xMarkMap.maxY1)\r\n                    ]\r\n                ];\r\n            }\r\n            else if (orient === 'horizontal') {\r\n                bbox[0][1] = Math.min(xMarkMap.minY, xMarkMap.maxY);\r\n                bbox[1][1] = Math.max(xMarkMap.minY, xMarkMap.maxY);\r\n            }\r\n            else {\r\n                bbox[0][0] = Math.min(xMarkMap.minX, xMarkMap.maxX);\r\n                bbox[1][0] = Math.max(xMarkMap.minX, xMarkMap.maxX);\r\n            }\r\n            return bbox;\r\n        },\r\n        \r\n        _isLarge: function(orient, singlePL) {\r\n            if (singlePL.length < 2) {\r\n                return false;\r\n            }\r\n            else {\r\n                return orient === 'horizontal'\r\n                       ? (Math.abs(singlePL[0][0] - singlePL[1][0]) < 0.5)\r\n                       : (Math.abs(singlePL[0][1] - singlePL[1][1]) < 0.5);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 大规模pointList优化 \r\n         */\r\n        _getLargePointList: function(orient, singlePL, filter) {\r\n            var total;\r\n            if (orient === 'horizontal') {\r\n                total = this.component.grid.getWidth();\r\n            }\r\n            else {\r\n                total = this.component.grid.getHeight();\r\n            }\r\n            \r\n            var len = singlePL.length;\r\n            var newList = [];\r\n\r\n            if (typeof(filter) != 'function') {\r\n                switch (filter) {\r\n                    case 'min':\r\n                        filter = function (arr) {\r\n                            return Math.max.apply(null, arr);\r\n                        };\r\n                        break;\r\n                    case 'max':\r\n                        filter = function (arr) {\r\n                            return Math.min.apply(null, arr);\r\n                        };\r\n                        break;\r\n                    case 'average':\r\n                        filter = function (arr) {\r\n                            var total = 0;\r\n                            for (var i = 0; i < arr.length; i++) {\r\n                                total += arr[i];\r\n                            }\r\n                            return total / arr.length;\r\n                        };\r\n                        break;\r\n                    default:\r\n                        filter = function (arr) {\r\n                            return arr[0];\r\n                        }\r\n                }\r\n            }\r\n\r\n            var windowData = [];\r\n            for (var i = 0; i < total; i++) {\r\n                var idx0 = Math.floor(len / total * i);\r\n                var idx1 = Math.min(Math.floor(len / total * (i + 1)), len);\r\n                if (idx1 <= idx0) {\r\n                    continue;\r\n                }\r\n\r\n                for (var j = idx0; j < idx1; j++) {\r\n                    windowData[j - idx0] = orient === 'horizontal'\r\n                        ? singlePL[j][1] : singlePL[j][0];\r\n                }\r\n\r\n                windowData.length = idx1 - idx0;\r\n                var filteredVal = filter(windowData);\r\n                var nearestIdx = -1;\r\n                var minDist = Infinity;\r\n                // 寻找值最相似的点，使用其其它属性\r\n                for (var j = idx0; j < idx1; j++) {\r\n                    var val = orient === 'horizontal'\r\n                        ? singlePL[j][1] : singlePL[j][0];\r\n                    var dist = Math.abs(val - filteredVal);\r\n                    if (dist < minDist) {\r\n                        nearestIdx = j;\r\n                        minDist = dist;\r\n                    }\r\n                }\r\n\r\n                var newItem = singlePL[nearestIdx].slice();\r\n                if (orient === 'horizontal') {\r\n                    newItem[1] = filteredVal;\r\n                }\r\n                else {\r\n                    newItem[0] = filteredVal;\r\n                }\r\n                newList.push(newItem);\r\n            }\r\n            return newList;\r\n        },\r\n\r\n        _getSmooth: function (isSmooth/*, pointList, orient*/) {\r\n            if (isSmooth) {\r\n                /* 不科学啊，发现0.3通用了\r\n                var delta;\r\n                if (orient === 'horizontal') {\r\n                    delta = Math.abs(pointList[0][0] - pointList[1][0]);\r\n                }\r\n                else {\r\n                    delta = Math.abs(pointList[0][1] - pointList[1][1]);\r\n                }\r\n                */\r\n                return 0.3;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 生成空数据所需的可计算提示图形\r\n         */\r\n        _getCalculableItem: function (seriesIndex, dataIndex, name, x, y, orient) {\r\n            var series = this.series;\r\n            var color = series[seriesIndex].calculableHolderColor\r\n                        || this.ecTheme.calculableHolderColor\r\n                        || ecConfig.calculableHolderColor;\r\n\r\n            var itemShape = this._getSymbol(\r\n                seriesIndex, dataIndex, name,\r\n                x, y, orient\r\n            );\r\n            itemShape.style.color = color;\r\n            itemShape.style.strokeColor = color;\r\n            itemShape.rotation = [0,0];\r\n            itemShape.hoverable = false;\r\n            itemShape.draggable = false;\r\n            itemShape.style.text = undefined;\r\n\r\n            return itemShape;\r\n        },\r\n\r\n        /**\r\n         * 生成折线图上的拐点图形\r\n         */\r\n        _getSymbol: function (seriesIndex, dataIndex, name, x, y, orient) {\r\n            var series = this.series;\r\n            var serie = series[seriesIndex];\r\n            var data = serie.data[dataIndex];\r\n            \r\n            var itemShape = this.getSymbolShape(\r\n                serie, seriesIndex, data, dataIndex, name, \r\n                x, y,\r\n                this._sIndex2ShapeMap[seriesIndex], \r\n                this._sIndex2ColorMap[seriesIndex],\r\n                '#fff',\r\n                orient === 'vertical' ? 'horizontal' : 'vertical' // 翻转\r\n            );\r\n            itemShape.zlevel = serie.zlevel;\r\n            itemShape.z = serie.z + 1;\r\n            \r\n            if (this.deepQuery([data, serie, this.option], 'calculable')) {\r\n                this.setCalculable(itemShape);\r\n                itemShape.draggable = true;\r\n            }\r\n            \r\n            return itemShape;\r\n        },\r\n\r\n        // 位置转换\r\n        getMarkCoord: function (seriesIndex, mpData) {\r\n            var serie = this.series[seriesIndex];\r\n            var xMarkMap = this.xMarkMap[seriesIndex];\r\n            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);\r\n            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);\r\n            \r\n            if (mpData.type\r\n                && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')\r\n            ) {\r\n                // 特殊值内置支持\r\n                var valueIndex = mpData.valueIndex != null \r\n                                 ? mpData.valueIndex \r\n                                 : xMarkMap.maxX0 != null \r\n                                   ? '1' : '';\r\n                return [\r\n                    xMarkMap[mpData.type + 'X' + valueIndex],\r\n                    xMarkMap[mpData.type + 'Y' + valueIndex],\r\n                    xMarkMap[mpData.type + 'Line' + valueIndex],\r\n                    xMarkMap[mpData.type + valueIndex]\r\n                ];\r\n            }\r\n            \r\n            return [\r\n                typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex\r\n                    ? xAxis.getCoordByIndex(mpData.xAxis || 0)\r\n                    : xAxis.getCoord(mpData.xAxis || 0),\r\n                \r\n                typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex\r\n                    ? yAxis.getCoordByIndex(mpData.yAxis || 0)\r\n                    : yAxis.getCoord(mpData.yAxis || 0)\r\n            ];\r\n        },\r\n        \r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption) {\r\n            if (newOption) {\r\n                this.option = newOption;\r\n                this.series = newOption.series;\r\n            }\r\n            \r\n            this.backupShapeList();\r\n            this._buildShape();\r\n        },\r\n        \r\n        ontooltipHover: function (param, tipShape) {\r\n            var seriesIndex = param.seriesIndex;\r\n            var dataIndex = param.dataIndex;\r\n            var seriesPL;\r\n            var singlePL;\r\n            var len = seriesIndex.length;\r\n            while (len--) {\r\n                seriesPL = this.finalPLMap[seriesIndex[len]];\r\n                if (seriesPL) {\r\n                    for (var i = 0, l = seriesPL.length; i < l; i++) {\r\n                        singlePL = seriesPL[i];\r\n                        for (var j = 0, k = singlePL.length; j < k; j++) {\r\n                            if (dataIndex === singlePL[j][2]) {\r\n                                tipShape.push(this._getSymbol(\r\n                                    seriesIndex[len],   // seriesIndex\r\n                                    singlePL[j][2],     // dataIndex\r\n                                    singlePL[j][3],     // name\r\n                                    singlePL[j][0],     // x\r\n                                    singlePL[j][1],     // y\r\n                                    'horizontal'\r\n                                ));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 动态数据增加动画 \r\n         */\r\n        addDataAnimation: function (params, done) {\r\n            var series = this.series;\r\n            var aniMap = {}; // seriesIndex索引参数\r\n            for (var i = 0, l = params.length; i < l; i++) {\r\n                aniMap[params[i][0]] = params[i];\r\n            }\r\n            var x;\r\n            var dx;\r\n            var y;\r\n            var dy;\r\n            var seriesIndex;\r\n            var pointList;\r\n            var isHorizontal; // 是否横向布局， isHorizontal;\r\n\r\n            var aniCount = 0;\r\n            function animationDone() {\r\n                aniCount--;\r\n                if (aniCount === 0) {\r\n                    done && done();\r\n                }\r\n            }\r\n            function animationDuring(target) {\r\n                // 强制更新曲线控制点\r\n                target.style.controlPointList = null;\r\n            }\r\n\r\n            for (var i = this.shapeList.length - 1; i >= 0; i--) {\r\n                seriesIndex = this.shapeList[i]._seriesIndex;\r\n                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {\r\n                    // 有数据删除才有移动的动画\r\n                    if (this.shapeList[i]._main && this.shapeList[i].style.pointList.length > 1) {\r\n                        pointList = this.shapeList[i].style.pointList;\r\n                        // 主线动画\r\n                        dx = Math.abs(pointList[0][0] - pointList[1][0]);\r\n                        dy = Math.abs(pointList[0][1] - pointList[1][1]);\r\n                        isHorizontal = this.shapeList[i]._orient === 'horizontal';\r\n                            \r\n                        if (aniMap[seriesIndex][2]) {\r\n                            // 队头加入删除末尾\r\n                            if (this.shapeList[i].type === 'half-smooth-polygon') {\r\n                                //区域图\r\n                                var len = pointList.length;\r\n                                this.shapeList[i].style.pointList[len - 3] = pointList[len - 2];\r\n                                this.shapeList[i].style.pointList[len - 3][isHorizontal ? 0 : 1]\r\n                                    = pointList[len - 4][isHorizontal ? 0 : 1];\r\n                                this.shapeList[i].style.pointList[len - 2] = pointList[len - 1];\r\n                            }\r\n                            this.shapeList[i].style.pointList.pop();\r\n                            isHorizontal ? (x = dx, y = 0) : (x = 0, y = -dy);\r\n                        }\r\n                        else {\r\n                            // 队尾加入删除头部\r\n                            this.shapeList[i].style.pointList.shift();\r\n                            if (this.shapeList[i].type === 'half-smooth-polygon') {\r\n                                //区域图\r\n                                var targetPoint =this.shapeList[i].style.pointList.pop();\r\n                                isHorizontal\r\n                                ? (targetPoint[0] = pointList[0][0])\r\n                                : (targetPoint[1] = pointList[0][1]);\r\n                                this.shapeList[i].style.pointList.push(targetPoint);\r\n                            }\r\n                            isHorizontal ? (x = -dx, y = 0) : (x = 0, y = dy);\r\n                        }\r\n                        this.shapeList[i].style.controlPointList = null;\r\n                        \r\n                        this.zr.modShape(this.shapeList[i]);\r\n                    }\r\n                    else {\r\n                        // 拐点动画\r\n                        if (aniMap[seriesIndex][2] \r\n                            && this.shapeList[i]._dataIndex \r\n                                === series[seriesIndex].data.length - 1\r\n                        ) {\r\n                            // 队头加入删除末尾\r\n                            this.zr.delShape(this.shapeList[i].id);\r\n                            continue;\r\n                        }\r\n                        else if (!aniMap[seriesIndex][2] \r\n                                 && this.shapeList[i]._dataIndex === 0\r\n                        ) {\r\n                            // 队尾加入删除头部\r\n                            this.zr.delShape(this.shapeList[i].id);\r\n                            continue;\r\n                        }\r\n                    }\r\n                    this.shapeList[i].position = [0, 0];\r\n\r\n                    aniCount++;\r\n                    this.zr.animate(this.shapeList[i].id, '')\r\n                        .when(\r\n                            this.query(this.option, 'animationDurationUpdate'),\r\n                            { position: [ x, y ] }\r\n                        )\r\n                        .during(animationDuring)\r\n                        .done(animationDone)\r\n                        .start();\r\n                }\r\n            }\r\n\r\n            // 没有动画\r\n            if (!aniCount) {\r\n                done && done();\r\n            }\r\n        }\r\n    };\r\n\r\n    function legendLineIcon(ctx, style, refreshNextFrame) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        \r\n        var dy = height / 2;\r\n        \r\n        if (style.symbol.match('empty')) {\r\n            ctx.fillStyle = '#fff';\r\n        }\r\n        style.brushType = 'both';\r\n        \r\n        var symbol = style.symbol.replace('empty', '').toLowerCase();\r\n        if (symbol.match('star')) {\r\n            dy = (symbol.replace('star','') - 0) || 5;\r\n            y -= 1;\r\n            symbol = 'star';\r\n        } \r\n        else if (symbol === 'rectangle' || symbol === 'arrow') {\r\n            x += (width - height) / 2;\r\n            width = height;\r\n        }\r\n        \r\n        var imageLocation = '';\r\n        if (symbol.match('image')) {\r\n            imageLocation = symbol.replace(\r\n                    new RegExp('^image:\\\\/\\\\/'), ''\r\n                );\r\n            symbol = 'image';\r\n            x += Math.round((width - height) / 2) - 1;\r\n            width = height = height + 2;\r\n        }\r\n        symbol = IconShape.prototype.iconLibrary[symbol];\r\n        \r\n        if (symbol) {\r\n            var x2 = style.x;\r\n            var y2 = style.y;\r\n            ctx.moveTo(x2, y2 + dy);\r\n            ctx.lineTo(x2 + 5, y2 + dy);\r\n            ctx.moveTo(x2 + style.width - 5, y2 + dy);\r\n            ctx.lineTo(x2 + style.width, y2 + dy);\r\n            var self = this;\r\n            symbol(\r\n                ctx,\r\n                {\r\n                    x: x + 4,\r\n                    y: y + 4,\r\n                    width: width - 8,\r\n                    height: height - 8,\r\n                    n: dy,\r\n                    image: imageLocation\r\n                },\r\n                function () {\r\n                    self.modSelf();\r\n                    refreshNextFrame();\r\n                }\r\n            );\r\n        }\r\n        else {\r\n            ctx.moveTo(x, y + dy);\r\n            ctx.lineTo(x + width, y + dy);\r\n        }\r\n    }\r\n    IconShape.prototype.iconLibrary['legendLineIcon'] = legendLineIcon;\r\n    \r\n    zrUtil.inherits(Line, ChartBase);\r\n    \r\n    // 图表注册\r\n    require('../chart').define('line', Line);\r\n    \r\n    return Line;\r\n});"
        },
        {
          "id": 68,
          "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
          "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
          "index": 68,
          "index2": 63,
          "size": 3072,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            5
          ],
          "assets": [],
          "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 67,
              "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
              "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
              "type": "cjs require",
              "userRequest": "../util/shape/HalfSmoothPolygon",
              "loc": "14:33-75"
            }
          ],
          "source": "/**\r\n * zrender\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * shape类：支持半平滑的polygon，折线面积图使用\r\n * 可配图形属性：\r\n   {\r\n       // 基础属性\r\n       shape  : 'halfSmoothPolygon',      // 必须，shape类标识，需要显式指定\r\n       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成\r\n       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中\r\n       invisible : {boolean},   // 默认为false，是否可见\r\n\r\n       // 样式属性，默认状态样式样式属性\r\n       style  : {\r\n           pointList     : {Array},   // 必须，多边形各个顶角坐标\r\n       },\r\n\r\n       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示\r\n       highlightStyle : {\r\n           // 同style\r\n       }\r\n\r\n       // 交互属性，详见shape.Base\r\n\r\n       // 事件属性，详见shape.Base\r\n   }\r\n         例子：\r\n   {\r\n       shape  : 'halfSmoothPolygon',\r\n       id     : '123456',\r\n       zlevel : 1,\r\n       style  : {\r\n           pointList : [[10, 10], [300, 20], [298, 400], [50, 450]]\r\n           color : '#eee',\r\n           text : 'Baidu'\r\n       },\r\n       myName : 'kener',  // 可自带任何有效自定义属性\r\n\r\n       clickable : true,\r\n       onClick : function (eventPacket) {\r\n           alert(eventPacket.target.myName);\r\n       }\r\n   }\r\n */\r\ndefine(function (require) {\r\n    var Base = require('zrenderjs/shape/Base');\r\n    var smoothBezier = require('zrenderjs/shape/util/smoothBezier');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    \r\n    function HalfSmoothPolygon(options) {\r\n        Base.call(this, options);\r\n    }\r\n\r\n    HalfSmoothPolygon.prototype = {\r\n        type : 'half-smooth-polygon',\r\n        /**\r\n         * 创建多边形路径\r\n         * @param {Context2D} ctx Canvas 2D上下文\r\n         * @param {Object} style 样式\r\n         */\r\n        buildPath : function (ctx, style) {\r\n            var pointList = style.pointList;\r\n            if (pointList.length < 2) {\r\n                // 少于2个点就不画了~\r\n                return;\r\n            }\r\n            if (style.smooth) {\r\n                var controlPoints = smoothBezier(\r\n                    pointList.slice(0, -2), style.smooth, false, style.smoothConstraint\r\n                );\r\n\r\n                ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                var cp1;\r\n                var cp2;\r\n                var p;\r\n                var l = pointList.length;\r\n                for (var i = 0; i < l - 3; i++) {\r\n                    cp1 = controlPoints[i * 2];\r\n                    cp2 = controlPoints[i * 2 + 1];\r\n                    p = pointList[i + 1];\r\n                    ctx.bezierCurveTo(\r\n                        cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\r\n                    );\r\n                }\r\n                ctx.lineTo(pointList[l - 2][0], pointList[l - 2][1]);\r\n                ctx.lineTo(pointList[l - 1][0], pointList[l - 1][1]);\r\n                ctx.lineTo(pointList[0][0], pointList[0][1]);\r\n            } \r\n            else {\r\n                require('zrenderjs/shape/Polygon').prototype.buildPath(\r\n                    ctx, style\r\n                );\r\n            }\r\n            return;\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(HalfSmoothPolygon, Base);\r\n    \r\n    return HalfSmoothPolygon;\r\n});"
        }
      ],
      "filteredModules": 0,
      "loc": "7:0-14:2",
      "origins": [
        {
          "moduleId": 66,
          "module": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "loc": "7:0-14:2",
          "name": null,
          "reasons": []
        }
      ]
    }
  ],
  "modules": [
    {
      "id": 0,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
      "name": "./parent.js",
      "index": 0,
      "index2": 68,
      "size": 76,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": null,
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [],
      "source": "require.ensure([], function(require) {\r\n\trequire('./echart');\r\n}, 'echart');"
    },
    {
      "id": 1,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\echart.js",
      "name": "./echart.js",
      "index": 1,
      "index2": 67,
      "size": 750,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        1
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 0,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\parent.js",
          "module": "./parent.js",
          "moduleName": "./parent.js",
          "type": "cjs require",
          "userRequest": "./echart",
          "loc": "2:1-20"
        }
      ],
      "source": "//var echarts = require('echarts/echarts');\r\nvar expr = 'bar';\r\n\r\n\trequire([\"bundle!echarts/chart/\" + expr + \".js\"], function(bundledResult) {\r\n\t\tbundledResult(function(result) {\r\n\t\t\tvar mychart = echarts.init(document.getElementById('root'));\r\n\t\t\tvar option = {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tshow: true\r\n\t\t\t\t},\r\n\t\t\t\tlegend: {\r\n\t\t\t\t\tdata:['销量']\r\n\t\t\t\t},\r\n\t\t\t\txAxis : [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttype : 'category',\r\n\t\t\t\t\t\tdata : [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"]\r\n\t\t\t\t\t}\r\n\t\t\t\t],\r\n\t\t\t\tyAxis : [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttype : 'value'\r\n\t\t\t\t\t}\r\n\t\t\t\t],\r\n\t\t\t\tseries : [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"name\":\"销量\",\r\n\t\t\t\t\t\t\"type\":\"bar\",\r\n\t\t\t\t\t\t\"data\":[5, 20, 40, 10, 10, 20]\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t};\r\n\r\n// 为echarts对象加载数1212s11ss11据\r\n\t\t\tmychart.setOption(option);\r\n\r\n\t\t});\r\n\t});\r\n\r\nmodule.exports = {};\r\n\r\n"
    },
    {
      "id": 2,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
      "index": 2,
      "index2": 66,
      "size": 217,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\echart.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\src\\echarts\\echart.js",
          "module": "./echart.js",
          "moduleName": "./echart.js",
          "type": "amd require context",
          "userRequest": "bundle!echarts/chart",
          "loc": "4:1-38:3"
        }
      ]
    },
    {
      "id": 3,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "name": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
      "index": 3,
      "index2": 58,
      "size": 280,
      "cacheable": true,
      "built": true,
      "optional": true,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
          "type": "context element",
          "userRequest": "./bar.js"
        }
      ],
      "source": "var cbs = [], \n\tdata;\nmodule.exports = function(cb) {\n\tif(cbs) cbs.push(cb);\n\telse cb(data);\n}\nrequire.ensure([], function(require) {\n\tdata = require(\"!!./bar.js\");\n\tvar callbacks = cbs;\n\tcbs = null;\n\tfor(var i = 0, l = callbacks.length; i < l; i++) {\n\t\tcallbacks[i](data);\n\t}\n});"
    },
    {
      "id": 4,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
      "index": 4,
      "index2": 57,
      "size": 42701,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        3
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 3,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "!!./bar.js",
          "loc": "8:8-29"
        }
      ],
      "source": "/**\r\n * echarts图表类：柱形图\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ChartBase = require('./base');\r\n    \r\n    // 图形依赖\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n    // 组件依赖\r\n    require('../component/axis');\r\n    require('../component/grid');\r\n    require('../component/dataZoom');\r\n    \r\n    var ecConfig = require('../config');\r\n    // 柱形图默认参数\r\n    ecConfig.bar = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 2,                       // 二级层叠\r\n        clickable: true,\r\n        legendHoverLink: true,\r\n        // stack: null\r\n        xAxisIndex: 0,\r\n        yAxisIndex: 0,\r\n        barMinHeight: 0,          // 最小高度改为0\r\n        // barWidth: null,        // 默认自适应\r\n        barGap: '30%',            // 柱间距离，默认为柱形宽度的30%，可设固定值\r\n        barCategoryGap: '20%',    // 类目间柱形距离，默认为类目间距的20%，可设固定值\r\n        itemStyle: {\r\n            normal: {\r\n                // color: '各异',\r\n                barBorderColor: '#fff',       // 柱条边线\r\n                barBorderRadius: 0,           // 柱条边线圆角，单位px，默认为0\r\n                barBorderWidth: 0,            // 柱条边线线宽，单位px，默认为1\r\n                label: {\r\n                    show: false\r\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\r\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\r\n                    //           'inside'|'left'|'right'|'top'|'bottom'\r\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                }\r\n            },\r\n            emphasis: {\r\n                // color: '各异',\r\n                barBorderColor: '#fff',            // 柱条边线\r\n                barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0\r\n                barBorderWidth: 0,                 // 柱条边线线宽，单位px，默认为1\r\n                label: {\r\n                    show: false\r\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\r\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\r\n                    //           'inside'|'left'|'right'|'top'|'bottom'\r\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    var ecData = require('../util/ecData');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrColor = require('zrenderjs/tool/color');\r\n    \r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} series 数据\r\n     * @param {Object} component 组件\r\n     */\r\n    function Bar(ecTheme, messageCenter, zr, option, myChart){\r\n        // 图表基类\r\n        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n        \r\n        this.refresh(option);\r\n    }\r\n    \r\n    Bar.prototype = {\r\n        type: ecConfig.CHART_TYPE_BAR,\r\n        /**\r\n         * 绘制图形\r\n         */\r\n        _buildShape: function () {\r\n            this._buildPosition();\r\n        },\r\n        \r\n        _buildNormal: function(seriesArray, maxDataLength, locationMap, xMarkMap, orient) {\r\n            var series = this.series;\r\n            // 确定类目轴和数值轴，同一方向随便找一个即可\r\n            var seriesIndex = locationMap[0][0];\r\n            var serie = series[seriesIndex];\r\n            var isHorizontal = orient == 'horizontal';\r\n            var xAxis = this.component.xAxis;\r\n            var yAxis = this.component.yAxis;\r\n            var categoryAxis = isHorizontal \r\n                               ? xAxis.getAxis(serie.xAxisIndex)\r\n                               : yAxis.getAxis(serie.yAxisIndex);\r\n            var valueAxis;  // 数值轴各异\r\n\r\n            var size = this._mapSize(categoryAxis, locationMap);\r\n            var gap = size.gap;\r\n            var barGap = size.barGap;\r\n            var barWidthMap = size.barWidthMap;\r\n            var barMaxWidthMap = size.barMaxWidthMap;\r\n            var barWidth = size.barWidth;                   // 自适应宽度\r\n            var barMinHeightMap = size.barMinHeightMap;\r\n            var barHeight;\r\n            var curBarWidth;\r\n            var interval = size.interval;\r\n\r\n            var x;\r\n            var y;\r\n            var lastP; // 正向堆积处理\r\n            var baseP;\r\n            var lastN; // 负向堆积处理\r\n            var baseN;\r\n            var barShape;\r\n            var data;\r\n            var value;\r\n            var islandR = this.deepQuery([this.ecTheme, ecConfig], 'island.r');\r\n            for (var i = 0, l = maxDataLength; i < l; i++) {\r\n                if (categoryAxis.getNameByIndex(i) == null) {\r\n                    // 系列数据超出类目轴长度\r\n                    break;\r\n                }\r\n                isHorizontal\r\n                    ? (x = categoryAxis.getCoordByIndex(i) - gap / 2)\r\n                    : (y = categoryAxis.getCoordByIndex(i) + gap / 2);\r\n\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    // 堆积数据用第一条valueAxis\r\n                    var yAxisIndex = series[locationMap[j][0]].yAxisIndex || 0;\r\n                    var xAxisIndex = series[locationMap[j][0]].xAxisIndex || 0;\r\n                    valueAxis = isHorizontal \r\n                                ? yAxis.getAxis(yAxisIndex)\r\n                                : xAxis.getAxis(xAxisIndex);\r\n                    baseP = lastP = baseN = lastN = valueAxis.getCoord(0);\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                                || {\r\n                                                    min: Number.POSITIVE_INFINITY,\r\n                                                    max: Number.NEGATIVE_INFINITY,\r\n                                                    sum: 0,\r\n                                                    counter: 0,\r\n                                                    average: 0\r\n                                                };\r\n                        curBarWidth = Math.min(\r\n                            barMaxWidthMap[seriesIndex] || Number.MAX_VALUE,\r\n                            barWidthMap[seriesIndex] || barWidth\r\n                        );\r\n                        if (value === '-') {\r\n                            // 空数据在做完后补充拖拽提示框\r\n                            continue;\r\n                        }\r\n                        if (value > 0) {\r\n                            // 正向堆积\r\n                            barHeight = m > 0 \r\n                                        ? valueAxis.getCoordSize(value)\r\n                                        : (\r\n                                            isHorizontal\r\n                                            ? (baseP - valueAxis.getCoord(value))\r\n                                            : (valueAxis.getCoord(value) - baseP)\r\n                                        );\r\n                            // 非堆积数据最小高度有效\r\n                            if (n === 1 && barMinHeightMap[seriesIndex] > barHeight) {\r\n                                barHeight = barMinHeightMap[seriesIndex];\r\n                            }\r\n                            if (isHorizontal) {\r\n                                lastP -= barHeight;\r\n                                y = lastP;\r\n                            }\r\n                            else {\r\n                                x = lastP;\r\n                                lastP += barHeight;\r\n                            }\r\n                        }\r\n                        else if (value < 0){\r\n                            // 负向堆积\r\n                            barHeight = m > 0 \r\n                                        ? valueAxis.getCoordSize(value)\r\n                                        : (\r\n                                            isHorizontal\r\n                                            ? (valueAxis.getCoord(value) - baseN)\r\n                                            : (baseN - valueAxis.getCoord(value))\r\n                                        );\r\n                            // 非堆积数据最小高度有效\r\n                            if (n === 1 && barMinHeightMap[seriesIndex] > barHeight) {\r\n                                barHeight = barMinHeightMap[seriesIndex];\r\n                            }\r\n                            if (isHorizontal) {\r\n                                y = lastN;\r\n                                lastN += barHeight;\r\n                            }\r\n                            else {\r\n                                lastN -= barHeight;\r\n                                x = lastN;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // 0值\r\n                            barHeight = 0;\r\n                            // 最小高度无效\r\n                            if (isHorizontal) {\r\n                                lastP -= barHeight;\r\n                                y = lastP;\r\n                            }\r\n                            else {\r\n                                x = lastP;\r\n                                lastP += barHeight;\r\n                            }\r\n                        }\r\n                        xMarkMap[seriesIndex][i] = isHorizontal\r\n                                                   ? (x + curBarWidth / 2) \r\n                                                   : (y - curBarWidth / 2);\r\n                        if (xMarkMap[seriesIndex].min > value) {\r\n                            xMarkMap[seriesIndex].min = value;\r\n                            if (isHorizontal) {\r\n                                xMarkMap[seriesIndex].minY = y;\r\n                                xMarkMap[seriesIndex].minX = xMarkMap[seriesIndex][i];\r\n                            }\r\n                            else {\r\n                                xMarkMap[seriesIndex].minX = x + barHeight;\r\n                                xMarkMap[seriesIndex].minY = xMarkMap[seriesIndex][i];\r\n                            }\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max < value) {\r\n                            xMarkMap[seriesIndex].max = value;\r\n                            if (isHorizontal) {\r\n                                xMarkMap[seriesIndex].maxY = y;\r\n                                xMarkMap[seriesIndex].maxX = xMarkMap[seriesIndex][i];\r\n                            }\r\n                            else {\r\n                                xMarkMap[seriesIndex].maxX = x + barHeight;\r\n                                xMarkMap[seriesIndex].maxY = xMarkMap[seriesIndex][i];\r\n                            }\r\n                            \r\n                        }\r\n                        xMarkMap[seriesIndex].sum += value;\r\n                        xMarkMap[seriesIndex].counter++;\r\n                        \r\n                        if (i % interval === 0) {\r\n                            barShape = this._getBarItem(\r\n                                seriesIndex, i,\r\n                                categoryAxis.getNameByIndex(i),\r\n                                x,\r\n                                y - (isHorizontal ? 0 : curBarWidth),\r\n                                isHorizontal ? curBarWidth : barHeight,\r\n                                isHorizontal ? barHeight : curBarWidth,\r\n                                isHorizontal ? 'vertical' : 'horizontal'\r\n                            );\r\n                            this.shapeList.push(new RectangleShape(barShape));\r\n                        }\r\n                    }\r\n\r\n                    // 补充空数据的拖拽提示框\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        curBarWidth = Math.min(\r\n                            barMaxWidthMap[seriesIndex] || Number.MAX_VALUE,\r\n                            barWidthMap[seriesIndex] || barWidth\r\n                        );\r\n                        if (value != '-') {\r\n                            // 只关心空数据\r\n                            continue;\r\n                        }\r\n\r\n                        if (this.deepQuery([data, serie, this.option], 'calculable')) {\r\n                            if (isHorizontal) {\r\n                                lastP -= islandR;\r\n                                y = lastP;\r\n                            }\r\n                            else {\r\n                                x = lastP;\r\n                                lastP += islandR;\r\n                            }\r\n                            \r\n                            barShape = this._getBarItem(\r\n                                seriesIndex, i,\r\n                                categoryAxis.getNameByIndex(i),\r\n                                x,\r\n                                y - (isHorizontal ? 0 : curBarWidth),\r\n                                isHorizontal ? curBarWidth : islandR,\r\n                                isHorizontal ? islandR : curBarWidth,\r\n                                isHorizontal ? 'vertical' : 'horizontal'\r\n                            );\r\n                            barShape.hoverable = false;\r\n                            barShape.draggable = false;\r\n                            barShape.style.lineWidth = 1;\r\n                            barShape.style.brushType = 'stroke';\r\n                            barShape.style.strokeColor = serie.calculableHolderColor\r\n                                                         || this.ecTheme.calculableHolderColor\r\n                                                         || ecConfig.calculableHolderColor;\r\n\r\n                            this.shapeList.push(new RectangleShape(barShape));\r\n                        }\r\n                    }\r\n                    isHorizontal\r\n                        ? (x += (curBarWidth + barGap))\r\n                        : (y -= (curBarWidth + barGap));\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, isHorizontal ? 'y' : 'x');\r\n        },\r\n        /**\r\n         * 构建类目轴为水平方向的柱形图系列\r\n         */\r\n        _buildHorizontal: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            return this._buildNormal(\r\n                seriesArray, maxDataLength, locationMap, xMarkMap, 'horizontal'\r\n            );\r\n        },\r\n\r\n        /**\r\n         * 构建类目轴为垂直方向的柱形图系列\r\n         */\r\n        _buildVertical: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            return this._buildNormal(\r\n                seriesArray, maxDataLength, locationMap, xMarkMap, 'vertical'\r\n            );\r\n        },\r\n        \r\n        /**\r\n         * 构建双数值轴柱形图\r\n         */\r\n        _buildOther: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            var series = this.series;\r\n            \r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                    var seriesIndex = locationMap[j][m];\r\n                    var serie = series[seriesIndex];\r\n                    var xAxisIndex = serie.xAxisIndex || 0;\r\n                    var xAxis = this.component.xAxis.getAxis(xAxisIndex);\r\n                    var baseX = xAxis.getCoord(0);\r\n                    var yAxisIndex = serie.yAxisIndex || 0;\r\n                    var yAxis = this.component.yAxis.getAxis(yAxisIndex);\r\n                    var baseY = yAxis.getCoord(0);\r\n                    \r\n                    xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                            || {\r\n                                                min0: Number.POSITIVE_INFINITY,\r\n                                                min1: Number.POSITIVE_INFINITY,\r\n                                                max0: Number.NEGATIVE_INFINITY,\r\n                                                max1: Number.NEGATIVE_INFINITY,\r\n                                                sum0: 0,\r\n                                                sum1: 0,\r\n                                                counter0: 0,\r\n                                                counter1: 0,\r\n                                                average0: 0,\r\n                                                average1: 0\r\n                                            };\r\n\r\n                    for (var i = 0, l = serie.data.length; i < l; i++) {\r\n                        var data = serie.data[i];\r\n                        var value = this.getDataFromOption(data, '-');\r\n                        if (!(value instanceof Array)) {\r\n                            continue;\r\n                        }\r\n                        \r\n                        var x = xAxis.getCoord(value[0]);\r\n                        var y = yAxis.getCoord(value[1]);\r\n                        \r\n                        var queryTarget = [data, serie];\r\n                        var barWidth = this.deepQuery(queryTarget, 'barWidth') || 10; // 默认柱形\r\n                        var barHeight = this.deepQuery(queryTarget, 'barHeight');\r\n                        var orient;\r\n                        var barShape;\r\n                        \r\n                        if (barHeight != null) {\r\n                            // 条形图\r\n                            orient = 'horizontal';\r\n                            \r\n                            if (value[0] > 0) {\r\n                                // 正向\r\n                                barWidth = x - baseX;\r\n                                x -= barWidth;\r\n                            }\r\n                            else if (value[0] < 0){\r\n                                // 负向\r\n                                barWidth = baseX - x;\r\n                            }\r\n                            else {\r\n                                // 0值\r\n                                barWidth = 0;\r\n                            }\r\n                            \r\n                            barShape = this._getBarItem(\r\n                                seriesIndex, i,\r\n                                value[0],\r\n                                x, \r\n                                y - barHeight / 2,\r\n                                barWidth,\r\n                                barHeight,\r\n                                orient\r\n                            );\r\n                        }\r\n                        else {\r\n                            // 柱形\r\n                            orient = 'vertical';\r\n                            \r\n                            if (value[1] > 0) {\r\n                            // 正向\r\n                                barHeight = baseY - y;\r\n                            }\r\n                            else if (value[1] < 0){\r\n                                // 负向\r\n                                barHeight = y - baseY;\r\n                                y -= barHeight;\r\n                            }\r\n                            else {\r\n                                // 0值\r\n                                barHeight = 0;\r\n                            }\r\n                            barShape = this._getBarItem(\r\n                                seriesIndex, i,\r\n                                value[0],\r\n                                x - barWidth / 2, \r\n                                y,\r\n                                barWidth,\r\n                                barHeight,\r\n                                orient\r\n                            );\r\n                        }\r\n                        this.shapeList.push(new RectangleShape(barShape));\r\n                        \r\n                        \r\n                        x = xAxis.getCoord(value[0]);\r\n                        y = yAxis.getCoord(value[1]);\r\n                        if (xMarkMap[seriesIndex].min0 > value[0]) {\r\n                            xMarkMap[seriesIndex].min0 = value[0];\r\n                            xMarkMap[seriesIndex].minY0 = y;\r\n                            xMarkMap[seriesIndex].minX0 = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max0 < value[0]) {\r\n                            xMarkMap[seriesIndex].max0 = value[0];\r\n                            xMarkMap[seriesIndex].maxY0 = y;\r\n                            xMarkMap[seriesIndex].maxX0 = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum0 += value[0];\r\n                        xMarkMap[seriesIndex].counter0++;\r\n                        \r\n                        if (xMarkMap[seriesIndex].min1 > value[1]) {\r\n                            xMarkMap[seriesIndex].min1 = value[1];\r\n                            xMarkMap[seriesIndex].minY1 = y;\r\n                            xMarkMap[seriesIndex].minX1 = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max1 < value[1]) {\r\n                            xMarkMap[seriesIndex].max1 = value[1];\r\n                            xMarkMap[seriesIndex].maxY1 = y;\r\n                            xMarkMap[seriesIndex].maxX1 = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum1 += value[1];\r\n                        xMarkMap[seriesIndex].counter1++;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, 'xy');\r\n        },\r\n        \r\n        /**\r\n         * 我真是自找麻烦啊，为啥要允许系列级个性化最小宽度和高度啊！！！\r\n         * @param {CategoryAxis} categoryAxis 类目坐标轴，需要知道类目间隔大小\r\n         * @param {Array} locationMap 整形数据的系列索引\r\n         */\r\n        _mapSize: function (categoryAxis, locationMap, ignoreUserDefined) {\r\n            var res = this._findSpecialBarSzie(locationMap, ignoreUserDefined);\r\n            var barWidthMap = res.barWidthMap;\r\n            var barMaxWidthMap = res.barMaxWidthMap;\r\n            var barMinHeightMap = res.barMinHeightMap;\r\n            var sBarWidthCounter = res.sBarWidthCounter;    // 用户指定\r\n            var sBarWidthTotal = res.sBarWidthTotal;        // 用户指定\r\n            var barGap = res.barGap;\r\n            var barCategoryGap = res.barCategoryGap;\r\n            \r\n            var gap;\r\n            var barWidth;\r\n            var interval = 1;\r\n            if (locationMap.length != sBarWidthCounter) {\r\n                // 至少存在一个自适应宽度的柱形图\r\n                if (!ignoreUserDefined) {\r\n                    gap = typeof barCategoryGap === 'string' && barCategoryGap.match(/%$/)\r\n                          // 百分比\r\n                          ? ((categoryAxis.getGap() * (100 - parseFloat(barCategoryGap)) / 100).toFixed(2) - 0)\r\n                          // 数值\r\n                          : (categoryAxis.getGap() - barCategoryGap);\r\n                    if (typeof barGap === 'string' && barGap.match(/%$/)) {\r\n                        barGap = parseFloat(barGap) / 100;\r\n                        barWidth = +(\r\n                            (gap - sBarWidthTotal) / (\r\n                                (locationMap.length - 1) * barGap + locationMap.length - sBarWidthCounter\r\n                            )\r\n                        ).toFixed(2);\r\n                        barGap = barWidth * barGap;\r\n                    }\r\n                    else {\r\n                        barGap = parseFloat(barGap);\r\n                        barWidth = +(\r\n                            (gap - sBarWidthTotal - barGap * (locationMap.length - 1)) / (\r\n                                locationMap.length - sBarWidthCounter\r\n                            )\r\n                        ).toFixed(2);\r\n                    }\r\n                    // 无法满足用户定义的宽度设计，忽略用户宽度，打回重做\r\n                    if (barWidth <= 0) {\r\n                        return this._mapSize(categoryAxis, locationMap, true);\r\n                    }\r\n                }\r\n                else {\r\n                    // 忽略用户定义的宽度设定\r\n                    gap = categoryAxis.getGap();\r\n                    barGap = 0;\r\n                    barWidth = +(gap / locationMap.length).toFixed(2);\r\n                    // 已经忽略用户定义的宽度设定依然还无法满足显示，只能硬来了;\r\n                    if (barWidth <= 0) {\r\n                        interval = Math.floor(locationMap.length / gap);\r\n                        barWidth = 1;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // 全是自定义宽度，barGap无效，系列间隔决定barGap\r\n                gap = sBarWidthCounter > 1\r\n                      ? (typeof barCategoryGap === 'string' && barCategoryGap.match(/%$/))\r\n                          // 百分比\r\n                          ? +(categoryAxis.getGap() * (100 - parseFloat(barCategoryGap)) / 100).toFixed(2)\r\n                          // 数值\r\n                          : (categoryAxis.getGap() - barCategoryGap)\r\n                      // 只有一个\r\n                      : sBarWidthTotal;\r\n                barWidth = 0;\r\n                barGap = sBarWidthCounter > 1 \r\n                         ? +((gap - sBarWidthTotal) / (sBarWidthCounter - 1)).toFixed(2)\r\n                         : 0;\r\n                if (barGap < 0) {\r\n                    // 无法满足用户定义的宽度设计，忽略用户宽度，打回重做\r\n                    return this._mapSize(categoryAxis, locationMap, true);\r\n                }\r\n            }\r\n            \r\n            // 检查是否满足barMaxWidthMap\r\n            \r\n            return this._recheckBarMaxWidth(\r\n                locationMap,\r\n                barWidthMap, barMaxWidthMap, barMinHeightMap,\r\n                gap,   // 总宽度\r\n                barWidth, barGap, interval\r\n            );\r\n        },\r\n        \r\n        /**\r\n         * 计算堆积下用户特殊指定的各种size \r\n         */\r\n        _findSpecialBarSzie: function(locationMap, ignoreUserDefined) {\r\n            var series = this.series;\r\n            var barWidthMap = {};\r\n            var barMaxWidthMap = {};\r\n            var barMinHeightMap = {};\r\n            var sBarWidth;              // 用户指定\r\n            var sBarMaxWidth;           // 用户指定\r\n            var sBarWidthCounter = 0;   // 用户指定\r\n            var sBarWidthTotal = 0;     // 用户指定\r\n            var barGap;\r\n            var barCategoryGap;\r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                var hasFound = {\r\n                    barWidth: false,\r\n                    barMaxWidth: false\r\n                };\r\n                for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                    var seriesIndex = locationMap[j][m];\r\n                    var queryTarget = series[seriesIndex];\r\n                    if (!ignoreUserDefined) {\r\n                        if (!hasFound.barWidth) {\r\n                            sBarWidth = this.query(queryTarget, 'barWidth');\r\n                            if (sBarWidth != null) {\r\n                                // 同一堆积第一个生效barWidth\r\n                                barWidthMap[seriesIndex] = sBarWidth;\r\n                                sBarWidthTotal += sBarWidth;\r\n                                sBarWidthCounter++;\r\n                                hasFound.barWidth = true;\r\n                                // 复位前面同一堆积但没被定义的\r\n                                for (var ii = 0, ll = m; ii < ll; ii++) {\r\n                                    var pSeriesIndex = locationMap[j][ii];\r\n                                    barWidthMap[pSeriesIndex] = sBarWidth;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            barWidthMap[seriesIndex] = sBarWidth;   // 用找到的一个\r\n                        }\r\n                        \r\n                        if (!hasFound.barMaxWidth) {\r\n                            sBarMaxWidth = this.query(queryTarget, 'barMaxWidth');\r\n                            if (sBarMaxWidth != null) {\r\n                                // 同一堆积第一个生效barMaxWidth\r\n                                barMaxWidthMap[seriesIndex] = sBarMaxWidth;\r\n                                hasFound.barMaxWidth = true;\r\n                                // 复位前面同一堆积但没被定义的\r\n                                for (var ii = 0, ll = m; ii < ll; ii++) {\r\n                                    var pSeriesIndex = locationMap[j][ii];\r\n                                    barMaxWidthMap[pSeriesIndex] = sBarMaxWidth;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            barMaxWidthMap[seriesIndex] = sBarMaxWidth;   // 用找到的一个\r\n                        }\r\n                    }\r\n\r\n                    barMinHeightMap[seriesIndex] = this.query(queryTarget, 'barMinHeight');\r\n                    barGap = barGap != null ? barGap : this.query(queryTarget, 'barGap');\r\n                    barCategoryGap = barCategoryGap != null \r\n                                     ? barCategoryGap : this.query(queryTarget, 'barCategoryGap');\r\n                }\r\n            }\r\n            \r\n            return {\r\n                barWidthMap: barWidthMap,\r\n                barMaxWidthMap: barMaxWidthMap,\r\n                barMinHeightMap: barMinHeightMap,\r\n                sBarWidth: sBarWidth,\r\n                sBarMaxWidth: sBarMaxWidth,\r\n                sBarWidthCounter: sBarWidthCounter,\r\n                sBarWidthTotal: sBarWidthTotal,\r\n                barGap: barGap,\r\n                barCategoryGap: barCategoryGap\r\n            };\r\n        },\r\n        \r\n        /**\r\n         * 检查是否满足barMaxWidthMap \r\n         */\r\n        _recheckBarMaxWidth: function(\r\n                locationMap,\r\n                barWidthMap, barMaxWidthMap, barMinHeightMap,\r\n                gap,   // 总宽度\r\n                barWidth, barGap, interval\r\n        ) {\r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                var seriesIndex = locationMap[j][0];\r\n                if (barMaxWidthMap[seriesIndex] && barMaxWidthMap[seriesIndex] < barWidth) {\r\n                    // 不满足最大宽度\r\n                    gap -= barWidth - barMaxWidthMap[seriesIndex]; // 总宽度减少\r\n                }\r\n            }\r\n            \r\n            return {\r\n                barWidthMap: barWidthMap,\r\n                barMaxWidthMap: barMaxWidthMap,\r\n                barMinHeightMap: barMinHeightMap ,\r\n                gap: gap,   // 总宽度\r\n                barWidth: barWidth,\r\n                barGap: barGap,\r\n                interval: interval\r\n            };\r\n        },\r\n        \r\n        /**\r\n         * 生成最终图形数据\r\n         */\r\n        _getBarItem: function (seriesIndex, dataIndex, name, x, y, width, height, orient) {\r\n            var series = this.series;\r\n            var barShape;\r\n            var serie = series[seriesIndex];\r\n            var data = serie.data[dataIndex];\r\n            // 多级控制\r\n            var defaultColor = this._sIndex2ColorMap[seriesIndex];\r\n            var queryTarget = [data, serie];\r\n            \r\n            var normal = this.deepMerge(queryTarget, 'itemStyle.normal');\r\n            var emphasis = this.deepMerge(queryTarget, 'itemStyle.emphasis');\r\n            var normalBorderWidth = normal.barBorderWidth;\r\n            \r\n            barShape = {\r\n                zlevel: serie.zlevel,\r\n                z: serie.z,\r\n                clickable: this.deepQuery(queryTarget, 'clickable'),\r\n                style: {\r\n                    x: x,\r\n                    y: y,\r\n                    width: width,\r\n                    height: height,\r\n                    brushType: 'both',\r\n                    color: this.getItemStyleColor(\r\n                        this.deepQuery(queryTarget, 'itemStyle.normal.color') || defaultColor,\r\n                        seriesIndex, dataIndex, data\r\n                    ),\r\n                    radius: normal.barBorderRadius,\r\n                    lineWidth: normalBorderWidth,\r\n                    strokeColor: normal.barBorderColor\r\n                },\r\n                highlightStyle: {\r\n                    color: this.getItemStyleColor(\r\n                        this.deepQuery(queryTarget, 'itemStyle.emphasis.color'),\r\n                        seriesIndex, dataIndex, data\r\n                    ),\r\n                    radius: emphasis.barBorderRadius,\r\n                    lineWidth: emphasis.barBorderWidth,\r\n                    strokeColor: emphasis.barBorderColor\r\n                },\r\n                _orient: orient\r\n            };\r\n            var barShapeStyle = barShape.style;\r\n            barShape.highlightStyle.color = barShape.highlightStyle.color\r\n                            || (typeof barShapeStyle.color === 'string'\r\n                                ? zrColor.lift(barShapeStyle.color, -0.3)\r\n                                : barShapeStyle.color\r\n                               );\r\n            //亚像素优化\r\n            barShapeStyle.x = Math.floor(barShapeStyle.x);\r\n            barShapeStyle.y = Math.floor(barShapeStyle.y);\r\n            barShapeStyle.height = Math.ceil(barShapeStyle.height);\r\n            barShapeStyle.width = Math.ceil(barShapeStyle.width);\r\n            // 考虑线宽的显示优化\r\n            if (normalBorderWidth > 0\r\n                && barShapeStyle.height > normalBorderWidth\r\n                && barShapeStyle.width > normalBorderWidth\r\n            ) {\r\n                barShapeStyle.y += normalBorderWidth / 2;\r\n                barShapeStyle.height -= normalBorderWidth;\r\n                barShapeStyle.x += normalBorderWidth / 2;\r\n                barShapeStyle.width -= normalBorderWidth;\r\n            }\r\n            else {\r\n                // 太小了或者线宽小于0，废了边线\r\n                barShapeStyle.brushType = 'fill';\r\n            }\r\n            \r\n            barShape.highlightStyle.textColor = barShape.highlightStyle.color;\r\n            \r\n            barShape = this.addLabel(barShape, serie, data, name, orient);\r\n            var barShapeStyleList = [                    // normal emphasis都需要检查\r\n                barShapeStyle,\r\n                barShape.highlightStyle\r\n            ];\r\n            for (var i = 0, l = barShapeStyleList.length; i < l; i++) {\r\n                var textPosition = barShapeStyleList[i].textPosition;\r\n                if (textPosition === 'insideLeft'\r\n                    || textPosition === 'insideRight'\r\n                    || textPosition === 'insideTop'\r\n                    || textPosition === 'insideBottom'\r\n                ) {\r\n                    var gap = 5;\r\n                    switch (textPosition) {\r\n                        case 'insideLeft':\r\n                            barShapeStyleList[i].textX = barShapeStyle.x + gap;\r\n                            barShapeStyleList[i].textY = barShapeStyle.y + barShapeStyle.height / 2;\r\n                            barShapeStyleList[i].textAlign = 'left';\r\n                            barShapeStyleList[i].textBaseline = 'middle';\r\n                            break;\r\n                        case 'insideRight':\r\n                            barShapeStyleList[i].textX = barShapeStyle.x + barShapeStyle.width - gap;\r\n                            barShapeStyleList[i].textY = barShapeStyle.y + barShapeStyle.height / 2;\r\n                            barShapeStyleList[i].textAlign = 'right';\r\n                            barShapeStyleList[i].textBaseline = 'middle';\r\n                            break;\r\n                        case 'insideTop':\r\n                            barShapeStyleList[i].textX = barShapeStyle.x + barShapeStyle.width / 2;\r\n                            barShapeStyleList[i].textY = barShapeStyle.y + gap / 2;\r\n                            barShapeStyleList[i].textAlign = 'center';\r\n                            barShapeStyleList[i].textBaseline = 'top';\r\n                            break;\r\n                        case 'insideBottom':\r\n                            barShapeStyleList[i].textX = barShapeStyle.x + barShapeStyle.width / 2;\r\n                            barShapeStyleList[i].textY = barShapeStyle.y + barShapeStyle.height - gap / 2;\r\n                            barShapeStyleList[i].textAlign = 'center';\r\n                            barShapeStyleList[i].textBaseline = 'bottom';\r\n                            break;\r\n                    }\r\n                    barShapeStyleList[i].textPosition = 'specific';\r\n                    barShapeStyleList[i].textColor = barShapeStyleList[i].textColor || '#fff';\r\n                }\r\n            }\r\n            \r\n\r\n            if (this.deepQuery([data, serie, this.option],'calculable')) {\r\n                this.setCalculable(barShape);\r\n                barShape.draggable = true;\r\n            }\r\n\r\n            ecData.pack(\r\n                barShape,\r\n                series[seriesIndex], seriesIndex,\r\n                series[seriesIndex].data[dataIndex], dataIndex,\r\n                name\r\n            );\r\n\r\n            return barShape;\r\n        },\r\n\r\n        // 位置转换\r\n        getMarkCoord: function (seriesIndex, mpData) {\r\n            var serie = this.series[seriesIndex];\r\n            var xMarkMap = this.xMarkMap[seriesIndex];\r\n            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);\r\n            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);\r\n            var dataIndex;\r\n            var pos;\r\n            if (mpData.type\r\n                && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')\r\n            ) {\r\n                // 特殊值内置支持\r\n                var valueIndex = mpData.valueIndex != null \r\n                                 ? mpData.valueIndex \r\n                                 : xMarkMap.maxX0 != null \r\n                                   ? '1' : '';\r\n                pos = [\r\n                    xMarkMap[mpData.type + 'X' + valueIndex],\r\n                    xMarkMap[mpData.type + 'Y' + valueIndex],\r\n                    xMarkMap[mpData.type + 'Line' + valueIndex],\r\n                    xMarkMap[mpData.type + valueIndex]\r\n                ];\r\n            }\r\n            else if (xMarkMap.isHorizontal) {\r\n                // 横向\r\n                dataIndex = typeof mpData.xAxis === 'string' && xAxis.getIndexByName\r\n                            ? xAxis.getIndexByName(mpData.xAxis)\r\n                            : (mpData.xAxis || 0);\r\n                \r\n                var x = xMarkMap[dataIndex];\r\n                x = x != null\r\n                    ? x \r\n                    : typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex\r\n                      ? xAxis.getCoordByIndex(mpData.xAxis || 0)\r\n                      : xAxis.getCoord(mpData.xAxis || 0);\r\n                \r\n                pos = [x, yAxis.getCoord(mpData.yAxis || 0)];\r\n            }\r\n            else {\r\n                // 纵向\r\n                dataIndex = typeof mpData.yAxis === 'string' && yAxis.getIndexByName\r\n                            ? yAxis.getIndexByName(mpData.yAxis)\r\n                            : (mpData.yAxis || 0);\r\n                \r\n                var y = xMarkMap[dataIndex];\r\n                y = y != null\r\n                    ? y\r\n                    : typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex\r\n                      ? yAxis.getCoordByIndex(mpData.yAxis || 0)\r\n                      : yAxis.getCoord(mpData.yAxis || 0);\r\n                \r\n                pos = [xAxis.getCoord(mpData.xAxis || 0), y];\r\n            }\r\n            \r\n            return pos;\r\n        },\r\n        \r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption) {\r\n            if (newOption) {\r\n                this.option = newOption;\r\n                this.series = newOption.series;\r\n            }\r\n            \r\n            this.backupShapeList();\r\n            this._buildShape();\r\n        },\r\n        \r\n        /**\r\n         * 动态数据增加动画 \r\n         */\r\n        addDataAnimation: function (params, done) {\r\n            var series = this.series;\r\n            var aniMap = {}; // seriesIndex索引参数\r\n            for (var i = 0, l = params.length; i < l; i++) {\r\n                aniMap[params[i][0]] = params[i];\r\n            }\r\n            var x;\r\n            var dx;\r\n            var y;\r\n            var dy;\r\n            var serie;\r\n            var seriesIndex;\r\n            var dataIndex;\r\n\r\n            var aniCount = 0;\r\n            function animationDone() {\r\n                aniCount--;\r\n                if (aniCount === 0) {\r\n                    done && done();\r\n                }\r\n            }\r\n            for (var i = this.shapeList.length - 1; i >= 0; i--) {\r\n                seriesIndex = ecData.get(this.shapeList[i], 'seriesIndex');\r\n                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {\r\n                    // 有数据删除才有移动的动画\r\n                    if (this.shapeList[i].type === 'rectangle') {\r\n                        // 主动画\r\n                        dataIndex = ecData.get(this.shapeList[i], 'dataIndex');\r\n                        serie = series[seriesIndex];\r\n                        if (aniMap[seriesIndex][2] && dataIndex === serie.data.length - 1) {\r\n                            // 队头加入删除末尾\r\n                            this.zr.delShape(this.shapeList[i].id);\r\n                            continue;\r\n                        }\r\n                        else if (!aniMap[seriesIndex][2] && dataIndex === 0) {\r\n                            // 队尾加入删除头部\r\n                            this.zr.delShape(this.shapeList[i].id);\r\n                            continue;\r\n                        }\r\n                        if (this.shapeList[i]._orient === 'horizontal') {\r\n                            // 条形图\r\n                            dy = this.component.yAxis.getAxis(serie.yAxisIndex || 0).getGap();\r\n                            y = aniMap[seriesIndex][2] ? -dy : dy;\r\n                            x = 0;\r\n                        }\r\n                        else {\r\n                            // 柱形图\r\n                            dx = this.component.xAxis.getAxis(serie.xAxisIndex || 0).getGap();\r\n                            x = aniMap[seriesIndex][2] ? dx : -dx;\r\n                            y = 0;\r\n                        }\r\n                        this.shapeList[i].position = [0, 0];\r\n\r\n                        aniCount++;\r\n                        this.zr.animate(this.shapeList[i].id, '')\r\n                            .when(\r\n                                this.query(this.option, 'animationDurationUpdate'),\r\n                                { position: [x, y] }\r\n                            )\r\n                            .done(animationDone)\r\n                            .start();\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // 没有动画\r\n            if (!aniCount) {\r\n                done && done();\r\n            }\r\n        }\r\n    };\r\n    \r\n    zrUtil.inherits(Bar, ChartBase);\r\n    \r\n    // 图表注册\r\n    require('../chart').define('bar', Bar);\r\n    \r\n    return Bar;\r\n});"
    },
    {
      "id": 5,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
      "index": 5,
      "index2": 44,
      "size": 70590,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "./base",
          "loc": "9:20-37"
        },
        {
          "moduleId": 62,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "!!./base.js",
          "loc": "8:8-30"
        },
        {
          "moduleId": 64,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "./base",
          "loc": "9:20-37"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "./base",
          "loc": "9:20-37"
        }
      ],
      "source": "/**\r\n * echarts图表基类\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    // 图形依赖\r\n    var ImageShape = require('zrenderjs/shape/Image');\r\n    var IconShape = require('../util/shape/Icon');\r\n    var MarkLineShape = require('../util/shape/MarkLine');\r\n    var SymbolShape = require('../util/shape/Symbol');\r\n    var PolylineShape = require('zrenderjs/shape/Polyline');\r\n    var ShapeBundle = require('zrenderjs/shape/ShapeBundle');\r\n    \r\n    var ecConfig = require('../config');\r\n    var ecData = require('../util/ecData');\r\n    var ecAnimation = require('../util/ecAnimation');\r\n    var ecEffect = require('../util/ecEffect');\r\n    var accMath = require('../util/accMath');\r\n    var ComponentBase = require('../component/base');\r\n    var EdgeBundling = require('../layout/EdgeBundling');\r\n\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrArea = require('zrenderjs/tool/area');\r\n\r\n    // Some utility functions\r\n    function isCoordAvailable(coord) {\r\n        return coord.x != null && coord.y != null;\r\n    }\r\n    \r\n    function Base(ecTheme, messageCenter, zr, option, myChart) {\r\n\r\n        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        var self = this;\r\n        this.selectedMap = {};\r\n        this.lastShapeList = [];\r\n        this.shapeHandler = {\r\n            onclick: function () {\r\n                self.isClick = true;\r\n            },\r\n            \r\n            ondragover: function (param) {\r\n                // 返回触发可计算特性的图形提示\r\n                var calculableShape = param.target;\r\n                calculableShape.highlightStyle = calculableShape.highlightStyle || {};\r\n                \r\n                // 备份特出特性\r\n                var highlightStyle = calculableShape.highlightStyle;\r\n                var brushType = highlightStyle.brushTyep;\r\n                var strokeColor = highlightStyle.strokeColor;\r\n                var lineWidth = highlightStyle.lineWidth;\r\n                \r\n                highlightStyle.brushType = 'stroke';\r\n                highlightStyle.strokeColor = self.ecTheme.calculableColor\r\n                                             || ecConfig.calculableColor;\r\n                highlightStyle.lineWidth = calculableShape.type === 'icon' ? 30 : 10;\r\n\r\n                self.zr.addHoverShape(calculableShape);\r\n                \r\n                setTimeout(function (){\r\n                    // 复位\r\n                    if (highlightStyle) {\r\n                        highlightStyle.brushType = brushType;\r\n                        highlightStyle.strokeColor = strokeColor;\r\n                        highlightStyle.lineWidth = lineWidth;\r\n                    }\r\n                },20);\r\n            },\r\n            \r\n            ondrop: function (param) {\r\n                // 排除一些非数据的拖拽进入\r\n                if (ecData.get(param.dragged, 'data') != null) {\r\n                    self.isDrop = true;\r\n                }\r\n            },\r\n            \r\n            ondragend: function () {\r\n                self.isDragend = true;\r\n            }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * 基类方法\r\n     */\r\n    Base.prototype = {\r\n        /**\r\n         * 图形拖拽特性 \r\n         */\r\n        setCalculable: function (shape) {\r\n            shape.dragEnableTime = this.ecTheme.DRAG_ENABLE_TIME || ecConfig.DRAG_ENABLE_TIME;\r\n            shape.ondragover = this.shapeHandler.ondragover;\r\n            shape.ondragend = this.shapeHandler.ondragend;\r\n            shape.ondrop = this.shapeHandler.ondrop;\r\n            return shape;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽进来\r\n         */\r\n        ondrop: function (param, status) {\r\n            if (!this.isDrop || !param.target || status.dragIn) {\r\n                // 没有在当前实例上发生拖拽行为或者已经被认领了则直接返回\r\n                return;\r\n            }\r\n            var target = param.target;      // 拖拽安放目标\r\n            var dragged = param.dragged;    // 当前被拖拽的图形对象\r\n\r\n            var seriesIndex = ecData.get(target, 'seriesIndex');\r\n            var dataIndex = ecData.get(target, 'dataIndex');\r\n\r\n            var series = this.series;\r\n            var data;\r\n            var legend = this.component.legend;\r\n            if (dataIndex === -1) {\r\n                // 落到calculableCase上，数据被拖拽进某个饼图|雷达|漏斗，增加数据\r\n                if (ecData.get(dragged, 'seriesIndex') == seriesIndex) {\r\n                    // 自己拖拽到自己\r\n                    status.dragOut = status.dragIn = status.needRefresh = true;\r\n                    this.isDrop = false;\r\n                    return;\r\n                }\r\n                \r\n                data = {\r\n                    value: ecData.get(dragged, 'value'),\r\n                    name: ecData.get(dragged, 'name')\r\n                };\r\n\r\n                // 修饼图数值不为负值\r\n                if (this.type === ecConfig.CHART_TYPE_PIE && data.value < 0) {\r\n                    data.value = 0;\r\n                }\r\n\r\n                var hasFind = false;\r\n                var sData = series[seriesIndex].data;\r\n                for (var i = 0, l = sData.length; i < l; i++) {\r\n                    if (sData[i].name === data.name && sData[i].value === '-') {\r\n                        series[seriesIndex].data[i].value = data.value;\r\n                        hasFind = true;\r\n                    }\r\n                }\r\n                !hasFind && series[seriesIndex].data.push(data);\r\n\r\n                legend && legend.add(\r\n                    data.name,\r\n                    dragged.style.color || dragged.style.strokeColor\r\n                );\r\n            }\r\n            else {\r\n                // 落到数据item上，数据被拖拽到某个数据项上，数据修改\r\n                data = series[seriesIndex].data[dataIndex] || '-';\r\n                if (data.value != null) {\r\n                    if (data.value != '-') {\r\n                        series[seriesIndex].data[dataIndex].value = \r\n                            accMath.accAdd(\r\n                                series[seriesIndex].data[dataIndex].value,\r\n                                ecData.get(dragged, 'value')\r\n                            );\r\n                    }\r\n                    else {\r\n                        series[seriesIndex].data[dataIndex].value =\r\n                            ecData.get(dragged, 'value');\r\n                    }\r\n                    \r\n                    if (this.type === ecConfig.CHART_TYPE_FUNNEL\r\n                        || this.type === ecConfig.CHART_TYPE_PIE\r\n                    ) {\r\n                        legend && legend.getRelatedAmount(data.name) === 1 \r\n                               && this.component.legend.del(data.name);\r\n                        data.name += this.option.nameConnector + ecData.get(dragged, 'name');\r\n                        legend && legend.add(\r\n                            data.name,\r\n                            dragged.style.color || dragged.style.strokeColor\r\n                        );\r\n                    }\r\n                }\r\n                else {\r\n                    if (data != '-') {\r\n                        series[seriesIndex].data[dataIndex] = \r\n                            accMath.accAdd(\r\n                                series[seriesIndex].data[dataIndex],\r\n                                ecData.get(dragged, 'value')\r\n                            );\r\n                    }\r\n                    else {\r\n                        series[seriesIndex].data[dataIndex] =\r\n                            ecData.get(dragged, 'value');\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 别status = {}赋值啊！！\r\n            status.dragIn = status.dragIn || true;\r\n\r\n            // 处理完拖拽事件后复位\r\n            this.isDrop = false;\r\n\r\n            var self = this;\r\n            setTimeout(function(){\r\n                self.zr.trigger('mousemove', param.event);\r\n            }, 300);\r\n            \r\n            return;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽出去\r\n         */\r\n        ondragend: function (param, status) {\r\n            if (!this.isDragend || !param.target || status.dragOut) {\r\n                // 没有在当前实例上发生拖拽行为或者已经被认领了则直接返回\r\n                return;\r\n            }\r\n            var target = param.target;      // 被拖拽图形元素\r\n\r\n            var seriesIndex = ecData.get(target, 'seriesIndex');\r\n            var dataIndex = ecData.get(target, 'dataIndex');\r\n\r\n            var series = this.series;\r\n\r\n            // 删除被拖拽走的数据\r\n            if (series[seriesIndex].data[dataIndex].value != null) {\r\n                series[seriesIndex].data[dataIndex].value = '-';\r\n                // 清理可能有且唯一的legend data\r\n                var name = series[seriesIndex].data[dataIndex].name;\r\n                var legend = this.component.legend;\r\n                if (legend && legend.getRelatedAmount(name) === 0) {\r\n                    legend.del(name);\r\n                }\r\n            }\r\n            else {\r\n                series[seriesIndex].data[dataIndex] = '-';\r\n            }\r\n            \r\n            // 别status = {}赋值啊！！\r\n            status.dragOut = true;\r\n            status.needRefresh = true;\r\n\r\n            // 处理完拖拽事件后复位\r\n            this.isDragend = false;\r\n\r\n            return;\r\n        },\r\n\r\n        /**\r\n         * 图例选择\r\n         */\r\n        onlegendSelected: function (param, status) {\r\n            var legendSelected = param.selected;\r\n            for (var itemName in this.selectedMap) {\r\n                if (this.selectedMap[itemName] != legendSelected[itemName]) {\r\n                    // 有一项不一致都需要重绘\r\n                    status.needRefresh = true;\r\n                }\r\n                this.selectedMap[itemName] = legendSelected[itemName];\r\n            }\r\n            return;\r\n        },\r\n        \r\n        /**\r\n         * 折线图、柱形图公用方法\r\n         */\r\n        _buildPosition: function() {\r\n            this._symbol = this.option.symbolList;\r\n            this._sIndex2ShapeMap = {};  // series拐点图形类型，seriesIndex索引到shape type\r\n            this._sIndex2ColorMap = {};  // series默认颜色索引，seriesIndex索引到color\r\n\r\n            this.selectedMap = {};\r\n            this.xMarkMap = {};\r\n            \r\n            var series = this.series;\r\n            // 水平垂直双向series索引 ，position索引到seriesIndex\r\n            var _position2sIndexMap = {\r\n                top: [],\r\n                bottom: [],\r\n                left: [],\r\n                right: [],\r\n                other: []\r\n            };\r\n            var xAxisIndex;\r\n            var yAxisIndex;\r\n            var xAxis;\r\n            var yAxis;\r\n            for (var i = 0, l = series.length; i < l; i++) {\r\n                if (series[i].type === this.type) {\r\n                    series[i] = this.reformOption(series[i]);\r\n                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;\r\n                    xAxisIndex = series[i].xAxisIndex;\r\n                    yAxisIndex = series[i].yAxisIndex;\r\n                    xAxis = this.component.xAxis.getAxis(xAxisIndex);\r\n                    yAxis = this.component.yAxis.getAxis(yAxisIndex);\r\n                    if (xAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {\r\n                        _position2sIndexMap[xAxis.getPosition()].push(i);\r\n                    }\r\n                    else if (yAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {\r\n                        _position2sIndexMap[yAxis.getPosition()].push(i);\r\n                    }\r\n                    else {\r\n                        _position2sIndexMap.other.push(i);\r\n                    }\r\n                }\r\n            }\r\n            // console.log(_position2sIndexMap);\r\n            for (var position in _position2sIndexMap) {\r\n                if (_position2sIndexMap[position].length > 0) {\r\n                    this._buildSinglePosition(\r\n                        position, _position2sIndexMap[position]\r\n                    );\r\n                }\r\n            }\r\n\r\n            this.addShapeList();\r\n        },\r\n        \r\n        /**\r\n         * 构建单个方向上的折线图、柱形图公用方法\r\n         *\r\n         * @param {number} seriesIndex 系列索引\r\n         */\r\n        _buildSinglePosition: function (position, seriesArray) {\r\n            var mapData = this._mapData(seriesArray);\r\n            var locationMap = mapData.locationMap;\r\n            var maxDataLength = mapData.maxDataLength;\r\n\r\n            if (maxDataLength === 0 || locationMap.length === 0) {\r\n                return;\r\n            }\r\n            switch (position) {\r\n                case 'bottom' :\r\n                case 'top' :\r\n                    this._buildHorizontal(seriesArray, maxDataLength, locationMap, this.xMarkMap);\r\n                    break;\r\n                case 'left' :\r\n                case 'right' :\r\n                    this._buildVertical(seriesArray, maxDataLength, locationMap, this.xMarkMap);\r\n                    break;\r\n                case 'other' :\r\n                    this._buildOther(seriesArray, maxDataLength, locationMap, this.xMarkMap);\r\n                    break;\r\n            }\r\n            \r\n            for (var i = 0, l = seriesArray.length; i < l; i++) {\r\n                this.buildMark(seriesArray[i]);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 数据整形，折线图、柱形图公用方法\r\n         * 数组位置映射到系列索引\r\n         */\r\n        _mapData: function (seriesArray) {\r\n            var series = this.series;\r\n            var serie;                              // 临时映射变量\r\n            var dataIndex = 0;                      // 堆积数据所在位置映射\r\n            var stackMap = {};                      // 堆积数据位置映射，堆积组在二维中的第几项\r\n            var magicStackKey = '__kener__stack__'; // 堆积命名，非堆积数据安单一堆积处理\r\n            var stackKey;                           // 临时映射变量\r\n            var serieName;                          // 临时映射变量\r\n            var legend = this.component.legend;\r\n            var locationMap = [];                   // 需要返回的东西：数组位置映射到系列索引\r\n            var maxDataLength = 0;                  // 需要返回的东西：最大数据长度\r\n            var iconShape;\r\n            // 计算需要显示的个数和分配位置并记在下面这个结构里\r\n            for (var i = 0, l = seriesArray.length; i < l; i++) {\r\n                serie = series[seriesArray[i]];\r\n                serieName = serie.name;\r\n                \r\n                this._sIndex2ShapeMap[seriesArray[i]] = this._sIndex2ShapeMap[seriesArray[i]]\r\n                                                        || this.query(serie,'symbol')\r\n                                                        || this._symbol[i % this._symbol.length];\r\n                      \r\n                if (legend){\r\n                    this.selectedMap[serieName] = legend.isSelected(serieName);\r\n                    \r\n                    this._sIndex2ColorMap[seriesArray[i]] = legend.getColor(serieName);\r\n                        \r\n                    iconShape = legend.getItemShape(serieName);\r\n                    if (iconShape) {\r\n                        // 回调legend，换一个更形象的icon\r\n                        var style = iconShape.style;\r\n                        if (this.type == ecConfig.CHART_TYPE_LINE) {\r\n                            style.iconType = 'legendLineIcon';\r\n                            style.symbol =  this._sIndex2ShapeMap[seriesArray[i]];\r\n                        }\r\n                        else if (serie.itemStyle.normal.barBorderWidth > 0) {\r\n                            var highlightStyle = iconShape.highlightStyle;\r\n                            style.brushType = 'both';\r\n                            style.x += 1;\r\n                            style.y += 1;\r\n                            style.width -= 2;\r\n                            style.height -= 2;\r\n                            style.strokeColor \r\n                                = highlightStyle.strokeColor \r\n                                = serie.itemStyle.normal.barBorderColor;\r\n                            highlightStyle.lineWidth = 3;\r\n                        }\r\n                        \r\n                        legend.setItemShape(serieName, iconShape);\r\n                    }\r\n                }\r\n                else {\r\n                    this.selectedMap[serieName] = true;\r\n                    this._sIndex2ColorMap[seriesArray[i]] = this.zr.getColor(seriesArray[i]);\r\n                }\r\n\r\n                if (this.selectedMap[serieName]) {\r\n                    stackKey = serie.stack || (magicStackKey + seriesArray[i]);\r\n                    if (stackMap[stackKey] == null) {\r\n                        stackMap[stackKey] = dataIndex;\r\n                        locationMap[dataIndex] = [seriesArray[i]];\r\n                        dataIndex++;\r\n                    }\r\n                    else {\r\n                        // 已经分配了位置就推进去就行\r\n                        locationMap[stackMap[stackKey]].push(seriesArray[i]);\r\n                    }\r\n                }\r\n                // 兼职帮算一下最大长度\r\n                maxDataLength = Math.max(maxDataLength, serie.data.length);\r\n            }\r\n            /* 调试输出\r\n            var s = '';\r\n            for (var i = 0, l = maxDataLength; i < l; i++) {\r\n                s = '[';\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    s +='['\r\n                    for (var m = 0, n = locationMap[j].length - 1; m < n; m++) {\r\n                        s += series[locationMap[j][m]].data[i] + ','\r\n                    }\r\n                    s += series[locationMap[j][locationMap[j].length - 1]]\r\n                         .data[i];\r\n                    s += ']'\r\n                }\r\n                s += ']';\r\n                console.log(s);\r\n            }\r\n            console.log(locationMap)\r\n            */\r\n\r\n            return {\r\n                locationMap: locationMap,\r\n                maxDataLength: maxDataLength\r\n            };\r\n        },\r\n        \r\n        _calculMarkMapXY : function(xMarkMap, locationMap, xy) {\r\n            var series = this.series;\r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                    var seriesIndex = locationMap[j][m];\r\n                    var valueIndex = xy == 'xy' ? 0 : '';\r\n                    var grid = this.component.grid;\r\n                    var tarMark = xMarkMap[seriesIndex];\r\n\r\n                    if (xy.indexOf('x') != '-1') {\r\n                        if (tarMark['counter' + valueIndex] > 0) {\r\n                            tarMark['average' + valueIndex] =\r\n                                tarMark['sum' + valueIndex] / tarMark['counter' + valueIndex];\r\n                        }\r\n                        \r\n                        var x = this.component.xAxis.getAxis(series[seriesIndex].xAxisIndex || 0)\r\n                                .getCoord(tarMark['average' + valueIndex]);\r\n                        tarMark['averageLine' + valueIndex] = [\r\n                            [x, grid.getYend()],\r\n                            [x, grid.getY()]\r\n                        ];\r\n                        tarMark['minLine' + valueIndex] = [\r\n                            [tarMark['minX' + valueIndex], grid.getYend()],\r\n                            [tarMark['minX' + valueIndex], grid.getY()]\r\n                        ];\r\n                        tarMark['maxLine' + valueIndex] = [\r\n                            [tarMark['maxX' + valueIndex], grid.getYend()],\r\n                            [tarMark['maxX' + valueIndex], grid.getY()]\r\n                        ];\r\n                        \r\n                        tarMark.isHorizontal = false;\r\n                    }\r\n                    \r\n                    valueIndex = xy == 'xy' ? 1 : '';\r\n                    if (xy.indexOf('y') != '-1') {\r\n                        if (tarMark['counter' + valueIndex] > 0) {\r\n                            tarMark['average' + valueIndex] = \r\n                                tarMark['sum' + valueIndex] / tarMark['counter' + valueIndex];\r\n                        }\r\n                        var y = this.component.yAxis.getAxis(series[seriesIndex].yAxisIndex || 0)\r\n                                .getCoord(tarMark['average' + valueIndex]);\r\n                        tarMark['averageLine' + valueIndex] = [\r\n                            [grid.getX(), y],\r\n                            [grid.getXend(), y]\r\n                        ];\r\n                        tarMark['minLine' + valueIndex] = [\r\n                            [grid.getX(), tarMark['minY' + valueIndex]],\r\n                            [grid.getXend(), tarMark['minY' + valueIndex]]\r\n                        ];\r\n                        tarMark['maxLine' + valueIndex] = [\r\n                            [grid.getX(), tarMark['maxY' + valueIndex]],\r\n                            [grid.getXend(), tarMark['maxY' + valueIndex]]\r\n                        ];\r\n                        \r\n                        tarMark.isHorizontal = true;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 添加文本 \r\n         */\r\n        addLabel: function (tarShape, serie, data, name, orient) {\r\n            // 多级控制\r\n            var queryTarget = [data, serie];\r\n            var nLabel = this.deepMerge(queryTarget, 'itemStyle.normal.label');\r\n            var eLabel = this.deepMerge(queryTarget, 'itemStyle.emphasis.label');\r\n\r\n            var nTextStyle = nLabel.textStyle || {};\r\n            var eTextStyle = eLabel.textStyle || {};\r\n            \r\n            if (nLabel.show) {\r\n                var style = tarShape.style;\r\n                style.text = this._getLabelText(\r\n                    serie, data, name, 'normal'\r\n                );\r\n                style.textPosition = nLabel.position == null\r\n                                     ? (orient === 'horizontal' ? 'right' : 'top')\r\n                                     : nLabel.position;\r\n                style.textColor = nTextStyle.color;\r\n                style.textFont = this.getFont(nTextStyle);\r\n                style.textAlign = nTextStyle.align;\r\n                style.textBaseline = nTextStyle.baseline;\r\n            }\r\n            if (eLabel.show) {\r\n                var highlightStyle = tarShape.highlightStyle;\r\n                highlightStyle.text = this._getLabelText(\r\n                    serie, data, name, 'emphasis'\r\n                );\r\n                highlightStyle.textPosition = nLabel.show\r\n                                              ? tarShape.style.textPosition\r\n                                              : (eLabel.position == null\r\n                                                 ? (orient === 'horizontal' ? 'right' : 'top')\r\n                                                 : eLabel.position);\r\n                highlightStyle.textColor = eTextStyle.color;\r\n                highlightStyle.textFont = this.getFont(eTextStyle);\r\n                highlightStyle.textAlign = eTextStyle.align;\r\n                highlightStyle.textBaseline = eTextStyle.baseline;\r\n            }\r\n            \r\n            return tarShape;\r\n        },\r\n        \r\n        /**\r\n         * 根据lable.format计算label text\r\n         */\r\n        _getLabelText: function (serie, data, name, status) {\r\n            var formatter = this.deepQuery(\r\n                [data, serie],\r\n                'itemStyle.' + status + '.label.formatter'\r\n            );\r\n            if (!formatter && status === 'emphasis') {\r\n                // emphasis时需要看看normal下是否有formatter\r\n                formatter = this.deepQuery(\r\n                    [data, serie],\r\n                    'itemStyle.normal.label.formatter'\r\n                );\r\n            }\r\n            \r\n            var value = this.getDataFromOption(data, '-');\r\n            \r\n            if (formatter) {\r\n                if (typeof formatter === 'function') {\r\n                    return formatter.call(\r\n                        this.myChart,\r\n                        {\r\n                            seriesName: serie.name,\r\n                            series: serie,\r\n                            name: name,\r\n                            value: value,\r\n                            data: data,\r\n                            status: status\r\n                        }\r\n                    );\r\n                }\r\n                else if (typeof formatter === 'string') {\r\n                    formatter = formatter.replace('{a}','{a0}')\r\n                                         .replace('{b}','{b0}')\r\n                                         .replace('{c}','{c0}')\r\n                                         .replace('{a0}', serie.name)\r\n                                         .replace('{b0}', name)\r\n                                         .replace('{c0}', this.numAddCommas(value));\r\n    \r\n                    return formatter;\r\n                }\r\n            }\r\n            else {\r\n                if (value instanceof Array) {\r\n                    return value[2] != null\r\n                           ? this.numAddCommas(value[2])\r\n                           : (value[0] + ' , ' + value[1]);\r\n                }\r\n                else {\r\n                    return this.numAddCommas(value);\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标线标注 \r\n         */\r\n        buildMark: function (seriesIndex) {\r\n            var serie = this.series[seriesIndex];\r\n            if (this.selectedMap[serie.name]) {\r\n                serie.markLine && this._buildMarkLine(seriesIndex);\r\n                serie.markPoint && this._buildMarkPoint(seriesIndex);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标注逻辑\r\n         */\r\n        _buildMarkPoint: function (seriesIndex) {\r\n            var attachStyle =  (this.markAttachStyle || {})[seriesIndex];\r\n            var serie = this.series[seriesIndex];\r\n            var mpData;\r\n            var pos;\r\n            var markPoint = zrUtil.clone(serie.markPoint);\r\n            for (var i = 0, l = markPoint.data.length; i < l; i++) {\r\n                mpData = markPoint.data[i];\r\n                pos = this.getMarkCoord(seriesIndex, mpData);\r\n                mpData.x = mpData.x != null ? mpData.x : pos[0];\r\n                mpData.y = mpData.y != null ? mpData.y : pos[1];\r\n                if (mpData.type\r\n                    && (mpData.type === 'max' || mpData.type === 'min')\r\n                ) {\r\n                    // 特殊值内置支持\r\n                    mpData.value = pos[3];\r\n                    mpData.name = mpData.name || mpData.type;\r\n                    mpData.symbolSize = mpData.symbolSize\r\n                        || (zrArea.getTextWidth(pos[3], this.getFont()) / 2 + 5);\r\n                }\r\n            }\r\n            \r\n            var shapeList = this._markPoint(seriesIndex, markPoint);\r\n            \r\n            for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                var tarShape = shapeList[i];\r\n                tarShape.zlevel = serie.zlevel;\r\n                tarShape.z = serie.z + 1;\r\n                for (var key in attachStyle) {\r\n                    tarShape[key] = zrUtil.clone(attachStyle[key]);\r\n                }\r\n                this.shapeList.push(tarShape);\r\n            }\r\n            // 个别特殊图表需要自己addShape\r\n            if (this.type === ecConfig.CHART_TYPE_FORCE\r\n                || this.type === ecConfig.CHART_TYPE_CHORD\r\n            ) {\r\n                for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                    this.zr.addShape(shapeList[i]);\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标线逻辑\r\n         */\r\n        _buildMarkLine: function (seriesIndex) {\r\n            var attachStyle =  (this.markAttachStyle || {})[seriesIndex];\r\n            var serie = this.series[seriesIndex];\r\n            var pos;\r\n            var markLine = zrUtil.clone(serie.markLine);\r\n            for (var i = 0, l = markLine.data.length; i < l; i++) {\r\n                var mlData = markLine.data[i];\r\n                if (mlData.type\r\n                    && (mlData.type === 'max' || mlData.type === 'min' || mlData.type === 'average')\r\n                ) {\r\n                    // 特殊值内置支持\r\n                    pos = this.getMarkCoord(seriesIndex, mlData);\r\n                    markLine.data[i] = [zrUtil.clone(mlData), {}];\r\n                    markLine.data[i][0].name = mlData.name || mlData.type;\r\n                    markLine.data[i][0].value = mlData.type !== 'average'\r\n                                                ? pos[3]\r\n                                                : +pos[3].toFixed(\r\n                                                      markLine.precision != null \r\n                                                      ? markLine.precision \r\n                                                      : this.deepQuery(\r\n                                                            [this.ecTheme, ecConfig],\r\n                                                            'markLine.precision'\r\n                                                        )\r\n                                                  );\r\n                    pos = pos[2];\r\n                    mlData = [{},{}];\r\n                }\r\n                else {\r\n                    pos = [\r\n                        this.getMarkCoord(seriesIndex, mlData[0]),\r\n                        this.getMarkCoord(seriesIndex, mlData[1])\r\n                    ];\r\n                }\r\n                if (pos == null || pos[0] == null || pos[1] == null) {\r\n                    // 不在显示区域内\r\n                    continue;\r\n                }\r\n                markLine.data[i][0].x = mlData[0].x != null ? mlData[0].x : pos[0][0];\r\n                markLine.data[i][0].y = mlData[0].y != null ? mlData[0].y : pos[0][1];\r\n                markLine.data[i][1].x = mlData[1].x != null ? mlData[1].x : pos[1][0];\r\n                markLine.data[i][1].y = mlData[1].y != null ? mlData[1].y : pos[1][1];\r\n            }\r\n            \r\n            var shapeList = this._markLine(seriesIndex, markLine);\r\n\r\n            var isLarge = markLine.large;\r\n\r\n            if (isLarge) {\r\n                var shapeBundle = new ShapeBundle({\r\n                    style: {\r\n                        shapeList: shapeList\r\n                    }\r\n                });\r\n                var firstShape = shapeList[0];\r\n                if (firstShape) {\r\n                    zrUtil.merge(shapeBundle.style, firstShape.style);\r\n                    zrUtil.merge(shapeBundle.highlightStyle = {}, firstShape.highlightStyle);\r\n                    shapeBundle.style.brushType = 'stroke';\r\n                    shapeBundle.zlevel = serie.zlevel;\r\n                    shapeBundle.z = serie.z + 1;\r\n                    shapeBundle.hoverable = false;\r\n                    for (var key in attachStyle) {\r\n                        shapeBundle[key] = zrUtil.clone(attachStyle[key]);\r\n                    }\r\n                }\r\n                this.shapeList.push(shapeBundle);\r\n                this.zr.addShape(shapeBundle);\r\n\r\n                shapeBundle._mark = 'largeLine';\r\n                var effect = markLine.effect;\r\n                if (effect.show) {\r\n                    shapeBundle.effect = effect;\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                    var tarShape = shapeList[i];\r\n                    tarShape.zlevel = serie.zlevel;\r\n                    tarShape.z = serie.z + 1;\r\n                    for (var key in attachStyle) {\r\n                        tarShape[key] = zrUtil.clone(attachStyle[key]);\r\n                    }\r\n                    this.shapeList.push(tarShape);\r\n                }\r\n                // 个别特殊图表需要自己addShape\r\n                if (this.type === ecConfig.CHART_TYPE_FORCE\r\n                    || this.type === ecConfig.CHART_TYPE_CHORD\r\n                ) {\r\n                    for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                        this.zr.addShape(shapeList[i]);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标注多级控制构造\r\n         */\r\n        _markPoint: function (seriesIndex, mpOption) {\r\n            var serie = this.series[seriesIndex];\r\n            var component = this.component;\r\n            zrUtil.merge(\r\n                zrUtil.merge(\r\n                    mpOption,\r\n                    zrUtil.clone(this.ecTheme.markPoint || {})\r\n                ),\r\n                zrUtil.clone(ecConfig.markPoint)\r\n            );\r\n\r\n            mpOption.name = serie.name;\r\n                   \r\n            var pList = [];\r\n            var data = mpOption.data;\r\n            var itemShape;\r\n            \r\n            var dataRange = component.dataRange;\r\n            var legend = component.legend;\r\n            var color;\r\n            var value;\r\n            var queryTarget;\r\n            var nColor;\r\n            var eColor;\r\n            var effect;\r\n            var zrWidth = this.zr.getWidth();\r\n            var zrHeight = this.zr.getHeight();\r\n\r\n            if (!mpOption.large) {\r\n                for (var i = 0, l = data.length; i < l; i++) {\r\n                    if (data[i].x == null || data[i].y == null) {\r\n                        continue;\r\n                    }\r\n                    value = data[i].value != null ? data[i].value : '';\r\n                    // 图例\r\n                    if (legend) {\r\n                        color = legend.getColor(serie.name);\r\n                    }\r\n                    // 值域\r\n                    if (dataRange) {\r\n                        color = isNaN(value) ? color : dataRange.getColor(value);\r\n                        \r\n                        queryTarget = [data[i], mpOption];\r\n                        nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color')\r\n                                 || color;\r\n                        eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color')\r\n                                 || nColor;\r\n                        // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark\r\n                        if (nColor == null && eColor == null) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    \r\n                    color = color == null ? this.zr.getColor(seriesIndex) : color;\r\n                    \r\n                    // 标准化一些参数\r\n                    data[i].tooltip = data[i].tooltip\r\n                                      || mpOption.tooltip\r\n                                      || {trigger:'item'}; // tooltip.trigger指定为item\r\n                    data[i].name = data[i].name != null ? data[i].name : '';\r\n                    data[i].value = value;\r\n\r\n                    // 复用getSymbolShape\r\n                    itemShape = this.getSymbolShape(\r\n                        mpOption, seriesIndex,      // 系列 \r\n                        data[i], i, data[i].name,   // 数据\r\n                        this.parsePercent(data[i].x, zrWidth),   // 坐标\r\n                        this.parsePercent(data[i].y, zrHeight),  // 坐标\r\n                        'pin', color,               // 默认symbol和color\r\n                        'rgba(0,0,0,0)',\r\n                        'horizontal'                // 走向，用于默认文字定位\r\n                    );\r\n                    itemShape._mark = 'point';\r\n                    \r\n                    effect = this.deepMerge(\r\n                        [data[i], mpOption],\r\n                        'effect'\r\n                    );\r\n                    if (effect.show) {\r\n                        itemShape.effect = effect;\r\n                    }\r\n                    \r\n                    if (serie.type === ecConfig.CHART_TYPE_MAP) {\r\n                        itemShape._geo = this.getMarkGeo(data[i]);\r\n                    }\r\n                    \r\n                    // 重新pack一下数据\r\n                    ecData.pack(\r\n                        itemShape,\r\n                        serie, seriesIndex,\r\n                        data[i], i,\r\n                        data[i].name,\r\n                        value\r\n                    );\r\n                    pList.push(itemShape);\r\n                }\r\n            }\r\n            else {\r\n                // 大规模MarkPoint\r\n                itemShape = this.getLargeMarkPointShape(seriesIndex, mpOption);\r\n                itemShape._mark = 'largePoint';\r\n                itemShape && pList.push(itemShape);\r\n            }\r\n            return pList;\r\n        },\r\n        \r\n        /**\r\n         * 标线多级控制构造\r\n         */\r\n        _markLine: (function () {\r\n            function normalizeOptionValue(mlOption, key) {\r\n                mlOption[key] = mlOption[key] instanceof Array\r\n                          ? mlOption[key].length > 1 \r\n                            ? mlOption[key] \r\n                            : [mlOption[key][0], mlOption[key][0]]\r\n                          : [mlOption[key], mlOption[key]];\r\n            }\r\n\r\n            return function (seriesIndex, mlOption) {\r\n                var serie = this.series[seriesIndex];\r\n                var component = this.component;\r\n                var dataRange = component.dataRange;\r\n                var legend = component.legend;\r\n\r\n                zrUtil.merge(\r\n                    zrUtil.merge(\r\n                        mlOption,\r\n                        zrUtil.clone(this.ecTheme.markLine || {})\r\n                    ),\r\n                    zrUtil.clone(ecConfig.markLine)\r\n                );\r\n\r\n                var defaultColor = legend ? legend.getColor(serie.name)\r\n                    : this.zr.getColor(seriesIndex);\r\n\r\n                // 标准化一些同时支持Array和String的参数\r\n                normalizeOptionValue(mlOption, 'symbol');\r\n                normalizeOptionValue(mlOption, 'symbolSize');\r\n                normalizeOptionValue(mlOption, 'symbolRotate');\r\n\r\n                // Normalize and filter data\r\n                var data = mlOption.data;\r\n                var edges = [];\r\n                var zrWidth = this.zr.getWidth();\r\n                var zrHeight = this.zr.getHeight();\r\n                for (var i = 0; i < data.length; i++) {\r\n                    var mlData = data[i];\r\n                    if (isCoordAvailable(mlData[0])\r\n                        && isCoordAvailable(mlData[1])\r\n                    ) {\r\n                        // 组装一个mergeData\r\n                        var mergeData = this.deepMerge(mlData);\r\n                        var queryTarget = [mergeData, mlOption];\r\n                        var color = defaultColor;\r\n                        var value = mergeData.value != null ? mergeData.value : '';\r\n                        // 值域\r\n                        if (dataRange) {\r\n                            color = isNaN(value) ? color : dataRange.getColor(value);\r\n\r\n                            var nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color')\r\n                                     || color;\r\n                            var eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color')\r\n                                     || nColor;\r\n                            // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark\r\n                            if (nColor == null && eColor == null) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        // 标准化一些参数\r\n                        mlData[0].tooltip = mergeData.tooltip\r\n                                            || mlOption.tooltip\r\n                                            || {trigger:'item'}; // tooltip.trigger指定为item\r\n                        mlData[0].name = mlData[0].name || '';\r\n                        mlData[1].name = mlData[1].name || '';\r\n                        mlData[0].value = value;\r\n\r\n                        edges.push({\r\n                            points: [\r\n                                [this.parsePercent(mlData[0].x, zrWidth),\r\n                                this.parsePercent(mlData[0].y, zrHeight)],\r\n                                [this.parsePercent(mlData[1].x, zrWidth),\r\n                                this.parsePercent(mlData[1].y, zrHeight)]\r\n                            ],\r\n                            rawData: mlData,\r\n                            color: color\r\n                        });\r\n                    }\r\n                }\r\n\r\n                var enableBundling = this.query(mlOption, 'bundling.enable');\r\n                if (enableBundling) {\r\n                    var edgeBundling = new EdgeBundling();\r\n                    edgeBundling.maxTurningAngle = this.query(\r\n                        mlOption, 'bundling.maxTurningAngle'\r\n                    ) / 180 * Math.PI;\r\n                    edges = edgeBundling.run(edges);\r\n                }\r\n\r\n                mlOption.name = serie.name;\r\n  \r\n                var shapeList = [];\r\n\r\n                for (var i = 0, l = edges.length; i < l; i++) {\r\n                    var edge = edges[i];\r\n                    var rawEdge = edge.rawEdge || edge; \r\n                    var mlData = rawEdge.rawData;\r\n                    var value = mlData.value != null ? mlData.value : '';\r\n\r\n                    var itemShape = this.getMarkLineShape(\r\n                        mlOption,\r\n                        seriesIndex,\r\n                        mlData,\r\n                        i,\r\n                        edge.points,\r\n                        enableBundling,\r\n                        rawEdge.color\r\n                    );\r\n                    itemShape._mark = 'line';\r\n                    \r\n                    var effect = this.deepMerge(\r\n                        [mlData[0], mlData[1], mlOption],\r\n                        'effect'\r\n                    );\r\n                    if (effect.show) {\r\n                        itemShape.effect = effect;\r\n                        itemShape.effect.large = mlOption.large;\r\n                    }\r\n                    \r\n                    if (serie.type === ecConfig.CHART_TYPE_MAP) {\r\n                        itemShape._geo = [\r\n                            this.getMarkGeo(mlData[0]),\r\n                            this.getMarkGeo(mlData[1])\r\n                        ];\r\n                    }\r\n                    \r\n                    // 重新pack一下数据\r\n                    ecData.pack(\r\n                        itemShape,\r\n                        serie, seriesIndex,\r\n                        mlData[0], i,\r\n                        mlData[0].name \r\n                            // 不要帮我代码规范\r\n                            + (mlData[1].name !== '' ? (' > ' + mlData[1].name) : ''),\r\n                        value\r\n                    );\r\n                    shapeList.push(itemShape);\r\n                }\r\n\r\n                return shapeList;\r\n            };\r\n        })(),\r\n        \r\n        getMarkCoord: function () {\r\n            // 无转换位置\r\n            return [0, 0];\r\n        },\r\n        \r\n        /**\r\n         * symbol构造器 \r\n         */\r\n        getSymbolShape: function (\r\n            serie, seriesIndex,     // 系列 \r\n            data, dataIndex, name,  // 数据\r\n            x, y,                   // 坐标\r\n            symbol, color,          // 默认symbol和color，来自legend或dataRange全局分配\r\n            emptyColor,             // 折线的emptySymbol用白色填充\r\n            orient                  // 走向，用于默认文字定位\r\n        ) {\r\n            var queryTarget = [data, serie];\r\n            var value = this.getDataFromOption(data, '-');\r\n            \r\n            symbol = this.deepQuery(queryTarget, 'symbol') || symbol;\r\n            var symbolSize = this.deepQuery(queryTarget, 'symbolSize');\r\n            symbolSize = typeof symbolSize === 'function'\r\n                         ? symbolSize(value)\r\n                         : symbolSize;\r\n            if (typeof symbolSize === 'number') {\r\n                symbolSize = [symbolSize, symbolSize];\r\n            }\r\n            var symbolRotate = this.deepQuery(queryTarget, 'symbolRotate');\r\n            \r\n            var normal = this.deepMerge(\r\n                queryTarget,\r\n                'itemStyle.normal'\r\n            );\r\n            var emphasis = this.deepMerge(\r\n                queryTarget,\r\n                'itemStyle.emphasis'\r\n            );\r\n            var nBorderWidth = normal.borderWidth != null\r\n                               ? normal.borderWidth\r\n                               : (normal.lineStyle && normal.lineStyle.width);\r\n            if (nBorderWidth == null) {\r\n                nBorderWidth = symbol.match('empty') ? 2 : 0;\r\n            }\r\n            var eBorderWidth = emphasis.borderWidth != null\r\n                               ? emphasis.borderWidth\r\n                               : (emphasis.lineStyle && emphasis.lineStyle.width);\r\n            if (eBorderWidth == null) {\r\n                eBorderWidth = nBorderWidth + 2;\r\n            }\r\n\r\n            var nColor = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);\r\n            var eColor = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);\r\n            \r\n            var width = symbolSize[0];\r\n            var height = symbolSize[1];\r\n            var itemShape = new IconShape({\r\n                style: {\r\n                    iconType: symbol.replace('empty', '').toLowerCase(),\r\n                    x: x - width,\r\n                    y: y - height,\r\n                    width: width * 2,\r\n                    height: height * 2,\r\n                    brushType: 'both',\r\n                    color: symbol.match('empty') \r\n                           ? emptyColor \r\n                           : (nColor || color),\r\n                    strokeColor: normal.borderColor || nColor || color,\r\n                    lineWidth: nBorderWidth\r\n                },\r\n                highlightStyle: {\r\n                    color: symbol.match('empty') \r\n                           ? emptyColor \r\n                           : (eColor || nColor || color),\r\n                    strokeColor: emphasis.borderColor \r\n                                 || normal.borderColor\r\n                                 || eColor\r\n                                 || nColor\r\n                                 || color,\r\n                    lineWidth: eBorderWidth\r\n                },\r\n                clickable: this.deepQuery(queryTarget, 'clickable')\r\n            });\r\n\r\n            if (symbol.match('image')) {\r\n                itemShape.style.image = symbol.replace(new RegExp('^image:\\\\/\\\\/'), '');\r\n                itemShape = new ImageShape({\r\n                    style: itemShape.style,\r\n                    highlightStyle: itemShape.highlightStyle,\r\n                    clickable: this.deepQuery(queryTarget, 'clickable')\r\n                });\r\n            }\r\n            \r\n            if (symbolRotate != null) {\r\n                itemShape.rotation = [\r\n                    symbolRotate * Math.PI / 180, x, y\r\n                ];\r\n            }\r\n            \r\n            if (symbol.match('star')) {\r\n                itemShape.style.iconType = 'star';\r\n                itemShape.style.n = \r\n                    (symbol.replace('empty', '').replace('star','') - 0) || 5;\r\n            }\r\n            \r\n            if (symbol === 'none') {\r\n                itemShape.invisible = true;\r\n                itemShape.hoverable = false;\r\n            }\r\n            \r\n            /*\r\n            if (this.deepQuery([data, serie, option], 'calculable')) {\r\n                this.setCalculable(itemShape);\r\n                itemShape.draggable = true;\r\n            }\r\n            */\r\n\r\n            itemShape = this.addLabel(\r\n                itemShape, \r\n                serie, data, name, \r\n                orient\r\n            );\r\n            \r\n            if (symbol.match('empty')) {\r\n                if (itemShape.style.textColor == null) {\r\n                    itemShape.style.textColor = itemShape.style.strokeColor;\r\n                }\r\n                if (itemShape.highlightStyle.textColor == null) {\r\n                    itemShape.highlightStyle.textColor = \r\n                        itemShape.highlightStyle.strokeColor;\r\n                }\r\n            }\r\n            \r\n            ecData.pack(\r\n                itemShape,\r\n                serie, seriesIndex,\r\n                data, dataIndex,\r\n                name\r\n            );\r\n\r\n            itemShape._x = x;\r\n            itemShape._y = y;\r\n            \r\n            itemShape._dataIndex = dataIndex;\r\n            itemShape._seriesIndex = seriesIndex;\r\n\r\n            return itemShape;\r\n        },\r\n        \r\n        /**\r\n         * 标线构造器 \r\n         */\r\n        getMarkLineShape: function (\r\n            mlOption,               // 系列 \r\n            seriesIndex,            // 系列索引\r\n            data,                   // 数据\r\n            dataIndex,              // 数据索引\r\n            points,                 // 坐标点\r\n            bundling,               // 是否边捆绑过\r\n            color                   // 默认color，来自legend或dataRange全局分配\r\n        ) {\r\n            var value0 = data[0].value != null ? data[0].value : '-';\r\n            var value1 = data[1].value != null ? data[1].value : '-';\r\n            var symbol = [\r\n                data[0].symbol || mlOption.symbol[0],\r\n                data[1].symbol || mlOption.symbol[1]\r\n            ];\r\n            var symbolSize = [\r\n                data[0].symbolSize || mlOption.symbolSize[0],\r\n                data[1].symbolSize || mlOption.symbolSize[1]\r\n            ];\r\n            symbolSize[0] = typeof symbolSize[0] === 'function'\r\n                            ? symbolSize[0](value0)\r\n                            : symbolSize[0];\r\n            symbolSize[1] = typeof symbolSize[1] === 'function'\r\n                            ? symbolSize[1](value1)\r\n                            : symbolSize[1];\r\n            var symbolRotate = [\r\n                this.query(data[0], 'symbolRotate') || mlOption.symbolRotate[0],\r\n                this.query(data[1], 'symbolRotate') || mlOption.symbolRotate[1]\r\n            ];\r\n            //console.log(symbol, symbolSize, symbolRotate);\r\n\r\n            var queryTarget = [data[0], data[1], mlOption];\r\n            var normal = this.deepMerge(\r\n                queryTarget,\r\n                'itemStyle.normal'\r\n            );\r\n            normal.color = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);\r\n            var emphasis = this.deepMerge(\r\n                queryTarget,\r\n                'itemStyle.emphasis'\r\n            );\r\n            emphasis.color = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);\r\n            \r\n            var nlineStyle = normal.lineStyle;\r\n            var elineStyle = emphasis.lineStyle;\r\n            \r\n            var nBorderWidth = nlineStyle.width;\r\n            if (nBorderWidth == null) {\r\n                nBorderWidth = normal.borderWidth;\r\n            }\r\n            var eBorderWidth = elineStyle.width;\r\n            if (eBorderWidth == null) {\r\n                eBorderWidth = emphasis.borderWidth != null \r\n                               ? emphasis.borderWidth\r\n                               : (nBorderWidth + 2);\r\n            }\r\n            var smoothness = this.deepQuery(queryTarget, 'smoothness');\r\n            if (! this.deepQuery(queryTarget, 'smooth')) {\r\n                smoothness = 0;\r\n            }\r\n\r\n            var ShapeCtor = bundling ? PolylineShape : MarkLineShape;\r\n            var itemShape = new ShapeCtor({\r\n                style: {\r\n                    symbol: symbol,\r\n                    symbolSize: symbolSize,\r\n                    symbolRotate: symbolRotate,\r\n                    // data: [data[0].name,data[1].name],\r\n                    brushType: 'both',\r\n                    lineType: nlineStyle.type,\r\n                    shadowColor: nlineStyle.shadowColor\r\n                                 || nlineStyle.color\r\n                                 || normal.borderColor\r\n                                 || normal.color\r\n                                 || color,\r\n                    shadowBlur: nlineStyle.shadowBlur,\r\n                    shadowOffsetX: nlineStyle.shadowOffsetX,\r\n                    shadowOffsetY: nlineStyle.shadowOffsetY,\r\n                    color: normal.color || color,\r\n                    strokeColor: nlineStyle.color\r\n                                 || normal.borderColor\r\n                                 || normal.color\r\n                                 || color,\r\n                    lineWidth: nBorderWidth,\r\n                    symbolBorderColor: normal.borderColor\r\n                                       || normal.color\r\n                                       || color,\r\n                    symbolBorder: normal.borderWidth\r\n                },\r\n                highlightStyle: {\r\n                    shadowColor: elineStyle.shadowColor,\r\n                    shadowBlur: elineStyle.shadowBlur,\r\n                    shadowOffsetX: elineStyle.shadowOffsetX,\r\n                    shadowOffsetY: elineStyle.shadowOffsetY,\r\n                    color: emphasis.color|| normal.color || color,\r\n                    strokeColor: elineStyle.color\r\n                                 || nlineStyle.color\r\n                                 || emphasis.borderColor \r\n                                 || normal.borderColor\r\n                                 || emphasis.color \r\n                                 || normal.color\r\n                                 || color,\r\n                    lineWidth: eBorderWidth,\r\n                    symbolBorderColor: emphasis.borderColor\r\n                                       || normal.borderColor\r\n                                       || emphasis.color\r\n                                       || normal.color\r\n                                       || color,\r\n                    symbolBorder: emphasis.borderWidth == null\r\n                                  ? (normal.borderWidth + 2)\r\n                                  : (emphasis.borderWidth)\r\n                },\r\n                clickable: this.deepQuery(queryTarget, 'clickable')\r\n            });\r\n            var shapeStyle = itemShape.style;\r\n            if (bundling) {\r\n                shapeStyle.pointList = points;\r\n                shapeStyle.smooth = smoothness;\r\n            }\r\n            else {\r\n                shapeStyle.xStart = points[0][0];\r\n                shapeStyle.yStart = points[0][1];\r\n                shapeStyle.xEnd = points[1][0];\r\n                shapeStyle.yEnd = points[1][1];\r\n                shapeStyle.curveness = smoothness;\r\n                itemShape.updatePoints(itemShape.style);\r\n            }\r\n            \r\n            itemShape = this.addLabel(\r\n                itemShape, \r\n                mlOption, \r\n                data[0], \r\n                data[0].name + ' : ' + data[1].name\r\n            );\r\n\r\n            return itemShape;\r\n        },\r\n        \r\n        /**\r\n         * 大规模标注构造器 \r\n         */\r\n        getLargeMarkPointShape: function(seriesIndex, mpOption) {\r\n            var serie = this.series[seriesIndex];\r\n            var component = this.component;\r\n            var data = mpOption.data;\r\n            var itemShape;\r\n            \r\n            var dataRange = component.dataRange;\r\n            var legend = component.legend;\r\n            var color;\r\n            var value;\r\n            var queryTarget = [data[0], mpOption];\r\n            var nColor;\r\n            var eColor;\r\n            var effect;\r\n            \r\n            // 图例\r\n            if (legend) {\r\n                color = legend.getColor(serie.name);\r\n            }\r\n            // 值域\r\n            if (dataRange) {\r\n                value = data[0].value != null ? data[0].value : '';\r\n                color = isNaN(value) ? color : dataRange.getColor(value);\r\n                \r\n                nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color')\r\n                         || color;\r\n                eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color')\r\n                         || nColor;\r\n                // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark\r\n                if (nColor == null && eColor == null) {\r\n                    return;\r\n                }\r\n            }\r\n            color = this.deepMerge(queryTarget, 'itemStyle.normal').color \r\n                    || color;\r\n            \r\n            var symbol = this.deepQuery(queryTarget, 'symbol') || 'circle';\r\n            symbol = symbol.replace('empty', '').replace(/\\d/g, '');\r\n            \r\n            effect = this.deepMerge(\r\n                [data[0], mpOption],\r\n                'effect'\r\n            );\r\n            \r\n            var devicePixelRatio = window.devicePixelRatio || 1;\r\n            \r\n            //console.log(data)\r\n            itemShape = new SymbolShape({\r\n                style: {\r\n                    pointList: data,\r\n                    color: color,\r\n                    strokeColor: color,\r\n                    shadowColor: effect.shadowColor || color,\r\n                    shadowBlur: (effect.shadowBlur != null ? effect.shadowBlur : 8)\r\n                                 * devicePixelRatio,\r\n                    size: this.deepQuery(queryTarget, 'symbolSize'),\r\n                    iconType: symbol,\r\n                    brushType: 'fill',\r\n                    lineWidth:1\r\n                },\r\n                draggable: false,\r\n                hoverable: false\r\n            });\r\n            \r\n            if (effect.show) {\r\n                itemShape.effect = effect;\r\n            }\r\n            \r\n            return itemShape;\r\n        },\r\n        \r\n        backupShapeList: function () {\r\n            if (this.shapeList && this.shapeList.length > 0) {\r\n                this.lastShapeList = this.shapeList;\r\n                this.shapeList = [];\r\n            }\r\n            else {\r\n                this.lastShapeList = [];\r\n            }\r\n        },\r\n        \r\n        addShapeList: function () {\r\n            var maxLenth = this.option.animationThreshold / (this.canvasSupported ? 2 : 4);\r\n            var lastShapeList = this.lastShapeList;\r\n            var shapeList = this.shapeList;\r\n            var isUpdate = lastShapeList.length > 0;\r\n            var duration = isUpdate\r\n                           ? this.query(this.option, 'animationDurationUpdate')\r\n                           : this.query(this.option, 'animationDuration');\r\n            var easing = this.query(this.option, 'animationEasing');\r\n            var delay;\r\n            var key;\r\n            var oldMap = {};\r\n            var newMap = {};\r\n            if (this.option.animation \r\n                && !this.option.renderAsImage \r\n                && shapeList.length < maxLenth\r\n                && !this.motionlessOnce\r\n            ) {\r\n                // 通过已有的shape做动画过渡\r\n                for (var i = 0, l = lastShapeList.length; i < l; i++) {\r\n                    key = this._getAnimationKey(lastShapeList[i]);\r\n                    if (key.match('undefined')) {\r\n                        this.zr.delShape(lastShapeList[i].id);  // 非关键元素直接删除\r\n                    }\r\n                    else {\r\n                        key += lastShapeList[i].type;\r\n                        // https://github.com/ecomfe/echarts/issues/1219#issuecomment-71987602\r\n                        // 响应中断可能产生的重复元素\r\n                        if (oldMap[key]) {\r\n                            this.zr.delShape(lastShapeList[i].id);\r\n                        }\r\n                        else {\r\n                            oldMap[key] = lastShapeList[i];\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                    key = this._getAnimationKey(shapeList[i]);\r\n                    if (key.match('undefined')) {\r\n                        this.zr.addShape(shapeList[i]);         // 非关键元素直接添加\r\n                    }\r\n                    else {\r\n                        key += shapeList[i].type;\r\n                        newMap[key] = shapeList[i];\r\n                    }\r\n                }\r\n                \r\n                for (key in oldMap) {\r\n                    if (!newMap[key]) {\r\n                        // 新的没有 删除\r\n                        this.zr.delShape(oldMap[key].id);\r\n                    }\r\n                }\r\n                for (key in newMap) {\r\n                    if (oldMap[key]) {\r\n                        // 新旧都有 动画过渡\r\n                        this.zr.delShape(oldMap[key].id);\r\n                        this._animateMod(\r\n                            oldMap[key], newMap[key], duration, easing, 0, isUpdate\r\n                        );\r\n                    }\r\n                    else {\r\n                        // 新有旧没有  添加并动画过渡\r\n                        //this._animateAdd(newMap[key], duration, easing);\r\n                        delay = (this.type == ecConfig.CHART_TYPE_LINE\r\n                                || this.type == ecConfig.CHART_TYPE_RADAR)\r\n                                && key.indexOf('icon') !== 0\r\n                                ? duration / 2\r\n                                : 0;\r\n                        this._animateMod(\r\n                            false, newMap[key], duration, easing, delay, isUpdate\r\n                        );\r\n                    }\r\n                }\r\n                this.zr.refresh();\r\n                this.animationEffect();\r\n            }\r\n            else {\r\n                this.motionlessOnce = false;\r\n                // clear old\r\n                this.zr.delShape(lastShapeList);\r\n                // 直接添加\r\n                for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                    this.zr.addShape(shapeList[i]);\r\n                }\r\n            }\r\n        },\r\n        \r\n        _getAnimationKey: function(shape) {\r\n            if (this.type != ecConfig.CHART_TYPE_MAP\r\n                && this.type != ecConfig.CHART_TYPE_TREEMAP\r\n                && this.type != ecConfig.CHART_TYPE_VENN\r\n                && this.type != ecConfig.CHART_TYPE_TREE\r\n                ) {\r\n                return ecData.get(shape, 'seriesIndex') + '_'\r\n                       + ecData.get(shape, 'dataIndex')\r\n                       + (shape._mark ? shape._mark : '')\r\n                       + (this.type === ecConfig.CHART_TYPE_RADAR \r\n                          ? ecData.get(shape, 'special') : '');\r\n            }\r\n            else {\r\n                return ecData.get(shape, 'seriesIndex') + '_'\r\n                       + ecData.get(shape, 'dataIndex')\r\n                       + (shape._mark ? shape._mark : 'undefined');\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 动画过渡 \r\n         */\r\n        _animateMod: function (oldShape, newShape, duration, easing, delay, isUpdate) {\r\n            switch (newShape.type) {\r\n                case 'polyline' :\r\n                case 'half-smooth-polygon' :\r\n                    ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'rectangle' :\r\n                    ecAnimation.rectangle(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'image' :\r\n                case 'icon' :\r\n                    ecAnimation.icon(this.zr, oldShape, newShape, duration, easing, delay);\r\n                    break;\r\n                case 'candle' :\r\n                    if (!isUpdate) {\r\n                        ecAnimation.candle(this.zr, oldShape, newShape, duration, easing);\r\n                    }\r\n                    else {\r\n                        this.zr.addShape(newShape);\r\n                    }\r\n                    break;\r\n                case 'ring' :\r\n                case 'sector' :\r\n                case 'circle' :\r\n                    if (!isUpdate) {\r\n                        // 进入动画，加旋转\r\n                        ecAnimation.ring(\r\n                            this.zr,\r\n                            oldShape,\r\n                            newShape, \r\n                            duration + ((ecData.get(newShape, 'dataIndex') || 0) % 20 * 100), \r\n                            easing\r\n                        );\r\n                    }\r\n                    else if (newShape.type === 'sector') {\r\n                        ecAnimation.sector(this.zr, oldShape, newShape, duration, easing);\r\n                    }\r\n                    else {\r\n                        this.zr.addShape(newShape);\r\n                    }\r\n                    break;\r\n                case 'text' :\r\n                    ecAnimation.text(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'polygon' :\r\n                    if (!isUpdate) {\r\n                        ecAnimation.polygon(this.zr, oldShape, newShape, duration, easing);\r\n                    }\r\n                    else {\r\n                        ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);\r\n                    }\r\n                    break;\r\n                case 'ribbon' :\r\n                    ecAnimation.ribbon(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'gauge-pointer' :\r\n                    ecAnimation.gaugePointer(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'mark-line' :\r\n                    ecAnimation.markline(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                case 'bezier-curve' :\r\n                case 'line' :\r\n                    ecAnimation.line(this.zr, oldShape, newShape, duration, easing);\r\n                    break;\r\n                default :\r\n                    this.zr.addShape(newShape);\r\n                    break;\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 标注动画\r\n         * @param {number} duration 时长\r\n         * @param {string=} easing 缓动效果\r\n         * @param {Array=} shapeList 指定特效对象，不指定默认使用this.shapeList\r\n         */\r\n        animationMark: function (duration , easing, shapeList) {\r\n            var shapeList = shapeList || this.shapeList;\r\n            for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                if (!shapeList[i]._mark) {\r\n                    continue;\r\n                }\r\n                this._animateMod(false, shapeList[i], duration, easing, 0, true);\r\n            }\r\n            this.animationEffect(shapeList);\r\n        },\r\n\r\n        /**\r\n         * 特效动画\r\n         * @param {Array=} shapeList 指定特效对象，不知道默认使用this.shapeList\r\n         */\r\n        animationEffect: function (shapeList) {\r\n            !shapeList && this.clearEffectShape();\r\n            shapeList = shapeList || this.shapeList;\r\n            if (shapeList == null) {\r\n                return;\r\n            }\r\n            var zlevel = ecConfig.EFFECT_ZLEVEL;\r\n            if (this.canvasSupported) {\r\n                this.zr.modLayer(\r\n                    zlevel,\r\n                    {\r\n                        motionBlur: true,\r\n                        lastFrameAlpha: this.option.effectBlendAlpha\r\n                            || ecConfig.effectBlendAlpha\r\n                    }\r\n                );\r\n            }\r\n            var shape;\r\n            for (var i = 0, l = shapeList.length; i < l; i++) {\r\n                shape = shapeList[i];\r\n                if (!(shape._mark && shape.effect && shape.effect.show && ecEffect[shape._mark])) {\r\n                    continue;\r\n                }\r\n                ecEffect[shape._mark](this.zr, this.effectList, shape, zlevel);\r\n                this.effectList[this.effectList.length - 1]._mark = shape._mark;\r\n            }\r\n        },\r\n        \r\n        clearEffectShape: function (clearMotionBlur) {\r\n            var effectList = this.effectList;\r\n            if (this.zr && effectList && effectList.length > 0) {\r\n                clearMotionBlur && this.zr.modLayer(\r\n                    ecConfig.EFFECT_ZLEVEL, \r\n                    { motionBlur: false }\r\n                );\r\n                this.zr.delShape(effectList);\r\n\r\n                // 手动清除不会被 zr 自动清除的动画控制器\r\n                for (var i = 0; i < effectList.length; i++) {\r\n                    if (effectList[i].effectAnimator) {\r\n                        effectList[i].effectAnimator.stop();\r\n                    }\r\n                }\r\n            }\r\n            this.effectList = [];\r\n        },\r\n        \r\n        /**\r\n         * 动态标线标注添加\r\n         * @param {number} seriesIndex 系列索引\r\n         * @param {Object} markData 标线标注对象，支持多个\r\n         * @param {string} markType 标线标注类型\r\n         */\r\n        addMark: function (seriesIndex, markData, markType) {\r\n            var serie = this.series[seriesIndex];\r\n            if (this.selectedMap[serie.name]) {\r\n                var duration = this.query(this.option, 'animationDurationUpdate');\r\n                var easing = this.query(this.option, 'animationEasing');\r\n                // 备份，复用_buildMarkX\r\n                var oriMarkData = serie[markType].data;\r\n                var lastLength = this.shapeList.length;\r\n                \r\n                serie[markType].data = markData.data;\r\n                this['_build' + markType.replace('m', 'M')](seriesIndex);\r\n                if (this.option.animation && !this.option.renderAsImage) {\r\n                    // animationMark就会addShape\r\n                    this.animationMark(duration, easing, this.shapeList.slice(lastLength));\r\n                }\r\n                else {\r\n                    for (var i = lastLength, l = this.shapeList.length; i < l; i++) {\r\n                        this.zr.addShape(this.shapeList[i]);\r\n                    }\r\n                    this.zr.refreshNextFrame();\r\n                }\r\n                // 还原，复用_buildMarkX\r\n                serie[markType].data = oriMarkData;\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 动态标线标注删除\r\n         * @param {number} seriesIndex 系列索引\r\n         * @param {string} markName 标线标注名称\r\n         * @param {string} markType 标线标注类型\r\n         */\r\n        delMark: function (seriesIndex, markName, markType) {\r\n            markType = markType.replace('mark', '').replace('large', '').toLowerCase();\r\n            var serie = this.series[seriesIndex];\r\n            if (this.selectedMap[serie.name]) {\r\n                var needRefresh = false;\r\n                var shapeList = [this.shapeList, this.effectList];\r\n                var len = 2;\r\n                while(len--) {\r\n                    for (var i = 0, l = shapeList[len].length; i < l; i++) {\r\n                        if (shapeList[len][i]._mark == markType\r\n                            && ecData.get(shapeList[len][i], 'seriesIndex') == seriesIndex\r\n                            && ecData.get(shapeList[len][i], 'name') == markName\r\n                        ) {\r\n                            this.zr.delShape(shapeList[len][i].id);\r\n                            shapeList[len].splice(i, 1);\r\n                            needRefresh = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                needRefresh && this.zr.refreshNextFrame();\r\n            }\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(Base, ComponentBase);\r\n\r\n    return Base;\r\n});\r\n"
    },
    {
      "id": 6,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Image.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
      "index": 6,
      "index2": 13,
      "size": 7017,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Image",
          "loc": "10:21-53"
        },
        {
          "moduleId": 20,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Image",
          "loc": "493:25-57"
        },
        {
          "moduleId": 20,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Image",
          "loc": "546:33-65"
        },
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Image",
          "loc": "12:21-53"
        }
      ],
      "source": "/**\r\n * 图片绘制\r\n * @module zrender/shape/Image\r\n * @author pissang(https://www.github.com/pissang)\r\n * @example\r\n *     var ImageShape = require('zrender/shape/Image');\r\n *     var image = new ImageShape({\r\n *         style: {\r\n *             image: 'test.jpg',\r\n *             x: 100,\r\n *             y: 100\r\n *         }\r\n *     });\r\n *     zr.addShape(image);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IImageStyle\r\n * @property {string|HTMLImageElement|HTMLCanvasElement} image 图片url或者图片对象\r\n * @property {number} x 左上角横坐标\r\n * @property {number} y 左上角纵坐标\r\n * @property {number} [width] 绘制到画布上的宽度，默认为图片宽度\r\n * @property {number} [height] 绘制到画布上的高度，默认为图片高度\r\n * @property {number} [sx=0] 从图片中裁剪的左上角横坐标\r\n * @property {number} [sy=0] 从图片中裁剪的左上角纵坐标\r\n * @property {number} [sWidth] 从图片中裁剪的宽度，默认为图片高度\r\n * @property {number} [sHeight] 从图片中裁剪的高度，默认为图片高度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n\r\n        var Base = require('./Base');\r\n\r\n        /**\r\n         * @alias zrender/shape/Image\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var ZImage = function(options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 图片绘制样式\r\n             * @name module:zrender/shape/Image#style\r\n             * @type {module:zrender/shape/Image~IImageStyle}\r\n             */\r\n            /**\r\n             * 图片高亮绘制样式\r\n             * @name module:zrender/shape/Image#highlightStyle\r\n             * @type {module:zrender/shape/Image~IImageStyle}\r\n             */\r\n        };\r\n\r\n        ZImage.prototype = {\r\n            \r\n            type: 'image',\r\n\r\n            brush : function(ctx, isHighlight, refreshNextFrame) {\r\n                var style = this.style || {};\r\n\r\n                if (isHighlight) {\r\n                    // 根据style扩展默认高亮样式\r\n                    style = this.getHighlightStyle(\r\n                        style, this.highlightStyle || {}\r\n                    );\r\n                }\r\n\r\n                var image = style.image;\r\n                var self = this;\r\n\r\n                if (!this._imageCache) {\r\n                    this._imageCache = {};\r\n                }\r\n                if (typeof(image) === 'string') {\r\n                    var src = image;\r\n                    if (this._imageCache[src]) {\r\n                        image = this._imageCache[src];\r\n                    } else {\r\n                        image = new Image();\r\n                        image.onload = function () {\r\n                            image.onload = null;\r\n                            self.modSelf();\r\n                            refreshNextFrame();\r\n                        };\r\n\r\n                        image.src = src;\r\n                        this._imageCache[src] = image;\r\n                    }\r\n                }\r\n                if (image) {\r\n                    // 图片已经加载完成\r\n                    if (image.nodeName.toUpperCase() == 'IMG') {\r\n                        if (window.ActiveXObject) {\r\n                            if (image.readyState != 'complete') {\r\n                                return;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (!image.complete) {\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                    // Else is canvas\r\n                    var width = style.width || image.width;\r\n                    var height = style.height || image.height;\r\n                    var x = style.x;\r\n                    var y = style.y;\r\n                    // 图片加载失败\r\n                    if (!image.width || !image.height) {\r\n                        return;\r\n                    }\r\n\r\n                    ctx.save();\r\n\r\n                    this.doClip(ctx);\r\n\r\n                    this.setContext(ctx, style);\r\n\r\n                    // 设置transform\r\n                    this.setTransform(ctx);\r\n\r\n                    if (style.sWidth && style.sHeight) {\r\n                        var sx = style.sx || 0;\r\n                        var sy = style.sy || 0;\r\n                        ctx.drawImage(\r\n                            image,\r\n                            sx, sy, style.sWidth, style.sHeight,\r\n                            x, y, width, height\r\n                        );\r\n                    }\r\n                    else if (style.sx && style.sy) {\r\n                        var sx = style.sx;\r\n                        var sy = style.sy;\r\n                        var sWidth = width - sx;\r\n                        var sHeight = height - sy;\r\n                        ctx.drawImage(\r\n                            image,\r\n                            sx, sy, sWidth, sHeight,\r\n                            x, y, width, height\r\n                        );\r\n                    }\r\n                    else {\r\n                        ctx.drawImage(image, x, y, width, height);\r\n                    }\r\n                    // 如果没设置宽和高的话自动根据图片宽高设置\r\n                    if (!style.width) {\r\n                        style.width = width;\r\n                    }\r\n                    if (!style.height) {\r\n                        style.height = height;\r\n                    }\r\n                    if (!this.style.width) {\r\n                        this.style.width = width;\r\n                    }\r\n                    if (!this.style.height) {\r\n                        this.style.height = height;\r\n                    }\r\n\r\n                    this.drawText(ctx, style, this.style);\r\n\r\n                    ctx.restore();\r\n                }\r\n            },\r\n\r\n            /**\r\n             * 计算返回图片的包围盒矩形\r\n             * @param {module:zrender/shape/Image~IImageStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect: function(style) {\r\n                return {\r\n                    x : style.x,\r\n                    y : style.y,\r\n                    width : style.width,\r\n                    height : style.height\r\n                };\r\n            },\r\n\r\n            clearCache: function() {\r\n                this._imageCache = {};\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(ZImage, Base);\r\n        return ZImage;\r\n    }\r\n);\r\n"
    },
    {
      "id": 7,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
      "index": 7,
      "index2": 12,
      "size": 23221,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 6,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Image.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "45:19-36"
        },
        {
          "moduleId": 20,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Base",
          "loc": "503:15-46"
        },
        {
          "moduleId": 21,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "55:19-36"
        },
        {
          "moduleId": 23,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "51:19-36"
        },
        {
          "moduleId": 25,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "52:19-36"
        },
        {
          "moduleId": 26,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Base",
          "loc": "23:15-46"
        },
        {
          "moduleId": 27,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "44:19-36"
        },
        {
          "moduleId": 29,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\BezierCurve.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "55:19-36"
        },
        {
          "moduleId": 30,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Base",
          "loc": "35:15-46"
        },
        {
          "moduleId": 31,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "43:19-36"
        },
        {
          "moduleId": 35,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "42:19-36"
        },
        {
          "moduleId": 36,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\ShapeBundle.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "42:15-32"
        },
        {
          "moduleId": 41,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Circle.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "50:19-36"
        },
        {
          "moduleId": 50,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Rectangle.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "48:19-36"
        },
        {
          "moduleId": 53,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Text.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
          "type": "cjs require",
          "userRequest": "./Base",
          "loc": "41:19-36"
        },
        {
          "moduleId": 68,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Base",
          "loc": "48:15-46"
        }
      ],
      "source": "/**\r\n * shape基类\r\n * @module zrender/shape/Base\r\n * @author  Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *          errorrik (errorrik@gmail.com)\r\n */\r\n\r\n/**\r\n * @typedef {Object} IBaseShapeStyle\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\n\r\n/**\r\n * @typedef {Object} module:zrender/shape/Base~IBoundingRect\r\n * @property {number} x 左上角顶点x轴坐标 \r\n * @property {number} y 左上角顶点y轴坐标\r\n * @property {number} width 包围盒矩形宽度\r\n * @property {number} height 包围盒矩形高度\r\n */\r\n\r\ndefine(\r\n    function(require) {\r\n        var vmlCanvasManager = window['G_vmlCanvasManager'];\r\n\r\n        var matrix = require('../tool/matrix');\r\n        var guid = require('../tool/guid');\r\n        var util = require('../tool/util');\r\n        var log = require('../tool/log');\r\n\r\n        var Transformable = require('../mixin/Transformable');\r\n        var Eventful = require('../mixin/Eventful');\r\n\r\n        function _fillText(ctx, text, x, y, textFont, textAlign, textBaseline) {\r\n            if (textFont) {\r\n                ctx.font = textFont;\r\n            }\r\n            ctx.textAlign = textAlign;\r\n            ctx.textBaseline = textBaseline;\r\n            var rect = _getTextRect(\r\n                text, x, y, textFont, textAlign, textBaseline\r\n            );\r\n            \r\n            text = (text + '').split('\\n');\r\n            var lineHeight = require('../tool/area').getTextHeight('国', textFont);\r\n            \r\n            switch (textBaseline) {\r\n                case 'top':\r\n                    y = rect.y;\r\n                    break;\r\n                case 'bottom':\r\n                    y = rect.y + lineHeight;\r\n                    break;\r\n                default:\r\n                    y = rect.y + lineHeight / 2;\r\n            }\r\n            \r\n            for (var i = 0, l = text.length; i < l; i++) {\r\n                ctx.fillText(text[i], x, y);\r\n                y += lineHeight;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 返回矩形区域，用于局部刷新和文字定位\r\n         * @inner\r\n         * @param {string} text\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @param {string} textFont\r\n         * @param {string} textAlign\r\n         * @param {string} textBaseline\r\n         */\r\n        function _getTextRect(text, x, y, textFont, textAlign, textBaseline) {\r\n            var area = require('../tool/area');\r\n            var width = area.getTextWidth(text, textFont);\r\n            var lineHeight = area.getTextHeight('国', textFont);\r\n            \r\n            text = (text + '').split('\\n');\r\n            \r\n            switch (textAlign) {\r\n                case 'end':\r\n                case 'right':\r\n                    x -= width;\r\n                    break;\r\n                case 'center':\r\n                    x -= (width / 2);\r\n                    break;\r\n            }\r\n\r\n            switch (textBaseline) {\r\n                case 'top':\r\n                    break;\r\n                case 'bottom':\r\n                    y -= lineHeight * text.length;\r\n                    break;\r\n                default:\r\n                    y -= lineHeight * text.length / 2;\r\n            }\r\n\r\n            return {\r\n                x : x,\r\n                y : y,\r\n                width : width,\r\n                height : lineHeight * text.length\r\n            };\r\n        }\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Base\r\n         * @constructor\r\n         * @extends module:zrender/mixin/Transformable\r\n         * @extends module:zrender/mixin/Eventful\r\n         * @param {Object} options 关于shape的配置项，可以是shape的自有属性，也可以是自定义的属性。\r\n         */\r\n        var Base = function(options) {\r\n            \r\n            options = options || {};\r\n            \r\n            /**\r\n             * Shape id, 全局唯一\r\n             * @type {string}\r\n             */\r\n            this.id = options.id || guid();\r\n\r\n            for (var key in options) {\r\n                this[key] = options[key];\r\n            }\r\n\r\n            /**\r\n             * 基础绘制样式\r\n             * @type {module:zrender/shape/Base~IBaseShapeStyle}\r\n             */\r\n            this.style = this.style || {};\r\n\r\n            /**\r\n             * 高亮样式\r\n             * @type {module:zrender/shape/Base~IBaseShapeStyle}\r\n             */\r\n            this.highlightStyle = this.highlightStyle || null;\r\n\r\n            /**\r\n             * 父节点\r\n             * @readonly\r\n             * @type {module:zrender/Group}\r\n             * @default null\r\n             */\r\n            this.parent = null;\r\n\r\n            this.__dirty = true;\r\n\r\n            this.__clipShapes = [];\r\n\r\n            Transformable.call(this);\r\n            Eventful.call(this);\r\n        };\r\n        /**\r\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\r\n         * @name module:zrender/shape/Base#invisible\r\n         * @type {boolean}\r\n         * @default false\r\n         */\r\n        Base.prototype.invisible = false;\r\n\r\n        /**\r\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\r\n         * @name module:zrender/shape/Base#ignore\r\n         * @type {boolean}\r\n         * @default false\r\n         */\r\n        Base.prototype.ignore = false;\r\n\r\n        /**\r\n         * z层level，决定绘画在哪层canvas中\r\n         * @name module:zrender/shape/Base#zlevel\r\n         * @type {number}\r\n         * @default 0\r\n         */\r\n        Base.prototype.zlevel = 0;\r\n\r\n        /**\r\n         * 是否可拖拽\r\n         * @name module:zrender/shape/Base#draggable\r\n         * @type {boolean}\r\n         * @default false\r\n         */\r\n        Base.prototype.draggable = false;\r\n\r\n        /**\r\n         * 是否可点击\r\n         * @name module:zrender/shape/Base#clickable\r\n         * @type {boolean}\r\n         * @default false\r\n         */\r\n        Base.prototype.clickable = false;\r\n\r\n        /**\r\n         * 是否可以hover\r\n         * @name module:zrender/shape/Base#hoverable\r\n         * @type {boolean}\r\n         * @default true\r\n         */\r\n        Base.prototype.hoverable = true;\r\n        \r\n        /**\r\n         * z值，跟zlevel一样影响shape绘制的前后顺序，z值大的shape会覆盖在z值小的上面，\r\n         * 但是并不会创建新的canvas，所以优先级低于zlevel，而且频繁改动的开销比zlevel小很多。\r\n         * \r\n         * @name module:zrender/shape/Base#z\r\n         * @type {number}\r\n         * @default 0\r\n         */\r\n        Base.prototype.z = 0;\r\n\r\n        /**\r\n         * 绘制图形\r\n         * \r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {boolean} [isHighlight=false] 是否使用高亮属性\r\n         * @param {Function} [updateCallback]\r\n         *        需要异步加载资源的shape可以通过这个callback(e), \r\n         *        让painter更新视图，base.brush没用，需要的话重载brush\r\n         */\r\n        Base.prototype.brush = function (ctx, isHighlight) {\r\n\r\n            var style = this.beforeBrush(ctx, isHighlight);\r\n\r\n            ctx.beginPath();\r\n            this.buildPath(ctx, style);\r\n\r\n            switch (style.brushType) {\r\n                /* jshint ignore:start */\r\n                case 'both':\r\n                    ctx.fill();\r\n                case 'stroke':\r\n                    style.lineWidth > 0 && ctx.stroke();\r\n                    break;\r\n                /* jshint ignore:end */\r\n                default:\r\n                    ctx.fill();\r\n            }\r\n            \r\n            this.drawText(ctx, style, this.style);\r\n\r\n            this.afterBrush(ctx);\r\n        };\r\n\r\n        /**\r\n         * 具体绘制操作前的一些公共操作\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {boolean} [isHighlight=false] 是否使用高亮属性\r\n         * @return {Object} 处理后的样式\r\n         */\r\n        Base.prototype.beforeBrush = function (ctx, isHighlight) {\r\n            var style = this.style;\r\n            \r\n            if (this.brushTypeOnly) {\r\n                style.brushType = this.brushTypeOnly;\r\n            }\r\n\r\n            if (isHighlight) {\r\n                // 根据style扩展默认高亮样式\r\n                style = this.getHighlightStyle(\r\n                    style,\r\n                    this.highlightStyle || {},\r\n                    this.brushTypeOnly\r\n                );\r\n            }\r\n\r\n            if (this.brushTypeOnly == 'stroke') {\r\n                style.strokeColor = style.strokeColor || style.color;\r\n            }\r\n\r\n            ctx.save();\r\n\r\n            this.doClip(ctx);\r\n\r\n            this.setContext(ctx, style);\r\n\r\n            // 设置transform\r\n            this.setTransform(ctx);\r\n\r\n            return style;\r\n        };\r\n\r\n        /**\r\n         * 绘制后的处理\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         */\r\n        Base.prototype.afterBrush = function (ctx) {\r\n            ctx.restore();\r\n        };\r\n\r\n        var STYLE_CTX_MAP = [\r\n            [ 'color', 'fillStyle' ],\r\n            [ 'strokeColor', 'strokeStyle' ],\r\n            [ 'opacity', 'globalAlpha' ],\r\n            [ 'lineCap', 'lineCap' ],\r\n            [ 'lineJoin', 'lineJoin' ],\r\n            [ 'miterLimit', 'miterLimit' ],\r\n            [ 'lineWidth', 'lineWidth' ],\r\n            [ 'shadowBlur', 'shadowBlur' ],\r\n            [ 'shadowColor', 'shadowColor' ],\r\n            [ 'shadowOffsetX', 'shadowOffsetX' ],\r\n            [ 'shadowOffsetY', 'shadowOffsetY' ]\r\n        ];\r\n\r\n        /**\r\n         * 设置 fillStyle, strokeStyle, shadow 等通用绘制样式\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style\r\n         */\r\n        Base.prototype.setContext = function (ctx, style) {\r\n            for (var i = 0, len = STYLE_CTX_MAP.length; i < len; i++) {\r\n                var styleProp = STYLE_CTX_MAP[i][0];\r\n                var styleValue = style[styleProp];\r\n                var ctxProp = STYLE_CTX_MAP[i][1];\r\n\r\n                if (typeof styleValue != 'undefined') {\r\n                    ctx[ctxProp] = styleValue;\r\n                }\r\n            }\r\n        };\r\n\r\n        var clipShapeInvTransform = matrix.create();\r\n        Base.prototype.doClip = function (ctx) {\r\n            if (this.__clipShapes && !vmlCanvasManager) {\r\n                for (var i = 0; i < this.__clipShapes.length; i++) {\r\n                    var clipShape = this.__clipShapes[i];\r\n                    if (clipShape.needTransform) {\r\n                        var m = clipShape.transform;\r\n                        matrix.invert(clipShapeInvTransform, m);\r\n                        ctx.transform(\r\n                            m[0], m[1],\r\n                            m[2], m[3],\r\n                            m[4], m[5]\r\n                        );\r\n                    }\r\n                    ctx.beginPath();\r\n                    clipShape.buildPath(ctx, clipShape.style);\r\n                    ctx.clip();\r\n                    // Transform back\r\n                    if (clipShape.needTransform) {\r\n                        var m = clipShapeInvTransform;\r\n                        ctx.transform(\r\n                            m[0], m[1],\r\n                            m[2], m[3],\r\n                            m[4], m[5]\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    \r\n        /**\r\n         * 根据默认样式扩展高亮样式\r\n         * \r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style 默认样式\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} highlightStyle 高亮样式\r\n         * @param {string} brushTypeOnly\r\n         */\r\n        Base.prototype.getHighlightStyle = function (style, highlightStyle, brushTypeOnly) {\r\n            var newStyle = {};\r\n            for (var k in style) {\r\n                newStyle[k] = style[k];\r\n            }\r\n\r\n            var color = require('../tool/color');\r\n            var highlightColor = color.getHighlightColor();\r\n            // 根据highlightStyle扩展\r\n            if (style.brushType != 'stroke') {\r\n                // 带填充则用高亮色加粗边线\r\n                newStyle.strokeColor = highlightColor;\r\n                newStyle.lineWidth = (style.lineWidth || 1)\r\n                                      + this.getHighlightZoom();\r\n                newStyle.brushType = 'both';\r\n            }\r\n            else {\r\n                if (brushTypeOnly != 'stroke') {\r\n                    // 描边型的则用原色加工高亮\r\n                    newStyle.strokeColor = highlightColor;\r\n                    newStyle.lineWidth = (style.lineWidth || 1)\r\n                                          + this.getHighlightZoom();\r\n                } \r\n                else {\r\n                    // 线型的则用原色加工高亮\r\n                    newStyle.strokeColor = highlightStyle.strokeColor\r\n                                           || color.mix(\r\n                                                 style.strokeColor,\r\n                                                 color.toRGB(highlightColor)\r\n                                              );\r\n                }\r\n            }\r\n\r\n            // 可自定义覆盖默认值\r\n            for (var k in highlightStyle) {\r\n                if (typeof highlightStyle[k] != 'undefined') {\r\n                    newStyle[k] = highlightStyle[k];\r\n                }\r\n            }\r\n\r\n            return newStyle;\r\n        };\r\n\r\n        // 高亮放大效果参数\r\n        // 当前统一设置为6，如有需要差异设置，通过this.type判断实例类型\r\n        Base.prototype.getHighlightZoom = function () {\r\n            return this.type != 'text' ? 6 : 2;\r\n        };\r\n\r\n        /**\r\n         * 移动位置\r\n         * @param {number} dx 横坐标变化\r\n         * @param {number} dy 纵坐标变化\r\n         */\r\n        Base.prototype.drift = function (dx, dy) {\r\n            this.position[0] += dx;\r\n            this.position[1] += dy;\r\n        };\r\n\r\n        /**\r\n         * 构建绘制的Path\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style\r\n         */\r\n        Base.prototype.buildPath = function (ctx, style) {\r\n            log('buildPath not implemented in ' + this.type);\r\n        };\r\n\r\n        /**\r\n         * 计算返回包围盒矩形\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style\r\n         * @return {module:zrender/shape/Base~IBoundingRect}\r\n         */\r\n        Base.prototype.getRect = function (style) {\r\n            log('getRect not implemented in ' + this.type);   \r\n        };\r\n        \r\n        /**\r\n         * 判断鼠标位置是否在图形内\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @return {boolean}\r\n         */\r\n        Base.prototype.isCover = function (x, y) {\r\n            var originPos = this.transformCoordToLocal(x, y);\r\n            x = originPos[0];\r\n            y = originPos[1];\r\n\r\n            // 快速预判并保留判断矩形\r\n            if (this.isCoverRect(x, y)) {\r\n                // 矩形内\r\n                return require('../tool/area').isInside(this, this.style, x, y);\r\n            }\r\n            \r\n            return false;\r\n        };\r\n\r\n        Base.prototype.isCoverRect = function (x, y) {\r\n            // 快速预判并保留判断矩形\r\n            var rect = this.style.__rect;\r\n            if (!rect) {\r\n                rect = this.style.__rect = this.getRect(this.style);\r\n            }\r\n            return x >= rect.x\r\n                && x <= (rect.x + rect.width)\r\n                && y >= rect.y\r\n                && y <= (rect.y + rect.height);\r\n        };\r\n\r\n        /**\r\n         * 绘制附加文本\r\n         * @param {CanvasRenderingContext2D} ctx\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} style 样式\r\n         * @param {module:zrender/shape/Base~IBaseShapeStyle} normalStyle 默认样式，用于定位文字显示\r\n         */\r\n        Base.prototype.drawText = function (ctx, style, normalStyle) {\r\n            if (typeof(style.text) == 'undefined' || style.text === false) {\r\n                return;\r\n            }\r\n            // 字体颜色策略\r\n            var textColor = style.textColor || style.color || style.strokeColor;\r\n            ctx.fillStyle = textColor;\r\n\r\n            // 文本与图形间空白间隙\r\n            var dd = 10;\r\n            var al;         // 文本水平对齐\r\n            var bl;         // 文本垂直对齐\r\n            var tx;         // 文本横坐标\r\n            var ty;         // 文本纵坐标\r\n\r\n            var textPosition = style.textPosition       // 用户定义\r\n                               || this.textPosition     // shape默认\r\n                               || 'top';                // 全局默认\r\n\r\n            switch (textPosition) {\r\n                case 'inside': \r\n                case 'top': \r\n                case 'bottom': \r\n                case 'left': \r\n                case 'right': \r\n                    if (this.getRect) {\r\n                        var rect = (normalStyle || style).__rect\r\n                                   || this.getRect(normalStyle || style);\r\n\r\n                        switch (textPosition) {\r\n                            case 'inside':\r\n                                tx = rect.x + rect.width / 2;\r\n                                ty = rect.y + rect.height / 2;\r\n                                al = 'center';\r\n                                bl = 'middle';\r\n                                if (style.brushType != 'stroke'\r\n                                    && textColor == style.color\r\n                                ) {\r\n                                    ctx.fillStyle = '#fff';\r\n                                }\r\n                                break;\r\n                            case 'left':\r\n                                tx = rect.x - dd;\r\n                                ty = rect.y + rect.height / 2;\r\n                                al = 'end';\r\n                                bl = 'middle';\r\n                                break;\r\n                            case 'right':\r\n                                tx = rect.x + rect.width + dd;\r\n                                ty = rect.y + rect.height / 2;\r\n                                al = 'start';\r\n                                bl = 'middle';\r\n                                break;\r\n                            case 'top':\r\n                                tx = rect.x + rect.width / 2;\r\n                                ty = rect.y - dd;\r\n                                al = 'center';\r\n                                bl = 'bottom';\r\n                                break;\r\n                            case 'bottom':\r\n                                tx = rect.x + rect.width / 2;\r\n                                ty = rect.y + rect.height + dd;\r\n                                al = 'center';\r\n                                bl = 'top';\r\n                                break;\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'start':\r\n                case 'end':\r\n                    var pointList = style.pointList\r\n                                    || [\r\n                                        [style.xStart || 0, style.yStart || 0],\r\n                                        [style.xEnd || 0, style.yEnd || 0]\r\n                                    ];\r\n                    var length = pointList.length;\r\n                    if (length < 2) {\r\n                        // 少于2个点就不画了~\r\n                        return;\r\n                    }\r\n                    var xStart;\r\n                    var xEnd;\r\n                    var yStart;\r\n                    var yEnd;\r\n                    switch (textPosition) {\r\n                        case 'start':\r\n                            xStart = pointList[1][0];\r\n                            xEnd = pointList[0][0];\r\n                            yStart = pointList[1][1];\r\n                            yEnd = pointList[0][1];\r\n                            break;\r\n                        case 'end':\r\n                            xStart = pointList[length - 2][0];\r\n                            xEnd = pointList[length - 1][0];\r\n                            yStart = pointList[length - 2][1];\r\n                            yEnd = pointList[length - 1][1];\r\n                            break;\r\n                    }\r\n                    tx = xEnd;\r\n                    ty = yEnd;\r\n                    \r\n                    var angle = Math.atan((yStart - yEnd) / (xEnd - xStart)) / Math.PI * 180;\r\n                    if ((xEnd - xStart) < 0) {\r\n                        angle += 180;\r\n                    }\r\n                    else if ((yStart - yEnd) < 0) {\r\n                        angle += 360;\r\n                    }\r\n                    \r\n                    dd = 5;\r\n                    if (angle >= 30 && angle <= 150) {\r\n                        al = 'center';\r\n                        bl = 'bottom';\r\n                        ty -= dd;\r\n                    }\r\n                    else if (angle > 150 && angle < 210) {\r\n                        al = 'right';\r\n                        bl = 'middle';\r\n                        tx -= dd;\r\n                    }\r\n                    else if (angle >= 210 && angle <= 330) {\r\n                        al = 'center';\r\n                        bl = 'top';\r\n                        ty += dd;\r\n                    }\r\n                    else {\r\n                        al = 'left';\r\n                        bl = 'middle';\r\n                        tx += dd;\r\n                    }\r\n                    break;\r\n                case 'specific':\r\n                    tx = style.textX || 0;\r\n                    ty = style.textY || 0;\r\n                    al = 'start';\r\n                    bl = 'middle';\r\n                    break;\r\n            }\r\n\r\n            if (tx != null && ty != null) {\r\n                _fillText(\r\n                    ctx,\r\n                    style.text, \r\n                    tx, ty, \r\n                    style.textFont,\r\n                    style.textAlign || al,\r\n                    style.textBaseline || bl\r\n                );\r\n            }\r\n        };\r\n\r\n        Base.prototype.modSelf = function() {\r\n            this.__dirty = true;\r\n            if (this.style) {\r\n                this.style.__rect = null;\r\n            }\r\n            if (this.highlightStyle) {\r\n                this.highlightStyle.__rect = null;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * 图形是否会触发事件\r\n         * @return {boolean}\r\n         */\r\n        // TODO, 通过 bind 绑定的事件\r\n        Base.prototype.isSilent = function () {\r\n            return !(\r\n                this.hoverable || this.draggable || this.clickable\r\n                || this.onmousemove || this.onmouseover || this.onmouseout\r\n                || this.onmousedown || this.onmouseup || this.onclick\r\n                || this.ondragenter || this.ondragover || this.ondragleave\r\n                || this.ondrop\r\n            );\r\n        };\r\n\r\n        util.merge(Base.prototype, Transformable.prototype, true);\r\n        util.merge(Base.prototype, Eventful.prototype, true);\r\n\r\n        return Base;\r\n    }\r\n);\r\n"
    },
    {
      "id": 8,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\matrix.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/matrix.js",
      "index": 8,
      "index2": 0,
      "size": 4932,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../tool/matrix",
          "loc": "42:21-46"
        },
        {
          "moduleId": 14,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\mixin\\Transformable.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
          "type": "cjs require",
          "userRequest": "../tool/matrix",
          "loc": "10:17-42"
        }
      ],
      "source": "define(\r\n    function () {\r\n\r\n        var ArrayCtor = typeof Float32Array === 'undefined'\r\n            ? Array\r\n            : Float32Array;\r\n        /**\r\n         * 3x2矩阵操作类\r\n         * @exports zrender/tool/matrix\r\n         */\r\n        var matrix = {\r\n            /**\r\n             * 创建一个单位矩阵\r\n             * @return {Float32Array|Array.<number>}\r\n             */\r\n            create : function() {\r\n                var out = new ArrayCtor(6);\r\n                matrix.identity(out);\r\n                \r\n                return out;\r\n            },\r\n            /**\r\n             * 设置矩阵为单位矩阵\r\n             * @param {Float32Array|Array.<number>} out\r\n             */\r\n            identity : function(out) {\r\n                out[0] = 1;\r\n                out[1] = 0;\r\n                out[2] = 0;\r\n                out[3] = 1;\r\n                out[4] = 0;\r\n                out[5] = 0;\r\n                return out;\r\n            },\r\n            /**\r\n             * 复制矩阵\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} m\r\n             */\r\n            copy: function(out, m) {\r\n                out[0] = m[0];\r\n                out[1] = m[1];\r\n                out[2] = m[2];\r\n                out[3] = m[3];\r\n                out[4] = m[4];\r\n                out[5] = m[5];\r\n                return out;\r\n            },\r\n            /**\r\n             * 矩阵相乘\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} m1\r\n             * @param {Float32Array|Array.<number>} m2\r\n             */\r\n            mul : function (out, m1, m2) {\r\n                out[0] = m1[0] * m2[0] + m1[2] * m2[1];\r\n                out[1] = m1[1] * m2[0] + m1[3] * m2[1];\r\n                out[2] = m1[0] * m2[2] + m1[2] * m2[3];\r\n                out[3] = m1[1] * m2[2] + m1[3] * m2[3];\r\n                out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\r\n                out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\r\n                return out;\r\n            },\r\n            /**\r\n             * 平移变换\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} a\r\n             * @param {Float32Array|Array.<number>} v\r\n             */\r\n            translate : function(out, a, v) {\r\n                out[0] = a[0];\r\n                out[1] = a[1];\r\n                out[2] = a[2];\r\n                out[3] = a[3];\r\n                out[4] = a[4] + v[0];\r\n                out[5] = a[5] + v[1];\r\n                return out;\r\n            },\r\n            /**\r\n             * 旋转变换\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} a\r\n             * @param {number} rad\r\n             */\r\n            rotate : function(out, a, rad) {\r\n                var aa = a[0];\r\n                var ac = a[2];\r\n                var atx = a[4];\r\n                var ab = a[1];\r\n                var ad = a[3];\r\n                var aty = a[5];\r\n                var st = Math.sin(rad);\r\n                var ct = Math.cos(rad);\r\n\r\n                out[0] = aa * ct + ab * st;\r\n                out[1] = -aa * st + ab * ct;\r\n                out[2] = ac * ct + ad * st;\r\n                out[3] = -ac * st + ct * ad;\r\n                out[4] = ct * atx + st * aty;\r\n                out[5] = ct * aty - st * atx;\r\n                return out;\r\n            },\r\n            /**\r\n             * 缩放变换\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} a\r\n             * @param {Float32Array|Array.<number>} v\r\n             */\r\n            scale : function(out, a, v) {\r\n                var vx = v[0];\r\n                var vy = v[1];\r\n                out[0] = a[0] * vx;\r\n                out[1] = a[1] * vy;\r\n                out[2] = a[2] * vx;\r\n                out[3] = a[3] * vy;\r\n                out[4] = a[4] * vx;\r\n                out[5] = a[5] * vy;\r\n                return out;\r\n            },\r\n            /**\r\n             * 求逆矩阵\r\n             * @param {Float32Array|Array.<number>} out\r\n             * @param {Float32Array|Array.<number>} a\r\n             */\r\n            invert : function(out, a) {\r\n            \r\n                var aa = a[0];\r\n                var ac = a[2];\r\n                var atx = a[4];\r\n                var ab = a[1];\r\n                var ad = a[3];\r\n                var aty = a[5];\r\n\r\n                var det = aa * ad - ab * ac;\r\n                if (!det) {\r\n                    return null;\r\n                }\r\n                det = 1.0 / det;\r\n\r\n                out[0] = ad * det;\r\n                out[1] = -ab * det;\r\n                out[2] = -ac * det;\r\n                out[3] = aa * det;\r\n                out[4] = (ac * aty - ad * atx) * det;\r\n                out[5] = (ab * atx - aa * aty) * det;\r\n                return out;\r\n            }\r\n        };\r\n\r\n        return matrix;\r\n    }\r\n);\r\n"
    },
    {
      "id": 9,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\guid.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/guid.js",
      "index": 9,
      "index2": 1,
      "size": 238,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../tool/guid",
          "loc": "43:19-42"
        }
      ],
      "source": "/**\r\n * zrender: 生成唯一id\r\n *\r\n * @author errorrik (errorrik@gmail.com)\r\n */\r\n\r\ndefine(\r\n    function() {\r\n        var idStart = 0x0907;\r\n\r\n        return function () {\r\n            return 'zrender__' + (idStart++);\r\n        };\r\n    }\r\n);\r\n"
    },
    {
      "id": 10,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\util.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/util.js",
      "index": 10,
      "index2": 3,
      "size": 7888,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "63:17-47"
        },
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "25:17-47"
        },
        {
          "moduleId": 6,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Image.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Image.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "198:8-31"
        },
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "44:19-42"
        },
        {
          "moduleId": 17,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\area.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
          "type": "cjs require",
          "userRequest": "./util",
          "loc": "16:19-36"
        },
        {
          "moduleId": 19,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\color.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/color.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/color.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "6:15-38"
        },
        {
          "moduleId": 20,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "35:17-47"
        },
        {
          "moduleId": 21,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "161:8-31"
        },
        {
          "moduleId": 23,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "138:8-31"
        },
        {
          "moduleId": 25,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "137:8-31"
        },
        {
          "moduleId": 26,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "32:17-47"
        },
        {
          "moduleId": 27,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "122:8-31"
        },
        {
          "moduleId": 29,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\BezierCurve.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "145:8-31"
        },
        {
          "moduleId": 30,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "38:17-47"
        },
        {
          "moduleId": 31,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "211:8-31"
        },
        {
          "moduleId": 35,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "155:8-31"
        },
        {
          "moduleId": 36,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\ShapeBundle.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "149:4-27"
        },
        {
          "moduleId": 39,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecAnimation.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "9:17-47"
        },
        {
          "moduleId": 41,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Circle.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "114:8-31"
        },
        {
          "moduleId": 44,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "13:17-47"
        },
        {
          "moduleId": 45,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecQuery.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecQuery.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecQuery.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "9:17-47"
        },
        {
          "moduleId": 50,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Rectangle.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "203:8-31"
        },
        {
          "moduleId": 51,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "23:17-47"
        },
        {
          "moduleId": 52,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "76:17-47"
        },
        {
          "moduleId": 53,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Text.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
          "type": "cjs require",
          "userRequest": "../tool/util",
          "loc": "207:8-31"
        },
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "76:17-47"
        },
        {
          "moduleId": 59,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "30:17-47"
        },
        {
          "moduleId": 60,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "45:17-47"
        },
        {
          "moduleId": 64,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "23:17-47"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "70:17-47"
        },
        {
          "moduleId": 68,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/util",
          "loc": "50:17-47"
        }
      ],
      "source": "/**\r\n * @module zrender/tool/util\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         Yi Shen(https://github.com/pissang)\r\n */\r\ndefine(\r\n    function(require) {\r\n\r\n        var ArrayProto = Array.prototype;\r\n        var nativeForEach = ArrayProto.forEach;\r\n        var nativeMap = ArrayProto.map;\r\n        var nativeFilter = ArrayProto.filter;\r\n\r\n        // 用于处理merge时无法遍历Date等对象的问题\r\n        var BUILTIN_OBJECT = {\r\n            '[object Function]': 1,\r\n            '[object RegExp]': 1,\r\n            '[object Date]': 1,\r\n            '[object Error]': 1,\r\n            '[object CanvasGradient]': 1\r\n        };\r\n\r\n        var objToString = Object.prototype.toString;\r\n\r\n        function isDom(obj) {\r\n            return obj && obj.nodeType === 1\r\n                   && typeof(obj.nodeName) == 'string';\r\n        }\r\n\r\n        /**\r\n         * 对一个object进行深度拷贝\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {*} source 需要进行拷贝的对象\r\n         * @return {*} 拷贝后的新对象\r\n         */\r\n        function clone(source) {\r\n            if (typeof source == 'object' && source !== null) {\r\n                var result = source;\r\n                if (source instanceof Array) {\r\n                    result = [];\r\n                    for (var i = 0, len = source.length; i < len; i++) {\r\n                        result[i] = clone(source[i]);\r\n                    }\r\n                }\r\n                else if (\r\n                    !BUILTIN_OBJECT[objToString.call(source)]\r\n                    // 是否为 dom 对象\r\n                    && !isDom(source)\r\n                ) {\r\n                    result = {};\r\n                    for (var key in source) {\r\n                        if (source.hasOwnProperty(key)) {\r\n                            result[key] = clone(source[key]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return result;\r\n            }\r\n\r\n            return source;\r\n        }\r\n\r\n        function mergeItem(target, source, key, overwrite) {\r\n            if (source.hasOwnProperty(key)) {\r\n                var targetProp = target[key];\r\n                if (typeof targetProp == 'object'\r\n                    && !BUILTIN_OBJECT[objToString.call(targetProp)]\r\n                    // 是否为 dom 对象\r\n                    && !isDom(targetProp)\r\n                ) {\r\n                    // 如果需要递归覆盖，就递归调用merge\r\n                    merge(\r\n                        target[key],\r\n                        source[key],\r\n                        overwrite\r\n                    );\r\n                }\r\n                else if (overwrite || !(key in target)) {\r\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\r\n                    target[key] = source[key];\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 合并源对象的属性到目标对象\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {*} target 目标对象\r\n         * @param {*} source 源对象\r\n         * @param {boolean} overwrite 是否覆盖\r\n         */\r\n        function merge(target, source, overwrite) {\r\n            for (var i in source) {\r\n                mergeItem(target, source, i, overwrite);\r\n            }\r\n            \r\n            return target;\r\n        }\r\n\r\n        var _ctx;\r\n\r\n        function getContext() {\r\n            if (!_ctx) {\r\n                require('../dep/excanvas');\r\n                /* jshint ignore:start */\r\n                if (window['G_vmlCanvasManager']) {\r\n                    var _div = document.createElement('div');\r\n                    _div.style.position = 'absolute';\r\n                    _div.style.top = '-1000px';\r\n                    document.body.appendChild(_div);\r\n\r\n                    _ctx = G_vmlCanvasManager.initElement(_div)\r\n                               .getContext('2d');\r\n                }\r\n                else {\r\n                    _ctx = document.createElement('canvas').getContext('2d');\r\n                }\r\n                /* jshint ignore:end */\r\n            }\r\n            return _ctx;\r\n        }\r\n\r\n        /**\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Array} array\r\n         * @param {*} value\r\n         */\r\n        function indexOf(array, value) {\r\n            if (array.indexOf) {\r\n                return array.indexOf(value);\r\n            }\r\n            for (var i = 0, len = array.length; i < len; i++) {\r\n                if (array[i] === value) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        /**\r\n         * 构造类继承关系\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Function} clazz 源类\r\n         * @param {Function} baseClazz 基类\r\n         */\r\n        function inherits(clazz, baseClazz) {\r\n            var clazzPrototype = clazz.prototype;\r\n            function F() {}\r\n            F.prototype = baseClazz.prototype;\r\n            clazz.prototype = new F();\r\n\r\n            for (var prop in clazzPrototype) {\r\n                clazz.prototype[prop] = clazzPrototype[prop];\r\n            }\r\n            clazz.constructor = clazz;\r\n        }\r\n\r\n        /**\r\n         * 数组或对象遍历\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Object|Array} obj\r\n         * @param {Function} cb\r\n         * @param {*} [context]\r\n         */\r\n        function each(obj, cb, context) {\r\n            if (!(obj && cb)) {\r\n                return;\r\n            }\r\n            if (obj.forEach && obj.forEach === nativeForEach) {\r\n                obj.forEach(cb, context);\r\n            }\r\n            else if (obj.length === +obj.length) {\r\n                for (var i = 0, len = obj.length; i < len; i++) {\r\n                    cb.call(context, obj[i], i, obj);\r\n                }\r\n            }\r\n            else {\r\n                for (var key in obj) {\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        cb.call(context, obj[key], key, obj);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 数组映射\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Array} obj\r\n         * @param {Function} cb\r\n         * @param {*} [context]\r\n         * @return {Array}\r\n         */\r\n        function map(obj, cb, context) {\r\n            if (!(obj && cb)) {\r\n                return;\r\n            }\r\n            if (obj.map && obj.map === nativeMap) {\r\n                return obj.map(cb, context);\r\n            }\r\n            else {\r\n                var result = [];\r\n                for (var i = 0, len = obj.length; i < len; i++) {\r\n                    result.push(cb.call(context, obj[i], i, obj));\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 数组过滤\r\n         * @memberOf module:zrender/tool/util\r\n         * @param {Array} obj\r\n         * @param {Function} cb\r\n         * @param {*} [context]\r\n         * @return {Array}\r\n         */\r\n        function filter(obj, cb, context) {\r\n            if (!(obj && cb)) {\r\n                return;\r\n            }\r\n            if (obj.filter && obj.filter === nativeFilter) {\r\n                return obj.filter(cb, context);\r\n            }\r\n            else {\r\n                var result = [];\r\n                for (var i = 0, len = obj.length; i < len; i++) {\r\n                    if (cb.call(context, obj[i], i, obj)) {\r\n                        result.push(obj[i]);\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n\r\n        function bind(func, context) {\r\n            \r\n            return function () {\r\n                func.apply(context, arguments);\r\n            }\r\n        }\r\n\r\n        return {\r\n            inherits: inherits,\r\n            clone: clone,\r\n            merge: merge,\r\n            getContext: getContext,\r\n            indexOf: indexOf,\r\n            each: each,\r\n            map: map,\r\n            filter: filter,\r\n            bind: bind\r\n        };\r\n    }\r\n);\r\n"
    },
    {
      "id": 11,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\dep\\excanvas.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/dep/excanvas.js",
      "index": 11,
      "index2": 2,
      "size": 44025,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\util.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 10,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\util.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/util.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/util.js",
          "type": "cjs require",
          "userRequest": "../dep/excanvas",
          "loc": "105:16-42"
        }
      ],
      "source": "// Copyright 2006 Google Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n\r\n// Known Issues:\r\n//\r\n// * Patterns only support repeat.\r\n// * Radial gradient are not implemented. The VML version of these look very\r\n//   different from the canvas one.\r\n// * Clipping paths are not implemented.\r\n// * Coordsize. The width and height attribute have higher priority than the\r\n//   width and height style values which isn't correct.\r\n// * Painting mode isn't implemented.\r\n// * Canvas width/height should is using content-box by default. IE in\r\n//   Quirks mode will draw the canvas using border-box. Either change your\r\n//   doctype to HTML5\r\n//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype)\r\n//   or use Box Sizing Behavior from WebFX\r\n//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html)\r\n// * Non uniform scaling does not correctly scale strokes.\r\n// * Optimize. There is always room for speed improvements.\r\n\r\n// AMD by kener.linfeng@gmail.com\r\ndefine(function(require) {\r\n\r\n// Only add this code if we do not already have a canvas implementation\r\nif (!document.createElement('canvas').getContext) {\r\n\r\n(function() {\r\n\r\n  // alias some functions to make (compiled) code shorter\r\n  var m = Math;\r\n  var mr = m.round;\r\n  var ms = m.sin;\r\n  var mc = m.cos;\r\n  var abs = m.abs;\r\n  var sqrt = m.sqrt;\r\n\r\n  // this is used for sub pixel precision\r\n  var Z = 10;\r\n  var Z2 = Z / 2;\r\n\r\n  var IE_VERSION = +navigator.userAgent.match(/MSIE ([\\d.]+)?/)[1];\r\n\r\n  /**\r\n   * This funtion is assigned to the <canvas> elements as element.getContext().\r\n   * @this {HTMLElement}\r\n   * @return {CanvasRenderingContext2D_}\r\n   */\r\n  function getContext() {\r\n    return this.context_ ||\r\n        (this.context_ = new CanvasRenderingContext2D_(this));\r\n  }\r\n\r\n  var slice = Array.prototype.slice;\r\n\r\n  /**\r\n   * Binds a function to an object. The returned function will always use the\r\n   * passed in {@code obj} as {@code this}.\r\n   *\r\n   * Example:\r\n   *\r\n   *   g = bind(f, obj, a, b)\r\n   *   g(c, d) // will do f.call(obj, a, b, c, d)\r\n   *\r\n   * @param {Function} f The function to bind the object to\r\n   * @param {Object} obj The object that should act as this when the function\r\n   *     is called\r\n   * @param {*} var_args Rest arguments that will be used as the initial\r\n   *     arguments when the function is called\r\n   * @return {Function} A new function that has bound this\r\n   */\r\n  function bind(f, obj, var_args) {\r\n    var a = slice.call(arguments, 2);\r\n    return function() {\r\n      return f.apply(obj, a.concat(slice.call(arguments)));\r\n    };\r\n  }\r\n\r\n  function encodeHtmlAttribute(s) {\r\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\r\n  }\r\n\r\n  function addNamespace(doc, prefix, urn) {\r\n    if (!doc.namespaces[prefix]) {\r\n      doc.namespaces.add(prefix, urn, '#default#VML');\r\n    }\r\n  }\r\n\r\n  function addNamespacesAndStylesheet(doc) {\r\n    addNamespace(doc, 'g_vml_', 'urn:schemas-microsoft-com:vml');\r\n    addNamespace(doc, 'g_o_', 'urn:schemas-microsoft-com:office:office');\r\n\r\n    // Setup default CSS.  Only add one style sheet per document\r\n    if (!doc.styleSheets['ex_canvas_']) {\r\n      var ss = doc.createStyleSheet();\r\n      ss.owningElement.id = 'ex_canvas_';\r\n      ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +\r\n          // default size is 300x150 in Gecko and Opera\r\n          'text-align:left;width:300px;height:150px}';\r\n    }\r\n  }\r\n\r\n  // Add namespaces and stylesheet at startup.\r\n  addNamespacesAndStylesheet(document);\r\n\r\n  var G_vmlCanvasManager_ = {\r\n    init: function(opt_doc) {\r\n      var doc = opt_doc || document;\r\n      // Create a dummy element so that IE will allow canvas elements to be\r\n      // recognized.\r\n      doc.createElement('canvas');\r\n      doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));\r\n    },\r\n\r\n    init_: function(doc) {\r\n      // find all canvas elements\r\n      var els = doc.getElementsByTagName('canvas');\r\n      for (var i = 0; i < els.length; i++) {\r\n        this.initElement(els[i]);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Public initializes a canvas element so that it can be used as canvas\r\n     * element from now on. This is called automatically before the page is\r\n     * loaded but if you are creating elements using createElement you need to\r\n     * make sure this is called on the element.\r\n     * @param {HTMLElement} el The canvas element to initialize.\r\n     * @return {HTMLElement} the element that was created.\r\n     */\r\n    initElement: function(el) {\r\n      if (!el.getContext) {\r\n        el.getContext = getContext;\r\n\r\n        // Add namespaces and stylesheet to document of the element.\r\n        addNamespacesAndStylesheet(el.ownerDocument);\r\n\r\n        // Remove fallback content. There is no way to hide text nodes so we\r\n        // just remove all childNodes. We could hide all elements and remove\r\n        // text nodes but who really cares about the fallback content.\r\n        el.innerHTML = '';\r\n\r\n        // do not use inline function because that will leak memory\r\n        el.attachEvent('onpropertychange', onPropertyChange);\r\n        el.attachEvent('onresize', onResize);\r\n\r\n        var attrs = el.attributes;\r\n        if (attrs.width && attrs.width.specified) {\r\n          // TODO: use runtimeStyle and coordsize\r\n          // el.getContext().setWidth_(attrs.width.nodeValue);\r\n          el.style.width = attrs.width.nodeValue + 'px';\r\n        } else {\r\n          el.width = el.clientWidth;\r\n        }\r\n        if (attrs.height && attrs.height.specified) {\r\n          // TODO: use runtimeStyle and coordsize\r\n          // el.getContext().setHeight_(attrs.height.nodeValue);\r\n          el.style.height = attrs.height.nodeValue + 'px';\r\n        } else {\r\n          el.height = el.clientHeight;\r\n        }\r\n        //el.getContext().setCoordsize_()\r\n      }\r\n      return el;\r\n    }\r\n  };\r\n\r\n  function onPropertyChange(e) {\r\n    var el = e.srcElement;\r\n\r\n    switch (e.propertyName) {\r\n      case 'width':\r\n        el.getContext().clearRect();\r\n        el.style.width = el.attributes.width.nodeValue + 'px';\r\n        // In IE8 this does not trigger onresize.\r\n        el.firstChild.style.width =  el.clientWidth + 'px';\r\n        break;\r\n      case 'height':\r\n        el.getContext().clearRect();\r\n        el.style.height = el.attributes.height.nodeValue + 'px';\r\n        el.firstChild.style.height = el.clientHeight + 'px';\r\n        break;\r\n    }\r\n  }\r\n\r\n  function onResize(e) {\r\n    var el = e.srcElement;\r\n    if (el.firstChild) {\r\n      el.firstChild.style.width =  el.clientWidth + 'px';\r\n      el.firstChild.style.height = el.clientHeight + 'px';\r\n    }\r\n  }\r\n\r\n  G_vmlCanvasManager_.init();\r\n\r\n  // precompute \"00\" to \"FF\"\r\n  var decToHex = [];\r\n  for (var i = 0; i < 16; i++) {\r\n    for (var j = 0; j < 16; j++) {\r\n      decToHex[i * 16 + j] = i.toString(16) + j.toString(16);\r\n    }\r\n  }\r\n\r\n  function createMatrixIdentity() {\r\n    return [\r\n      [1, 0, 0],\r\n      [0, 1, 0],\r\n      [0, 0, 1]\r\n    ];\r\n  }\r\n\r\n  function matrixMultiply(m1, m2) {\r\n    var result = createMatrixIdentity();\r\n\r\n    for (var x = 0; x < 3; x++) {\r\n      for (var y = 0; y < 3; y++) {\r\n        var sum = 0;\r\n\r\n        for (var z = 0; z < 3; z++) {\r\n          sum += m1[x][z] * m2[z][y];\r\n        }\r\n\r\n        result[x][y] = sum;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function copyState(o1, o2) {\r\n    o2.fillStyle     = o1.fillStyle;\r\n    o2.lineCap       = o1.lineCap;\r\n    o2.lineJoin      = o1.lineJoin;\r\n    o2.lineWidth     = o1.lineWidth;\r\n    o2.miterLimit    = o1.miterLimit;\r\n    o2.shadowBlur    = o1.shadowBlur;\r\n    o2.shadowColor   = o1.shadowColor;\r\n    o2.shadowOffsetX = o1.shadowOffsetX;\r\n    o2.shadowOffsetY = o1.shadowOffsetY;\r\n    o2.strokeStyle   = o1.strokeStyle;\r\n    o2.globalAlpha   = o1.globalAlpha;\r\n    o2.font          = o1.font;\r\n    o2.textAlign     = o1.textAlign;\r\n    o2.textBaseline  = o1.textBaseline;\r\n    o2.scaleX_    = o1.scaleX_;\r\n    o2.scaleY_    = o1.scaleY_;\r\n    o2.lineScale_    = o1.lineScale_;\r\n  }\r\n\r\n  var colorData = {\r\n    aliceblue: '#F0F8FF',\r\n    antiquewhite: '#FAEBD7',\r\n    aquamarine: '#7FFFD4',\r\n    azure: '#F0FFFF',\r\n    beige: '#F5F5DC',\r\n    bisque: '#FFE4C4',\r\n    black: '#000000',\r\n    blanchedalmond: '#FFEBCD',\r\n    blueviolet: '#8A2BE2',\r\n    brown: '#A52A2A',\r\n    burlywood: '#DEB887',\r\n    cadetblue: '#5F9EA0',\r\n    chartreuse: '#7FFF00',\r\n    chocolate: '#D2691E',\r\n    coral: '#FF7F50',\r\n    cornflowerblue: '#6495ED',\r\n    cornsilk: '#FFF8DC',\r\n    crimson: '#DC143C',\r\n    cyan: '#00FFFF',\r\n    darkblue: '#00008B',\r\n    darkcyan: '#008B8B',\r\n    darkgoldenrod: '#B8860B',\r\n    darkgray: '#A9A9A9',\r\n    darkgreen: '#006400',\r\n    darkgrey: '#A9A9A9',\r\n    darkkhaki: '#BDB76B',\r\n    darkmagenta: '#8B008B',\r\n    darkolivegreen: '#556B2F',\r\n    darkorange: '#FF8C00',\r\n    darkorchid: '#9932CC',\r\n    darkred: '#8B0000',\r\n    darksalmon: '#E9967A',\r\n    darkseagreen: '#8FBC8F',\r\n    darkslateblue: '#483D8B',\r\n    darkslategray: '#2F4F4F',\r\n    darkslategrey: '#2F4F4F',\r\n    darkturquoise: '#00CED1',\r\n    darkviolet: '#9400D3',\r\n    deeppink: '#FF1493',\r\n    deepskyblue: '#00BFFF',\r\n    dimgray: '#696969',\r\n    dimgrey: '#696969',\r\n    dodgerblue: '#1E90FF',\r\n    firebrick: '#B22222',\r\n    floralwhite: '#FFFAF0',\r\n    forestgreen: '#228B22',\r\n    gainsboro: '#DCDCDC',\r\n    ghostwhite: '#F8F8FF',\r\n    gold: '#FFD700',\r\n    goldenrod: '#DAA520',\r\n    grey: '#808080',\r\n    greenyellow: '#ADFF2F',\r\n    honeydew: '#F0FFF0',\r\n    hotpink: '#FF69B4',\r\n    indianred: '#CD5C5C',\r\n    indigo: '#4B0082',\r\n    ivory: '#FFFFF0',\r\n    khaki: '#F0E68C',\r\n    lavender: '#E6E6FA',\r\n    lavenderblush: '#FFF0F5',\r\n    lawngreen: '#7CFC00',\r\n    lemonchiffon: '#FFFACD',\r\n    lightblue: '#ADD8E6',\r\n    lightcoral: '#F08080',\r\n    lightcyan: '#E0FFFF',\r\n    lightgoldenrodyellow: '#FAFAD2',\r\n    lightgreen: '#90EE90',\r\n    lightgrey: '#D3D3D3',\r\n    lightpink: '#FFB6C1',\r\n    lightsalmon: '#FFA07A',\r\n    lightseagreen: '#20B2AA',\r\n    lightskyblue: '#87CEFA',\r\n    lightslategray: '#778899',\r\n    lightslategrey: '#778899',\r\n    lightsteelblue: '#B0C4DE',\r\n    lightyellow: '#FFFFE0',\r\n    limegreen: '#32CD32',\r\n    linen: '#FAF0E6',\r\n    magenta: '#FF00FF',\r\n    mediumaquamarine: '#66CDAA',\r\n    mediumblue: '#0000CD',\r\n    mediumorchid: '#BA55D3',\r\n    mediumpurple: '#9370DB',\r\n    mediumseagreen: '#3CB371',\r\n    mediumslateblue: '#7B68EE',\r\n    mediumspringgreen: '#00FA9A',\r\n    mediumturquoise: '#48D1CC',\r\n    mediumvioletred: '#C71585',\r\n    midnightblue: '#191970',\r\n    mintcream: '#F5FFFA',\r\n    mistyrose: '#FFE4E1',\r\n    moccasin: '#FFE4B5',\r\n    navajowhite: '#FFDEAD',\r\n    oldlace: '#FDF5E6',\r\n    olivedrab: '#6B8E23',\r\n    orange: '#FFA500',\r\n    orangered: '#FF4500',\r\n    orchid: '#DA70D6',\r\n    palegoldenrod: '#EEE8AA',\r\n    palegreen: '#98FB98',\r\n    paleturquoise: '#AFEEEE',\r\n    palevioletred: '#DB7093',\r\n    papayawhip: '#FFEFD5',\r\n    peachpuff: '#FFDAB9',\r\n    peru: '#CD853F',\r\n    pink: '#FFC0CB',\r\n    plum: '#DDA0DD',\r\n    powderblue: '#B0E0E6',\r\n    rosybrown: '#BC8F8F',\r\n    royalblue: '#4169E1',\r\n    saddlebrown: '#8B4513',\r\n    salmon: '#FA8072',\r\n    sandybrown: '#F4A460',\r\n    seagreen: '#2E8B57',\r\n    seashell: '#FFF5EE',\r\n    sienna: '#A0522D',\r\n    skyblue: '#87CEEB',\r\n    slateblue: '#6A5ACD',\r\n    slategray: '#708090',\r\n    slategrey: '#708090',\r\n    snow: '#FFFAFA',\r\n    springgreen: '#00FF7F',\r\n    steelblue: '#4682B4',\r\n    tan: '#D2B48C',\r\n    thistle: '#D8BFD8',\r\n    tomato: '#FF6347',\r\n    turquoise: '#40E0D0',\r\n    violet: '#EE82EE',\r\n    wheat: '#F5DEB3',\r\n    whitesmoke: '#F5F5F5',\r\n    yellowgreen: '#9ACD32'\r\n  };\r\n\r\n\r\n  function getRgbHslContent(styleString) {\r\n    var start = styleString.indexOf('(', 3);\r\n    var end = styleString.indexOf(')', start + 1);\r\n    var parts = styleString.substring(start + 1, end).split(',');\r\n    // add alpha if needed\r\n    if (parts.length != 4 || styleString.charAt(3) != 'a') {\r\n      parts[3] = 1;\r\n    }\r\n    return parts;\r\n  }\r\n\r\n  function percent(s) {\r\n    return parseFloat(s) / 100;\r\n  }\r\n\r\n  function clamp(v, min, max) {\r\n    return Math.min(max, Math.max(min, v));\r\n  }\r\n\r\n  function hslToRgb(parts){\r\n    var r, g, b, h, s, l;\r\n    h = parseFloat(parts[0]) / 360 % 360;\r\n    if (h < 0)\r\n      h++;\r\n    s = clamp(percent(parts[1]), 0, 1);\r\n    l = clamp(percent(parts[2]), 0, 1);\r\n    if (s == 0) {\r\n      r = g = b = l; // achromatic\r\n    } else {\r\n      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n      var p = 2 * l - q;\r\n      r = hueToRgb(p, q, h + 1 / 3);\r\n      g = hueToRgb(p, q, h);\r\n      b = hueToRgb(p, q, h - 1 / 3);\r\n    }\r\n\r\n    return '#' + decToHex[Math.floor(r * 255)] +\r\n        decToHex[Math.floor(g * 255)] +\r\n        decToHex[Math.floor(b * 255)];\r\n  }\r\n\r\n  function hueToRgb(m1, m2, h) {\r\n    if (h < 0)\r\n      h++;\r\n    if (h > 1)\r\n      h--;\r\n\r\n    if (6 * h < 1)\r\n      return m1 + (m2 - m1) * 6 * h;\r\n    else if (2 * h < 1)\r\n      return m2;\r\n    else if (3 * h < 2)\r\n      return m1 + (m2 - m1) * (2 / 3 - h) * 6;\r\n    else\r\n      return m1;\r\n  }\r\n\r\n  var processStyleCache = {};\r\n\r\n  function processStyle(styleString) {\r\n    if (styleString in processStyleCache) {\r\n      return processStyleCache[styleString];\r\n    }\r\n\r\n    var str, alpha = 1;\r\n\r\n    styleString = String(styleString);\r\n    if (styleString.charAt(0) == '#') {\r\n      str = styleString;\r\n    } else if (/^rgb/.test(styleString)) {\r\n      var parts = getRgbHslContent(styleString);\r\n      var str = '#', n;\r\n      for (var i = 0; i < 3; i++) {\r\n        if (parts[i].indexOf('%') != -1) {\r\n          n = Math.floor(percent(parts[i]) * 255);\r\n        } else {\r\n          n = +parts[i];\r\n        }\r\n        str += decToHex[clamp(n, 0, 255)];\r\n      }\r\n      alpha = +parts[3];\r\n    } else if (/^hsl/.test(styleString)) {\r\n      var parts = getRgbHslContent(styleString);\r\n      str = hslToRgb(parts);\r\n      alpha = parts[3];\r\n    } else {\r\n      str = colorData[styleString] || styleString;\r\n    }\r\n    return processStyleCache[styleString] = {color: str, alpha: alpha};\r\n  }\r\n\r\n  var DEFAULT_STYLE = {\r\n    style: 'normal',\r\n    variant: 'normal',\r\n    weight: 'normal',\r\n    size: 12,           //10\r\n    family: '微软雅黑'     //'sans-serif'\r\n  };\r\n\r\n  // Internal text style cache\r\n  var fontStyleCache = {};\r\n\r\n  function processFontStyle(styleString) {\r\n    if (fontStyleCache[styleString]) {\r\n      return fontStyleCache[styleString];\r\n    }\r\n\r\n    var el = document.createElement('div');\r\n    var style = el.style;\r\n    var fontFamily;\r\n    try {\r\n      style.font = styleString;\r\n      fontFamily = style.fontFamily.split(',')[0];\r\n    } catch (ex) {\r\n      // Ignore failures to set to invalid font.\r\n    }\r\n\r\n    return fontStyleCache[styleString] = {\r\n      style: style.fontStyle || DEFAULT_STYLE.style,\r\n      variant: style.fontVariant || DEFAULT_STYLE.variant,\r\n      weight: style.fontWeight || DEFAULT_STYLE.weight,\r\n      size: style.fontSize || DEFAULT_STYLE.size,\r\n      family: fontFamily || DEFAULT_STYLE.family\r\n    };\r\n  }\r\n\r\n  function getComputedStyle(style, element) {\r\n    var computedStyle = {};\r\n\r\n    for (var p in style) {\r\n      computedStyle[p] = style[p];\r\n    }\r\n\r\n    // Compute the size\r\n    var canvasFontSize = parseFloat(element.currentStyle.fontSize),\r\n        fontSize = parseFloat(style.size);\r\n\r\n    if (typeof style.size == 'number') {\r\n      computedStyle.size = style.size;\r\n    } else if (style.size.indexOf('px') != -1) {\r\n      computedStyle.size = fontSize;\r\n    } else if (style.size.indexOf('em') != -1) {\r\n      computedStyle.size = canvasFontSize * fontSize;\r\n    } else if(style.size.indexOf('%') != -1) {\r\n      computedStyle.size = (canvasFontSize / 100) * fontSize;\r\n    } else if (style.size.indexOf('pt') != -1) {\r\n      computedStyle.size = fontSize / .75;\r\n    } else {\r\n      computedStyle.size = canvasFontSize;\r\n    }\r\n\r\n    // Different scaling between normal text and VML text. This was found using\r\n    // trial and error to get the same size as non VML text.\r\n    //computedStyle.size *= 0.981;\r\n\r\n    return computedStyle;\r\n  }\r\n\r\n  function buildStyle(style) {\r\n    return style.style + ' ' + style.variant + ' ' + style.weight + ' ' +\r\n        style.size + \"px '\" + style.family + \"'\";\r\n  }\r\n\r\n  var lineCapMap = {\r\n    'butt': 'flat',\r\n    'round': 'round'\r\n  };\r\n\r\n  function processLineCap(lineCap) {\r\n    return lineCapMap[lineCap] || 'square';\r\n  }\r\n\r\n  /**\r\n   * This class implements CanvasRenderingContext2D interface as described by\r\n   * the WHATWG.\r\n   * @param {HTMLElement} canvasElement The element that the 2D context should\r\n   * be associated with\r\n   */\r\n  function CanvasRenderingContext2D_(canvasElement) {\r\n    this.m_ = createMatrixIdentity();\r\n\r\n    this.mStack_ = [];\r\n    this.aStack_ = [];\r\n    this.currentPath_ = [];\r\n\r\n    // Canvas context properties\r\n    this.strokeStyle = '#000';\r\n    this.fillStyle = '#000';\r\n\r\n    this.lineWidth = 1;\r\n    this.lineJoin = 'miter';\r\n    this.lineCap = 'butt';\r\n    this.miterLimit = Z * 1;\r\n    this.globalAlpha = 1;\r\n    // this.font = '10px sans-serif';\r\n    this.font = '12px 微软雅黑';        // 决定还是改这吧，影响代价最小\r\n    this.textAlign = 'left';\r\n    this.textBaseline = 'alphabetic';\r\n    this.canvas = canvasElement;\r\n\r\n    var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' +\r\n        canvasElement.clientHeight + 'px;overflow:hidden;position:absolute';\r\n    var el = canvasElement.ownerDocument.createElement('div');\r\n    el.style.cssText = cssText;\r\n    canvasElement.appendChild(el);\r\n\r\n    var overlayEl = el.cloneNode(false);\r\n    // Use a non transparent background.\r\n    overlayEl.style.backgroundColor = '#fff'; //red, I don't know why, it work!\r\n    overlayEl.style.filter = 'alpha(opacity=0)';\r\n    canvasElement.appendChild(overlayEl);\r\n\r\n    this.element_ = el;\r\n    this.scaleX_ = 1;\r\n    this.scaleY_ = 1;\r\n    this.lineScale_ = 1;\r\n  }\r\n\r\n  var contextPrototype = CanvasRenderingContext2D_.prototype;\r\n  contextPrototype.clearRect = function() {\r\n    if (this.textMeasureEl_) {\r\n      this.textMeasureEl_.removeNode(true);\r\n      this.textMeasureEl_ = null;\r\n    }\r\n    this.element_.innerHTML = '';\r\n  };\r\n\r\n  contextPrototype.beginPath = function() {\r\n    // TODO: Branch current matrix so that save/restore has no effect\r\n    //       as per safari docs.\r\n    this.currentPath_ = [];\r\n  };\r\n\r\n  contextPrototype.moveTo = function(aX, aY) {\r\n    var p = getCoords(this, aX, aY);\r\n    this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});\r\n    this.currentX_ = p.x;\r\n    this.currentY_ = p.y;\r\n  };\r\n\r\n  contextPrototype.lineTo = function(aX, aY) {\r\n    var p = getCoords(this, aX, aY);\r\n    this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});\r\n\r\n    this.currentX_ = p.x;\r\n    this.currentY_ = p.y;\r\n  };\r\n\r\n  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,\r\n                                            aCP2x, aCP2y,\r\n                                            aX, aY) {\r\n    var p = getCoords(this, aX, aY);\r\n    var cp1 = getCoords(this, aCP1x, aCP1y);\r\n    var cp2 = getCoords(this, aCP2x, aCP2y);\r\n    bezierCurveTo(this, cp1, cp2, p);\r\n  };\r\n\r\n  // Helper function that takes the already fixed cordinates.\r\n  function bezierCurveTo(self, cp1, cp2, p) {\r\n    self.currentPath_.push({\r\n      type: 'bezierCurveTo',\r\n      cp1x: cp1.x,\r\n      cp1y: cp1.y,\r\n      cp2x: cp2.x,\r\n      cp2y: cp2.y,\r\n      x: p.x,\r\n      y: p.y\r\n    });\r\n    self.currentX_ = p.x;\r\n    self.currentY_ = p.y;\r\n  }\r\n\r\n  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {\r\n    // the following is lifted almost directly from\r\n    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes\r\n\r\n    var cp = getCoords(this, aCPx, aCPy);\r\n    var p = getCoords(this, aX, aY);\r\n\r\n    var cp1 = {\r\n      x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),\r\n      y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)\r\n    };\r\n    var cp2 = {\r\n      x: cp1.x + (p.x - this.currentX_) / 3.0,\r\n      y: cp1.y + (p.y - this.currentY_) / 3.0\r\n    };\r\n\r\n    bezierCurveTo(this, cp1, cp2, p);\r\n  };\r\n\r\n  contextPrototype.arc = function(aX, aY, aRadius,\r\n                                  aStartAngle, aEndAngle, aClockwise) {\r\n    aRadius *= Z;\r\n    var arcType = aClockwise ? 'at' : 'wa';\r\n\r\n    var xStart = aX + mc(aStartAngle) * aRadius - Z2;\r\n    var yStart = aY + ms(aStartAngle) * aRadius - Z2;\r\n\r\n    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;\r\n    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;\r\n\r\n    // IE won't render arches drawn counter clockwise if xStart == xEnd.\r\n    if (xStart == xEnd && !aClockwise) {\r\n      xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something\r\n                       // that can be represented in binary\r\n    }\r\n\r\n    var p = getCoords(this, aX, aY);\r\n    var pStart = getCoords(this, xStart, yStart);\r\n    var pEnd = getCoords(this, xEnd, yEnd);\r\n\r\n    this.currentPath_.push({type: arcType,\r\n                           x: p.x,\r\n                           y: p.y,\r\n                           radius: aRadius,\r\n                           xStart: pStart.x,\r\n                           yStart: pStart.y,\r\n                           xEnd: pEnd.x,\r\n                           yEnd: pEnd.y});\r\n\r\n  };\r\n\r\n  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {\r\n    this.moveTo(aX, aY);\r\n    this.lineTo(aX + aWidth, aY);\r\n    this.lineTo(aX + aWidth, aY + aHeight);\r\n    this.lineTo(aX, aY + aHeight);\r\n    this.closePath();\r\n  };\r\n\r\n  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {\r\n    var oldPath = this.currentPath_;\r\n    this.beginPath();\r\n\r\n    this.moveTo(aX, aY);\r\n    this.lineTo(aX + aWidth, aY);\r\n    this.lineTo(aX + aWidth, aY + aHeight);\r\n    this.lineTo(aX, aY + aHeight);\r\n    this.closePath();\r\n    this.stroke();\r\n\r\n    this.currentPath_ = oldPath;\r\n  };\r\n\r\n  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {\r\n    var oldPath = this.currentPath_;\r\n    this.beginPath();\r\n\r\n    this.moveTo(aX, aY);\r\n    this.lineTo(aX + aWidth, aY);\r\n    this.lineTo(aX + aWidth, aY + aHeight);\r\n    this.lineTo(aX, aY + aHeight);\r\n    this.closePath();\r\n    this.fill();\r\n\r\n    this.currentPath_ = oldPath;\r\n  };\r\n\r\n  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {\r\n    var gradient = new CanvasGradient_('gradient');\r\n    gradient.x0_ = aX0;\r\n    gradient.y0_ = aY0;\r\n    gradient.x1_ = aX1;\r\n    gradient.y1_ = aY1;\r\n    return gradient;\r\n  };\r\n\r\n  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,\r\n                                                   aX1, aY1, aR1) {\r\n    var gradient = new CanvasGradient_('gradientradial');\r\n    gradient.x0_ = aX0;\r\n    gradient.y0_ = aY0;\r\n    gradient.r0_ = aR0;\r\n    gradient.x1_ = aX1;\r\n    gradient.y1_ = aY1;\r\n    gradient.r1_ = aR1;\r\n    return gradient;\r\n  };\r\n\r\n  contextPrototype.drawImage = function(image, var_args) {\r\n    var dx, dy, dw, dh, sx, sy, sw, sh;\r\n\r\n    // to find the original width we overide the width and height\r\n    var oldRuntimeWidth = image.runtimeStyle.width;\r\n    var oldRuntimeHeight = image.runtimeStyle.height;\r\n    image.runtimeStyle.width = 'auto';\r\n    image.runtimeStyle.height = 'auto';\r\n\r\n    // get the original size\r\n    var w = image.width;\r\n    var h = image.height;\r\n\r\n    // and remove overides\r\n    image.runtimeStyle.width = oldRuntimeWidth;\r\n    image.runtimeStyle.height = oldRuntimeHeight;\r\n\r\n    if (arguments.length == 3) {\r\n      dx = arguments[1];\r\n      dy = arguments[2];\r\n      sx = sy = 0;\r\n      sw = dw = w;\r\n      sh = dh = h;\r\n    } else if (arguments.length == 5) {\r\n      dx = arguments[1];\r\n      dy = arguments[2];\r\n      dw = arguments[3];\r\n      dh = arguments[4];\r\n      sx = sy = 0;\r\n      sw = w;\r\n      sh = h;\r\n    } else if (arguments.length == 9) {\r\n      sx = arguments[1];\r\n      sy = arguments[2];\r\n      sw = arguments[3];\r\n      sh = arguments[4];\r\n      dx = arguments[5];\r\n      dy = arguments[6];\r\n      dw = arguments[7];\r\n      dh = arguments[8];\r\n    } else {\r\n      throw Error('Invalid number of arguments');\r\n    }\r\n\r\n    var d = getCoords(this, dx, dy);\r\n\r\n    var w2 = sw / 2;\r\n    var h2 = sh / 2;\r\n\r\n    var vmlStr = [];\r\n\r\n    var W = 10;\r\n    var H = 10;\r\n\r\n    var scaleX = scaleY = 1;\r\n\r\n    // For some reason that I've now forgotten, using divs didn't work\r\n    vmlStr.push(' <g_vml_:group',\r\n                ' coordsize=\"', Z * W, ',', Z * H, '\"',\r\n                ' coordorigin=\"0,0\"' ,\r\n                ' style=\"width:', W, 'px;height:', H, 'px;position:absolute;');\r\n\r\n    // If filters are necessary (rotation exists), create them\r\n    // filters are bog-slow, so only create them if abbsolutely necessary\r\n    // The following check doesn't account for skews (which don't exist\r\n    // in the canvas spec (yet) anyway.\r\n\r\n    if (this.m_[0][0] != 1 || this.m_[0][1] ||\r\n        this.m_[1][1] != 1 || this.m_[1][0]) {\r\n      var filter = [];\r\n\r\n     var scaleX = this.scaleX_;\r\n     var scaleY = this.scaleY_;\r\n      // Note the 12/21 reversal\r\n      filter.push('M11=', this.m_[0][0] / scaleX, ',',\r\n                  'M12=', this.m_[1][0] / scaleY, ',',\r\n                  'M21=', this.m_[0][1] / scaleX, ',',\r\n                  'M22=', this.m_[1][1] / scaleY, ',',\r\n                  'Dx=', mr(d.x / Z), ',',\r\n                  'Dy=', mr(d.y / Z), '');\r\n\r\n      // Bounding box calculation (need to minimize displayed area so that\r\n      // filters don't waste time on unused pixels.\r\n      var max = d;\r\n      var c2 = getCoords(this, dx + dw, dy);\r\n      var c3 = getCoords(this, dx, dy + dh);\r\n      var c4 = getCoords(this, dx + dw, dy + dh);\r\n\r\n      max.x = m.max(max.x, c2.x, c3.x, c4.x);\r\n      max.y = m.max(max.y, c2.y, c3.y, c4.y);\r\n\r\n      vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),\r\n                  'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',\r\n                  filter.join(''), \", SizingMethod='clip');\");\r\n\r\n    } else {\r\n      vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');\r\n    }\r\n\r\n    vmlStr.push(' \">');\r\n\r\n    // Draw a special cropping div if needed\r\n    if (sx || sy) {\r\n      // Apply scales to width and height\r\n      vmlStr.push('<div style=\"overflow: hidden; width:', Math.ceil((dw + sx * dw / sw) * scaleX), 'px;',\r\n                  ' height:', Math.ceil((dh + sy * dh / sh) * scaleY), 'px;',\r\n                  ' filter:progid:DxImageTransform.Microsoft.Matrix(Dx=',\r\n                  -sx * dw / sw * scaleX, ',Dy=', -sy * dh / sh * scaleY, ');\">');\r\n    }\r\n\r\n\r\n    // Apply scales to width and height\r\n    vmlStr.push('<div style=\"width:', Math.round(scaleX * w * dw / sw), 'px;',\r\n                ' height:', Math.round(scaleY * h * dh / sh), 'px;',\r\n                ' filter:');\r\n\r\n    // If there is a globalAlpha, apply it to image\r\n    if(this.globalAlpha < 1) {\r\n      vmlStr.push(' progid:DXImageTransform.Microsoft.Alpha(opacity=' + (this.globalAlpha * 100) + ')');\r\n    }\r\n\r\n    vmlStr.push(' progid:DXImageTransform.Microsoft.AlphaImageLoader(src=', image.src, ',sizingMethod=scale)\">');\r\n\r\n    // Close the crop div if necessary\r\n    if (sx || sy) vmlStr.push('</div>');\r\n\r\n    vmlStr.push('</div></div>');\r\n\r\n    this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));\r\n  };\r\n\r\n  contextPrototype.stroke = function(aFill) {\r\n    var lineStr = [];\r\n    var lineOpen = false;\r\n\r\n    var W = 10;\r\n    var H = 10;\r\n\r\n    lineStr.push('<g_vml_:shape',\r\n                 ' filled=\"', !!aFill, '\"',\r\n                 ' style=\"position:absolute;width:', W, 'px;height:', H, 'px;\"',\r\n                 ' coordorigin=\"0,0\"',\r\n                 ' coordsize=\"', Z * W, ',', Z * H, '\"',\r\n                 ' stroked=\"', !aFill, '\"',\r\n                 ' path=\"');\r\n\r\n    var newSeq = false;\r\n    var min = {x: null, y: null};\r\n    var max = {x: null, y: null};\r\n\r\n    for (var i = 0; i < this.currentPath_.length; i++) {\r\n      var p = this.currentPath_[i];\r\n      var c;\r\n\r\n      switch (p.type) {\r\n        case 'moveTo':\r\n          c = p;\r\n          lineStr.push(' m ', mr(p.x), ',', mr(p.y));\r\n          break;\r\n        case 'lineTo':\r\n          lineStr.push(' l ', mr(p.x), ',', mr(p.y));\r\n          break;\r\n        case 'close':\r\n          lineStr.push(' x ');\r\n          p = null;\r\n          break;\r\n        case 'bezierCurveTo':\r\n          lineStr.push(' c ',\r\n                       mr(p.cp1x), ',', mr(p.cp1y), ',',\r\n                       mr(p.cp2x), ',', mr(p.cp2y), ',',\r\n                       mr(p.x), ',', mr(p.y));\r\n          break;\r\n        case 'at':\r\n        case 'wa':\r\n          lineStr.push(' ', p.type, ' ',\r\n                       mr(p.x - this.scaleX_ * p.radius), ',',\r\n                       mr(p.y - this.scaleY_ * p.radius), ' ',\r\n                       mr(p.x + this.scaleX_ * p.radius), ',',\r\n                       mr(p.y + this.scaleY_ * p.radius), ' ',\r\n                       mr(p.xStart), ',', mr(p.yStart), ' ',\r\n                       mr(p.xEnd), ',', mr(p.yEnd));\r\n          break;\r\n      }\r\n\r\n\r\n      // TODO: Following is broken for curves due to\r\n      //       move to proper paths.\r\n\r\n      // Figure out dimensions so we can do gradient fills\r\n      // properly\r\n      if (p) {\r\n        if (min.x == null || p.x < min.x) {\r\n          min.x = p.x;\r\n        }\r\n        if (max.x == null || p.x > max.x) {\r\n          max.x = p.x;\r\n        }\r\n        if (min.y == null || p.y < min.y) {\r\n          min.y = p.y;\r\n        }\r\n        if (max.y == null || p.y > max.y) {\r\n          max.y = p.y;\r\n        }\r\n      }\r\n    }\r\n    lineStr.push(' \">');\r\n\r\n    if (!aFill) {\r\n      appendStroke(this, lineStr);\r\n    } else {\r\n      appendFill(this, lineStr, min, max);\r\n    }\r\n\r\n    lineStr.push('</g_vml_:shape>');\r\n\r\n    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));\r\n  };\r\n\r\n  function appendStroke(ctx, lineStr) {\r\n    var a = processStyle(ctx.strokeStyle);\r\n    var color = a.color;\r\n    var opacity = a.alpha * ctx.globalAlpha;\r\n    var lineWidth = ctx.lineScale_ * ctx.lineWidth;\r\n\r\n    // VML cannot correctly render a line if the width is less than 1px.\r\n    // In that case, we dilute the color to make the line look thinner.\r\n    if (lineWidth < 1) {\r\n      opacity *= lineWidth;\r\n    }\r\n\r\n    lineStr.push(\r\n      '<g_vml_:stroke',\r\n      ' opacity=\"', opacity, '\"',\r\n      ' joinstyle=\"', ctx.lineJoin, '\"',\r\n      ' miterlimit=\"', ctx.miterLimit, '\"',\r\n      ' endcap=\"', processLineCap(ctx.lineCap), '\"',\r\n      ' weight=\"', lineWidth, 'px\"',\r\n      ' color=\"', color, '\" />'\r\n    );\r\n  }\r\n\r\n  function appendFill(ctx, lineStr, min, max) {\r\n    var fillStyle = ctx.fillStyle;\r\n    var arcScaleX = ctx.scaleX_;\r\n    var arcScaleY = ctx.scaleY_;\r\n    var width = max.x - min.x;\r\n    var height = max.y - min.y;\r\n    if (fillStyle instanceof CanvasGradient_) {\r\n      // TODO: Gradients transformed with the transformation matrix.\r\n      var angle = 0;\r\n      var focus = {x: 0, y: 0};\r\n\r\n      // additional offset\r\n      var shift = 0;\r\n      // scale factor for offset\r\n      var expansion = 1;\r\n\r\n      if (fillStyle.type_ == 'gradient') {\r\n        var x0 = fillStyle.x0_ / arcScaleX;\r\n        var y0 = fillStyle.y0_ / arcScaleY;\r\n        var x1 = fillStyle.x1_ / arcScaleX;\r\n        var y1 = fillStyle.y1_ / arcScaleY;\r\n        var p0 = getCoords(ctx, x0, y0);\r\n        var p1 = getCoords(ctx, x1, y1);\r\n        var dx = p1.x - p0.x;\r\n        var dy = p1.y - p0.y;\r\n        angle = Math.atan2(dx, dy) * 180 / Math.PI;\r\n\r\n        // The angle should be a non-negative number.\r\n        if (angle < 0) {\r\n          angle += 360;\r\n        }\r\n\r\n        // Very small angles produce an unexpected result because they are\r\n        // converted to a scientific notation string.\r\n        if (angle < 1e-6) {\r\n          angle = 0;\r\n        }\r\n      } else {\r\n        var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);\r\n        focus = {\r\n          x: (p0.x - min.x) / width,\r\n          y: (p0.y - min.y) / height\r\n        };\r\n\r\n        width  /= arcScaleX * Z;\r\n        height /= arcScaleY * Z;\r\n        var dimension = m.max(width, height);\r\n        shift = 2 * fillStyle.r0_ / dimension;\r\n        expansion = 2 * fillStyle.r1_ / dimension - shift;\r\n      }\r\n\r\n      // We need to sort the color stops in ascending order by offset,\r\n      // otherwise IE won't interpret it correctly.\r\n      var stops = fillStyle.colors_;\r\n      stops.sort(function(cs1, cs2) {\r\n        return cs1.offset - cs2.offset;\r\n      });\r\n\r\n      var length = stops.length;\r\n      var color1 = stops[0].color;\r\n      var color2 = stops[length - 1].color;\r\n      var opacity1 = stops[0].alpha * ctx.globalAlpha;\r\n      var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;\r\n\r\n      var colors = [];\r\n      for (var i = 0; i < length; i++) {\r\n        var stop = stops[i];\r\n        colors.push(stop.offset * expansion + shift + ' ' + stop.color);\r\n      }\r\n\r\n      // When colors attribute is used, the meanings of opacity and o:opacity2\r\n      // are reversed.\r\n      lineStr.push('<g_vml_:fill type=\"', fillStyle.type_, '\"',\r\n                   ' method=\"none\" focus=\"100%\"',\r\n                   ' color=\"', color1, '\"',\r\n                   ' color2=\"', color2, '\"',\r\n                   ' colors=\"', colors.join(','), '\"',\r\n                   ' opacity=\"', opacity2, '\"',\r\n                   ' g_o_:opacity2=\"', opacity1, '\"',\r\n                   ' angle=\"', angle, '\"',\r\n                   ' focusposition=\"', focus.x, ',', focus.y, '\" />');\r\n    } else if (fillStyle instanceof CanvasPattern_) {\r\n      if (width && height) {\r\n        var deltaLeft = -min.x;\r\n        var deltaTop = -min.y;\r\n        lineStr.push('<g_vml_:fill',\r\n                     ' position=\"',\r\n                     deltaLeft / width * arcScaleX * arcScaleX, ',',\r\n                     deltaTop / height * arcScaleY * arcScaleY, '\"',\r\n                     ' type=\"tile\"',\r\n                     // TODO: Figure out the correct size to fit the scale.\r\n                     //' size=\"', w, 'px ', h, 'px\"',\r\n                     ' src=\"', fillStyle.src_, '\" />');\r\n       }\r\n    } else {\r\n      var a = processStyle(ctx.fillStyle);\r\n      var color = a.color;\r\n      var opacity = a.alpha * ctx.globalAlpha;\r\n      lineStr.push('<g_vml_:fill color=\"', color, '\" opacity=\"', opacity,\r\n                   '\" />');\r\n    }\r\n  }\r\n\r\n  contextPrototype.fill = function() {\r\n    this.stroke(true);\r\n  };\r\n\r\n  contextPrototype.closePath = function() {\r\n    this.currentPath_.push({type: 'close'});\r\n  };\r\n\r\n  function getCoords(ctx, aX, aY) {\r\n    var m = ctx.m_;\r\n    return {\r\n      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,\r\n      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2\r\n    };\r\n  };\r\n\r\n  contextPrototype.save = function() {\r\n    var o = {};\r\n    copyState(this, o);\r\n    this.aStack_.push(o);\r\n    this.mStack_.push(this.m_);\r\n    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);\r\n  };\r\n\r\n  contextPrototype.restore = function() {\r\n    if (this.aStack_.length) {\r\n      copyState(this.aStack_.pop(), this);\r\n      this.m_ = this.mStack_.pop();\r\n    }\r\n  };\r\n\r\n  function matrixIsFinite(m) {\r\n    return isFinite(m[0][0]) && isFinite(m[0][1]) &&\r\n        isFinite(m[1][0]) && isFinite(m[1][1]) &&\r\n        isFinite(m[2][0]) && isFinite(m[2][1]);\r\n  }\r\n\r\n  function setM(ctx, m, updateLineScale) {\r\n    if (!matrixIsFinite(m)) {\r\n      return;\r\n    }\r\n    ctx.m_ = m;\r\n\r\n    ctx.scaleX_ = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1]);\r\n    ctx.scaleY_ = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1]);\r\n\r\n    if (updateLineScale) {\r\n      // Get the line scale.\r\n      // Determinant of this.m_ means how much the area is enlarged by the\r\n      // transformation. So its square root can be used as a scale factor\r\n      // for width.\r\n      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];\r\n      ctx.lineScale_ = sqrt(abs(det));\r\n    }\r\n  }\r\n\r\n  contextPrototype.translate = function(aX, aY) {\r\n    var m1 = [\r\n      [1,  0,  0],\r\n      [0,  1,  0],\r\n      [aX, aY, 1]\r\n    ];\r\n\r\n    setM(this, matrixMultiply(m1, this.m_), false);\r\n  };\r\n\r\n  contextPrototype.rotate = function(aRot) {\r\n    var c = mc(aRot);\r\n    var s = ms(aRot);\r\n\r\n    var m1 = [\r\n      [c,  s, 0],\r\n      [-s, c, 0],\r\n      [0,  0, 1]\r\n    ];\r\n\r\n    setM(this, matrixMultiply(m1, this.m_), false);\r\n  };\r\n\r\n  contextPrototype.scale = function(aX, aY) {\r\n    var m1 = [\r\n      [aX, 0,  0],\r\n      [0,  aY, 0],\r\n      [0,  0,  1]\r\n    ];\r\n\r\n    setM(this, matrixMultiply(m1, this.m_), true);\r\n  };\r\n\r\n  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {\r\n    var m1 = [\r\n      [m11, m12, 0],\r\n      [m21, m22, 0],\r\n      [dx,  dy,  1]\r\n    ];\r\n\r\n    setM(this, matrixMultiply(m1, this.m_), true);\r\n\r\n  };\r\n\r\n  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {\r\n    var m = [\r\n      [m11, m12, 0],\r\n      [m21, m22, 0],\r\n      [dx,  dy,  1]\r\n    ];\r\n\r\n    setM(this, m, true);\r\n  };\r\n\r\n  /**\r\n   * The text drawing function.\r\n   * The maxWidth argument isn't taken in account, since no browser supports\r\n   * it yet.\r\n   */\r\n  contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {\r\n    var m = this.m_,\r\n        delta = 1000,\r\n        left = 0,\r\n        right = delta,\r\n        offset = {x: 0, y: 0},\r\n        lineStr = [];\r\n\r\n    var fontStyle = getComputedStyle(processFontStyle(this.font),\r\n                                     this.element_);\r\n\r\n    var fontStyleString = buildStyle(fontStyle);\r\n\r\n    var elementStyle = this.element_.currentStyle;\r\n    var textAlign = this.textAlign.toLowerCase();\r\n    switch (textAlign) {\r\n      case 'left':\r\n      case 'center':\r\n      case 'right':\r\n        break;\r\n      case 'end':\r\n        textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';\r\n        break;\r\n      case 'start':\r\n        textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';\r\n        break;\r\n      default:\r\n        textAlign = 'left';\r\n    }\r\n\r\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\r\n    switch (this.textBaseline) {\r\n      case 'hanging':\r\n      case 'top':\r\n        offset.y = fontStyle.size / 1.75;\r\n        break;\r\n      case 'middle':\r\n        break;\r\n      default:\r\n      case null:\r\n      case 'alphabetic':\r\n      case 'ideographic':\r\n      case 'bottom':\r\n        offset.y = -fontStyle.size / 2.25;\r\n        break;\r\n    }\r\n\r\n    switch(textAlign) {\r\n      case 'right':\r\n        left = delta;\r\n        right = 0.05;\r\n        break;\r\n      case 'center':\r\n        left = right = delta / 2;\r\n        break;\r\n    }\r\n\r\n    var d = getCoords(this, x + offset.x, y + offset.y);\r\n\r\n    lineStr.push('<g_vml_:line from=\"', -left ,' 0\" to=\"', right ,' 0.05\" ',\r\n                 ' coordsize=\"100 100\" coordorigin=\"0 0\"',\r\n                 ' filled=\"', !stroke, '\" stroked=\"', !!stroke,\r\n                 '\" style=\"position:absolute;width:1px;height:1px;\">');\r\n\r\n    if (stroke) {\r\n      appendStroke(this, lineStr);\r\n    } else {\r\n      // TODO: Fix the min and max params.\r\n      appendFill(this, lineStr, {x: -left, y: 0},\r\n                 {x: right, y: fontStyle.size});\r\n    }\r\n\r\n    var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' +\r\n                m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';\r\n\r\n    var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);\r\n\r\n    lineStr.push('<g_vml_:skew on=\"t\" matrix=\"', skewM ,'\" ',\r\n                 ' offset=\"', skewOffset, '\" origin=\"', left ,' 0\" />',\r\n                 '<g_vml_:path textpathok=\"true\" />',\r\n                 '<g_vml_:textpath on=\"true\" string=\"',\r\n                 encodeHtmlAttribute(text),\r\n                 '\" style=\"v-text-align:', textAlign,\r\n                 ';font:', encodeHtmlAttribute(fontStyleString),\r\n                 '\" /></g_vml_:line>');\r\n\r\n    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));\r\n  };\r\n\r\n  contextPrototype.fillText = function(text, x, y, maxWidth) {\r\n    this.drawText_(text, x, y, maxWidth, false);\r\n  };\r\n\r\n  contextPrototype.strokeText = function(text, x, y, maxWidth) {\r\n    this.drawText_(text, x, y, maxWidth, true);\r\n  };\r\n\r\n  contextPrototype.measureText = function(text) {\r\n    if (!this.textMeasureEl_) {\r\n      var s = '<span style=\"position:absolute;' +\r\n          'top:-20000px;left:0;padding:0;margin:0;border:none;' +\r\n          'white-space:pre;\"></span>';\r\n      this.element_.insertAdjacentHTML('beforeEnd', s);\r\n      this.textMeasureEl_ = this.element_.lastChild;\r\n    }\r\n    var doc = this.element_.ownerDocument;\r\n    this.textMeasureEl_.innerHTML = '';\r\n    try {\r\n        this.textMeasureEl_.style.font = this.font;\r\n    } catch (ex) {\r\n        // Ignore failures to set to invalid font.\r\n    }\r\n\r\n    // Don't use innerHTML or innerText because they allow markup/whitespace.\r\n    this.textMeasureEl_.appendChild(doc.createTextNode(text));\r\n    return {width: this.textMeasureEl_.offsetWidth};\r\n  };\r\n\r\n  /******** STUBS ********/\r\n  contextPrototype.clip = function() {\r\n    // TODO: Implement\r\n  };\r\n\r\n  contextPrototype.arcTo = function() {\r\n    // TODO: Implement\r\n  };\r\n\r\n  contextPrototype.createPattern = function(image, repetition) {\r\n    return new CanvasPattern_(image, repetition);\r\n  };\r\n\r\n  // Gradient / Pattern Stubs\r\n  function CanvasGradient_(aType) {\r\n    this.type_ = aType;\r\n    this.x0_ = 0;\r\n    this.y0_ = 0;\r\n    this.r0_ = 0;\r\n    this.x1_ = 0;\r\n    this.y1_ = 0;\r\n    this.r1_ = 0;\r\n    this.colors_ = [];\r\n  }\r\n\r\n  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {\r\n    aColor = processStyle(aColor);\r\n    this.colors_.push({offset: aOffset,\r\n                       color: aColor.color,\r\n                       alpha: aColor.alpha});\r\n  };\r\n\r\n  function CanvasPattern_(image, repetition) {\r\n    assertImageIsValid(image);\r\n    switch (repetition) {\r\n      case 'repeat':\r\n      case null:\r\n      case '':\r\n        this.repetition_ = 'repeat';\r\n        break\r\n      case 'repeat-x':\r\n      case 'repeat-y':\r\n      case 'no-repeat':\r\n        this.repetition_ = repetition;\r\n        break;\r\n      default:\r\n        throwException('SYNTAX_ERR');\r\n    }\r\n\r\n    this.src_ = image.src;\r\n    this.width_ = image.width;\r\n    this.height_ = image.height;\r\n  }\r\n\r\n  function throwException(s) {\r\n    throw new DOMException_(s);\r\n  }\r\n\r\n  function assertImageIsValid(img) {\r\n    if (!img || img.nodeType != 1 || img.tagName != 'IMG') {\r\n      throwException('TYPE_MISMATCH_ERR');\r\n    }\r\n    if (img.readyState != 'complete') {\r\n      throwException('INVALID_STATE_ERR');\r\n    }\r\n  }\r\n\r\n  function DOMException_(s) {\r\n    this.code = this[s];\r\n    this.message = s +': DOM Exception ' + this.code;\r\n  }\r\n  var p = DOMException_.prototype = new Error;\r\n  p.INDEX_SIZE_ERR = 1;\r\n  p.DOMSTRING_SIZE_ERR = 2;\r\n  p.HIERARCHY_REQUEST_ERR = 3;\r\n  p.WRONG_DOCUMENT_ERR = 4;\r\n  p.INVALID_CHARACTER_ERR = 5;\r\n  p.NO_DATA_ALLOWED_ERR = 6;\r\n  p.NO_MODIFICATION_ALLOWED_ERR = 7;\r\n  p.NOT_FOUND_ERR = 8;\r\n  p.NOT_SUPPORTED_ERR = 9;\r\n  p.INUSE_ATTRIBUTE_ERR = 10;\r\n  p.INVALID_STATE_ERR = 11;\r\n  p.SYNTAX_ERR = 12;\r\n  p.INVALID_MODIFICATION_ERR = 13;\r\n  p.NAMESPACE_ERR = 14;\r\n  p.INVALID_ACCESS_ERR = 15;\r\n  p.VALIDATION_ERR = 16;\r\n  p.TYPE_MISMATCH_ERR = 17;\r\n\r\n  // set up externs\r\n  G_vmlCanvasManager = G_vmlCanvasManager_;\r\n  CanvasRenderingContext2D = CanvasRenderingContext2D_;\r\n  CanvasGradient = CanvasGradient_;\r\n  CanvasPattern = CanvasPattern_;\r\n  DOMException = DOMException_;\r\n})();\r\n\r\n} // if\r\nelse { // make the canvas test simple by kener.linfeng@gmail.com\r\n    G_vmlCanvasManager = void 0;\r\n}\r\nreturn G_vmlCanvasManager;\r\n}); // define\r\n"
    },
    {
      "id": 12,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\log.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/log.js",
      "index": 12,
      "index2": 5,
      "size": 983,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../tool/log",
          "loc": "45:18-40"
        }
      ],
      "source": "define(\r\n    function (require) {\r\n        var config = require('../config');\r\n\r\n        /**\r\n         * @exports zrender/tool/log\r\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n         */\r\n        return function() {\r\n            if (config.debugMode === 0) {\r\n                return;\r\n            }\r\n            else if (config.debugMode == 1) {\r\n                for (var k in arguments) {\r\n                    throw new Error(arguments[k]);\r\n                }\r\n            }\r\n            else if (config.debugMode > 1) {\r\n                for (var k in arguments) {\r\n                    console.log(arguments[k]);\r\n                }\r\n            }\r\n        };\r\n\r\n        /* for debug\r\n        return function(mes) {\r\n            document.getElementById('wrong-message').innerHTML =\r\n                mes + ' ' + (new Date() - 0)\r\n                + '<br/>' \r\n                + document.getElementById('wrong-message').innerHTML;\r\n        };\r\n        */\r\n    }\r\n);\r\n"
    },
    {
      "id": 13,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\config.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/config.js",
      "index": 13,
      "index2": 4,
      "size": 3235,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\log.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 12,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\log.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/log.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/log.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "3:21-41"
        }
      ],
      "source": "define(function () {\r\n    /**\r\n     * config默认配置项\r\n     * @exports zrender/config\r\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n     */\r\n    var config = {\r\n        /**\r\n         * @namespace module:zrender/config.EVENT\r\n         */\r\n        EVENT : {\r\n            /**\r\n             * 窗口大小变化\r\n             * @type {string}\r\n             */\r\n            RESIZE : 'resize',\r\n            /**\r\n             * 鼠标按钮被（手指）按下，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            CLICK : 'click',\r\n            /**\r\n             * 双击事件\r\n             * @type {string}\r\n             */\r\n            DBLCLICK : 'dblclick',\r\n            /**\r\n             * 鼠标滚轮变化，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            MOUSEWHEEL : 'mousewheel',\r\n            /**\r\n             * 鼠标（手指）被移动，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            MOUSEMOVE : 'mousemove',\r\n            /**\r\n             * 鼠标移到某图形元素之上，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            MOUSEOVER : 'mouseover',\r\n            /**\r\n             * 鼠标从某图形元素移开，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            MOUSEOUT : 'mouseout',\r\n            /**\r\n             * 鼠标按钮（手指）被按下，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            MOUSEDOWN : 'mousedown',\r\n            /**\r\n             * 鼠标按键（手指）被松开，事件对象是：目标图形元素或空\r\n             * @type {string}\r\n             */\r\n            MOUSEUP : 'mouseup',\r\n            /**\r\n             * 全局离开，MOUSEOUT触发比较频繁，一次离开优化绑定\r\n             * @type {string}\r\n             */\r\n            GLOBALOUT : 'globalout',    // \r\n\r\n            // 一次成功元素拖拽的行为事件过程是：\r\n            // dragstart > dragenter > dragover [> dragleave] > drop > dragend\r\n            /**\r\n             * 开始拖拽时触发，事件对象是：被拖拽图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGSTART : 'dragstart',\r\n            /**\r\n             * 拖拽完毕时触发（在drop之后触发），事件对象是：被拖拽图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGEND : 'dragend',\r\n            /**\r\n             * 拖拽图形元素进入目标图形元素时触发，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGENTER : 'dragenter',\r\n            /**\r\n             * 拖拽图形元素在目标图形元素上移动时触发，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGOVER : 'dragover',\r\n            /**\r\n             * 拖拽图形元素离开目标图形元素时触发，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            DRAGLEAVE : 'dragleave',\r\n            /**\r\n             * 拖拽图形元素放在目标图形元素内时触发，事件对象是：目标图形元素\r\n             * @type {string}\r\n             */\r\n            DROP : 'drop',\r\n            /**\r\n             * touch end - start < delay is click\r\n             * @type {number}\r\n             */\r\n            touchClickDelay : 300\r\n        },\r\n\r\n        elementClassName: 'zr-element',\r\n\r\n        // 是否异常捕获\r\n        catchBrushException: false,\r\n\r\n        /**\r\n         * debug日志选项：catchBrushException为true下有效\r\n         * 0 : 不生成debug数据，发布用\r\n         * 1 : 异常抛出，调试用\r\n         * 2 : 控制台输出，调试用\r\n         */\r\n        debugMode: 0,\r\n\r\n        // retina 屏幕优化\r\n        devicePixelRatio: Math.max(window.devicePixelRatio || 1, 1)\r\n    };\r\n    return config;\r\n});\r\n\r\n"
    },
    {
      "id": 14,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\mixin\\Transformable.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
      "index": 14,
      "index2": 7,
      "size": 7955,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../mixin/Transformable",
          "loc": "47:28-61"
        }
      ],
      "source": "/**\r\n * 提供变换扩展\r\n * @module zrender/mixin/Transformable\r\n * @author pissang (https://www.github.com/pissang)\r\n */\r\ndefine(function (require) {\r\n\r\n    'use strict';\r\n\r\n    var matrix = require('../tool/matrix');\r\n    var vector = require('../tool/vector');\r\n    var origin = [0, 0];\r\n\r\n    var mTranslate = matrix.translate;\r\n\r\n    var EPSILON = 5e-5;\r\n\r\n    function isAroundZero(val) {\r\n        return val > -EPSILON && val < EPSILON;\r\n    }\r\n    function isNotAroundZero(val) {\r\n        return val > EPSILON || val < -EPSILON;\r\n    }\r\n\r\n    /**\r\n     * @alias module:zrender/mixin/Transformable\r\n     * @constructor\r\n     */\r\n    var Transformable = function () {\r\n\r\n        if (!this.position) {\r\n            /**\r\n             * 平移\r\n             * @type {Array.<number>}\r\n             * @default [0, 0]\r\n             */\r\n            this.position = [ 0, 0 ];\r\n        }\r\n        if (typeof(this.rotation) == 'undefined') {\r\n            /**\r\n             * 旋转，可以通过数组二三项指定旋转的原点\r\n             * @type {Array.<number>}\r\n             * @default [0, 0, 0]\r\n             */\r\n            this.rotation = [ 0, 0, 0 ];\r\n        }\r\n        if (!this.scale) {\r\n            /**\r\n             * 缩放，可以通过数组三四项指定缩放的原点\r\n             * @type {Array.<number>}\r\n             * @default [1, 1, 0, 0]\r\n             */\r\n            this.scale = [ 1, 1, 0, 0 ];\r\n        }\r\n\r\n        this.needLocalTransform = false;\r\n\r\n        /**\r\n         * 是否有坐标变换\r\n         * @type {boolean}\r\n         * @readOnly\r\n         */\r\n        this.needTransform = false;\r\n    };\r\n\r\n    Transformable.prototype = {\r\n        \r\n        constructor: Transformable,\r\n\r\n        updateNeedTransform: function () {\r\n            this.needLocalTransform = isNotAroundZero(this.rotation[0])\r\n                || isNotAroundZero(this.position[0])\r\n                || isNotAroundZero(this.position[1])\r\n                || isNotAroundZero(this.scale[0] - 1)\r\n                || isNotAroundZero(this.scale[1] - 1);\r\n        },\r\n\r\n        /**\r\n         * 判断是否需要有坐标变换，更新needTransform属性。\r\n         * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\r\n         */\r\n        updateTransform: function () {\r\n            \r\n            this.updateNeedTransform();\r\n\r\n            var parentHasTransform = this.parent && this.parent.needTransform;\r\n            this.needTransform = this.needLocalTransform || parentHasTransform;\r\n            \r\n            if (!this.needTransform) {\r\n                return;\r\n            }\r\n\r\n            var m = this.transform || matrix.create();\r\n            matrix.identity(m);\r\n\r\n            if (this.needLocalTransform) {\r\n                var scale = this.scale;\r\n                if (\r\n                    isNotAroundZero(scale[0])\r\n                 || isNotAroundZero(scale[1])\r\n                ) {\r\n                    origin[0] = -scale[2] || 0;\r\n                    origin[1] = -scale[3] || 0;\r\n                    var haveOrigin = isNotAroundZero(origin[0])\r\n                                  || isNotAroundZero(origin[1]);\r\n                    if (haveOrigin) {\r\n                        mTranslate(m, m, origin);\r\n                    }\r\n                    matrix.scale(m, m, scale);\r\n                    if (haveOrigin) {\r\n                        origin[0] = -origin[0];\r\n                        origin[1] = -origin[1];\r\n                        mTranslate(m, m, origin);\r\n                    }\r\n                }\r\n\r\n                if (this.rotation instanceof Array) {\r\n                    if (this.rotation[0] !== 0) {\r\n                        origin[0] = -this.rotation[1] || 0;\r\n                        origin[1] = -this.rotation[2] || 0;\r\n                        var haveOrigin = isNotAroundZero(origin[0])\r\n                                      || isNotAroundZero(origin[1]);\r\n                        if (haveOrigin) {\r\n                            mTranslate(m, m, origin);\r\n                        }\r\n                        matrix.rotate(m, m, this.rotation[0]);\r\n                        if (haveOrigin) {\r\n                            origin[0] = -origin[0];\r\n                            origin[1] = -origin[1];\r\n                            mTranslate(m, m, origin);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (this.rotation !== 0) {\r\n                        matrix.rotate(m, m, this.rotation);\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1])\r\n                ) {\r\n                    mTranslate(m, m, this.position);\r\n                }\r\n            }\r\n\r\n            // 应用父节点变换\r\n            if (parentHasTransform) {\r\n                if (this.needLocalTransform) {\r\n                    matrix.mul(m, this.parent.transform, m);\r\n                }\r\n                else {\r\n                    matrix.copy(m, this.parent.transform);\r\n                }\r\n            }\r\n            // 保存这个变换矩阵\r\n            this.transform = m;\r\n\r\n            this.invTransform = this.invTransform || matrix.create();\r\n            matrix.invert(this.invTransform, m);\r\n        },\r\n        /**\r\n         * 将自己的transform应用到context上\r\n         * @param {Context2D} ctx\r\n         */\r\n        setTransform: function (ctx) {\r\n            if (this.needTransform) {\r\n                var m = this.transform;\r\n                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\r\n            }\r\n        },\r\n        /**\r\n         * 设置图形的朝向\r\n         * @param  {Array.<number>|Float32Array} target\r\n         * @method\r\n         */\r\n        lookAt: (function () {\r\n            var v = vector.create();\r\n            return function(target) {\r\n                if (!this.transform) {\r\n                    this.transform = matrix.create();\r\n                }\r\n                var m = this.transform;\r\n                vector.sub(v, target, this.position);\r\n                if (isAroundZero(v[0]) && isAroundZero(v[1])) {\r\n                    return;\r\n                }\r\n                vector.normalize(v, v);\r\n                var scale = this.scale;\r\n                // Y Axis\r\n                // TODO Scale origin ?\r\n                m[2] = v[0] * scale[1];\r\n                m[3] = v[1] * scale[1];\r\n                // X Axis\r\n                m[0] = v[1] * scale[0];\r\n                m[1] = -v[0] * scale[0];\r\n                // Position\r\n                m[4] = this.position[0];\r\n                m[5] = this.position[1];\r\n\r\n                this.decomposeTransform();\r\n            };\r\n        })(),\r\n        /**\r\n         * 分解`transform`矩阵到`position`, `rotation`, `scale`\r\n         */\r\n        decomposeTransform: function () {\r\n            if (!this.transform) {\r\n                return;\r\n            }\r\n            var m = this.transform;\r\n            var sx = m[0] * m[0] + m[1] * m[1];\r\n            var position = this.position;\r\n            var scale = this.scale;\r\n            var rotation = this.rotation;\r\n            if (isNotAroundZero(sx - 1)) {\r\n                sx = Math.sqrt(sx);\r\n            }\r\n            var sy = m[2] * m[2] + m[3] * m[3];\r\n            if (isNotAroundZero(sy - 1)) {\r\n                sy = Math.sqrt(sy);\r\n            }\r\n            position[0] = m[4];\r\n            position[1] = m[5];\r\n            scale[0] = sx;\r\n            scale[1] = sy;\r\n            scale[2] = scale[3] = 0;\r\n            rotation[0] = Math.atan2(-m[1] / sy, m[0] / sx);\r\n            rotation[1] = rotation[2] = 0;\r\n        },\r\n\r\n        /**\r\n         * 变换坐标位置到 shape 的局部坐标空间\r\n         * @method\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @return {Array.<number>}\r\n         */\r\n        transformCoordToLocal: function (x, y) {\r\n            var v2 = [x, y];\r\n            if (this.needTransform && this.invTransform) {\r\n                vector.applyTransform(v2, v2, this.invTransform);\r\n            }\r\n            return v2;\r\n        }\r\n    };\r\n\r\n    return Transformable;\r\n});\r\n"
    },
    {
      "id": 15,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\vector.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/vector.js",
      "index": 15,
      "index2": 6,
      "size": 7857,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 14,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\mixin\\Transformable.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Transformable.js",
          "type": "cjs require",
          "userRequest": "../tool/vector",
          "loc": "11:17-42"
        },
        {
          "moduleId": 18,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\curve.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/curve.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/curve.js",
          "type": "cjs require",
          "userRequest": "./vector",
          "loc": "8:17-36"
        },
        {
          "moduleId": 24,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\PathProxy.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/PathProxy.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/PathProxy.js",
          "type": "cjs require",
          "userRequest": "../../tool/vector",
          "loc": "42:17-45"
        },
        {
          "moduleId": 32,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\smoothSpline.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothSpline.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothSpline.js",
          "type": "cjs require",
          "userRequest": "../../tool/vector",
          "loc": "10:21-49"
        },
        {
          "moduleId": 33,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\smoothBezier.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothBezier.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothBezier.js",
          "type": "cjs require",
          "userRequest": "../../tool/vector",
          "loc": "10:21-49"
        },
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/vector",
          "loc": "18:15-47"
        },
        {
          "moduleId": 47,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\layout\\EdgeBundling.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/vector",
          "loc": "12:15-47"
        }
      ],
      "source": "define(\r\n    function () {\r\n        var ArrayCtor = typeof Float32Array === 'undefined'\r\n            ? Array\r\n            : Float32Array;\r\n\r\n        /**\r\n         * @typedef {Float32Array|Array.<number>} Vector2\r\n         */\r\n        /**\r\n         * 二维向量类\r\n         * @exports zrender/tool/vector\r\n         */\r\n        var vector = {\r\n            /**\r\n             * 创建一个向量\r\n             * @param {number} [x=0]\r\n             * @param {number} [y=0]\r\n             * @return {Vector2}\r\n             */\r\n            create: function (x, y) {\r\n                var out = new ArrayCtor(2);\r\n                out[0] = x || 0;\r\n                out[1] = y || 0;\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 复制向量数据\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             * @return {Vector2}\r\n             */\r\n            copy: function (out, v) {\r\n                out[0] = v[0];\r\n                out[1] = v[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 克隆一个向量\r\n             * @param {Vector2} v\r\n             * @return {Vector2}\r\n             */\r\n            clone: function (v) {\r\n                var out = new ArrayCtor(2);\r\n                out[0] = v[0];\r\n                out[1] = v[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 设置向量的两个项\r\n             * @param {Vector2} out\r\n             * @param {number} a\r\n             * @param {number} b\r\n             * @return {Vector2} 结果\r\n             */\r\n            set: function (out, a, b) {\r\n                out[0] = a;\r\n                out[1] = b;\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量相加\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             */\r\n            add: function (out, v1, v2) {\r\n                out[0] = v1[0] + v2[0];\r\n                out[1] = v1[1] + v2[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量缩放后相加\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @param {number} a\r\n             */\r\n            scaleAndAdd: function (out, v1, v2, a) {\r\n                out[0] = v1[0] + v2[0] * a;\r\n                out[1] = v1[1] + v2[1] * a;\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量相减\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             */\r\n            sub: function (out, v1, v2) {\r\n                out[0] = v1[0] - v2[0];\r\n                out[1] = v1[1] - v2[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量长度\r\n             * @param {Vector2} v\r\n             * @return {number}\r\n             */\r\n            len: function (v) {\r\n                return Math.sqrt(this.lenSquare(v));\r\n            },\r\n\r\n            /**\r\n             * 向量长度平方\r\n             * @param {Vector2} v\r\n             * @return {number}\r\n             */\r\n            lenSquare: function (v) {\r\n                return v[0] * v[0] + v[1] * v[1];\r\n            },\r\n\r\n            /**\r\n             * 向量乘法\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             */\r\n            mul: function (out, v1, v2) {\r\n                out[0] = v1[0] * v2[0];\r\n                out[1] = v1[1] * v2[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量除法\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             */\r\n            div: function (out, v1, v2) {\r\n                out[0] = v1[0] / v2[0];\r\n                out[1] = v1[1] / v2[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量点乘\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @return {number}\r\n             */\r\n            dot: function (v1, v2) {\r\n                return v1[0] * v2[0] + v1[1] * v2[1];\r\n            },\r\n\r\n            /**\r\n             * 向量缩放\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             * @param {number} s\r\n             */\r\n            scale: function (out, v, s) {\r\n                out[0] = v[0] * s;\r\n                out[1] = v[1] * s;\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 向量归一化\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             */\r\n            normalize: function (out, v) {\r\n                var d = vector.len(v);\r\n                if (d === 0) {\r\n                    out[0] = 0;\r\n                    out[1] = 0;\r\n                }\r\n                else {\r\n                    out[0] = v[0] / d;\r\n                    out[1] = v[1] / d;\r\n                }\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 计算向量间距离\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @return {number}\r\n             */\r\n            distance: function (v1, v2) {\r\n                return Math.sqrt(\r\n                    (v1[0] - v2[0]) * (v1[0] - v2[0])\r\n                    + (v1[1] - v2[1]) * (v1[1] - v2[1])\r\n                );\r\n            },\r\n\r\n            /**\r\n             * 向量距离平方\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @return {number}\r\n             */\r\n            distanceSquare: function (v1, v2) {\r\n                return (v1[0] - v2[0]) * (v1[0] - v2[0])\r\n                    + (v1[1] - v2[1]) * (v1[1] - v2[1]);\r\n            },\r\n\r\n            /**\r\n             * 求负向量\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             */\r\n            negate: function (out, v) {\r\n                out[0] = -v[0];\r\n                out[1] = -v[1];\r\n                return out;\r\n            },\r\n\r\n            /**\r\n             * 插值两个点\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v1\r\n             * @param {Vector2} v2\r\n             * @param {number} t\r\n             */\r\n            lerp: function (out, v1, v2, t) {\r\n                // var ax = v1[0];\r\n                // var ay = v1[1];\r\n                out[0] = v1[0] + t * (v2[0] - v1[0]);\r\n                out[1] = v1[1] + t * (v2[1] - v1[1]);\r\n                return out;\r\n            },\r\n            \r\n            /**\r\n             * 矩阵左乘向量\r\n             * @param {Vector2} out\r\n             * @param {Vector2} v\r\n             * @param {Vector2} m\r\n             */\r\n            applyTransform: function (out, v, m) {\r\n                var x = v[0];\r\n                var y = v[1];\r\n                out[0] = m[0] * x + m[2] * y + m[4];\r\n                out[1] = m[1] * x + m[3] * y + m[5];\r\n                return out;\r\n            },\r\n            /**\r\n             * 求两个向量最小值\r\n             * @param  {Vector2} out\r\n             * @param  {Vector2} v1\r\n             * @param  {Vector2} v2\r\n             */\r\n            min: function (out, v1, v2) {\r\n                out[0] = Math.min(v1[0], v2[0]);\r\n                out[1] = Math.min(v1[1], v2[1]);\r\n                return out;\r\n            },\r\n            /**\r\n             * 求两个向量最大值\r\n             * @param  {Vector2} out\r\n             * @param  {Vector2} v1\r\n             * @param  {Vector2} v2\r\n             */\r\n            max: function (out, v1, v2) {\r\n                out[0] = Math.max(v1[0], v2[0]);\r\n                out[1] = Math.max(v1[1], v2[1]);\r\n                return out;\r\n            }\r\n        };\r\n\r\n        vector.length = vector.len;\r\n        vector.lengthSquare = vector.lenSquare;\r\n        vector.dist = vector.distance;\r\n        vector.distSquare = vector.distanceSquare;\r\n        \r\n        return vector;\r\n    }\r\n);\r\n"
    },
    {
      "id": 16,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\mixin\\Eventful.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/mixin/Eventful.js",
      "index": 16,
      "index2": 8,
      "size": 6861,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\event.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../mixin/Eventful",
          "loc": "48:23-51"
        },
        {
          "moduleId": 65,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\event.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/event.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/event.js",
          "type": "cjs require",
          "userRequest": "../mixin/Eventful",
          "loc": "11:23-51"
        }
      ],
      "source": "/**\r\n * 事件扩展\r\n * @module zrender/mixin/Eventful\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         pissang (https://www.github.com/pissang)\r\n */\r\ndefine(function (require) {\r\n\r\n    /**\r\n     * 事件分发器\r\n     * @alias module:zrender/mixin/Eventful\r\n     * @constructor\r\n     */\r\n    var Eventful = function () {\r\n        this._handlers = {};\r\n    };\r\n    /**\r\n     * 单次触发绑定，dispatch后销毁\r\n     * \r\n     * @param {string} event 事件名\r\n     * @param {Function} handler 响应函数\r\n     * @param {Object} context\r\n     */\r\n    Eventful.prototype.one = function (event, handler, context) {\r\n        var _h = this._handlers;\r\n\r\n        if (!handler || !event) {\r\n            return this;\r\n        }\r\n\r\n        if (!_h[event]) {\r\n            _h[event] = [];\r\n        }\r\n\r\n        _h[event].push({\r\n            h : handler,\r\n            one : true,\r\n            ctx: context || this\r\n        });\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 绑定事件\r\n     * @param {string} event 事件名\r\n     * @param {Function} handler 事件处理函数\r\n     * @param {Object} [context]\r\n     */\r\n    Eventful.prototype.bind = function (event, handler, context) {\r\n        var _h = this._handlers;\r\n\r\n        if (!handler || !event) {\r\n            return this;\r\n        }\r\n\r\n        if (!_h[event]) {\r\n            _h[event] = [];\r\n        }\r\n\r\n        _h[event].push({\r\n            h : handler,\r\n            one : false,\r\n            ctx: context || this\r\n        });\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 解绑事件\r\n     * @param {string} event 事件名\r\n     * @param {Function} [handler] 事件处理函数\r\n     */\r\n    Eventful.prototype.unbind = function (event, handler) {\r\n        var _h = this._handlers;\r\n\r\n        if (!event) {\r\n            this._handlers = {};\r\n            return this;\r\n        }\r\n\r\n        if (handler) {\r\n            if (_h[event]) {\r\n                var newList = [];\r\n                for (var i = 0, l = _h[event].length; i < l; i++) {\r\n                    if (_h[event][i]['h'] != handler) {\r\n                        newList.push(_h[event][i]);\r\n                    }\r\n                }\r\n                _h[event] = newList;\r\n            }\r\n\r\n            if (_h[event] && _h[event].length === 0) {\r\n                delete _h[event];\r\n            }\r\n        }\r\n        else {\r\n            delete _h[event];\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 事件分发\r\n     * \r\n     * @param {string} type 事件类型\r\n     */\r\n    Eventful.prototype.dispatch = function (type) {\r\n        if (this._handlers[type]) {\r\n            var args = arguments;\r\n            var argLen = args.length;\r\n\r\n            if (argLen > 3) {\r\n                args = Array.prototype.slice.call(args, 1);\r\n            }\r\n            \r\n            var _h = this._handlers[type];\r\n            var len = _h.length;\r\n            for (var i = 0; i < len;) {\r\n                // Optimize advise from backbone\r\n                switch (argLen) {\r\n                    case 1:\r\n                        _h[i]['h'].call(_h[i]['ctx']);\r\n                        break;\r\n                    case 2:\r\n                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\r\n                        break;\r\n                    case 3:\r\n                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\r\n                        break;\r\n                    default:\r\n                        // have more than 2 given arguments\r\n                        _h[i]['h'].apply(_h[i]['ctx'], args);\r\n                        break;\r\n                }\r\n                \r\n                if (_h[i]['one']) {\r\n                    _h.splice(i, 1);\r\n                    len--;\r\n                }\r\n                else {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 带有context的事件分发, 最后一个参数是事件回调的context\r\n     * @param {string} type 事件类型\r\n     */\r\n    Eventful.prototype.dispatchWithContext = function (type) {\r\n        if (this._handlers[type]) {\r\n            var args = arguments;\r\n            var argLen = args.length;\r\n\r\n            if (argLen > 4) {\r\n                args = Array.prototype.slice.call(args, 1, args.length - 1);\r\n            }\r\n            var ctx = args[args.length - 1];\r\n\r\n            var _h = this._handlers[type];\r\n            var len = _h.length;\r\n            for (var i = 0; i < len;) {\r\n                // Optimize advise from backbone\r\n                switch (argLen) {\r\n                    case 1:\r\n                        _h[i]['h'].call(ctx);\r\n                        break;\r\n                    case 2:\r\n                        _h[i]['h'].call(ctx, args[1]);\r\n                        break;\r\n                    case 3:\r\n                        _h[i]['h'].call(ctx, args[1], args[2]);\r\n                        break;\r\n                    default:\r\n                        // have more than 2 given arguments\r\n                        _h[i]['h'].apply(ctx, args);\r\n                        break;\r\n                }\r\n                \r\n                if (_h[i]['one']) {\r\n                    _h.splice(i, 1);\r\n                    len--;\r\n                }\r\n                else {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    // 对象可以通过 onxxxx 绑定事件\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onclick\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmouseover\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmouseout\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmousemove\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmousewheel\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmousedown\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#onmouseup\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragstart\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragend\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragenter\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragleave\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondragover\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    /**\r\n     * @event module:zrender/mixin/Eventful#ondrop\r\n     * @type {Function}\r\n     * @default null\r\n     */\r\n    \r\n    return Eventful;\r\n});\r\n"
    },
    {
      "id": 17,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\area.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
      "index": 17,
      "index2": 10,
      "size": 29342,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/area",
          "loc": "26:17-47"
        },
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../tool/area",
          "loc": "61:29-52"
        },
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../tool/area",
          "loc": "91:23-46"
        },
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../tool/area",
          "loc": "469:23-46"
        },
        {
          "moduleId": 23,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
          "type": "cjs require",
          "userRequest": "../tool/area",
          "loc": "53:19-42"
        },
        {
          "moduleId": 25,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
          "type": "cjs require",
          "userRequest": "../tool/area",
          "loc": "54:19-42"
        },
        {
          "moduleId": 26,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/area",
          "loc": "30:15-45"
        },
        {
          "moduleId": 52,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/area",
          "loc": "77:17-47"
        },
        {
          "moduleId": 53,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Text.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
          "type": "cjs require",
          "userRequest": "../tool/area",
          "loc": "40:19-42"
        }
      ],
      "source": "/**\r\n * zrender: 图形空间辅助类\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         pissang (https://www.github.com/pissang)\r\n *\r\n * isInside：是否在区域内部\r\n * isOutside：是否在区域外部\r\n * getTextWidth：测算单行文本宽度\r\n */\r\ndefine(\r\n    function (require) {\r\n\r\n        'use strict';\r\n\r\n        var util = require('./util');\r\n        var curve = require('./curve');\r\n\r\n        var _ctx;\r\n        \r\n        var _textWidthCache = {};\r\n        var _textHeightCache = {};\r\n        var _textWidthCacheCounter = 0;\r\n        var _textHeightCacheCounter = 0;\r\n        var TEXT_CACHE_MAX = 5000;\r\n            \r\n        var PI2 = Math.PI * 2;\r\n\r\n        function normalizeRadian(angle) {\r\n            angle %= PI2;\r\n            if (angle < 0) {\r\n                angle += PI2;\r\n            }\r\n            return angle;\r\n        }\r\n        /**\r\n         * 包含判断\r\n         *\r\n         * @param {Object} shape : 图形\r\n         * @param {Object} area ： 目标区域\r\n         * @param {number} x ： 横坐标\r\n         * @param {number} y ： 纵坐标\r\n         */\r\n        function isInside(shape, area, x, y) {\r\n            if (!area || !shape) {\r\n                // 无参数或不支持类型\r\n                return false;\r\n            }\r\n            var zoneType = shape.type;\r\n\r\n            _ctx = _ctx || util.getContext();\r\n\r\n            // 未实现或不可用时(excanvas不支持)则数学运算，主要是line，polyline，ring\r\n            var _mathReturn = _mathMethod(shape, area, x, y);\r\n            if (typeof _mathReturn != 'undefined') {\r\n                return _mathReturn;\r\n            }\r\n\r\n            if (shape.buildPath && _ctx.isPointInPath) {\r\n                return _buildPathMethod(shape, _ctx, area, x, y);\r\n            }\r\n\r\n            // 上面的方法都行不通时\r\n            switch (zoneType) {\r\n                case 'ellipse': // Todo，不精确\r\n                    return true;\r\n                // 旋轮曲线  不准确\r\n                case 'trochoid':\r\n                    var _r = area.location == 'out'\r\n                            ? area.r1 + area.r2 + area.d\r\n                            : area.r1 - area.r2 + area.d;\r\n                    return isInsideCircle(area, x, y, _r);\r\n                // 玫瑰线 不准确\r\n                case 'rose' :\r\n                    return isInsideCircle(area, x, y, area.maxr);\r\n                // 路径，椭圆，曲线等-----------------13\r\n                default:\r\n                    return false;   // Todo，暂不支持\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @param {Object} shape : 图形\r\n         * @param {Object} area ：目标区域\r\n         * @param {number} x ： 横坐标\r\n         * @param {number} y ： 纵坐标\r\n         * @return {boolean=} true表示坐标处在图形中\r\n         */\r\n        function _mathMethod(shape, area, x, y) {\r\n            var zoneType = shape.type;\r\n            // 在矩形内则部分图形需要进一步判断\r\n            switch (zoneType) {\r\n                // 贝塞尔曲线\r\n                case 'bezier-curve':\r\n                    if (typeof(area.cpX2) === 'undefined') {\r\n                        return isInsideQuadraticStroke(\r\n                            area.xStart, area.yStart,\r\n                            area.cpX1, area.cpY1, \r\n                            area.xEnd, area.yEnd,\r\n                            area.lineWidth, x, y\r\n                        );\r\n                    }\r\n                    return isInsideCubicStroke(\r\n                        area.xStart, area.yStart,\r\n                        area.cpX1, area.cpY1, \r\n                        area.cpX2, area.cpY2, \r\n                        area.xEnd, area.yEnd,\r\n                        area.lineWidth, x, y\r\n                    );\r\n                // 线\r\n                case 'line':\r\n                    return isInsideLine(\r\n                        area.xStart, area.yStart,\r\n                        area.xEnd, area.yEnd,\r\n                        area.lineWidth, x, y\r\n                    );\r\n                // 折线\r\n                case 'polyline':\r\n                    return isInsidePolyline(\r\n                        area.pointList, area.lineWidth, x, y\r\n                    );\r\n                // 圆环\r\n                case 'ring':\r\n                    return isInsideRing(\r\n                        area.x, area.y, area.r0, area.r, x, y\r\n                    );\r\n                // 圆形\r\n                case 'circle':\r\n                    return isInsideCircle(\r\n                        area.x, area.y, area.r, x, y\r\n                    );\r\n                // 扇形\r\n                case 'sector':\r\n                    var startAngle = area.startAngle * Math.PI / 180;\r\n                    var endAngle = area.endAngle * Math.PI / 180;\r\n                    if (!area.clockWise) {\r\n                        startAngle = -startAngle;\r\n                        endAngle = -endAngle;\r\n                    }\r\n                    return isInsideSector(\r\n                        area.x, area.y, area.r0, area.r,\r\n                        startAngle, endAngle,\r\n                        !area.clockWise,\r\n                        x, y\r\n                    );\r\n                // 多边形\r\n                case 'path':\r\n                    return area.pathArray && isInsidePath(\r\n                        area.pathArray, Math.max(area.lineWidth, 5),\r\n                        area.brushType, x, y\r\n                    );\r\n                case 'polygon':\r\n                case 'star':\r\n                case 'isogon':\r\n                    return isInsidePolygon(area.pointList, x, y);\r\n                // 文本\r\n                case 'text':\r\n                    var rect =  area.__rect || shape.getRect(area);\r\n                    return isInsideRect(\r\n                        rect.x, rect.y, rect.width, rect.height, x, y\r\n                    );\r\n                // 矩形\r\n                case 'rectangle':\r\n                // 图片\r\n                case 'image':\r\n                    return isInsideRect(\r\n                        area.x, area.y, area.width, area.height, x, y\r\n                    );\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 通过buildPath方法来判断，三个方法中较快，但是不支持线条类型的shape，\r\n         * 而且excanvas不支持isPointInPath方法\r\n         *\r\n         * @param {Object} shape ： shape\r\n         * @param {Object} context : 上下文\r\n         * @param {Object} area ：目标区域\r\n         * @param {number} x ： 横坐标\r\n         * @param {number} y ： 纵坐标\r\n         * @return {boolean} true表示坐标处在图形中\r\n         */\r\n        function _buildPathMethod(shape, context, area, x, y) {\r\n            // 图形类实现路径创建了则用类的path\r\n            context.beginPath();\r\n            shape.buildPath(context, area);\r\n            context.closePath();\r\n            return context.isPointInPath(x, y);\r\n        }\r\n\r\n        /**\r\n         * !isInside\r\n         */\r\n        function isOutside(shape, area, x, y) {\r\n            return !isInside(shape, area, x, y);\r\n        }\r\n\r\n        /**\r\n         * 线段包含判断\r\n         * @param  {number}  x0\r\n         * @param  {number}  y0\r\n         * @param  {number}  x1\r\n         * @param  {number}  y1\r\n         * @param  {number}  lineWidth\r\n         * @param  {number}  x\r\n         * @param  {number}  y\r\n         * @return {boolean}\r\n         */\r\n        function isInsideLine(x0, y0, x1, y1, lineWidth, x, y) {\r\n            if (lineWidth === 0) {\r\n                return false;\r\n            }\r\n            var _l = Math.max(lineWidth, 5);\r\n            var _a = 0;\r\n            var _b = x0;\r\n            // Quick reject\r\n            if (\r\n                (y > y0 + _l && y > y1 + _l)\r\n                || (y < y0 - _l && y < y1 - _l)\r\n                || (x > x0 + _l && x > x1 + _l)\r\n                || (x < x0 - _l && x < x1 - _l)\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            if (x0 !== x1) {\r\n                _a = (y0 - y1) / (x0 - x1);\r\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\r\n            }\r\n            else {\r\n                return Math.abs(x - x0) <= _l / 2;\r\n            }\r\n            var tmp = _a * x - y + _b;\r\n            var _s = tmp * tmp / (_a * _a + 1);\r\n            return _s <= _l / 2 * _l / 2;\r\n        }\r\n\r\n        /**\r\n         * 三次贝塞尔曲线描边包含判断\r\n         * @param  {number}  x0\r\n         * @param  {number}  y0\r\n         * @param  {number}  x1\r\n         * @param  {number}  y1\r\n         * @param  {number}  x2\r\n         * @param  {number}  y2\r\n         * @param  {number}  x3\r\n         * @param  {number}  y3\r\n         * @param  {number}  lineWidth\r\n         * @param  {number}  x\r\n         * @param  {number}  y\r\n         * @return {boolean}\r\n         */\r\n        function isInsideCubicStroke(\r\n            x0, y0, x1, y1, x2, y2, x3, y3,\r\n            lineWidth, x, y\r\n        ) {\r\n            if (lineWidth === 0) {\r\n                return false;\r\n            }\r\n            var _l = Math.max(lineWidth, 5);\r\n            // Quick reject\r\n            if (\r\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\r\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\r\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\r\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\r\n            ) {\r\n                return false;\r\n            }\r\n            var d =  curve.cubicProjectPoint(\r\n                x0, y0, x1, y1, x2, y2, x3, y3,\r\n                x, y, null\r\n            );\r\n            return d <= _l / 2;\r\n        }\r\n\r\n        /**\r\n         * 二次贝塞尔曲线描边包含判断\r\n         * @param  {number}  x0\r\n         * @param  {number}  y0\r\n         * @param  {number}  x1\r\n         * @param  {number}  y1\r\n         * @param  {number}  x2\r\n         * @param  {number}  y2\r\n         * @param  {number}  lineWidth\r\n         * @param  {number}  x\r\n         * @param  {number}  y\r\n         * @return {boolean}\r\n         */\r\n        function isInsideQuadraticStroke(\r\n            x0, y0, x1, y1, x2, y2,\r\n            lineWidth, x, y\r\n        ) {\r\n            if (lineWidth === 0) {\r\n                return false;\r\n            }\r\n            var _l = Math.max(lineWidth, 5);\r\n            // Quick reject\r\n            if (\r\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\r\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\r\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\r\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\r\n            ) {\r\n                return false;\r\n            }\r\n            var d =  curve.quadraticProjectPoint(\r\n                x0, y0, x1, y1, x2, y2,\r\n                x, y, null\r\n            );\r\n            return d <= _l / 2;\r\n        }\r\n\r\n        /**\r\n         * 圆弧描边包含判断\r\n         * @param  {number}  cx\r\n         * @param  {number}  cy\r\n         * @param  {number}  r\r\n         * @param  {number}  startAngle\r\n         * @param  {number}  endAngle\r\n         * @param  {boolean}  anticlockwise\r\n         * @param  {number} lineWidth\r\n         * @param  {number}  x\r\n         * @param  {number}  y\r\n         * @return {Boolean}\r\n         */\r\n        function isInsideArcStroke(\r\n            cx, cy, r, startAngle, endAngle, anticlockwise,\r\n            lineWidth, x, y\r\n        ) {\r\n            if (lineWidth === 0) {\r\n                return false;\r\n            }\r\n            var _l = Math.max(lineWidth, 5);\r\n\r\n            x -= cx;\r\n            y -= cy;\r\n            var d = Math.sqrt(x * x + y * y);\r\n            if ((d - _l > r) || (d + _l < r)) {\r\n                return false;\r\n            }\r\n            if (Math.abs(startAngle - endAngle) >= PI2) {\r\n                // Is a circle\r\n                return true;\r\n            }\r\n            if (anticlockwise) {\r\n                var tmp = startAngle;\r\n                startAngle = normalizeRadian(endAngle);\r\n                endAngle = normalizeRadian(tmp);\r\n            } else {\r\n                startAngle = normalizeRadian(startAngle);\r\n                endAngle = normalizeRadian(endAngle);\r\n            }\r\n            if (startAngle > endAngle) {\r\n                endAngle += PI2;\r\n            }\r\n            \r\n            var angle = Math.atan2(y, x);\r\n            if (angle < 0) {\r\n                angle += PI2;\r\n            }\r\n            return (angle >= startAngle && angle <= endAngle)\r\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\r\n        }\r\n\r\n        function isInsidePolyline(points, lineWidth, x, y) {\r\n            var lineWidth = Math.max(lineWidth, 10);\r\n            for (var i = 0, l = points.length - 1; i < l; i++) {\r\n                var x0 = points[i][0];\r\n                var y0 = points[i][1];\r\n                var x1 = points[i + 1][0];\r\n                var y1 = points[i + 1][1];\r\n\r\n                if (isInsideLine(x0, y0, x1, y1, lineWidth, x, y)) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isInsideRing(cx, cy, r0, r, x, y) {\r\n            var d = (x - cx) * (x - cx) + (y - cy) * (y - cy);\r\n            return (d < r * r) && (d > r0 * r0);\r\n        }\r\n\r\n        /**\r\n         * 矩形包含判断\r\n         */\r\n        function isInsideRect(x0, y0, width, height, x, y) {\r\n            return x >= x0 && x <= (x0 + width)\r\n                && y >= y0 && y <= (y0 + height);\r\n        }\r\n\r\n        /**\r\n         * 圆形包含判断\r\n         */\r\n        function isInsideCircle(x0, y0, r, x, y) {\r\n            return (x - x0) * (x - x0) + (y - y0) * (y - y0)\r\n                   < r * r;\r\n        }\r\n\r\n        /**\r\n         * 扇形包含判断\r\n         */\r\n        function isInsideSector(\r\n            cx, cy, r0, r, startAngle, endAngle, anticlockwise, x, y\r\n        ) {\r\n            return isInsideArcStroke(\r\n                cx, cy, (r0 + r) / 2, startAngle, endAngle, anticlockwise,\r\n                r - r0, x, y\r\n            );\r\n        }\r\n\r\n        /**\r\n         * 多边形包含判断\r\n         * 与 canvas 一样采用 non-zero winding rule\r\n         */\r\n        function isInsidePolygon(points, x, y) {\r\n            var N = points.length;\r\n            var w = 0;\r\n\r\n            for (var i = 0, j = N - 1; i < N; i++) {\r\n                var x0 = points[j][0];\r\n                var y0 = points[j][1];\r\n                var x1 = points[i][0];\r\n                var y1 = points[i][1];\r\n                w += windingLine(x0, y0, x1, y1, x, y);\r\n                j = i;\r\n            }\r\n            return w !== 0;\r\n        }\r\n\r\n        function windingLine(x0, y0, x1, y1, x, y) {\r\n            if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\r\n                return 0;\r\n            }\r\n            if (y1 == y0) {\r\n                return 0;\r\n            }\r\n            var dir = y1 < y0 ? 1 : -1;\r\n            var t = (y - y0) / (y1 - y0);\r\n            var x_ = t * (x1 - x0) + x0;\r\n\r\n            return x_ > x ? dir : 0;\r\n        }\r\n\r\n        // 临时数组\r\n        var roots = [-1, -1, -1];\r\n        var extrema = [-1, -1];\r\n\r\n        function swapExtrema() {\r\n            var tmp = extrema[0];\r\n            extrema[0] = extrema[1];\r\n            extrema[1] = tmp;\r\n        }\r\n        function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\r\n            // Quick reject\r\n            if (\r\n                (y > y0 && y > y1 && y > y2 && y > y3)\r\n                || (y < y0 && y < y1 && y < y2 && y < y3)\r\n            ) {\r\n                return 0;\r\n            }\r\n            var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\r\n            if (nRoots === 0) {\r\n                return 0;\r\n            }\r\n            else {\r\n                var w = 0;\r\n                var nExtrema = -1;\r\n                var y0_, y1_;\r\n                for (var i = 0; i < nRoots; i++) {\r\n                    var t = roots[i];\r\n                    var x_ = curve.cubicAt(x0, x1, x2, x3, t);\r\n                    if (x_ < x) { // Quick reject\r\n                        continue;\r\n                    }\r\n                    if (nExtrema < 0) {\r\n                        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\r\n                        if (extrema[1] < extrema[0] && nExtrema > 1) {\r\n                            swapExtrema();\r\n                        }\r\n                        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\r\n                        if (nExtrema > 1) {\r\n                            y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\r\n                        }\r\n                    }\r\n                    if (nExtrema == 2) {\r\n                        // 分成三段单调函数\r\n                        if (t < extrema[0]) {\r\n                            w += y0_ < y0 ? 1 : -1;\r\n                        } \r\n                        else if (t < extrema[1]) {\r\n                            w += y1_ < y0_ ? 1 : -1;\r\n                        } \r\n                        else {\r\n                            w += y3 < y1_ ? 1 : -1;\r\n                        }\r\n                    } \r\n                    else {\r\n                        // 分成两段单调函数\r\n                        if (t < extrema[0]) {\r\n                            w += y0_ < y0 ? 1 : -1;\r\n                        } \r\n                        else {\r\n                            w += y3 < y0_ ? 1 : -1;\r\n                        }\r\n                    }\r\n                }\r\n                return w;\r\n            }\r\n        }\r\n\r\n        function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\r\n            // Quick reject\r\n            if (\r\n                (y > y0 && y > y1 && y > y2)\r\n                || (y < y0 && y < y1 && y < y2)\r\n            ) {\r\n                return 0;\r\n            }\r\n            var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\r\n            if (nRoots === 0) {\r\n                return 0;\r\n            } \r\n            else {\r\n                var t = curve.quadraticExtremum(y0, y1, y2);\r\n                if (t >=0 && t <= 1) {\r\n                    var w = 0;\r\n                    var y_ = curve.quadraticAt(y0, y1, y2, t);\r\n                    for (var i = 0; i < nRoots; i++) {\r\n                        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\r\n                        if (x_ < x) {\r\n                            continue;\r\n                        }\r\n                        if (roots[i] < t) {\r\n                            w += y_ < y0 ? 1 : -1;\r\n                        } \r\n                        else {\r\n                            w += y2 < y_ ? 1 : -1;\r\n                        }\r\n                    }\r\n                    return w;\r\n                } \r\n                else {\r\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\r\n                    if (x_ < x) {\r\n                        return 0;\r\n                    }\r\n                    return y2 < y0 ? 1 : -1;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // TODO\r\n        // Arc 旋转\r\n        function windingArc(\r\n            cx, cy, r, startAngle, endAngle, anticlockwise, x, y\r\n        ) {\r\n            y -= cy;\r\n            if (y > r || y < -r) {\r\n                return 0;\r\n            }\r\n            var tmp = Math.sqrt(r * r - y * y);\r\n            roots[0] = -tmp;\r\n            roots[1] = tmp;\r\n\r\n            if (Math.abs(startAngle - endAngle) >= PI2) {\r\n                // Is a circle\r\n                startAngle = 0;\r\n                endAngle = PI2;\r\n                var dir = anticlockwise ? 1 : -1;\r\n                if (x >= roots[0] + cx && x <= roots[1] + cx) {\r\n                    return dir;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            if (anticlockwise) {\r\n                var tmp = startAngle;\r\n                startAngle = normalizeRadian(endAngle);\r\n                endAngle = normalizeRadian(tmp);   \r\n            } else {\r\n                startAngle = normalizeRadian(startAngle);\r\n                endAngle = normalizeRadian(endAngle);   \r\n            }\r\n            if (startAngle > endAngle) {\r\n                endAngle += PI2;\r\n            }\r\n\r\n            var w = 0;\r\n            for (var i = 0; i < 2; i++) {\r\n                var x_ = roots[i];\r\n                if (x_ + cx > x) {\r\n                    var angle = Math.atan2(y, x_);\r\n                    var dir = anticlockwise ? 1 : -1;\r\n                    if (angle < 0) {\r\n                        angle = PI2 + angle;\r\n                    }\r\n                    if (\r\n                        (angle >= startAngle && angle <= endAngle)\r\n                        || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\r\n                    ) {\r\n                        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\r\n                            dir = -dir;\r\n                        }\r\n                        w += dir;\r\n                    }\r\n                }\r\n            }\r\n            return w;\r\n        }\r\n\r\n        /**\r\n         * 路径包含判断\r\n         * 与 canvas 一样采用 non-zero winding rule\r\n         */\r\n        function isInsidePath(pathArray, lineWidth, brushType, x, y) {\r\n            var w = 0;\r\n            var xi = 0;\r\n            var yi = 0;\r\n            var x0 = 0;\r\n            var y0 = 0;\r\n            var beginSubpath = true;\r\n            var firstCmd = true;\r\n\r\n            brushType = brushType || 'fill';\r\n\r\n            var hasStroke = brushType === 'stroke' || brushType === 'both';\r\n            var hasFill = brushType === 'fill' || brushType === 'both';\r\n\r\n            // var roots = [-1, -1, -1];\r\n            for (var i = 0; i < pathArray.length; i++) {\r\n                var seg = pathArray[i];\r\n                var p = seg.points;\r\n                // Begin a new subpath\r\n                if (beginSubpath || seg.command === 'M') {\r\n                    if (i > 0) {\r\n                        // Close previous subpath\r\n                        if (hasFill) {\r\n                            w += windingLine(xi, yi, x0, y0, x, y);\r\n                        }\r\n                        if (w !== 0) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    x0 = p[p.length - 2];\r\n                    y0 = p[p.length - 1];\r\n                    beginSubpath = false;\r\n                    if (firstCmd && seg.command !== 'A') {\r\n                        // 如果第一个命令不是M, 是lineTo, bezierCurveTo\r\n                        // 等绘制命令的话，是会从该绘制的起点开始算的\r\n                        // Arc 会在之后做单独处理所以这里忽略\r\n                        firstCmd = false;\r\n                        xi = x0;\r\n                        yi = y0;\r\n                    }\r\n                }\r\n                switch (seg.command) {\r\n                    case 'M':\r\n                        xi = p[0];\r\n                        yi = p[1];\r\n                        break;\r\n                    case 'L':\r\n                        if (hasStroke) {\r\n                            if (isInsideLine(\r\n                                xi, yi, p[0], p[1], lineWidth, x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (hasFill) {\r\n                            w += windingLine(xi, yi, p[0], p[1], x, y);\r\n                        }\r\n                        xi = p[0];\r\n                        yi = p[1];\r\n                        break;\r\n                    case 'C':\r\n                        if (hasStroke) {\r\n                            if (isInsideCubicStroke(\r\n                                xi, yi, p[0], p[1], p[2], p[3], p[4], p[5],\r\n                                lineWidth, x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (hasFill) {\r\n                            w += windingCubic(\r\n                                xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], x, y\r\n                            );\r\n                        }\r\n                        xi = p[4];\r\n                        yi = p[5];\r\n                        break;\r\n                    case 'Q':\r\n                        if (hasStroke) {\r\n                            if (isInsideQuadraticStroke(\r\n                                xi, yi, p[0], p[1], p[2], p[3],\r\n                                lineWidth, x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (hasFill) {\r\n                            w += windingQuadratic(\r\n                                xi, yi, p[0], p[1], p[2], p[3], x, y\r\n                            );\r\n                        }\r\n                        xi = p[2];\r\n                        yi = p[3];\r\n                        break;\r\n                    case 'A':\r\n                        // TODO Arc 旋转\r\n                        // TODO Arc 判断的开销比较大\r\n                        var cx = p[0];\r\n                        var cy = p[1];\r\n                        var rx = p[2];\r\n                        var ry = p[3];\r\n                        var theta = p[4];\r\n                        var dTheta = p[5];\r\n                        var x1 = Math.cos(theta) * rx + cx;\r\n                        var y1 = Math.sin(theta) * ry + cy;\r\n                        // 不是直接使用 arc 命令\r\n                        if (!firstCmd) {\r\n                            w += windingLine(xi, yi, x1, y1);\r\n                        } else {\r\n                            firstCmd = false;\r\n                            // 第一个命令起点还未定义\r\n                            x0 = x1;\r\n                            y0 = y1;\r\n                        }\r\n                        // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\r\n                        var _x = (x - cx) * ry / rx + cx;\r\n                        if (hasStroke) {\r\n                            if (isInsideArcStroke(\r\n                                cx, cy, ry, theta, theta + dTheta, 1 - p[7],\r\n                                lineWidth, _x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (hasFill) {\r\n                            w += windingArc(\r\n                                cx, cy, ry, theta, theta + dTheta, 1 - p[7],\r\n                                _x, y\r\n                            );\r\n                        }\r\n                        xi = Math.cos(theta + dTheta) * rx + cx;\r\n                        yi = Math.sin(theta + dTheta) * ry + cy;\r\n                        break;\r\n                    case 'z':\r\n                        if (hasStroke) {\r\n                            if (isInsideLine(\r\n                                xi, yi, x0, y0, lineWidth, x, y\r\n                            )) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        beginSubpath = true;\r\n                        break;\r\n                }\r\n            }\r\n            if (hasFill) {\r\n                w += windingLine(xi, yi, x0, y0, x, y);\r\n            }\r\n            return w !== 0;\r\n        }\r\n\r\n        /**\r\n         * 测算多行文本宽度\r\n         * @param {Object} text\r\n         * @param {Object} textFont\r\n         */\r\n        function getTextWidth(text, textFont) {\r\n            var key = text + ':' + textFont;\r\n            if (_textWidthCache[key]) {\r\n                return _textWidthCache[key];\r\n            }\r\n            _ctx = _ctx || util.getContext();\r\n            _ctx.save();\r\n\r\n            if (textFont) {\r\n                _ctx.font = textFont;\r\n            }\r\n            \r\n            text = (text + '').split('\\n');\r\n            var width = 0;\r\n            for (var i = 0, l = text.length; i < l; i++) {\r\n                width =  Math.max(\r\n                    _ctx.measureText(text[i]).width,\r\n                    width\r\n                );\r\n            }\r\n            _ctx.restore();\r\n\r\n            _textWidthCache[key] = width;\r\n            if (++_textWidthCacheCounter > TEXT_CACHE_MAX) {\r\n                // 内存释放\r\n                _textWidthCacheCounter = 0;\r\n                _textWidthCache = {};\r\n            }\r\n            \r\n            return width;\r\n        }\r\n        \r\n        /**\r\n         * 测算多行文本高度\r\n         * @param {Object} text\r\n         * @param {Object} textFont\r\n         */\r\n        function getTextHeight(text, textFont) {\r\n            var key = text + ':' + textFont;\r\n            if (_textHeightCache[key]) {\r\n                return _textHeightCache[key];\r\n            }\r\n            \r\n            _ctx = _ctx || util.getContext();\r\n\r\n            _ctx.save();\r\n            if (textFont) {\r\n                _ctx.font = textFont;\r\n            }\r\n            \r\n            text = (text + '').split('\\n');\r\n            // 比较粗暴\r\n            var height = (_ctx.measureText('国').width + 2) * text.length;\r\n\r\n            _ctx.restore();\r\n\r\n            _textHeightCache[key] = height;\r\n            if (++_textHeightCacheCounter > TEXT_CACHE_MAX) {\r\n                // 内存释放\r\n                _textHeightCacheCounter = 0;\r\n                _textHeightCache = {};\r\n            }\r\n            return height;\r\n        }\r\n\r\n        return {\r\n            isInside : isInside,\r\n            isOutside : isOutside,\r\n            getTextWidth : getTextWidth,\r\n            getTextHeight : getTextHeight,\r\n\r\n            isInsidePath: isInsidePath,\r\n            isInsidePolygon: isInsidePolygon,\r\n            isInsideSector: isInsideSector,\r\n            isInsideCircle: isInsideCircle,\r\n            isInsideLine: isInsideLine,\r\n            isInsideRect: isInsideRect,\r\n            isInsidePolyline: isInsidePolyline,\r\n\r\n            isInsideCubicStroke: isInsideCubicStroke,\r\n            isInsideQuadraticStroke: isInsideQuadraticStroke\r\n        };\r\n    }\r\n);\r\n"
    },
    {
      "id": 18,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\curve.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/curve.js",
      "index": 18,
      "index2": 9,
      "size": 14871,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 17,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\area.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/area.js",
          "type": "cjs require",
          "userRequest": "./curve",
          "loc": "17:20-38"
        },
        {
          "moduleId": 26,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/curve",
          "loc": "33:20-51"
        },
        {
          "moduleId": 39,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecAnimation.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/curve",
          "loc": "10:20-51"
        },
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/curve",
          "loc": "13:20-51"
        }
      ],
      "source": "/**\r\n * 曲线辅助模块\r\n * @module zrender/tool/curve\r\n * @author pissang(https://www.github.com/pissang)\r\n */\r\ndefine(function(require) {\r\n\r\n    var vector = require('./vector');\r\n\r\n    'use strict';\r\n\r\n    var EPSILON = 1e-4;\r\n\r\n    var THREE_SQRT = Math.sqrt(3);\r\n    var ONE_THIRD = 1 / 3;\r\n\r\n    // 临时变量\r\n    var _v0 = vector.create();\r\n    var _v1 = vector.create();\r\n    var _v2 = vector.create();\r\n    // var _v3 = vector.create();\r\n\r\n    function isAroundZero(val) {\r\n        return val > -EPSILON && val < EPSILON;\r\n    }\r\n    function isNotAroundZero(val) {\r\n        return val > EPSILON || val < -EPSILON;\r\n    }\r\n    /*\r\n    function evalCubicCoeff(a, b, c, d, t) {\r\n        return ((a * t + b) * t + c) * t + d;\r\n    }\r\n    */\r\n\r\n    /** \r\n     * 计算三次贝塞尔值\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {number} t\r\n     * @return {number}\r\n     */\r\n    function cubicAt(p0, p1, p2, p3, t) {\r\n        var onet = 1 - t;\r\n        return onet * onet * (onet * p0 + 3 * t * p1)\r\n             + t * t * (t * p3 + 3 * onet * p2);\r\n    }\r\n\r\n    /** \r\n     * 计算三次贝塞尔导数值\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {number} t\r\n     * @return {number}\r\n     */\r\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\r\n        var onet = 1 - t;\r\n        return 3 * (\r\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\r\n            + (p3 - p2) * t * t\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 计算三次贝塞尔方程根，使用盛金公式\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {number} val\r\n     * @param  {Array.<number>} roots\r\n     * @return {number} 有效根数目\r\n     */\r\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\r\n        // Evaluate roots of cubic functions\r\n        var a = p3 + 3 * (p1 - p2) - p0;\r\n        var b = 3 * (p2 - p1 * 2 + p0);\r\n        var c = 3 * (p1  - p0);\r\n        var d = p0 - val;\r\n\r\n        var A = b * b - 3 * a * c;\r\n        var B = b * c - 9 * a * d;\r\n        var C = c * c - 3 * b * d;\r\n\r\n        var n = 0;\r\n\r\n        if (isAroundZero(A) && isAroundZero(B)) {\r\n            if (isAroundZero(b)) {\r\n                roots[0] = 0;\r\n            }\r\n            else {\r\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var disc = B * B - 4 * A * C;\r\n\r\n            if (isAroundZero(disc)) {\r\n                var K = B / A;\r\n                var t1 = -b / a + K;  // t1, a is not zero\r\n                var t2 = -K / 2;  // t2, t3\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n                if (t2 >= 0 && t2 <= 1) {\r\n                    roots[n++] = t2;\r\n                }\r\n            }\r\n            else if (disc > 0) {\r\n                var discSqrt = Math.sqrt(disc);\r\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\r\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\r\n                if (Y1 < 0) {\r\n                    Y1 = -Math.pow(-Y1, ONE_THIRD);\r\n                }\r\n                else {\r\n                    Y1 = Math.pow(Y1, ONE_THIRD);\r\n                }\r\n                if (Y2 < 0) {\r\n                    Y2 = -Math.pow(-Y2, ONE_THIRD);\r\n                }\r\n                else {\r\n                    Y2 = Math.pow(Y2, ONE_THIRD);\r\n                }\r\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n            }\r\n            else {\r\n                var T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));\r\n                var theta = Math.acos(T) / 3;\r\n                var ASqrt = Math.sqrt(A);\r\n                var tmp = Math.cos(theta);\r\n                \r\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\r\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\r\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n                if (t2 >= 0 && t2 <= 1) {\r\n                    roots[n++] = t2;\r\n                }\r\n                if (t3 >= 0 && t3 <= 1) {\r\n                    roots[n++] = t3;\r\n                }\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n\r\n    /**\r\n     * 计算三次贝塞尔方程极限值的位置\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {Array.<number>} extrema\r\n     * @return {number} 有效数目\r\n     */\r\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\r\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\r\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\r\n        var c = 3 * p1 - 3 * p0;\r\n\r\n        var n = 0;\r\n        if (isAroundZero(a)) {\r\n            if (isNotAroundZero(b)) {\r\n                var t1 = -c / b;\r\n                if (t1 >= 0 && t1 <=1) {\r\n                    extrema[n++] = t1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var disc = b * b - 4 * a * c;\r\n            if (isAroundZero(disc)) {\r\n                extrema[0] = -b / (2 * a);\r\n            }\r\n            else if (disc > 0) {\r\n                var discSqrt = Math.sqrt(disc);\r\n                var t1 = (-b + discSqrt) / (2 * a);\r\n                var t2 = (-b - discSqrt) / (2 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    extrema[n++] = t1;\r\n                }\r\n                if (t2 >= 0 && t2 <= 1) {\r\n                    extrema[n++] = t2;\r\n                }\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n\r\n    /**\r\n     * 细分三次贝塞尔曲线\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} p3\r\n     * @param  {number} t\r\n     * @param  {Array.<number>} out\r\n     */\r\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\r\n        var p01 = (p1 - p0) * t + p0;\r\n        var p12 = (p2 - p1) * t + p1;\r\n        var p23 = (p3 - p2) * t + p2;\r\n\r\n        var p012 = (p12 - p01) * t + p01;\r\n        var p123 = (p23 - p12) * t + p12;\r\n\r\n        var p0123 = (p123 - p012) * t + p012;\r\n        // Seg0\r\n        out[0] = p0;\r\n        out[1] = p01;\r\n        out[2] = p012;\r\n        out[3] = p0123;\r\n        // Seg1\r\n        out[4] = p0123;\r\n        out[5] = p123;\r\n        out[6] = p23;\r\n        out[7] = p3;\r\n    }\r\n\r\n    /**\r\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\r\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\r\n     * @param {number} x0\r\n     * @param {number} y0\r\n     * @param {number} x1\r\n     * @param {number} y1\r\n     * @param {number} x2\r\n     * @param {number} y2\r\n     * @param {number} x3\r\n     * @param {number} y3\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {Array.<number>} [out] 投射点\r\n     * @return {number}\r\n     */\r\n    function cubicProjectPoint(\r\n        x0, y0, x1, y1, x2, y2, x3, y3,\r\n        x, y, out\r\n    ) {\r\n        // http://pomax.github.io/bezierinfo/#projections\r\n        var t;\r\n        var interval = 0.005;\r\n        var d = Infinity;\r\n\r\n        _v0[0] = x;\r\n        _v0[1] = y;\r\n\r\n        // 先粗略估计一下可能的最小距离的 t 值\r\n        // PENDING\r\n        for (var _t = 0; _t < 1; _t += 0.05) {\r\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\r\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\r\n            var d1 = vector.distSquare(_v0, _v1);\r\n            if (d1 < d) {\r\n                t = _t;\r\n                d = d1;\r\n            }\r\n        }\r\n        d = Infinity;\r\n\r\n        // At most 32 iteration\r\n        for (var i = 0; i < 32; i++) {\r\n            if (interval < EPSILON) {\r\n                break;\r\n            }\r\n            var prev = t - interval;\r\n            var next = t + interval;\r\n            // t - interval\r\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\r\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\r\n\r\n            var d1 = vector.distSquare(_v1, _v0);\r\n\r\n            if (prev >= 0 && d1 < d) {\r\n                t = prev;\r\n                d = d1;\r\n            }\r\n            else {\r\n                // t + interval\r\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\r\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\r\n                var d2 = vector.distSquare(_v2, _v0);\r\n\r\n                if (next <= 1 && d2 < d) {\r\n                    t = next;\r\n                    d = d2;\r\n                }\r\n                else {\r\n                    interval *= 0.5;\r\n                }\r\n            }\r\n        }\r\n        // t\r\n        if (out) {\r\n            out[0] = cubicAt(x0, x1, x2, x3, t);\r\n            out[1] = cubicAt(y0, y1, y2, y3, t);   \r\n        }\r\n        // console.log(interval, i);\r\n        return Math.sqrt(d);\r\n    }\r\n\r\n    /**\r\n     * 计算二次方贝塞尔值\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} t\r\n     * @return {number}\r\n     */\r\n    function quadraticAt(p0, p1, p2, t) {\r\n        var onet = 1 - t;\r\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\r\n    }\r\n\r\n    /**\r\n     * 计算二次方贝塞尔导数值\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} t\r\n     * @return {number}\r\n     */\r\n    function quadraticDerivativeAt(p0, p1, p2, t) {\r\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\r\n    }\r\n\r\n    /**\r\n     * 计算二次方贝塞尔方程根\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} t\r\n     * @param  {Array.<number>} roots\r\n     * @return {number} 有效根数目\r\n     */\r\n    function quadraticRootAt(p0, p1, p2, val, roots) {\r\n        var a = p0 - 2 * p1 + p2;\r\n        var b = 2 * (p1 - p0);\r\n        var c = p0 - val;\r\n\r\n        var n = 0;\r\n        if (isAroundZero(a)) {\r\n            if (isNotAroundZero(b)) {\r\n                var t1 = -c / b;\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var disc = b * b - 4 * a * c;\r\n            if (isAroundZero(disc)) {\r\n                var t1 = -b / (2 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n            }\r\n            else if (disc > 0) {\r\n                var discSqrt = Math.sqrt(disc);\r\n                var t1 = (-b + discSqrt) / (2 * a);\r\n                var t2 = (-b - discSqrt) / (2 * a);\r\n                if (t1 >= 0 && t1 <= 1) {\r\n                    roots[n++] = t1;\r\n                }\r\n                if (t2 >= 0 && t2 <= 1) {\r\n                    roots[n++] = t2;\r\n                }\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n\r\n    /**\r\n     * 计算二次贝塞尔方程极限值\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @return {number}\r\n     */\r\n    function quadraticExtremum(p0, p1, p2) {\r\n        var divider = p0 + p2 - 2 * p1;\r\n        if (divider === 0) {\r\n            // p1 is center of p0 and p2 \r\n            return 0.5;\r\n        }\r\n        else {\r\n            return (p0 - p1) / divider;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 细分二次贝塞尔曲线\r\n     * @memberOf module:zrender/tool/curve\r\n     * @param  {number} p0\r\n     * @param  {number} p1\r\n     * @param  {number} p2\r\n     * @param  {number} t\r\n     * @param  {Array.<number>} out\r\n     */\r\n    function quadraticSubdivide(p0, p1, p2, t, out) {\r\n        var p01 = (p1 - p0) * t + p0;\r\n        var p12 = (p2 - p1) * t + p1;\r\n        var p012 = (p12 - p01) * t + p01;\r\n\r\n        // Seg0\r\n        out[0] = p0;\r\n        out[1] = p01;\r\n        out[2] = p012;\r\n\r\n        // Seg1\r\n        out[3] = p012;\r\n        out[4] = p12;\r\n        out[5] = p2;\r\n    }\r\n\r\n    /**\r\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\r\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\r\n     * @param {number} x0\r\n     * @param {number} y0\r\n     * @param {number} x1\r\n     * @param {number} y1\r\n     * @param {number} x2\r\n     * @param {number} y2\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {Array.<number>} out 投射点\r\n     * @return {number}\r\n     */\r\n    function quadraticProjectPoint(\r\n        x0, y0, x1, y1, x2, y2,\r\n        x, y, out\r\n    ) {\r\n        // http://pomax.github.io/bezierinfo/#projections\r\n        var t;\r\n        var interval = 0.005;\r\n        var d = Infinity;\r\n\r\n        _v0[0] = x;\r\n        _v0[1] = y;\r\n\r\n        // 先粗略估计一下可能的最小距离的 t 值\r\n        // PENDING\r\n        for (var _t = 0; _t < 1; _t += 0.05) {\r\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\r\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\r\n            var d1 = vector.distSquare(_v0, _v1);\r\n            if (d1 < d) {\r\n                t = _t;\r\n                d = d1;\r\n            }\r\n        }\r\n        d = Infinity;\r\n\r\n        // At most 32 iteration\r\n        for (var i = 0; i < 32; i++) {\r\n            if (interval < EPSILON) {\r\n                break;\r\n            }\r\n            var prev = t - interval;\r\n            var next = t + interval;\r\n            // t - interval\r\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\r\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\r\n\r\n            var d1 = vector.distSquare(_v1, _v0);\r\n\r\n            if (prev >= 0 && d1 < d) {\r\n                t = prev;\r\n                d = d1;\r\n            }\r\n            else {\r\n                // t + interval\r\n                _v2[0] = quadraticAt(x0, x1, x2, next);\r\n                _v2[1] = quadraticAt(y0, y1, y2, next);\r\n                var d2 = vector.distSquare(_v2, _v0);\r\n                if (next <= 1 && d2 < d) {\r\n                    t = next;\r\n                    d = d2;\r\n                }\r\n                else {\r\n                    interval *= 0.5;\r\n                }\r\n            }\r\n        }\r\n        // t\r\n        if (out) {\r\n            out[0] = quadraticAt(x0, x1, x2, t);\r\n            out[1] = quadraticAt(y0, y1, y2, t);   \r\n        }\r\n        // console.log(interval, i);\r\n        return Math.sqrt(d);\r\n    }\r\n\r\n    return {\r\n\r\n        cubicAt: cubicAt,\r\n\r\n        cubicDerivativeAt: cubicDerivativeAt,\r\n\r\n        cubicRootAt: cubicRootAt,\r\n\r\n        cubicExtrema: cubicExtrema,\r\n\r\n        cubicSubdivide: cubicSubdivide,\r\n\r\n        cubicProjectPoint: cubicProjectPoint,\r\n\r\n        quadraticAt: quadraticAt,\r\n\r\n        quadraticDerivativeAt: quadraticDerivativeAt,\r\n\r\n        quadraticRootAt: quadraticRootAt,\r\n\r\n        quadraticExtremum: quadraticExtremum,\r\n\r\n        quadraticSubdivide: quadraticSubdivide,\r\n\r\n        quadraticProjectPoint: quadraticProjectPoint\r\n    };\r\n});"
    },
    {
      "id": 19,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\color.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/color.js",
      "index": 19,
      "index2": 11,
      "size": 29604,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/color",
          "loc": "64:18-49"
        },
        {
          "moduleId": 7,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Base.js",
          "type": "cjs require",
          "userRequest": "../tool/color",
          "loc": "384:24-48"
        },
        {
          "moduleId": 51,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/color",
          "loc": "24:18-49"
        },
        {
          "moduleId": 64,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/color",
          "loc": "81:26-57"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/color",
          "loc": "71:18-49"
        }
      ],
      "source": "/**\r\n * 颜色辅助模块\r\n * @module zrender/tool/color\r\n */\r\ndefine(function(require) {\r\n    var util = require('../tool/util');\r\n\r\n    var _ctx;\r\n\r\n    // Color palette is an array containing the default colors for the chart's\r\n    // series.\r\n    // When all colors are used, new colors are selected from the start again.\r\n    // Defaults to:\r\n    // 默认色板\r\n    var palette = [\r\n        '#ff9277', ' #dddd00', ' #ffc877', ' #bbe3ff', ' #d5ffbb',\r\n        '#bbbbff', ' #ddb000', ' #b0dd00', ' #e2bbff', ' #ffbbe3',\r\n        '#ff7777', ' #ff9900', ' #83dd00', ' #77e3ff', ' #778fff',\r\n        '#c877ff', ' #ff77ab', ' #ff6600', ' #aa8800', ' #77c7ff',\r\n        '#ad77ff', ' #ff77ff', ' #dd0083', ' #777700', ' #00aa00',\r\n        '#0088aa', ' #8400dd', ' #aa0088', ' #dd0000', ' #772e00'\r\n    ];\r\n    var _palette = palette;\r\n\r\n    var highlightColor = 'rgba(255,255,0,0.5)';\r\n    var _highlightColor = highlightColor;\r\n\r\n    // 颜色格式\r\n    /*jshint maxlen: 330 */\r\n    var colorRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i;\r\n\r\n    var _nameColors = {\r\n        aliceblue : '#f0f8ff',\r\n        antiquewhite : '#faebd7',\r\n        aqua : '#0ff',\r\n        aquamarine : '#7fffd4',\r\n        azure : '#f0ffff',\r\n        beige : '#f5f5dc',\r\n        bisque : '#ffe4c4',\r\n        black : '#000',\r\n        blanchedalmond : '#ffebcd',\r\n        blue : '#00f',\r\n        blueviolet : '#8a2be2',\r\n        brown : '#a52a2a',\r\n        burlywood : '#deb887',\r\n        cadetblue : '#5f9ea0',\r\n        chartreuse : '#7fff00',\r\n        chocolate : '#d2691e',\r\n        coral : '#ff7f50',\r\n        cornflowerblue : '#6495ed',\r\n        cornsilk : '#fff8dc',\r\n        crimson : '#dc143c',\r\n        cyan : '#0ff',\r\n        darkblue : '#00008b',\r\n        darkcyan : '#008b8b',\r\n        darkgoldenrod : '#b8860b',\r\n        darkgray : '#a9a9a9',\r\n        darkgrey : '#a9a9a9',\r\n        darkgreen : '#006400',\r\n        darkkhaki : '#bdb76b',\r\n        darkmagenta : '#8b008b',\r\n        darkolivegreen : '#556b2f',\r\n        darkorange : '#ff8c00',\r\n        darkorchid : '#9932cc',\r\n        darkred : '#8b0000',\r\n        darksalmon : '#e9967a',\r\n        darkseagreen : '#8fbc8f',\r\n        darkslateblue : '#483d8b',\r\n        darkslategray : '#2f4f4f',\r\n        darkslategrey : '#2f4f4f',\r\n        darkturquoise : '#00ced1',\r\n        darkviolet : '#9400d3',\r\n        deeppink : '#ff1493',\r\n        deepskyblue : '#00bfff',\r\n        dimgray : '#696969',\r\n        dimgrey : '#696969',\r\n        dodgerblue : '#1e90ff',\r\n        firebrick : '#b22222',\r\n        floralwhite : '#fffaf0',\r\n        forestgreen : '#228b22',\r\n        fuchsia : '#f0f',\r\n        gainsboro : '#dcdcdc',\r\n        ghostwhite : '#f8f8ff',\r\n        gold : '#ffd700',\r\n        goldenrod : '#daa520',\r\n        gray : '#808080',\r\n        grey : '#808080',\r\n        green : '#008000',\r\n        greenyellow : '#adff2f',\r\n        honeydew : '#f0fff0',\r\n        hotpink : '#ff69b4',\r\n        indianred : '#cd5c5c',\r\n        indigo : '#4b0082',\r\n        ivory : '#fffff0',\r\n        khaki : '#f0e68c',\r\n        lavender : '#e6e6fa',\r\n        lavenderblush : '#fff0f5',\r\n        lawngreen : '#7cfc00',\r\n        lemonchiffon : '#fffacd',\r\n        lightblue : '#add8e6',\r\n        lightcoral : '#f08080',\r\n        lightcyan : '#e0ffff',\r\n        lightgoldenrodyellow : '#fafad2',\r\n        lightgray : '#d3d3d3',\r\n        lightgrey : '#d3d3d3',\r\n        lightgreen : '#90ee90',\r\n        lightpink : '#ffb6c1',\r\n        lightsalmon : '#ffa07a',\r\n        lightseagreen : '#20b2aa',\r\n        lightskyblue : '#87cefa',\r\n        lightslategray : '#789',\r\n        lightslategrey : '#789',\r\n        lightsteelblue : '#b0c4de',\r\n        lightyellow : '#ffffe0',\r\n        lime : '#0f0',\r\n        limegreen : '#32cd32',\r\n        linen : '#faf0e6',\r\n        magenta : '#f0f',\r\n        maroon : '#800000',\r\n        mediumaquamarine : '#66cdaa',\r\n        mediumblue : '#0000cd',\r\n        mediumorchid : '#ba55d3',\r\n        mediumpurple : '#9370d8',\r\n        mediumseagreen : '#3cb371',\r\n        mediumslateblue : '#7b68ee',\r\n        mediumspringgreen : '#00fa9a',\r\n        mediumturquoise : '#48d1cc',\r\n        mediumvioletred : '#c71585',\r\n        midnightblue : '#191970',\r\n        mintcream : '#f5fffa',\r\n        mistyrose : '#ffe4e1',\r\n        moccasin : '#ffe4b5',\r\n        navajowhite : '#ffdead',\r\n        navy : '#000080',\r\n        oldlace : '#fdf5e6',\r\n        olive : '#808000',\r\n        olivedrab : '#6b8e23',\r\n        orange : '#ffa500',\r\n        orangered : '#ff4500',\r\n        orchid : '#da70d6',\r\n        palegoldenrod : '#eee8aa',\r\n        palegreen : '#98fb98',\r\n        paleturquoise : '#afeeee',\r\n        palevioletred : '#d87093',\r\n        papayawhip : '#ffefd5',\r\n        peachpuff : '#ffdab9',\r\n        peru : '#cd853f',\r\n        pink : '#ffc0cb',\r\n        plum : '#dda0dd',\r\n        powderblue : '#b0e0e6',\r\n        purple : '#800080',\r\n        red : '#f00',\r\n        rosybrown : '#bc8f8f',\r\n        royalblue : '#4169e1',\r\n        saddlebrown : '#8b4513',\r\n        salmon : '#fa8072',\r\n        sandybrown : '#f4a460',\r\n        seagreen : '#2e8b57',\r\n        seashell : '#fff5ee',\r\n        sienna : '#a0522d',\r\n        silver : '#c0c0c0',\r\n        skyblue : '#87ceeb',\r\n        slateblue : '#6a5acd',\r\n        slategray : '#708090',\r\n        slategrey : '#708090',\r\n        snow : '#fffafa',\r\n        springgreen : '#00ff7f',\r\n        steelblue : '#4682b4',\r\n        tan : '#d2b48c',\r\n        teal : '#008080',\r\n        thistle : '#d8bfd8',\r\n        tomato : '#ff6347',\r\n        turquoise : '#40e0d0',\r\n        violet : '#ee82ee',\r\n        wheat : '#f5deb3',\r\n        white : '#fff',\r\n        whitesmoke : '#f5f5f5',\r\n        yellow : '#ff0',\r\n        yellowgreen : '#9acd32'\r\n    };\r\n\r\n    /**\r\n     * 自定义调色板\r\n     */\r\n    function customPalette(userPalete) {\r\n        palette = userPalete;\r\n    }\r\n\r\n    /**\r\n     * 复位默认色板\r\n     */\r\n    function resetPalette() {\r\n        palette = _palette;\r\n    }\r\n\r\n    /**\r\n     * 获取色板颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {number} idx 色板位置\r\n     * @param {Array.<string>} [userPalete] 自定义色板\r\n     * @return {string} 颜色\r\n     */\r\n    function getColor(idx, userPalete) {\r\n        idx = idx | 0;\r\n        userPalete = userPalete || palette;\r\n        return userPalete[idx % userPalete.length];\r\n    }\r\n\r\n    /**\r\n     * 自定义默认高亮颜色\r\n     */\r\n    function customHighlight(userHighlightColor) {\r\n        highlightColor = userHighlightColor;\r\n    }\r\n\r\n    /**\r\n     * 重置默认高亮颜色\r\n     */\r\n    function resetHighlight() {\r\n        _highlightColor = highlightColor;\r\n    }\r\n\r\n    /**\r\n     * 获取默认高亮颜色\r\n     */\r\n    function getHighlightColor() {\r\n        return highlightColor;\r\n    }\r\n\r\n    /**\r\n     * 径向渐变\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {number} x0 渐变起点\r\n     * @param {number} y0\r\n     * @param {number} r0\r\n     * @param {number} x1 渐变终点\r\n     * @param {number} y1\r\n     * @param {number} r1\r\n     * @param {Array} colorList 颜色列表\r\n     * @return {CanvasGradient}\r\n     */\r\n    function getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {\r\n        if (!_ctx) {\r\n            _ctx = util.getContext();\r\n        }\r\n        var gradient = _ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\r\n        for (var i = 0, l = colorList.length; i < l; i++) {\r\n            gradient.addColorStop(colorList[i][0], colorList[i][1]);\r\n        }\r\n        gradient.__nonRecursion = true;\r\n        return gradient;\r\n    }\r\n\r\n    /**\r\n     * 线性渐变\r\n     * @param {Object} x0 渐变起点\r\n     * @param {Object} y0\r\n     * @param {Object} x1 渐变终点\r\n     * @param {Object} y1\r\n     * @param {Array} colorList 颜色列表\r\n     */\r\n    function getLinearGradient(x0, y0, x1, y1, colorList) {\r\n        if (!_ctx) {\r\n            _ctx = util.getContext();\r\n        }\r\n        var gradient = _ctx.createLinearGradient(x0, y0, x1, y1);\r\n        for (var i = 0, l = colorList.length; i < l; i++) {\r\n            gradient.addColorStop(colorList[i][0], colorList[i][1]);\r\n        }\r\n        gradient.__nonRecursion = true;\r\n        return gradient;\r\n    }\r\n\r\n    /**\r\n     * 获取两种颜色之间渐变颜色数组\r\n     * @param {color} start 起始颜色\r\n     * @param {color} end 结束颜色\r\n     * @param {number} step 渐变级数\r\n     * @return {Array}  颜色数组\r\n     */\r\n    function getStepColors(start, end, step) {\r\n        start = toRGBA(start);\r\n        end = toRGBA(end);\r\n        start = getData(start);\r\n        end = getData(end);\r\n\r\n        var colors = [];\r\n        var stepR = (end[0] - start[0]) / step;\r\n        var stepG = (end[1] - start[1]) / step;\r\n        var stepB = (end[2] - start[2]) / step;\r\n        var stepA = (end[3] - start[3]) / step;\r\n        // 生成颜色集合\r\n        // fix by linfeng 颜色堆积\r\n        for (var i = 0, r = start[0], g = start[1], b = start[2], a = start[3]; i < step; i++) {\r\n            colors[i] = toColor([\r\n                adjust(Math.floor(r), [ 0, 255 ]),\r\n                adjust(Math.floor(g), [ 0, 255 ]), \r\n                adjust(Math.floor(b), [ 0, 255 ]),\r\n                a.toFixed(4) - 0\r\n            ],'rgba');\r\n            r += stepR;\r\n            g += stepG;\r\n            b += stepB;\r\n            a += stepA;\r\n        }\r\n        r = end[0];\r\n        g = end[1];\r\n        b = end[2];\r\n        a = end[3];\r\n        colors[i] = toColor([r, g, b, a], 'rgba');\r\n        return colors;\r\n    }\r\n\r\n    /**\r\n     * 获取指定级数的渐变颜色数组\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {Array.<string>} colors 颜色组\r\n     * @param {number} [step=20] 渐变级数\r\n     * @return {Array.<string>}  颜色数组\r\n     */\r\n    function getGradientColors(colors, step) {\r\n        var ret = [];\r\n        var len = colors.length;\r\n        if (step === undefined) {\r\n            step = 20;\r\n        }\r\n        if (len === 1) {\r\n            ret = getStepColors(colors[0], colors[0], step);\r\n        }\r\n        else if (len > 1) {\r\n            for (var i = 0, n = len - 1; i < n; i++) {\r\n                var steps = getStepColors(colors[i], colors[i + 1], step);\r\n                if (i < n - 1) {\r\n                    steps.pop();\r\n                }\r\n                ret = ret.concat(steps);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * 颜色值数组转为指定格式颜色,例如:<br/>\r\n     * data = [60,20,20,0.1] format = 'rgba'\r\n     * 返回：rgba(60,20,20,0.1)\r\n     * @param {Array} data 颜色值数组\r\n     * @param {string} format 格式,默认rgb\r\n     * @return {string} 颜色\r\n     */\r\n    function toColor(data, format) {\r\n        format = format || 'rgb';\r\n        if (data && (data.length === 3 || data.length === 4)) {\r\n            data = map(data,\r\n                function(c) {\r\n                    return c > 1 ? Math.ceil(c) : c;\r\n                }\r\n            );\r\n\r\n            if (format.indexOf('hex') > -1) {\r\n                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);\r\n            }\r\n            else if (format.indexOf('hs') > -1) {\r\n                var sx = map(data.slice(1, 3),\r\n                    function(c) {\r\n                        return c + '%';\r\n                    }\r\n                );\r\n                data[1] = sx[0];\r\n                data[2] = sx[1];\r\n            }\r\n\r\n            if (format.indexOf('a') > -1) {\r\n                if (data.length === 3) {\r\n                    data.push(1);\r\n                }\r\n                data[3] = adjust(data[3], [ 0, 1 ]);\r\n                return format + '(' + data.slice(0, 4).join(',') + ')';\r\n            }\r\n\r\n            return format + '(' + data.slice(0, 3).join(',') + ')';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 颜色字符串转换为rgba数组\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {Array.<number>} 颜色值数组\r\n     */\r\n    function toArray(color) {\r\n        color = trim(color);\r\n        if (color.indexOf('rgba') < 0) {\r\n            color = toRGBA(color);\r\n        }\r\n\r\n        var data = [];\r\n        var i = 0;\r\n        color.replace(/[\\d.]+/g, function (n) {\r\n            if (i < 3) {\r\n                n = n | 0;\r\n            }\r\n            else {\r\n                // Alpha\r\n                n = +n;\r\n            }\r\n            data[i++] = n;\r\n        });\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * 颜色格式转化\r\n     *\r\n     * @param {string} color 颜色值数组\r\n     * @param {string} format 格式,默认rgb\r\n     * @return {string} 颜色\r\n     */\r\n    function convert(color, format) {\r\n        if (!isCalculableColor(color)) {\r\n            return color;\r\n        }\r\n        var data = getData(color);\r\n        var alpha = data[3];\r\n        if (typeof alpha === 'undefined') {\r\n            alpha = 1;\r\n        }\r\n\r\n        if (color.indexOf('hsb') > -1) {\r\n            data = _HSV_2_RGB(data);\r\n        }\r\n        else if (color.indexOf('hsl') > -1) {\r\n            data = _HSL_2_RGB(data);\r\n        }\r\n\r\n        if (format.indexOf('hsb') > -1 || format.indexOf('hsv') > -1) {\r\n            data = _RGB_2_HSB(data);\r\n        }\r\n        else if (format.indexOf('hsl') > -1) {\r\n            data = _RGB_2_HSL(data);\r\n        }\r\n\r\n        data[3] = alpha;\r\n\r\n        return toColor(data, format);\r\n    }\r\n\r\n    /**\r\n     * 转换为rgba格式的颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} rgba颜色，rgba(r,g,b,a)\r\n     */\r\n    function toRGBA(color) {\r\n        return convert(color, 'rgba');\r\n    }\r\n\r\n    /**\r\n     * 转换为rgb数字格式的颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} rgb颜色，rgb(0,0,0)格式\r\n     */\r\n    function toRGB(color) {\r\n        return convert(color, 'rgb');\r\n    }\r\n\r\n    /**\r\n     * 转换为16进制颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} 16进制颜色，#rrggbb格式\r\n     */\r\n    function toHex(color) {\r\n        return convert(color, 'hex');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSV颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSVA颜色，hsva(h,s,v,a)\r\n     */\r\n    function toHSVA(color) {\r\n        return convert(color, 'hsva');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSV颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSV颜色，hsv(h,s,v)\r\n     */\r\n    function toHSV(color) {\r\n        return convert(color, 'hsv');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSBA颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSBA颜色，hsba(h,s,b,a)\r\n     */\r\n    function toHSBA(color) {\r\n        return convert(color, 'hsba');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSB颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSB颜色，hsb(h,s,b)\r\n     */\r\n    function toHSB(color) {\r\n        return convert(color, 'hsb');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSLA颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSLA颜色，hsla(h,s,l,a)\r\n     */\r\n    function toHSLA(color) {\r\n        return convert(color, 'hsla');\r\n    }\r\n\r\n    /**\r\n     * 转换为HSL颜色\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} HSL颜色，hsl(h,s,l)\r\n     */\r\n    function toHSL(color) {\r\n        return convert(color, 'hsl');\r\n    }\r\n\r\n    /**\r\n     * 转换颜色名\r\n     * \r\n     * @param {string} color 颜色\r\n     * @return {string} 颜色名\r\n     */\r\n    function toName(color) {\r\n        for (var key in _nameColors) {\r\n            if (toHex(_nameColors[key]) === toHex(color)) {\r\n                return key;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 移除颜色中多余空格\r\n     * \r\n     * @param {string} color 颜色\r\n     * @return {string} 无空格颜色\r\n     */\r\n    function trim(color) {\r\n        return String(color).replace(/\\s+/g, '');\r\n    }\r\n\r\n    /**\r\n     * 颜色规范化\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} 规范化后的颜色\r\n     */\r\n    function normalize(color) {\r\n        // 颜色名\r\n        if (_nameColors[color]) {\r\n            color = _nameColors[color];\r\n        }\r\n        // 去掉空格\r\n        color = trim(color);\r\n        // hsv与hsb等价\r\n        color = color.replace(/hsv/i, 'hsb');\r\n        // rgb转为rrggbb\r\n        if (/^#[\\da-f]{3}$/i.test(color)) {\r\n            color = parseInt(color.slice(1), 16);\r\n            var r = (color & 0xf00) << 8;\r\n            var g = (color & 0xf0) << 4;\r\n            var b = color & 0xf;\r\n\r\n            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);\r\n        }\r\n        // 或者使用以下正则替换，不过 chrome 下性能相对差点\r\n        // color = color.replace(/^#([\\da-f])([\\da-f])([\\da-f])$/i, '#$1$1$2$2$3$3');\r\n        return color;\r\n    }\r\n\r\n    /**\r\n     * 颜色加深或减淡，当level>0加深，当level<0减淡\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @param {number} level 升降程度,取值区间[-1,1]\r\n     * @return {string} 加深或减淡后颜色值\r\n     */\r\n    function lift(color, level) {\r\n        if (!isCalculableColor(color)) {\r\n            return color;\r\n        }\r\n        var direct = level > 0 ? 1 : -1;\r\n        if (typeof level === 'undefined') {\r\n            level = 0;\r\n        }\r\n        level = Math.abs(level) > 1 ? 1 : Math.abs(level);\r\n        color = toRGB(color);\r\n        var data = getData(color);\r\n        for (var i = 0; i < 3; i++) {\r\n            if (direct === 1) {\r\n                data[i] = data[i] * (1 - level) | 0;\r\n            }\r\n            else {\r\n                data[i] = ((255 - data[i]) * level + data[i]) | 0;\r\n            }\r\n        }\r\n        return 'rgb(' + data.join(',') + ')';\r\n    }\r\n\r\n    /**\r\n     * 颜色翻转,[255-r,255-g,255-b,1-a]\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @return {string} 翻转颜色\r\n     */\r\n    function reverse(color) {\r\n        if (!isCalculableColor(color)) {\r\n            return color;\r\n        }\r\n        var data = getData(toRGBA(color));\r\n        data = map(data,\r\n            function(c) {\r\n                return 255 - c;\r\n            }\r\n        );\r\n        return toColor(data, 'rgb');\r\n    }\r\n\r\n    /**\r\n     * 简单两种颜色混合\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color1 第一种颜色\r\n     * @param {string} color2 第二种颜色\r\n     * @param {number} weight 混合权重[0-1]\r\n     * @return {string} 结果色,rgb(r,g,b)或rgba(r,g,b,a)\r\n     */\r\n    function mix(color1, color2, weight) {\r\n        if (!isCalculableColor(color1) || !isCalculableColor(color2)) {\r\n            return color1;\r\n        }\r\n        \r\n        if (typeof weight === 'undefined') {\r\n            weight = 0.5;\r\n        }\r\n        weight = 1 - adjust(weight, [ 0, 1 ]);\r\n\r\n        var w = weight * 2 - 1;\r\n        var data1 = getData(toRGBA(color1));\r\n        var data2 = getData(toRGBA(color2));\r\n\r\n        var d = data1[3] - data2[3];\r\n\r\n        var weight1 = (((w * d === -1) ? w : (w + d) / (1 + w * d)) + 1) / 2;\r\n        var weight2 = 1 - weight1;\r\n\r\n        var data = [];\r\n\r\n        for (var i = 0; i < 3; i++) {\r\n            data[i] = data1[i] * weight1 + data2[i] * weight2;\r\n        }\r\n\r\n        var alpha = data1[3] * weight + data2[3] * (1 - weight);\r\n        alpha = Math.max(0, Math.min(1, alpha));\r\n\r\n        if (data1[3] === 1 && data2[3] === 1) {// 不考虑透明度\r\n            return toColor(data, 'rgb');\r\n        }\r\n        data[3] = alpha;\r\n        return toColor(data, 'rgba');\r\n    }\r\n\r\n    /**\r\n     * 随机颜色\r\n     * \r\n     * @return {string} 颜色值，#rrggbb格式\r\n     */\r\n    function random() {\r\n        return '#' + (Math.random().toString(16) + '0000').slice(2, 8);\r\n    }\r\n\r\n    /**\r\n     * 获取颜色值数组,返回值范围： <br/>\r\n     * RGB 范围[0-255] <br/>\r\n     * HSL/HSV/HSB 范围[0-1]<br/>\r\n     * A透明度范围[0-1]\r\n     * 支持格式：\r\n     * #rgb\r\n     * #rrggbb\r\n     * rgb(r,g,b)\r\n     * rgb(r%,g%,b%)\r\n     * rgba(r,g,b,a)\r\n     * hsb(h,s,b) // hsv与hsb等价\r\n     * hsb(h%,s%,b%)\r\n     * hsba(h,s,b,a)\r\n     * hsl(h,s,l)\r\n     * hsl(h%,s%,l%)\r\n     * hsla(h,s,l,a)\r\n     *\r\n     * @param {string} color 颜色\r\n     * @return {Array.<number>} 颜色值数组或null\r\n     */\r\n    function getData(color) {\r\n        color = normalize(color);\r\n        var r = color.match(colorRegExp);\r\n        if (r === null) {\r\n            throw new Error('The color format error'); // 颜色格式错误\r\n        }\r\n        var d;\r\n        var a;\r\n        var data = [];\r\n        var rgb;\r\n\r\n        if (r[2]) {\r\n            // #rrggbb\r\n            d = r[2].replace('#', '').split('');\r\n            rgb = [ d[0] + d[1], d[2] + d[3], d[4] + d[5] ];\r\n            data = map(rgb,\r\n                function(c) {\r\n                    return adjust(parseInt(c, 16), [ 0, 255 ]);\r\n                }\r\n            );\r\n\r\n        }\r\n        else if (r[4]) {\r\n            // rgb rgba\r\n            var rgba = (r[4]).split(',');\r\n            a = rgba[3];\r\n            rgb = rgba.slice(0, 3);\r\n            data = map(\r\n                rgb,\r\n                function(c) {\r\n                    c = Math.floor(\r\n                        c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c\r\n                    );\r\n                    return adjust(c, [ 0, 255 ]);\r\n                }\r\n            );\r\n\r\n            if (typeof a !== 'undefined') {\r\n                data.push(adjust(parseFloat(a), [ 0, 1 ]));\r\n            }\r\n        }\r\n        else if (r[5] || r[6]) {\r\n            // hsb hsba hsl hsla\r\n            var hsxa = (r[5] || r[6]).split(',');\r\n            var h = parseInt(hsxa[0], 0) / 360;\r\n            var s = hsxa[1];\r\n            var x = hsxa[2];\r\n            a = hsxa[3];\r\n            data = map([ s, x ],\r\n                function(c) {\r\n                    return adjust(parseFloat(c) / 100, [ 0, 1 ]);\r\n                }\r\n            );\r\n            data.unshift(h);\r\n            if (typeof a !== 'undefined') {\r\n                data.push(adjust(parseFloat(a), [ 0, 1 ]));\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * 设置颜色透明度\r\n     * @memberOf module:zrender/tool/color\r\n     * @param {string} color 颜色\r\n     * @param {number} a 透明度,区间[0,1]\r\n     * @return {string} rgba颜色值\r\n     */\r\n    function alpha(color, a) {\r\n        if (!isCalculableColor(color)) {\r\n            return color;\r\n        }\r\n        if (a === null) {\r\n            a = 1;\r\n        }\r\n        var data = getData(toRGBA(color));\r\n        data[3] = adjust(Number(a).toFixed(4), [ 0, 1 ]);\r\n\r\n        return toColor(data, 'rgba');\r\n    }\r\n\r\n    // 数组映射\r\n    function map(array, fun) {\r\n        if (typeof fun !== 'function') {\r\n            throw new TypeError();\r\n        }\r\n        var len = array ? array.length : 0;\r\n        for (var i = 0; i < len; i++) {\r\n            array[i] = fun(array[i]);\r\n        }\r\n        return array;\r\n    }\r\n\r\n    // 调整值区间\r\n    function adjust(value, region) {\r\n        // < to <= & > to >=\r\n        // modify by linzhifeng 2014-05-25 because -0 == 0\r\n        if (value <= region[0]) {\r\n            value = region[0];\r\n        }\r\n        else if (value >= region[1]) {\r\n            value = region[1];\r\n        }\r\n        return value;\r\n    }\r\n    \r\n    function isCalculableColor(color) {\r\n        return color instanceof Array || typeof color === 'string';\r\n    }\r\n\r\n    // 参见 http:// www.easyrgb.com/index.php?X=MATH\r\n    function _HSV_2_RGB(data) {\r\n        var H = data[0];\r\n        var S = data[1];\r\n        var V = data[2];\r\n        // HSV from 0 to 1\r\n        var R; \r\n        var G;\r\n        var B;\r\n        if (S === 0) {\r\n            R = V * 255;\r\n            G = V * 255;\r\n            B = V * 255;\r\n        }\r\n        else {\r\n            var h = H * 6;\r\n            if (h === 6) {\r\n                h = 0;\r\n            }\r\n            var i = h | 0;\r\n            var v1 = V * (1 - S);\r\n            var v2 = V * (1 - S * (h - i));\r\n            var v3 = V * (1 - S * (1 - (h - i)));\r\n            var r = 0;\r\n            var g = 0;\r\n            var b = 0;\r\n\r\n            if (i === 0) {\r\n                r = V;\r\n                g = v3;\r\n                b = v1;\r\n            }\r\n            else if (i === 1) {\r\n                r = v2;\r\n                g = V;\r\n                b = v1;\r\n            }\r\n            else if (i === 2) {\r\n                r = v1;\r\n                g = V;\r\n                b = v3;\r\n            }\r\n            else if (i === 3) {\r\n                r = v1;\r\n                g = v2;\r\n                b = V;\r\n            }\r\n            else if (i === 4) {\r\n                r = v3;\r\n                g = v1;\r\n                b = V;\r\n            }\r\n            else {\r\n                r = V;\r\n                g = v1;\r\n                b = v2;\r\n            }\r\n\r\n            // RGB results from 0 to 255\r\n            R = r * 255;\r\n            G = g * 255;\r\n            B = b * 255;\r\n        }\r\n        return [ R, G, B ];\r\n    }\r\n\r\n    function _HSL_2_RGB(data) {\r\n        var H = data[0];\r\n        var S = data[1];\r\n        var L = data[2];\r\n        // HSL from 0 to 1\r\n        var R;\r\n        var G;\r\n        var B;\r\n        if (S === 0) {\r\n            R = L * 255;\r\n            G = L * 255;\r\n            B = L * 255;\r\n        }\r\n        else {\r\n            var v2;\r\n            if (L < 0.5) {\r\n                v2 = L * (1 + S);\r\n            }\r\n            else {\r\n                v2 = (L + S) - (S * L);\r\n            }\r\n\r\n            var v1 = 2 * L - v2;\r\n\r\n            R = 255 * _HUE_2_RGB(v1, v2, H + (1 / 3));\r\n            G = 255 * _HUE_2_RGB(v1, v2, H);\r\n            B = 255 * _HUE_2_RGB(v1, v2, H - (1 / 3));\r\n        }\r\n        return [ R, G, B ];\r\n    }\r\n\r\n    function _HUE_2_RGB(v1, v2, vH) {\r\n        if (vH < 0) {\r\n            vH += 1;\r\n        }\r\n        if (vH > 1) {\r\n            vH -= 1;\r\n        }\r\n        if ((6 * vH) < 1) {\r\n            return (v1 + (v2 - v1) * 6 * vH);\r\n        }\r\n        if ((2 * vH) < 1) {\r\n            return (v2);\r\n        }\r\n        if ((3 * vH) < 2) {\r\n            return (v1 + (v2 - v1) * ((2 / 3) - vH) * 6);\r\n        }\r\n        return v1;\r\n    }\r\n\r\n    function _RGB_2_HSB(data) {\r\n        // RGB from 0 to 255\r\n        var R = (data[0] / 255);\r\n        var G = (data[1] / 255);\r\n        var B = (data[2] / 255);\r\n\r\n        var vMin = Math.min(R, G, B); // Min. value of RGB\r\n        var vMax = Math.max(R, G, B); // Max. value of RGB\r\n        var delta = vMax - vMin; // Delta RGB value\r\n        var V = vMax;\r\n        var H;\r\n        var S;\r\n\r\n        // HSV results from 0 to 1\r\n        if (delta === 0) {\r\n            H = 0;\r\n            S = 0;\r\n        }\r\n        else {\r\n            S = delta / vMax;\r\n\r\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\r\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\r\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\r\n\r\n            if (R === vMax) {\r\n                H = deltaB - deltaG;\r\n            }\r\n            else if (G === vMax) {\r\n                H = (1 / 3) + deltaR - deltaB;\r\n            }\r\n            else if (B === vMax) {\r\n                H = (2 / 3) + deltaG - deltaR;\r\n            }\r\n\r\n            if (H < 0) {\r\n                H += 1;\r\n            }\r\n            if (H > 1) {\r\n                H -= 1;\r\n            }\r\n        }\r\n        H = H * 360;\r\n        S = S * 100;\r\n        V = V * 100;\r\n        return [ H, S, V ];\r\n    }\r\n\r\n    function _RGB_2_HSL(data) {\r\n        // RGB from 0 to 255\r\n        var R = (data[0] / 255);\r\n        var G = (data[1] / 255);\r\n        var B = (data[2] / 255);\r\n\r\n        var vMin = Math.min(R, G, B); // Min. value of RGB\r\n        var vMax = Math.max(R, G, B); // Max. value of RGB\r\n        var delta = vMax - vMin; // Delta RGB value\r\n\r\n        var L = (vMax + vMin) / 2;\r\n        var H;\r\n        var S;\r\n        // HSL results from 0 to 1\r\n        if (delta === 0) {\r\n            H = 0;\r\n            S = 0;\r\n        }\r\n        else {\r\n            if (L < 0.5) {\r\n                S = delta / (vMax + vMin);\r\n            }\r\n            else {\r\n                S = delta / (2 - vMax - vMin);\r\n            }\r\n\r\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\r\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\r\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\r\n\r\n            if (R === vMax) {\r\n                H = deltaB - deltaG;\r\n            }\r\n            else if (G === vMax) {\r\n                H = (1 / 3) + deltaR - deltaB;\r\n            }\r\n            else if (B === vMax) {\r\n                H = (2 / 3) + deltaG - deltaR;\r\n            }\r\n\r\n            if (H < 0) {\r\n                H += 1;\r\n            }\r\n\r\n            if (H > 1) {\r\n                H -= 1;\r\n            }\r\n        }\r\n\r\n        H = H * 360;\r\n        S = S * 100;\r\n        L = L * 100;\r\n\r\n        return [ H, S, L ];\r\n    }\r\n\r\n    return {\r\n        customPalette : customPalette,\r\n        resetPalette : resetPalette,\r\n        getColor : getColor,\r\n        getHighlightColor : getHighlightColor,\r\n        customHighlight : customHighlight,\r\n        resetHighlight : resetHighlight,\r\n        getRadialGradient : getRadialGradient,\r\n        getLinearGradient : getLinearGradient,\r\n        getGradientColors : getGradientColors,\r\n        getStepColors : getStepColors,\r\n        reverse : reverse,\r\n        mix : mix,\r\n        lift : lift,\r\n        trim : trim,\r\n        random : random,\r\n        toRGB : toRGB,\r\n        toRGBA : toRGBA,\r\n        toHex : toHex,\r\n        toHSL : toHSL,\r\n        toHSLA : toHSLA,\r\n        toHSB : toHSB,\r\n        toHSBA : toHSBA,\r\n        toHSV : toHSV,\r\n        toHSVA : toHSVA,\r\n        toName : toName,\r\n        toColor : toColor,\r\n        toArray : toArray,\r\n        alpha : alpha,\r\n        getData : getData\r\n    };\r\n});\r\n\r\n"
    },
    {
      "id": 20,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
      "index": 20,
      "index2": 19,
      "size": 21602,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../util/shape/Icon",
          "loc": "11:20-49"
        },
        {
          "moduleId": 26,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "type": "cjs require",
          "userRequest": "./Icon",
          "loc": "24:20-37"
        },
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "../util/shape/Icon",
          "loc": "14:20-49"
        },
        {
          "moduleId": 60,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "type": "cjs require",
          "userRequest": "../util/shape/Icon",
          "loc": "14:20-49"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "../util/shape/Icon",
          "loc": "13:20-49"
        }
      ],
      "source": "/**\r\n * echarts扩展zrender shape\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * shape类：icon\r\n * 可配图形属性：\r\n   {\r\n       // 基础属性\r\n       shape  : 'icon',       // 必须，shape类标识，需要显式指定\r\n       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成\r\n       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中\r\n       invisible : {boolean},   // 默认为false，是否可见\r\n\r\n       // 样式属性，默认状态样式样式属性\r\n       style  : {\r\n           x             : {number},  // 必须，左上角横坐标\r\n           y             : {number},  // 必须，左上角纵坐标\r\n           width         : {number},  // 必须，宽度\r\n           height        : {number},  // 必须，高度\r\n           iconType      : {string},  // 必须，icon类型\r\n       },\r\n\r\n       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示\r\n       highlightStyle : {\r\n           // 同style\r\n       }\r\n\r\n       // 交互属性，详见shape.Base\r\n\r\n       // 事件属性，详见shape.Base\r\n   }\r\n */\r\ndefine(function (require) {\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    \r\n    function _iconMark(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n        ctx.moveTo(x,                 y + style.height);\r\n        ctx.lineTo(x + 5 * dx,        y + 14 * dy);\r\n        ctx.lineTo(x + style.width,   y + 3 * dy);\r\n        ctx.lineTo(x + 13 * dx,       y);\r\n        ctx.lineTo(x + 2 * dx,        y + 11 * dy);\r\n        ctx.lineTo(x,                 y + style.height);\r\n\r\n        ctx.moveTo(x + 6 * dx,        y + 10 * dy);\r\n        ctx.lineTo(x + 14 * dx,       y + 2 * dy);\r\n\r\n        ctx.moveTo(x + 10 * dx,       y + 13 * dy);\r\n        ctx.lineTo(x + style.width,   y + 13 * dy);\r\n\r\n        ctx.moveTo(x + 13 * dx,       y + 10 * dy);\r\n        ctx.lineTo(x + 13 * dx,       y + style.height);\r\n    }\r\n\r\n    function _iconMarkUndo(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n        ctx.moveTo(x,                 y + style.height);\r\n        ctx.lineTo(x + 5 * dx,        y + 14 * dy);\r\n        ctx.lineTo(x + style.width,   y + 3 * dy);\r\n        ctx.lineTo(x + 13 * dx,       y);\r\n        ctx.lineTo(x + 2 * dx,        y + 11 * dy);\r\n        ctx.lineTo(x,                 y + style.height);\r\n\r\n        ctx.moveTo(x + 6 * dx,        y + 10 * dy);\r\n        ctx.lineTo(x + 14 * dx,       y + 2 * dy);\r\n\r\n        ctx.moveTo(x + 10 * dx,       y + 13 * dy);\r\n        ctx.lineTo(x + style.width,   y + 13 * dy);\r\n    }\r\n\r\n    function _iconMarkClear(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x + 4 * dx,        y + 15 * dy);\r\n        ctx.lineTo(x + 9 * dx,        y + 13 * dy);\r\n        ctx.lineTo(x + 14 * dx,       y + 8 * dy);\r\n        ctx.lineTo(x + 11 * dx,       y + 5 * dy);\r\n        ctx.lineTo(x + 6 * dx,        y + 10 * dy);\r\n        ctx.lineTo(x + 4 * dx,        y + 15 * dy);\r\n\r\n        ctx.moveTo(x + 5 * dx,        y);\r\n        ctx.lineTo(x + 11 * dx,       y);\r\n        ctx.moveTo(x + 5 * dx,        y + dy);\r\n        ctx.lineTo(x + 11 * dx,       y + dy);\r\n        ctx.moveTo(x,                 y + 2 * dy);\r\n        ctx.lineTo(x + style.width,   y + 2 * dy);\r\n\r\n        ctx.moveTo(x,                 y + 5 * dy);\r\n        ctx.lineTo(x + 3 * dx,        y + style.height);\r\n        ctx.lineTo(x + 13 * dx,       y + style.height);\r\n        ctx.lineTo(x + style.width,   y + 5 * dy);\r\n    }\r\n\r\n    function _iconDataZoom(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x,               y + 3 * dy);\r\n        ctx.lineTo(x + 6 * dx,      y + 3 * dy);\r\n        \r\n        ctx.moveTo(x + 3 * dx,      y);\r\n        ctx.lineTo(x + 3 * dx,      y + 6 * dy);\r\n\r\n        ctx.moveTo(x + 3 * dx,      y + 8 * dy);\r\n        ctx.lineTo(x + 3 * dx,      y + style.height);\r\n        ctx.lineTo(x + style.width, y + style.height);\r\n        ctx.lineTo(x + style.width, y + 3 * dy);\r\n        ctx.lineTo(x + 8 * dx,      y + 3 * dy);\r\n    }\r\n    \r\n    function _iconDataZoomReset(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x + 6 * dx,      y);\r\n        ctx.lineTo(x + 2 * dx,      y + 3 * dy);\r\n        ctx.lineTo(x + 6 * dx,      y + 6 * dy);\r\n        \r\n        ctx.moveTo(x + 2 * dx,      y + 3 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 3 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 11 * dy);\r\n        \r\n        ctx.moveTo(x + 2 * dx,      y + 5 * dy);\r\n        ctx.lineTo(x + 2 * dx,      y + 13 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 13 * dy);\r\n        \r\n        ctx.moveTo(x + 10 * dx,     y + 10 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 13 * dy);\r\n        ctx.lineTo(x + 10 * dx,     y + style.height);\r\n    }\r\n    \r\n    function _iconRestore(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n        var r = style.width / 2;\r\n        \r\n        ctx.lineWidth = 1.5;\r\n\r\n        ctx.arc(x + r, y + r, r - dx, 0, Math.PI * 2 / 3);\r\n        ctx.moveTo(x + 3 * dx,        y + style.height);\r\n        ctx.lineTo(x + 0 * dx,        y + 12 * dy);\r\n        ctx.lineTo(x + 5 * dx,        y + 11 * dy);\r\n\r\n        ctx.moveTo(x, y + 8 * dy);\r\n        ctx.arc(x + r, y + r, r - dx, Math.PI, Math.PI * 5 / 3);\r\n        ctx.moveTo(x + 13 * dx,       y);\r\n        ctx.lineTo(x + style.width,   y + 4 * dy);\r\n        ctx.lineTo(x + 11 * dx,       y + 5 * dy);\r\n    }\r\n\r\n    function _iconLineChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x, y + style.height);\r\n        ctx.lineTo(x + style.width, y + style.height);\r\n\r\n        ctx.moveTo(x + 2 * dx,    y + 14 * dy);\r\n        ctx.lineTo(x + 7 * dx,    y + 6 * dy);\r\n        ctx.lineTo(x + 11 * dx,   y + 11 * dy);\r\n        ctx.lineTo(x + 15 * dx,   y + 2 * dy);\r\n    }\r\n\r\n    function _iconBarChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x, y + style.height);\r\n        ctx.lineTo(x + style.width, y + style.height);\r\n\r\n        ctx.moveTo(x + 3 * dx,        y + 14 * dy);\r\n        ctx.lineTo(x + 3 * dx,        y + 6 * dy);\r\n        ctx.lineTo(x + 4 * dx,        y + 6 * dy);\r\n        ctx.lineTo(x + 4 * dx,        y + 14 * dy);\r\n        ctx.moveTo(x + 7 * dx,        y + 14 * dy);\r\n        ctx.lineTo(x + 7 * dx,        y + 2 * dy);\r\n        ctx.lineTo(x + 8 * dx,        y + 2 * dy);\r\n        ctx.lineTo(x + 8 * dx,        y + 14 * dy);\r\n        ctx.moveTo(x + 11 * dx,       y + 14 * dy);\r\n        ctx.lineTo(x + 11 * dx,       y + 9 * dy);\r\n        ctx.lineTo(x + 12 * dx,       y + 9 * dy);\r\n        ctx.lineTo(x + 12 * dx,       y + 14 * dy);\r\n    }\r\n    \r\n    function _iconPieChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width - 2;\r\n        var height = style.height - 2;\r\n        var r = Math.min(width, height) / 2;\r\n        y += 2;\r\n        ctx.moveTo(x + r + 3, y + r - 3);\r\n        ctx.arc(x + r + 3, y + r - 3, r - 1, 0, -Math.PI / 2, true);\r\n        ctx.lineTo(x + r + 3, y + r - 3);\r\n      \r\n        ctx.moveTo(x + r, y);\r\n        ctx.lineTo(x + r, y + r);\r\n        ctx.arc(x + r, y + r, r, -Math.PI / 2, Math.PI * 2, true);\r\n        ctx.lineTo(x + r, y + r);\r\n        ctx.lineWidth = 1.5;\r\n    }\r\n    \r\n    function _iconFunnelChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n        y -= dy;\r\n        ctx.moveTo(x + 1 * dx,      y + 2 * dy);\r\n        ctx.lineTo(x + 15 * dx,     y + 2 * dy);\r\n        ctx.lineTo(x + 14 * dx,     y + 3 * dy);\r\n        ctx.lineTo(x + 2 * dx,      y + 3 * dy);\r\n        \r\n        ctx.moveTo(x + 3 * dx,      y + 6 * dy);\r\n        ctx.lineTo(x + 13 * dx,     y + 6 * dy);\r\n        ctx.lineTo(x + 12 * dx,     y + 7 * dy);\r\n        ctx.lineTo(x + 4 * dx,      y + 7 * dy);\r\n        \r\n        ctx.moveTo(x + 5 * dx,      y + 10 * dy);\r\n        ctx.lineTo(x + 11 * dx,      y + 10 * dy);\r\n        ctx.lineTo(x + 10 * dx,      y + 11 * dy);\r\n        ctx.lineTo(x + 6 * dx,      y + 11 * dy);\r\n        \r\n        ctx.moveTo(x + 7 * dx,      y + 14 * dy);\r\n        ctx.lineTo(x + 9 * dx,      y + 14 * dy);\r\n        ctx.lineTo(x + 8 * dx,      y + 15 * dy);\r\n        ctx.lineTo(x + 7 * dx,      y + 15 * dy);\r\n    }\r\n    \r\n    function _iconForceChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        var dx = width / 16;\r\n        var dy = height / 16;\r\n        var r = Math.min(dx, dy) * 2;\r\n\r\n        ctx.moveTo(x + dx + r, y + dy + r);\r\n        ctx.arc(x + dx, y + dy, r, Math.PI / 4, Math.PI * 3);\r\n        \r\n        ctx.lineTo(x + 7 * dx - r, y + 6 * dy - r);\r\n        ctx.arc(x + 7 * dx, y + 6 * dy, r, Math.PI / 4 * 5, Math.PI * 4);\r\n        ctx.arc(x + 7 * dx, y + 6 * dy, r / 2, Math.PI / 4 * 5, Math.PI * 4);\r\n        \r\n        ctx.moveTo(x + 7 * dx - r / 2, y + 6 * dy + r);\r\n        ctx.lineTo(x + dx + r, y + 14 * dy - r);\r\n        ctx.arc(x + dx, y + 14 * dy, r, -Math.PI / 4, Math.PI * 2);\r\n        \r\n        ctx.moveTo(x + 7 * dx + r / 2, y + 6 * dy);\r\n        ctx.lineTo(x + 14 * dx - r, y + 10 * dy - r / 2);\r\n        ctx.moveTo(x + 16 * dx, y + 10 * dy);\r\n        ctx.arc(x + 14 * dx, y + 10 * dy, r, 0, Math.PI * 3);\r\n        ctx.lineWidth = 1.5;\r\n    }\r\n    \r\n    function _iconChordChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        var r = Math.min(width, height) / 2;\r\n\r\n        ctx.moveTo(x + width, y + height / 2);\r\n        ctx.arc(x + r, y + r, r, 0, Math.PI * 2);\r\n        \r\n        ctx.arc(x + r, y, r, Math.PI / 4, Math.PI / 5 * 4);\r\n        ctx.arc(x, y + r, r, -Math.PI / 3, Math.PI / 3);\r\n        ctx.arc(x + width, y + height, r, Math.PI, Math.PI / 2 * 3);\r\n        ctx.lineWidth = 1.5;\r\n    }\r\n\r\n    function _iconStackChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        var dy = Math.round(height / 3);\r\n        var delta = Math.round((dy - 2) / 2);\r\n        var len = 3;\r\n        while (len--) {\r\n            ctx.rect(x, y + dy * len + delta, width, 2);\r\n        }\r\n    }\r\n    \r\n    function _iconTiledChart(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        var dx = Math.round(width / 3);\r\n        var delta = Math.round((dx - 2) / 2);\r\n        var len = 3;\r\n        while (len--) {\r\n            ctx.rect(x + dx * len + delta, y, 2, height);\r\n        }\r\n    }\r\n    \r\n    function _iconDataView(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n\r\n        ctx.moveTo(x + dx, y);\r\n        ctx.lineTo(x + dx, y + style.height);\r\n        ctx.lineTo(x + 15 * dx, y + style.height);\r\n        ctx.lineTo(x + 15 * dx, y);\r\n        ctx.lineTo(x + dx, y);\r\n\r\n        ctx.moveTo(x + 3 * dx, y + 3 * dx);\r\n        ctx.lineTo(x + 13 * dx, y + 3 * dx);\r\n\r\n        ctx.moveTo(x + 3 * dx, y + 6 * dx);\r\n        ctx.lineTo(x + 13 * dx, y + 6 * dx);\r\n\r\n        ctx.moveTo(x + 3 * dx, y + 9 * dx);\r\n        ctx.lineTo(x + 13 * dx, y + 9 * dx);\r\n\r\n        ctx.moveTo(x + 3 * dx, y + 12 * dx);\r\n        ctx.lineTo(x + 9 * dx, y + 12 * dx);\r\n    }\r\n    \r\n    function _iconSave(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        var dy = style.height / 16;\r\n\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x, y + style.height);\r\n        ctx.lineTo(x + style.width, y + style.height);\r\n        ctx.lineTo(x + style.width, y);\r\n        ctx.lineTo(x, y);\r\n\r\n        ctx.moveTo(x + 4 * dx,    y);\r\n        ctx.lineTo(x + 4 * dx,    y + 8 * dy);\r\n        ctx.lineTo(x + 12 * dx,   y + 8 * dy);\r\n        ctx.lineTo(x + 12 * dx,   y);\r\n        \r\n        ctx.moveTo(x + 6 * dx,    y + 11 * dy);\r\n        ctx.lineTo(x + 6 * dx,    y + 13 * dy);\r\n        ctx.lineTo(x + 10 * dx,   y + 13 * dy);\r\n        ctx.lineTo(x + 10 * dx,   y + 11 * dy);\r\n        ctx.lineTo(x + 6 * dx,    y + 11 * dy);\r\n    }\r\n    \r\n    function _iconCross(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        ctx.moveTo(x, y + height / 2);\r\n        ctx.lineTo(x + width, y + height / 2);\r\n        \r\n        ctx.moveTo(x + width / 2, y);\r\n        ctx.lineTo(x + width / 2, y + height);\r\n    }\r\n    \r\n    function _iconCircle(ctx, style) {\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        var r = Math.min(width, height);\r\n        ctx.moveTo(\r\n            style.x + width + r, \r\n            style.y + height\r\n        );\r\n        ctx.arc(\r\n            style.x + width, \r\n            style.y + height, \r\n            r,\r\n            0, \r\n            Math.PI * 2\r\n        );\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconRectangle(ctx, style) {\r\n        ctx.rect(style.x, style.y, style.width, style.height);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconTriangle(ctx, style) {\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        var x = style.x + width;\r\n        var y = style.y + height;\r\n        var symbolSize = Math.min(width, height);\r\n        ctx.moveTo(x, y - symbolSize);\r\n        ctx.lineTo(x + symbolSize, y + symbolSize);\r\n        ctx.lineTo(x - symbolSize, y + symbolSize);\r\n        ctx.lineTo(x, y - symbolSize);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconDiamond(ctx, style) {\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        var x = style.x + width;\r\n        var y = style.y + height;\r\n        var symbolSize = Math.min(width, height);\r\n        ctx.moveTo(x, y - symbolSize);\r\n        ctx.lineTo(x + symbolSize, y);\r\n        ctx.lineTo(x, y + symbolSize);\r\n        ctx.lineTo(x - symbolSize, y);\r\n        ctx.lineTo(x, y - symbolSize);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconArrow(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var dx = style.width / 16;\r\n        ctx.moveTo(x + 8 * dx,  y);\r\n        ctx.lineTo(x + dx,      y + style.height);\r\n        ctx.lineTo(x + 8 * dx,  y + style.height / 4 * 3);\r\n        ctx.lineTo(x + 15 * dx, y + style.height);\r\n        ctx.lineTo(x + 8 * dx,  y);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconStar(ctx, style) {\r\n        var StarShape = require('zrenderjs/shape/Star');\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        StarShape.prototype.buildPath(ctx, {\r\n            x : style.x + width,\r\n            y : style.y + height,\r\n            r : Math.min(width, height),\r\n            n : style.n || 5\r\n        });\r\n    }\r\n    \r\n    function _iconHeart(ctx, style) {\r\n        var HeartShape = require('zrenderjs/shape/Heart');\r\n        HeartShape.prototype.buildPath(ctx, {\r\n            x : style.x + style.width / 2,\r\n            y : style.y + style.height * 0.2,\r\n            a : style.width / 2,\r\n            b : style.height * 0.8\r\n        });\r\n    }\r\n    \r\n    function _iconDroplet(ctx, style) {\r\n        var DropletShape = require('zrenderjs/shape/Droplet');\r\n        DropletShape.prototype.buildPath(ctx, {\r\n            x : style.x + style.width * 0.5,\r\n            y : style.y + style.height * 0.5,\r\n            a : style.width * 0.5,\r\n            b : style.height * 0.8\r\n        });\r\n    }\r\n    \r\n    function _iconPin(ctx, style) {\r\n        var x = style.x;\r\n        var y = style.y - style.height / 2 * 1.5;\r\n        var width = style.width / 2;\r\n        var height = style.height / 2;\r\n        var r = Math.min(width, height);\r\n        ctx.arc(\r\n            x + width, \r\n            y + height, \r\n            r,\r\n            Math.PI / 5 * 4, \r\n            Math.PI / 5\r\n        );\r\n        ctx.lineTo(x + width, y + height + r * 1.5);\r\n        ctx.closePath();\r\n    }\r\n    \r\n    function _iconImage(ctx, style, refreshNextFrame) {\r\n        var ImageShape = require('zrenderjs/shape/Image');\r\n        this._imageShape = this._imageShape || new ImageShape({\r\n            style: {}\r\n        });\r\n        for (var name in style) {\r\n            this._imageShape.style[name] = style[name];\r\n        }\r\n        this._imageShape.brush(ctx, false, refreshNextFrame);\r\n    }\r\n    \r\n    var Base = require('zrenderjs/shape/Base');\r\n    \r\n    function Icon(options) {\r\n        Base.call(this, options);\r\n    }\r\n\r\n    Icon.prototype =  {\r\n        type : 'icon',\r\n        iconLibrary : {\r\n            mark : _iconMark,\r\n            markUndo : _iconMarkUndo,\r\n            markClear : _iconMarkClear,\r\n            dataZoom : _iconDataZoom,\r\n            dataZoomReset : _iconDataZoomReset,\r\n            restore : _iconRestore,\r\n            lineChart : _iconLineChart,\r\n            barChart : _iconBarChart,\r\n            pieChart : _iconPieChart,\r\n            funnelChart : _iconFunnelChart,\r\n            forceChart : _iconForceChart,\r\n            chordChart : _iconChordChart,\r\n            stackChart : _iconStackChart,\r\n            tiledChart : _iconTiledChart,\r\n            dataView : _iconDataView,\r\n            saveAsImage : _iconSave,\r\n            \r\n            cross : _iconCross,\r\n            circle : _iconCircle,\r\n            rectangle : _iconRectangle,\r\n            triangle : _iconTriangle,\r\n            diamond : _iconDiamond,\r\n            arrow : _iconArrow,\r\n            star : _iconStar,\r\n            heart : _iconHeart,\r\n            droplet : _iconDroplet,\r\n            pin : _iconPin,\r\n            image : _iconImage\r\n        },\r\n        brush: function (ctx, isHighlight, refreshNextFrame) {\r\n            var style = isHighlight ? this.highlightStyle : this.style;\r\n            style = style || {};\r\n            var iconType = style.iconType || this.style.iconType;\r\n            if (iconType === 'image') {\r\n                var ImageShape = require('zrenderjs/shape/Image');\r\n                ImageShape.prototype.brush.call(this, ctx, isHighlight, refreshNextFrame);\r\n\r\n            } else {\r\n\r\n                var style = this.beforeBrush(ctx, isHighlight);\r\n\r\n                ctx.beginPath();\r\n                this.buildPath(ctx, style, refreshNextFrame);\r\n\r\n                switch (style.brushType) {\r\n                    /* jshint ignore:start */\r\n                    case 'both':\r\n                        ctx.fill();\r\n                    case 'stroke':\r\n                        style.lineWidth > 0 && ctx.stroke();\r\n                        break;\r\n                    /* jshint ignore:end */\r\n                    default:\r\n                        ctx.fill();\r\n                }\r\n                \r\n                this.drawText(ctx, style, this.style);\r\n\r\n                this.afterBrush(ctx);\r\n            }\r\n        },\r\n        /**\r\n         * 创建矩形路径\r\n         * @param {Context2D} ctx Canvas 2D上下文\r\n         * @param {Object} style 样式\r\n         */\r\n        buildPath : function (ctx, style, refreshNextFrame) {\r\n            if (this.iconLibrary[style.iconType]) {\r\n                this.iconLibrary[style.iconType].call(this, ctx, style, refreshNextFrame);\r\n            }\r\n            else {\r\n                ctx.moveTo(style.x, style.y);\r\n                ctx.lineTo(style.x + style.width, style.y);\r\n                ctx.lineTo(style.x + style.width, style.y + style.height);\r\n                ctx.lineTo(style.x, style.y + style.height);\r\n                ctx.lineTo(style.x, style.y);\r\n                ctx.closePath();\r\n            }\r\n\r\n            return;\r\n        },\r\n\r\n        /**\r\n         * 返回矩形区域，用于局部刷新和文字定位\r\n         * @param {Object} style\r\n         */\r\n        getRect : function (style) {\r\n            if (style.__rect) {\r\n                return style.__rect;\r\n            }\r\n            \r\n            // pin比较特殊，让尖端在目标x,y上\r\n            style.__rect = {\r\n                x : Math.round(style.x),\r\n                y : Math.round(style.y - (style.iconType == 'pin' \r\n                                         ? (style.height / 2 * 1.5) : 0)\r\n                               ),\r\n                width : style.width,\r\n                height : style.height * (\r\n                    style.iconType === 'pin' ? 1.25 : 1\r\n                )\r\n            };\r\n            \r\n            return style.__rect;\r\n        },\r\n\r\n        isCover : function (x, y) {\r\n            var originPos = this.transformCoordToLocal(x, y);\r\n            x = originPos[0];\r\n            y = originPos[1];\r\n\r\n            // 快速预判并保留判断矩形\r\n            var rect = this.style.__rect;\r\n            if (!rect) {\r\n                rect = this.style.__rect = this.getRect(this.style);\r\n            }\r\n            // 提高交互体验，太小的图形包围盒四向扩大4px\r\n            var delta = (rect.height < 8 || rect.width < 8 ) ? 4 : 0;\r\n            return x >= rect.x - delta\r\n                && x <= (rect.x + rect.width + delta)\r\n                && y >= rect.y - delta\r\n                && y <= (rect.y + rect.height + delta);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(Icon, Base);\r\n    \r\n    return Icon;\r\n});"
    },
    {
      "id": 21,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
      "index": 21,
      "index2": 15,
      "size": 5537,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 20,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Star",
          "loc": "444:24-55"
        }
      ],
      "source": "/**\r\n * n角星（n>3）\r\n * @module zrender/shape/Star\r\n * @author sushuang (宿爽, sushuang0322@gmail.com)\r\n * @example\r\n *     var Star = require('zrender/shape/Star');\r\n *     var shape = new Star({\r\n *         style: {\r\n *             x: 200,\r\n *             y: 100,\r\n *             r: 150,\r\n *             n: 5,\r\n *             text: '五角星'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IStarStyle\r\n * @property {number} x n角星外接圆心x坐标\r\n * @property {number} y n角星外接圆心y坐标\r\n * @property {number} r n角星外接圆半径\r\n * @property {number} [r0] n角星内部顶点（凹点）的外接圆半径。\r\n *                         如果不指定此参数，则自动计算：取相隔外部顶点连线的交点作内部顶点。\r\n * @property {number} n 指明几角星\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\n\r\ndefine(\r\n    function (require) {\r\n\r\n        var math = require('../tool/math');\r\n        var sin = math.sin;\r\n        var cos = math.cos;\r\n        var PI = Math.PI;\r\n\r\n        var Base = require('./Base');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Star\r\n         * @param {Object} options\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         */\r\n        var Star = function(options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * n角星绘制样式\r\n             * @name module:zrender/shape/Star#style\r\n             * @type {module:zrender/shape/Star~IStarStyle}\r\n             */\r\n            /**\r\n             * n角星高亮绘制样式\r\n             * @name module:zrender/shape/Star#highlightStyle\r\n             * @type {module:zrender/shape/Star~IStarStyle}\r\n             */\r\n        };\r\n\r\n        Star.prototype = {\r\n            type: 'star',\r\n\r\n            /**\r\n             * 创建n角星（n>3）路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Star~IStarStyle} style\r\n             */\r\n            buildPath : function(ctx, style) {\r\n                var n = style.n;\r\n                if (!n || n < 2) {\r\n                    return;\r\n                }\r\n\r\n                var x = style.x;\r\n                var y = style.y;\r\n                var r = style.r;\r\n                var r0 = style.r0;\r\n\r\n                // 如果未指定内部顶点外接圆半径，则自动计算\r\n                if (r0 == null) {\r\n                    r0 = n > 4\r\n                        // 相隔的外部顶点的连线的交点，\r\n                        // 被取为内部交点，以此计算r0\r\n                        ? r * cos(2 * PI / n) / cos(PI / n)\r\n                        // 二三四角星的特殊处理\r\n                        : r / 3;\r\n                }\r\n\r\n                var dStep = PI / n;\r\n                var deg = -PI / 2;\r\n                var xStart = x + r * cos(deg);\r\n                var yStart = y + r * sin(deg);\r\n                deg += dStep;\r\n\r\n                // 记录边界点，用于判断inside\r\n                var pointList = style.pointList = [];\r\n                pointList.push([ xStart, yStart ]);\r\n                for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {\r\n                    ri = i % 2 === 0 ? r0 : r;\r\n                    pointList.push([ x + ri * cos(deg), y + ri * sin(deg) ]);\r\n                    deg += dStep;\r\n                }\r\n                pointList.push([ xStart, yStart ]);\r\n\r\n                // 绘制\r\n                ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                for (var i = 0; i < pointList.length; i++) {\r\n                    ctx.lineTo(pointList[i][0], pointList[i][1]);\r\n                }\r\n                \r\n                ctx.closePath();\r\n\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 返回n角星包围盒矩形\r\n             * @param {module:zrender/shape/Star~IStarStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function(style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var lineWidth;\r\n                if (style.brushType == 'stroke' || style.brushType == 'fill') {\r\n                    lineWidth = style.lineWidth || 1;\r\n                }\r\n                else {\r\n                    lineWidth = 0;\r\n                }\r\n                style.__rect = {\r\n                    x : Math.round(style.x - style.r - lineWidth / 2),\r\n                    y : Math.round(style.y - style.r - lineWidth / 2),\r\n                    width : style.r * 2 + lineWidth,\r\n                    height : style.r * 2 + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Star, Base);\r\n        return Star;\r\n    }\r\n);\r\n"
    },
    {
      "id": 22,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\math.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/math.js",
      "index": 22,
      "index2": 14,
      "size": 1301,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 21,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Star.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Star.js",
          "type": "cjs require",
          "userRequest": "../tool/math",
          "loc": "50:19-42"
        }
      ],
      "source": "/**\r\n * zrender: 数学辅助类\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * sin：正弦函数\r\n * cos：余弦函数\r\n * degreeToRadian：角度转弧度\r\n * radianToDegree：弧度转角度\r\n */\r\ndefine(\r\n    function () {\r\n\r\n        var _radians = Math.PI / 180;\r\n\r\n        /**\r\n         * @param {number} angle 弧度（角度）参数\r\n         * @param {boolean} isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度\r\n         */\r\n        function sin(angle, isDegrees) {\r\n            return Math.sin(isDegrees ? angle * _radians : angle);\r\n        }\r\n\r\n        /**\r\n         * @param {number} angle 弧度（角度）参数\r\n         * @param {boolean} isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度\r\n         */\r\n        function cos(angle, isDegrees) {\r\n            return Math.cos(isDegrees ? angle * _radians : angle);\r\n        }\r\n\r\n        /**\r\n         * 角度转弧度\r\n         * @param {Object} angle\r\n         */\r\n        function degreeToRadian(angle) {\r\n            return angle * _radians;\r\n        }\r\n\r\n        /**\r\n         * 弧度转角度\r\n         * @param {Object} angle\r\n         */\r\n        function radianToDegree(angle) {\r\n            return angle / _radians;\r\n        }\r\n\r\n        return {\r\n            sin : sin,\r\n            cos : cos,\r\n            degreeToRadian : degreeToRadian,\r\n            radianToDegree : radianToDegree\r\n        };\r\n    }\r\n);\r\n"
    },
    {
      "id": 23,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
      "index": 23,
      "index2": 17,
      "size": 4841,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 20,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Heart",
          "loc": "456:25-57"
        }
      ],
      "source": "/**\r\n * @module zrender/shape/Heart\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *   var Heart = require('zrender/shape/Heart');\r\n *   var shape = new Heart({\r\n *       style: {\r\n *           x: 100,\r\n *           y: 100,\r\n *           a: 40,\r\n *           b: 40,\r\n *           brushType: 'both',\r\n *           color: 'blue',\r\n *           strokeColor: 'red',\r\n *           lineWidth: 3,\r\n *           text: 'Heart'\r\n *       }    \r\n *   });\r\n *   zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IHeartStyle\r\n * @property {number} x 心形内部尖端横坐标\r\n * @property {number} y 心形内部尖端纵坐标\r\n * @property {number} a 心形横宽（中轴线到水平边缘最宽处距离）\r\n * @property {number} b 心形纵高（内尖到外尖距离）\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        'use strict';\r\n        \r\n        var Base = require('./Base');\r\n        var PathProxy = require('./util/PathProxy');\r\n        var area = require('../tool/area');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/Heart\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Heart = function (options) {\r\n            Base.call(this, options);\r\n\r\n            this._pathProxy = new PathProxy();\r\n            /**\r\n             * 心形绘制样式\r\n             * @name module:zrender/shape/Heart#style\r\n             * @type {module:zrender/shape/Heart~IHeartStyle}\r\n             */\r\n            /**\r\n             * 心形高亮绘制样式\r\n             * @name module:zrender/shape/Heart#highlightStyle\r\n             * @type {module:zrender/shape/Heart~IHeartStyle}\r\n             */\r\n        };\r\n\r\n        Heart.prototype = {\r\n            type: 'heart',\r\n\r\n            /**\r\n             * 创建扇形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Heart~IHeartStyle} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                var path = this._pathProxy || new PathProxy();\r\n                path.begin(ctx);\r\n\r\n                path.moveTo(style.x, style.y);\r\n                path.bezierCurveTo(\r\n                    style.x + style.a / 2,\r\n                    style.y - style.b * 2 / 3,\r\n                    style.x + style.a * 2,\r\n                    style.y + style.b / 3,\r\n                    style.x,\r\n                    style.y + style.b\r\n                );\r\n                path.bezierCurveTo(\r\n                    style.x - style.a *  2,\r\n                    style.y + style.b / 3,\r\n                    style.x - style.a / 2,\r\n                    style.y - style.b * 2 / 3,\r\n                    style.x,\r\n                    style.y\r\n                );\r\n                path.closePath();\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 计算返回心形的包围盒矩形\r\n             * @param {module:zrender/shape/Heart~IHeartStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                if (!this._pathProxy.isEmpty()) {\r\n                    this.buildPath(null, style);\r\n                }\r\n                return this._pathProxy.fastBoundingRect();\r\n            },\r\n\r\n            isCover: function (x, y) {\r\n                var originPos = this.transformCoordToLocal(x, y);\r\n                x = originPos[0];\r\n                y = originPos[1];\r\n                \r\n                if (this.isCoverRect(x, y)) {\r\n                    return area.isInsidePath(\r\n                        this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y\r\n                    );\r\n                }\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Heart, Base);\r\n        return Heart;\r\n    }\r\n);\r\n"
    },
    {
      "id": 24,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\PathProxy.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/PathProxy.js",
      "index": 24,
      "index2": 16,
      "size": 7660,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 23,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Heart.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Heart.js",
          "type": "cjs require",
          "userRequest": "./util/PathProxy",
          "loc": "52:24-51"
        },
        {
          "moduleId": 25,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
          "type": "cjs require",
          "userRequest": "./util/PathProxy",
          "loc": "53:24-51"
        }
      ],
      "source": "/**\r\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\r\n * 可以用于 isInsidePath 判断以及获取boundingRect\r\n * \r\n * @module zrender/shape/tool/PathProxy\r\n * @author pissang (http://www.github.com/pissang)\r\n * \r\n * @example\r\n *     var SomeShape = function() {\r\n *         this._pathProxy = new PathProxy();\r\n *         ...\r\n *     }\r\n *     SomeShape.prototype.buildPath = function(ctx, style) {\r\n *         this._pathProxy.begin(ctx);\r\n *             .moveTo(style.x, style.y);\r\n *             .lineTo(style.x1, style.y1);\r\n *         ...\r\n *             .closePath();\r\n *     },\r\n *     SomeShape.prototype.getRect = function(style) {\r\n *         if (!style._rect) {\r\n *             // 这里必须要在 buildPath 之后才能调用\r\n *             style._rect = this._pathProxy.fastBoundingRect();\r\n *         }\r\n *         return this.style._rect;\r\n *     },\r\n *     SomeShape.prototype.isCover = function(x, y) {\r\n *         var rect = this.getRect(this.style);\r\n *         if (x >= rect.x\r\n *             && x <= (rect.x + rect.width)\r\n *             && y >= rect.y\r\n *             && y <= (rect.y + rect.height)\r\n *         ) {\r\n *             return area.isInsidePath(\r\n *                 this._pathProxy.pathCommands, 0, 'fill', x, y\r\n *             );\r\n *         }\r\n *     }\r\n */\r\ndefine(function (require) {\r\n    \r\n    var vector = require('../../tool/vector');\r\n    // var computeBoundingBox = require('../../tool/computeBoundingBox');\r\n\r\n    var PathSegment = function(command, points) {\r\n        this.command = command;\r\n        this.points = points || null;\r\n    };\r\n\r\n    /**\r\n     * @alias module:zrender/shape/tool/PathProxy\r\n     * @constructor\r\n     */\r\n    var PathProxy = function () {\r\n\r\n        /**\r\n         * Path描述的数组，用于`isInsidePath`的判断\r\n         * @type {Array.<Object>}\r\n         */\r\n        this.pathCommands = [];\r\n\r\n        this._ctx = null;\r\n\r\n        this._min = [];\r\n        this._max = [];\r\n    };\r\n\r\n    /**\r\n     * 快速计算Path包围盒（并不是最小包围盒）\r\n     * @return {Object}\r\n     */\r\n    PathProxy.prototype.fastBoundingRect = function () {\r\n        var min = this._min;\r\n        var max = this._max;\r\n        min[0] = min[1] = Infinity;\r\n        max[0] = max[1] = -Infinity;\r\n        for (var i = 0; i < this.pathCommands.length; i++) {\r\n            var seg = this.pathCommands[i];\r\n            var p = seg.points;\r\n            switch (seg.command) {\r\n                case 'M':\r\n                    vector.min(min, min, p);\r\n                    vector.max(max, max, p);\r\n                    break;\r\n                case 'L':\r\n                    vector.min(min, min, p);\r\n                    vector.max(max, max, p);\r\n                    break;\r\n                case 'C':\r\n                    for (var j = 0; j < 6; j += 2) {\r\n                        min[0] = Math.min(min[0], min[0], p[j]);\r\n                        min[1] = Math.min(min[1], min[1], p[j + 1]);\r\n                        max[0] = Math.max(max[0], max[0], p[j]);\r\n                        max[1] = Math.max(max[1], max[1], p[j + 1]);\r\n                    }\r\n                    break;\r\n                case 'Q':\r\n                    for (var j = 0; j < 4; j += 2) {\r\n                        min[0] = Math.min(min[0], min[0], p[j]);\r\n                        min[1] = Math.min(min[1], min[1], p[j + 1]);\r\n                        max[0] = Math.max(max[0], max[0], p[j]);\r\n                        max[1] = Math.max(max[1], max[1], p[j + 1]);\r\n                    }\r\n                    break;\r\n                case 'A':\r\n                    var cx = p[0];\r\n                    var cy = p[1];\r\n                    var rx = p[2];\r\n                    var ry = p[3];\r\n                    min[0] = Math.min(min[0], min[0], cx - rx);\r\n                    min[1] = Math.min(min[1], min[1], cy - ry);\r\n                    max[0] = Math.max(max[0], max[0], cx + rx);\r\n                    max[1] = Math.max(max[1], max[1], cy + ry);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return {\r\n            x: min[0],\r\n            y: min[1],\r\n            width: max[0] - min[0],\r\n            height: max[1] - min[1]\r\n        };\r\n    };\r\n\r\n    /**\r\n     * @param  {CanvasRenderingContext2D} ctx\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.begin = function (ctx) {\r\n        this._ctx = ctx || null;\r\n        // 清空pathCommands\r\n        this.pathCommands.length = 0;\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} x\r\n     * @param  {number} y\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.moveTo = function (x, y) {\r\n        this.pathCommands.push(new PathSegment('M', [x, y]));\r\n        if (this._ctx) {\r\n            this._ctx.moveTo(x, y);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} x\r\n     * @param  {number} y\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.lineTo = function (x, y) {\r\n        this.pathCommands.push(new PathSegment('L', [x, y]));\r\n        if (this._ctx) {\r\n            this._ctx.lineTo(x, y);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} x1\r\n     * @param  {number} y1\r\n     * @param  {number} x2\r\n     * @param  {number} y2\r\n     * @param  {number} x3\r\n     * @param  {number} y3\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {\r\n        this.pathCommands.push(new PathSegment('C', [x1, y1, x2, y2, x3, y3]));\r\n        if (this._ctx) {\r\n            this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} x1\r\n     * @param  {number} y1\r\n     * @param  {number} x2\r\n     * @param  {number} y2\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {\r\n        this.pathCommands.push(new PathSegment('Q', [x1, y1, x2, y2]));\r\n        if (this._ctx) {\r\n            this._ctx.quadraticCurveTo(x1, y1, x2, y2);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param  {number} cx\r\n     * @param  {number} cy\r\n     * @param  {number} r\r\n     * @param  {number} startAngle\r\n     * @param  {number} endAngle\r\n     * @param  {boolean} anticlockwise\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {\r\n        this.pathCommands.push(new PathSegment(\r\n            'A', [cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1]\r\n        ));\r\n        if (this._ctx) {\r\n            this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // TODO\r\n    PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {\r\n        if (this._ctx) {\r\n            this._ctx.arcTo(x1, y1, x2, y2, radius);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // TODO\r\n    PathProxy.prototype.rect = function (x, y, w, h) {\r\n        if (this._ctx) {\r\n            this._ctx.rect(x, y, w, h);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @return {module:zrender/shape/util/PathProxy}\r\n     */\r\n    PathProxy.prototype.closePath = function () {\r\n        this.pathCommands.push(new PathSegment('z'));\r\n        if (this._ctx) {\r\n            this._ctx.closePath();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * 是否没有Path命令\r\n     * @return {boolean}\r\n     */\r\n    PathProxy.prototype.isEmpty = function() {\r\n        return this.pathCommands.length === 0;\r\n    };\r\n\r\n    PathProxy.PathSegment = PathSegment;\r\n\r\n    return PathProxy;\r\n});"
    },
    {
      "id": 25,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Droplet.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Droplet.js",
      "index": 25,
      "index2": 18,
      "size": 4847,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 20,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Icon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Icon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Droplet",
          "loc": "466:27-61"
        }
      ],
      "source": "/**\r\n * 水滴形状\r\n * @module zrender/shape/Droplet\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *   var Droplet = require('zrender/shape/Droplet');\r\n *   var shape = new Droplet({\r\n *       style: {\r\n *           x: 100,\r\n *           y: 100,\r\n *           a: 40,\r\n *           b: 40,\r\n *           brushType: 'both',\r\n *           color: 'blue',\r\n *           strokeColor: 'red',\r\n *           lineWidth: 3,\r\n *           text: 'Droplet'\r\n *       }    \r\n *   });\r\n *   zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IDropletStyle\r\n * @property {number} x 水滴中心x坐标\r\n * @property {number} y 水滴中心y坐标\r\n * @property {number} a 水滴横宽（中心到水平边缘最宽处距离）\r\n * @property {number} b 水滴纵高（中心到尖端距离）\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        'use strict';\r\n\r\n        var Base = require('./Base');\r\n        var PathProxy = require('./util/PathProxy');\r\n        var area = require('../tool/area');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Droplet\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Droplet = function(options) {\r\n            Base.call(this, options);\r\n            this._pathProxy = new PathProxy();\r\n            /**\r\n             * 水滴绘制样式\r\n             * @name module:zrender/shape/Droplet#style\r\n             * @type {module:zrender/shape/Droplet~IDropletStyle}\r\n             */\r\n            /**\r\n             * 水滴高亮绘制样式\r\n             * @name module:zrender/shape/Droplet#highlightStyle\r\n             * @type {module:zrender/shape/Droplet~IDropletStyle}\r\n             */\r\n        };\r\n\r\n        Droplet.prototype = {\r\n            type: 'droplet',\r\n\r\n            /**\r\n             * 创建水滴路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Droplet~IDropletStyle} style\r\n             */\r\n            buildPath : function(ctx, style) {\r\n                var path = this._pathProxy || new PathProxy();\r\n                path.begin(ctx);\r\n\r\n                path.moveTo(style.x, style.y + style.a);\r\n                path.bezierCurveTo(\r\n                    style.x + style.a,\r\n                    style.y + style.a,\r\n                    style.x + style.a * 3 / 2,\r\n                    style.y - style.a / 3,\r\n                    style.x,\r\n                    style.y - style.b\r\n                );\r\n                path.bezierCurveTo(\r\n                    style.x - style.a * 3 / 2,\r\n                    style.y - style.a / 3,\r\n                    style.x - style.a,\r\n                    style.y + style.a,\r\n                    style.x,\r\n                    style.y + style.a\r\n                );\r\n                path.closePath();\r\n            },\r\n\r\n            /**\r\n             * 计算返回水滴的包围盒矩形\r\n             * @param {module:zrender/shape/Droplet~IDropletStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                if (!this._pathProxy.isEmpty()) {\r\n                    this.buildPath(null, style);\r\n                }\r\n                return this._pathProxy.fastBoundingRect();\r\n            },\r\n\r\n            isCover: function (x, y) {\r\n                var originPos = this.transformCoordToLocal(x, y);\r\n                x = originPos[0];\r\n                y = originPos[1];\r\n                \r\n                if (this.isCoverRect(x, y)) {\r\n                    return area.isInsidePath(\r\n                        this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y\r\n                    );\r\n                }\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Droplet, Base);\r\n        return Droplet;\r\n    }\r\n);\r\n"
    },
    {
      "id": 26,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
      "index": 26,
      "index2": 23,
      "size": 7817,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../util/shape/MarkLine",
          "loc": "12:24-57"
        }
      ],
      "source": "/**\r\n * zrender\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         Yi Shen(https://github.com/pissang)\r\n *\r\n * shape类：标线\r\n */\r\n\r\n/**\r\n * @typedef {Object} IMarkLineStyle\r\n * @property {number} xStart 起点x坐标\r\n * @property {number} yStart 起点y坐标\r\n * @property {number} xEnd 终止点x坐标\r\n * @property {number} yEnd 终止点y坐标\r\n * @property {number} cpX1 控制点x坐标，可以使用updatePoints自动根据curveness计算\r\n * @property {number} cpY1 控制点y坐标，可以使用updatePoints自动根据curveness计算\r\n * @property {number} curveness 曲度\r\n * @property {Array.<string>} symbol\r\n * @property {Array.<number>} symbolRotate\r\n */\r\ndefine(function (require) {\r\n    var Base = require('zrenderjs/shape/Base');\r\n    var IconShape = require('./Icon');\r\n    var LineShape = require('zrenderjs/shape/Line');\r\n    var lineInstance = new LineShape({});\r\n    var CurveShape = require('zrenderjs/shape/BezierCurve');\r\n    var curveInstance = new CurveShape({});\r\n\r\n    var area = require('zrenderjs/tool/area');\r\n    var dashedLineTo = require('zrenderjs/shape/util/dashedLineTo');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var curveTool = require('zrenderjs/tool/curve');\r\n\r\n    function MarkLine(options) {\r\n        Base.call(this, options);\r\n\r\n        if (this.style.curveness > 0) {\r\n            this.updatePoints(this.style);\r\n        }\r\n        if (this.highlightStyle.curveness > 0) {\r\n            this.updatePoints(this.highlightStyle);\r\n        }\r\n    }\r\n\r\n    MarkLine.prototype =  {\r\n        type : 'mark-line',\r\n        /**\r\n         * 画刷\r\n         * @param ctx 画布句柄\r\n         * @param isHighlight   是否为高亮状态\r\n         * @param updateCallback 让painter更新视图，base.brush没用，需要的话重载brush\r\n         */\r\n        brush : function (ctx, isHighlight) {\r\n            var style = this.style;\r\n\r\n            if (isHighlight) {\r\n                // 根据style扩展默认高亮样式\r\n                style = this.getHighlightStyle(\r\n                    style,\r\n                    this.highlightStyle || {}\r\n                );\r\n            }\r\n\r\n            ctx.save();\r\n            this.setContext(ctx, style);\r\n\r\n            // 设置transform\r\n            this.setTransform(ctx);\r\n\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            this.buildPath(ctx, style);\r\n            ctx.stroke();\r\n            ctx.restore();\r\n\r\n            this.brushSymbol(ctx, style, 0);\r\n            this.brushSymbol(ctx, style, 1);\r\n\r\n            this.drawText(ctx, style, this.style);\r\n\r\n            ctx.restore();\r\n        },\r\n\r\n        /**\r\n         * 创建线条路径\r\n         * @param {Context2D} ctx Canvas 2D上下文\r\n         * @param {Object} style 样式\r\n         */\r\n        buildPath : function (ctx, style) {\r\n            var lineType = style.lineType || 'solid';\r\n\r\n            ctx.moveTo(style.xStart, style.yStart);\r\n            if (style.curveness > 0) {\r\n                // FIXME Bezier 在少部分浏览器上暂时不支持虚线\r\n                var lineDash = null;\r\n                switch (lineType) {\r\n                    case 'dashed':\r\n                        lineDash = [5, 5];\r\n                        break;\r\n                    case'dotted':\r\n                        lineDash = [1, 1];\r\n                        break;\r\n                }\r\n                if (lineDash && ctx.setLineDash) {\r\n                    ctx.setLineDash(lineDash);\r\n                }\r\n                \r\n                ctx.quadraticCurveTo(\r\n                    style.cpX1, style.cpY1, style.xEnd, style.yEnd\r\n                );\r\n            }\r\n            else {\r\n                if (lineType == 'solid') {\r\n                    ctx.lineTo(style.xEnd, style.yEnd);\r\n                }\r\n                else {\r\n                    var dashLength = (style.lineWidth || 1) \r\n                        * (style.lineType == 'dashed' ? 5 : 1);\r\n                    dashedLineTo(\r\n                        ctx, style.xStart, style.yStart,\r\n                        style.xEnd, style.yEnd, dashLength\r\n                    );\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Update cpX1 and cpY1 according to curveniss\r\n         * @param  {Object} style\r\n         */\r\n        updatePoints: function (style) {\r\n            var curveness = style.curveness || 0;\r\n            var inv = 1;\r\n\r\n            var x0 = style.xStart;\r\n            var y0 = style.yStart;\r\n            var x2 = style.xEnd;\r\n            var y2 = style.yEnd;\r\n            var x1 = (x0 + x2) / 2 - inv * (y0 - y2) * curveness;\r\n            var y1 =(y0 + y2) / 2 - inv * (x2 - x0) * curveness;\r\n\r\n            style.cpX1 = x1;\r\n            style.cpY1 = y1;\r\n        },\r\n\r\n        /**\r\n         * 标线始末标注\r\n         */\r\n        brushSymbol : function (ctx, style, idx) {\r\n            if (style.symbol[idx] == 'none') {\r\n                return;\r\n            }\r\n            ctx.save();\r\n            ctx.beginPath();\r\n\r\n            ctx.lineWidth = style.symbolBorder;\r\n            ctx.strokeStyle = style.symbolBorderColor;\r\n            // symbol\r\n            var symbol = style.symbol[idx].replace('empty', '')\r\n                                              .toLowerCase();\r\n            if (style.symbol[idx].match('empty')) {\r\n                ctx.fillStyle = '#fff'; //'rgba(0, 0, 0, 0)';\r\n            }\r\n\r\n            // symbolRotate\r\n            var x0 = style.xStart;\r\n            var y0 = style.yStart;\r\n            var x2 = style.xEnd;\r\n            var y2 = style.yEnd;\r\n            var x = idx === 0 ? x0 : x2;\r\n            var y = idx === 0 ? y0 : y2;\r\n            var curveness = style.curveness || 0;\r\n            var rotate = style.symbolRotate[idx] != null ? (style.symbolRotate[idx] - 0) : 0;\r\n            rotate = rotate / 180 * Math.PI;\r\n\r\n            if (symbol == 'arrow' && rotate === 0) {\r\n                if (curveness === 0) {\r\n                    var sign = idx === 0 ? -1 : 1; \r\n                    rotate = Math.PI / 2 + Math.atan2(\r\n                        sign * (y2 - y0), sign * (x2 - x0)\r\n                    );\r\n                }\r\n                else {\r\n                    var x1 = style.cpX1;\r\n                    var y1 = style.cpY1;\r\n\r\n                    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\r\n                    var dx = quadraticDerivativeAt(x0, x1, x2, idx);\r\n                    var dy = quadraticDerivativeAt(y0, y1, y2, idx);\r\n\r\n                    rotate = Math.PI / 2 + Math.atan2(dy, dx);\r\n                }\r\n            }\r\n            \r\n            ctx.translate(x, y);\r\n\r\n            if (rotate !== 0) {\r\n                ctx.rotate(rotate);\r\n            }\r\n\r\n            // symbolSize\r\n            var symbolSize = style.symbolSize[idx];\r\n            IconShape.prototype.buildPath(ctx, {\r\n                x: -symbolSize,\r\n                y: -symbolSize,\r\n                width: symbolSize * 2,\r\n                height: symbolSize * 2,\r\n                iconType: symbol\r\n            });\r\n\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        },\r\n\r\n        /**\r\n         * 返回矩形区域，用于局部刷新和文字定位\r\n         * @param {Object} style\r\n         */\r\n        getRect : function (style) {\r\n            style.curveness > 0 ? curveInstance.getRect(style)\r\n                : lineInstance.getRect(style);\r\n            return style.__rect;\r\n        },\r\n\r\n        isCover : function (x, y) {\r\n            var originPos = this.transformCoordToLocal(x, y);\r\n            x = originPos[0];\r\n            y = originPos[1];\r\n\r\n            // 快速预判并保留判断矩形\r\n            if (this.isCoverRect(x, y)) {\r\n                // 矩形内\r\n                return this.style.curveness > 0\r\n                       ? area.isInside(curveInstance, this.style, x, y)\r\n                       : area.isInside(lineInstance, this.style, x, y);\r\n            }\r\n\r\n            return false;\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(MarkLine, Base);\r\n\r\n    return MarkLine;\r\n});\r\n"
    },
    {
      "id": 27,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Line.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
      "index": 27,
      "index2": 21,
      "size": 4479,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 26,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Line",
          "loc": "25:20-51"
        },
        {
          "moduleId": 51,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Line",
          "loc": "19:20-51"
        },
        {
          "moduleId": 52,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Line",
          "loc": "13:20-51"
        },
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Line",
          "loc": "13:20-51"
        }
      ],
      "source": "/**\r\n * 直线\r\n * @module zrender/shape/Line\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *   var Line = require('zrender/shape/Line');\r\n *   var shape = new Line({\r\n *       style: {\r\n *           xStart: 0,\r\n *           yStart: 0,\r\n *           xEnd: 100,\r\n *           yEnd: 100,\r\n *           strokeColor: '#000',\r\n *           lineWidth: 10\r\n *       }\r\n *   });\r\n *   zr.addShape(line);\r\n */\r\n/**\r\n * @typedef {Object} ILineStyle\r\n * @property {number} xStart 起点x坐标\r\n * @property {number} yStart 起点y坐标\r\n * @property {number} xEnd 终止点x坐标\r\n * @property {number} yEnd 终止点y坐标\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        var Base = require('./Base');\r\n        var dashedLineTo = require('./util/dashedLineTo');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/Line\r\n         * @param {Object} options\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         */\r\n        var Line = function (options) {\r\n            this.brushTypeOnly = 'stroke';  // 线条只能描边，填充后果自负\r\n            this.textPosition = 'end';\r\n            Base.call(this, options);\r\n\r\n            /**\r\n             * 直线绘制样式\r\n             * @name module:zrender/shape/Line#style\r\n             * @type {module:zrender/shape/Line~ILineStyle}\r\n             */\r\n            /**\r\n             * 直线高亮绘制样式\r\n             * @name module:zrender/shape/Line#highlightStyle\r\n             * @type {module:zrender/shape/Line~ILineStyle}\r\n             */\r\n        };\r\n\r\n        Line.prototype =  {\r\n            type: 'line',\r\n\r\n            /**\r\n             * 创建线条路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Line~ILineStyle} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                if (!style.lineType || style.lineType == 'solid') {\r\n                    // 默认为实线\r\n                    ctx.moveTo(style.xStart, style.yStart);\r\n                    ctx.lineTo(style.xEnd, style.yEnd);\r\n                }\r\n                else if (style.lineType == 'dashed'\r\n                        || style.lineType == 'dotted'\r\n                ) {\r\n                    var dashLength = (style.lineWidth || 1)  \r\n                                     * (style.lineType == 'dashed' ? 5 : 1);\r\n                    dashedLineTo(\r\n                        ctx,\r\n                        style.xStart, style.yStart,\r\n                        style.xEnd, style.yEnd,\r\n                        dashLength\r\n                    );\r\n                }\r\n            },\r\n\r\n            /**\r\n             * 计算返回线条的包围盒矩形\r\n             * @param {module:zrender/shape/Line~ILineStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var lineWidth = style.lineWidth || 1;\r\n                style.__rect = {\r\n                    x : Math.min(style.xStart, style.xEnd) - lineWidth,\r\n                    y : Math.min(style.yStart, style.yEnd) - lineWidth,\r\n                    width : Math.abs(style.xStart - style.xEnd)\r\n                            + lineWidth,\r\n                    height : Math.abs(style.yStart - style.yEnd)\r\n                             + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Line, Base);\r\n        return Line;\r\n    }\r\n);\r\n"
    },
    {
      "id": 28,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\dashedLineTo.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/dashedLineTo.js",
      "index": 28,
      "index2": 20,
      "size": 1451,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 26,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/util/dashedLineTo",
          "loc": "31:23-67"
        },
        {
          "moduleId": 27,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Line.js",
          "type": "cjs require",
          "userRequest": "./util/dashedLineTo",
          "loc": "45:27-57"
        },
        {
          "moduleId": 31,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "type": "cjs require",
          "userRequest": "./util/dashedLineTo",
          "loc": "46:27-57"
        },
        {
          "moduleId": 35,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "type": "cjs require",
          "userRequest": "./util/dashedLineTo",
          "loc": "45:27-57"
        }
      ],
      "source": "/**\r\n * 虚线lineTo \r\n *\r\n * author:  Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *          errorrik (errorrik@gmail.com)\r\n */\r\ndefine(\r\n    function (/* require */) {\r\n\r\n        var dashPattern = [ 5, 5 ];\r\n        /**\r\n         * 虚线lineTo \r\n         */\r\n        return function (ctx, x1, y1, x2, y2, dashLength) {\r\n            // http://msdn.microsoft.com/en-us/library/ie/dn265063(v=vs.85).aspx\r\n            if (ctx.setLineDash) {\r\n                dashPattern[0] = dashPattern[1] = dashLength;\r\n                ctx.setLineDash(dashPattern);\r\n                ctx.moveTo(x1, y1);\r\n                ctx.lineTo(x2, y2);\r\n                return;\r\n            }\r\n\r\n            dashLength = typeof dashLength != 'number'\r\n                            ? 5 \r\n                            : dashLength;\r\n\r\n            var dx = x2 - x1;\r\n            var dy = y2 - y1;\r\n            var numDashes = Math.floor(\r\n                Math.sqrt(dx * dx + dy * dy) / dashLength\r\n            );\r\n            dx = dx / numDashes;\r\n            dy = dy / numDashes;\r\n            var flag = true;\r\n            for (var i = 0; i < numDashes; ++i) {\r\n                if (flag) {\r\n                    ctx.moveTo(x1, y1);\r\n                }\r\n                else {\r\n                    ctx.lineTo(x1, y1);\r\n                }\r\n                flag = !flag;\r\n                x1 += dx;\r\n                y1 += dy;\r\n            }\r\n            ctx.lineTo(x2, y2);\r\n        };\r\n    }\r\n);\r\n"
    },
    {
      "id": 29,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\BezierCurve.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/BezierCurve.js",
      "index": 29,
      "index2": 22,
      "size": 5355,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 26,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\MarkLine.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/MarkLine.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/BezierCurve",
          "loc": "27:21-59"
        }
      ],
      "source": "/**\r\n * 贝塞尔曲线\r\n * @module zrender/shape/BezierCurve\r\n * @author Neil (杨骥, 511415343@qq.com)\r\n * @example\r\n *     var BezierCurve = require('zrender/shape/BezierCurve');\r\n *     var shape = new BezierCurve({\r\n *         style: {\r\n *             xStart: 0,\r\n *             yStart: 0,\r\n *             cpX1: 100,\r\n *             cpY1: 0,\r\n *             cpX2: 0,\r\n *             cpY2: 100,\r\n *             xEnd: 100,\r\n *             yEnd: 100,\r\n *             strokeColor: 'red'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IBezierCurveStyle\r\n * @property {number} xStart 起点x坐标\r\n * @property {number} yStart 起点y坐标\r\n * @property {number} cpX1 第一个控制点x坐标\r\n * @property {number} cpY1 第一个控制点y坐标\r\n * @property {number} [cpX2] 第二个控制点x坐标，如果不给则为二次贝塞尔曲线\r\n * @property {number} [cpY2] 第二个控制点y坐标，如果不给则为二次贝塞尔曲线\r\n * @property {number} xEnd 终止点x坐标\r\n * @property {number} yEnd 终止点y坐标\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\n\r\ndefine(\r\n    function (require) {\r\n        'use strict';\r\n\r\n        var Base = require('./Base');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/BezierCurve\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var BezierCurve = function(options) {\r\n            this.brushTypeOnly = 'stroke';  // 线条只能描边，填充后果自负\r\n            this.textPosition = 'end';\r\n            Base.call(this, options);\r\n            /**\r\n             * 贝赛尔曲线绘制样式\r\n             * @name module:zrender/shape/BezierCurve#style\r\n             * @type {module:zrender/shape/BezierCurve~IBezierCurveStyle}\r\n             */\r\n            /**\r\n             * 贝赛尔曲线高亮绘制样式\r\n             * @name module:zrender/shape/BezierCurve#highlightStyle\r\n             * @type {module:zrender/shape/BezierCurve~IBezierCurveStyle}\r\n             */\r\n        };\r\n\r\n        BezierCurve.prototype = {\r\n            type: 'bezier-curve',\r\n\r\n            /**\r\n             * 创建贝塞尔曲线路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/BezierCurve~IBezierCurveStyle} style\r\n             */\r\n            buildPath : function(ctx, style) {\r\n                ctx.moveTo(style.xStart, style.yStart);\r\n                if (typeof style.cpX2 != 'undefined'\r\n                    && typeof style.cpY2 != 'undefined'\r\n                ) {\r\n                    ctx.bezierCurveTo(\r\n                        style.cpX1, style.cpY1,\r\n                        style.cpX2, style.cpY2,\r\n                        style.xEnd, style.yEnd\r\n                    );\r\n                }\r\n                else {\r\n                    ctx.quadraticCurveTo(\r\n                        style.cpX1, style.cpY1,\r\n                        style.xEnd, style.yEnd\r\n                    );\r\n                }\r\n            },\r\n\r\n            /**\r\n             * 计算返回贝赛尔曲线包围盒矩形。\r\n             * 该包围盒是直接从四个控制点计算，并非最小包围盒。\r\n             * @param {module:zrender/shape/BezierCurve~IBezierCurveStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function(style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var _minX = Math.min(style.xStart, style.xEnd, style.cpX1);\r\n                var _minY = Math.min(style.yStart, style.yEnd, style.cpY1);\r\n                var _maxX = Math.max(style.xStart, style.xEnd, style.cpX1);\r\n                var _maxY = Math.max(style.yStart, style.yEnd, style.cpY1);\r\n                var _x2 = style.cpX2;\r\n                var _y2 = style.cpY2;\r\n\r\n                if (typeof _x2 != 'undefined'\r\n                    && typeof _y2 != 'undefined'\r\n                ) {\r\n                    _minX = Math.min(_minX, _x2);\r\n                    _minY = Math.min(_minY, _y2);\r\n                    _maxX = Math.max(_maxX, _x2);\r\n                    _maxY = Math.max(_maxY, _y2);\r\n                }\r\n\r\n                var lineWidth = style.lineWidth || 1;\r\n                style.__rect = {\r\n                    x : _minX - lineWidth,\r\n                    y : _minY - lineWidth,\r\n                    width : _maxX - _minX + lineWidth,\r\n                    height : _maxY - _minY + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(BezierCurve, Base);\r\n        return BezierCurve;\r\n    }\r\n);\r\n"
    },
    {
      "id": 30,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
      "index": 30,
      "index2": 28,
      "size": 6763,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../util/shape/Symbol",
          "loc": "13:22-53"
        },
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "../util/shape/Symbol",
          "loc": "15:22-53"
        }
      ],
      "source": "/**\r\n * zrender\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * shape类：大规模散点图图形\r\n * 可配图形属性：\r\n   {\r\n       // 基础属性\r\n       shape  : 'symbol',       // 必须，shape类标识，需要显式指定\r\n       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成\r\n       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中\r\n       invisible : {boolean},   // 默认为false，是否可见\r\n\r\n       // 样式属性，默认状态样式样式属性\r\n       style  : {\r\n           pointList     : {Array},   // 必须，二维数组，二维内容如下\r\n               x         : {number},  // 必须，横坐标\r\n               y         : {number},  // 必须，纵坐标数组\r\n               size      : {number},  // 必须，半宽\r\n               type      : {string=}, // 默认为'circle',图形类型\r\n       },\r\n\r\n       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示\r\n       highlightStyle : {\r\n           // 同style\r\n       }\r\n\r\n       // 交互属性，详见shape.Base\r\n\r\n       // 事件属性，详见shape.Base\r\n   }\r\n */\r\ndefine(function (require) {\r\n    var Base = require('zrenderjs/shape/Base');\r\n    var PolygonShape = require('zrenderjs/shape/Polygon');\r\n    var polygonInstance = new PolygonShape({});\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n\r\n    function Symbol(options) {\r\n        Base.call(this, options);\r\n    }\r\n\r\n    Symbol.prototype =  {\r\n        type : 'symbol',\r\n        /**\r\n         * 创建矩形路径\r\n         * @param {Context2D} ctx Canvas 2D上下文\r\n         * @param {Object} style 样式\r\n         */\r\n        buildPath : function (ctx, style) {\r\n            var pointList = style.pointList;\r\n            var len = pointList.length;\r\n            if (len === 0) {\r\n                return;\r\n            }\r\n\r\n            var subSize = 10000;\r\n            var subSetLength = Math.ceil(len / subSize);\r\n            var sub;\r\n            var subLen;\r\n            var isArray = pointList[0] instanceof Array;\r\n            var size = style.size ? style.size : 2;\r\n            var curSize = size;\r\n            var halfSize = size / 2;\r\n            var PI2 = Math.PI * 2;\r\n            var percent;\r\n            var x;\r\n            var y;\r\n            for (var j = 0; j < subSetLength; j++) {\r\n                ctx.beginPath();\r\n                sub = j * subSize;\r\n                subLen = sub + subSize;\r\n                subLen = subLen > len ? len : subLen;\r\n                for (var i = sub; i < subLen; i++) {\r\n                    if (style.random) {\r\n                        percent = style['randomMap' + (i % 20)] / 100;\r\n                        curSize = size * percent * percent;\r\n                        halfSize = curSize / 2;\r\n                    }\r\n                    if (isArray) {\r\n                        x = pointList[i][0];\r\n                        y = pointList[i][1];\r\n                    }\r\n                    else {\r\n                        x = pointList[i].x;\r\n                        y = pointList[i].y;\r\n                    }\r\n                    if (curSize < 3) {\r\n                        // 小于3像素视觉误差\r\n                        ctx.rect(x - halfSize, y - halfSize, curSize, curSize);\r\n                    }\r\n                    else {\r\n                        // 大于3像素才考虑图形\r\n                        switch (style.iconType) {\r\n                            case 'circle' :\r\n                                ctx.moveTo(x, y);\r\n                                ctx.arc(x, y, halfSize, 0, PI2, true);\r\n                                break;\r\n                            case 'diamond' :\r\n                                ctx.moveTo(x, y - halfSize);\r\n                                ctx.lineTo(x + halfSize / 3, y - halfSize / 3);\r\n                                ctx.lineTo(x + halfSize, y);\r\n                                ctx.lineTo(x + halfSize / 3, y + halfSize / 3);\r\n                                ctx.lineTo(x, y + halfSize);\r\n                                ctx.lineTo(x - halfSize / 3, y + halfSize / 3);\r\n                                ctx.lineTo(x - halfSize, y);\r\n                                ctx.lineTo(x - halfSize / 3, y - halfSize / 3);\r\n                                ctx.lineTo(x, y - halfSize);\r\n                                break;\r\n                            default :\r\n                                ctx.rect(x - halfSize, y - halfSize, curSize, curSize);\r\n                        }\r\n                    }\r\n                }\r\n                ctx.closePath();\r\n                if (j < (subSetLength - 1)) {\r\n                    switch (style.brushType) {\r\n                        case 'both':\r\n                            ctx.fill();\r\n                            style.lineWidth > 0 && ctx.stroke();  // js hint -_-\"\r\n                            break;\r\n                        case 'stroke':\r\n                            style.lineWidth > 0 && ctx.stroke();\r\n                            break;\r\n                        default:\r\n                            ctx.fill();\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /* 像素模式\r\n        buildPath : function (ctx, style) {\r\n            var pointList = style.pointList;\r\n            var rect = this.getRect(style);\r\n            var ratio = window.devicePixelRatio || 1;\r\n            // console.log(rect)\r\n            // var ti = new Date();\r\n            // bbox取整\r\n            rect = {\r\n                x : Math.floor(rect.x),\r\n                y : Math.floor(rect.y),\r\n                width : Math.floor(rect.width),\r\n                height : Math.floor(rect.height)\r\n            };\r\n            var pixels = ctx.getImageData(\r\n                rect.x * ratio, rect.y * ratio,\r\n                rect.width * ratio, rect.height * ratio\r\n            );\r\n            var data = pixels.data;\r\n            var idx;\r\n            var zrColor = require('zrenderjs/tool/color');\r\n            var color = zrColor.toArray(style.color);\r\n            var r = color[0];\r\n            var g = color[1];\r\n            var b = color[2];\r\n            var width = rect.width;\r\n\r\n            for (var i = 1, l = pointList.length; i < l; i++) {\r\n                idx = ((Math.floor(pointList[i][0]) - rect.x) * ratio\r\n                       + (Math.floor(pointList[i][1])- rect.y) * width * ratio * ratio\r\n                      ) * 4;\r\n                data[idx] = r;\r\n                data[idx + 1] = g;\r\n                data[idx + 2] = b;\r\n                data[idx + 3] = 255;\r\n            }\r\n            ctx.putImageData(pixels, rect.x * ratio, rect.y * ratio);\r\n            // console.log(new Date() - ti);\r\n            return;\r\n        },\r\n        */\r\n\r\n        /**\r\n         * 返回矩形区域，用于局部刷新和文字定位\r\n         * @param {Object} style\r\n         */\r\n        getRect : function (style) {\r\n            return style.__rect || polygonInstance.getRect(style);\r\n        },\r\n\r\n        isCover : require('./normalIsCover')\r\n    };\r\n\r\n    zrUtil.inherits(Symbol, Base);\r\n\r\n    return Symbol;\r\n});\r\n"
    },
    {
      "id": 31,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
      "index": 31,
      "index2": 26,
      "size": 8261,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 30,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Polygon",
          "loc": "36:23-57"
        },
        {
          "moduleId": 35,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "type": "cjs require",
          "userRequest": "./Polygon",
          "loc": "151:23-43"
        },
        {
          "moduleId": 39,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecAnimation.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Polygon",
          "loc": "357:19-53"
        },
        {
          "moduleId": 60,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Polygon",
          "loc": "13:23-57"
        },
        {
          "moduleId": 68,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Polygon",
          "loc": "92:16-50"
        }
      ],
      "source": "/**\r\n * 多边形\r\n * @module zrender/shape/Polygon\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *     var Polygon = require('zrender/shape/Polygon');\r\n *     var shape = new Polygon({\r\n *         style: {\r\n *             // 100x100的正方形\r\n *             pointList: [[0, 0], [100, 0], [100, 100], [0, 100]],\r\n *             color: 'blue'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IPolygonStyle\r\n * @property {string} pointList 多边形顶点数组\r\n * @property {string} [smooth=''] 是否做平滑插值, 平滑算法可以选择 bezier, spline\r\n * @property {number} [smoothConstraint] 平滑约束\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        var Base = require('./Base');\r\n        var smoothSpline = require('./util/smoothSpline');\r\n        var smoothBezier = require('./util/smoothBezier');\r\n        var dashedLineTo = require('./util/dashedLineTo');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Polygon\r\n         * @param {Object} options\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         */\r\n        var Polygon = function (options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 多边形绘制样式\r\n             * @name module:zrender/shape/Polygon#style\r\n             * @type {module:zrender/shape/Polygon~IPolygonStyle}\r\n             */\r\n            /**\r\n             * 多边形高亮绘制样式\r\n             * @name module:zrender/shape/Polygon#highlightStyle\r\n             * @type {module:zrender/shape/Polygon~IPolygonStyle}\r\n             */\r\n        };\r\n\r\n        Polygon.prototype = {\r\n            type: 'polygon',\r\n\r\n            /**\r\n             * 创建多边形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Polygon~IPolygonStyle} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                // 虽然能重用brokenLine，但底层图形基于性能考虑，重复代码减少调用吧\r\n                var pointList = style.pointList;\r\n                // 开始点和结束点重复\r\n                /*\r\n                var start = pointList[0];\r\n                var end = pointList[pointList.length-1];\r\n\r\n                if (start && end) {\r\n                    if (start[0] == end[0] &&\r\n                        start[1] == end[1]) {\r\n                        // 移除最后一个点\r\n                        pointList.pop();\r\n                    }\r\n                }\r\n                */\r\n\r\n                if (pointList.length < 2) {\r\n                    // 少于2个点就不画了~\r\n                    return;\r\n                }\r\n\r\n                if (style.smooth && style.smooth !== 'spline') {\r\n                    var controlPoints = smoothBezier(\r\n                        pointList, style.smooth, true, style.smoothConstraint\r\n                    );\r\n\r\n                    ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                    var cp1;\r\n                    var cp2;\r\n                    var p;\r\n                    var len = pointList.length;\r\n                    for (var i = 0; i < len; i++) {\r\n                        cp1 = controlPoints[i * 2];\r\n                        cp2 = controlPoints[i * 2 + 1];\r\n                        p = pointList[(i + 1) % len];\r\n                        ctx.bezierCurveTo(\r\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\r\n                        );\r\n                    }\r\n                } \r\n                else {\r\n                    if (style.smooth === 'spline') {\r\n                        pointList = smoothSpline(pointList, true);\r\n                    }\r\n\r\n                    if (!style.lineType || style.lineType == 'solid') {\r\n                        // 默认为实线\r\n                        ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                        for (var i = 1, l = pointList.length; i < l; i++) {\r\n                            ctx.lineTo(pointList[i][0], pointList[i][1]);\r\n                        }\r\n                        ctx.lineTo(pointList[0][0], pointList[0][1]);\r\n                    }\r\n                    else if (style.lineType == 'dashed'\r\n                            || style.lineType == 'dotted'\r\n                    ) {\r\n                        var dashLength = \r\n                            style._dashLength\r\n                            || (style.lineWidth || 1) \r\n                               * (style.lineType == 'dashed' ? 5 : 1);\r\n                        style._dashLength = dashLength;\r\n                        ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                        for (var i = 1, l = pointList.length; i < l; i++) {\r\n                            dashedLineTo(\r\n                                ctx,\r\n                                pointList[i - 1][0], pointList[i - 1][1],\r\n                                pointList[i][0], pointList[i][1],\r\n                                dashLength\r\n                            );\r\n                        }\r\n                        dashedLineTo(\r\n                            ctx,\r\n                            pointList[pointList.length - 1][0], \r\n                            pointList[pointList.length - 1][1],\r\n                            pointList[0][0],\r\n                            pointList[0][1],\r\n                            dashLength\r\n                        );\r\n                    }\r\n                }\r\n\r\n                ctx.closePath();\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 计算返回多边形包围盒矩阵\r\n             * @param {module:zrender/shape/Polygon~IPolygonStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var minX =  Number.MAX_VALUE;\r\n                var maxX =  Number.MIN_VALUE;\r\n                var minY = Number.MAX_VALUE;\r\n                var maxY = Number.MIN_VALUE;\r\n\r\n                var pointList = style.pointList;\r\n                for (var i = 0, l = pointList.length; i < l; i++) {\r\n                    if (pointList[i][0] < minX) {\r\n                        minX = pointList[i][0];\r\n                    }\r\n                    if (pointList[i][0] > maxX) {\r\n                        maxX = pointList[i][0];\r\n                    }\r\n                    if (pointList[i][1] < minY) {\r\n                        minY = pointList[i][1];\r\n                    }\r\n                    if (pointList[i][1] > maxY) {\r\n                        maxY = pointList[i][1];\r\n                    }\r\n                }\r\n\r\n                var lineWidth;\r\n                if (style.brushType == 'stroke' || style.brushType == 'fill') {\r\n                    lineWidth = style.lineWidth || 1;\r\n                }\r\n                else {\r\n                    lineWidth = 0;\r\n                }\r\n                \r\n                style.__rect = {\r\n                    x : Math.round(minX - lineWidth / 2),\r\n                    y : Math.round(minY - lineWidth / 2),\r\n                    width : maxX - minX + lineWidth,\r\n                    height : maxY - minY + lineWidth\r\n                };\r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Polygon, Base);\r\n        return Polygon;\r\n    }\r\n);\r\n\r\n"
    },
    {
      "id": 32,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\smoothSpline.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothSpline.js",
      "index": 32,
      "index2": 24,
      "size": 2375,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 31,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "type": "cjs require",
          "userRequest": "./util/smoothSpline",
          "loc": "44:27-57"
        },
        {
          "moduleId": 35,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "type": "cjs require",
          "userRequest": "./util/smoothSpline",
          "loc": "43:27-57"
        }
      ],
      "source": "/**\r\n * Catmull-Rom spline 插值折线\r\n * @module zrender/shape/util/smoothSpline\r\n * @author pissang (https://www.github.com/pissang) \r\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         errorrik (errorrik@gmail.com)\r\n */\r\ndefine(\r\n    function (require) {\r\n        var vector = require('../../tool/vector');\r\n\r\n        /**\r\n         * @inner\r\n         */\r\n        function interpolate(p0, p1, p2, p3, t, t2, t3) {\r\n            var v0 = (p2 - p0) * 0.5;\r\n            var v1 = (p3 - p1) * 0.5;\r\n            return (2 * (p1 - p2) + v0 + v1) * t3 \r\n                    + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\r\n                    + v0 * t + p1;\r\n        }\r\n\r\n        /**\r\n         * @alias module:zrender/shape/util/smoothSpline\r\n         * @param {Array} points 线段顶点数组\r\n         * @param {boolean} isLoop\r\n         * @param {Array} constraint \r\n         * @return {Array}\r\n         */\r\n        return function (points, isLoop, constraint) {\r\n            var len = points.length;\r\n            var ret = [];\r\n\r\n            var distance = 0;\r\n            for (var i = 1; i < len; i++) {\r\n                distance += vector.distance(points[i - 1], points[i]);\r\n            }\r\n            \r\n            var segs = distance / 5;\r\n            segs = segs < len ? len : segs;\r\n            for (var i = 0; i < segs; i++) {\r\n                var pos = i / (segs - 1) * (isLoop ? len : len - 1);\r\n                var idx = Math.floor(pos);\r\n\r\n                var w = pos - idx;\r\n\r\n                var p0;\r\n                var p1 = points[idx % len];\r\n                var p2;\r\n                var p3;\r\n                if (!isLoop) {\r\n                    p0 = points[idx === 0 ? idx : idx - 1];\r\n                    p2 = points[idx > len - 2 ? len - 1 : idx + 1];\r\n                    p3 = points[idx > len - 3 ? len - 1 : idx + 2];\r\n                }\r\n                else {\r\n                    p0 = points[(idx - 1 + len) % len];\r\n                    p2 = points[(idx + 1) % len];\r\n                    p3 = points[(idx + 2) % len];\r\n                }\r\n\r\n                var w2 = w * w;\r\n                var w3 = w * w2;\r\n\r\n                ret.push([\r\n                    interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\r\n                    interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\r\n                ]);\r\n            }\r\n            return ret;\r\n        };\r\n    }\r\n);\r\n"
    },
    {
      "id": 33,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\util\\smoothBezier.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/util/smoothBezier.js",
      "index": 33,
      "index2": 25,
      "size": 3372,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 31,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polygon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polygon.js",
          "type": "cjs require",
          "userRequest": "./util/smoothBezier",
          "loc": "45:27-57"
        },
        {
          "moduleId": 35,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
          "type": "cjs require",
          "userRequest": "./util/smoothBezier",
          "loc": "44:27-57"
        },
        {
          "moduleId": 68,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/util/smoothBezier",
          "loc": "49:23-67"
        }
      ],
      "source": "/**\r\n * 贝塞尔平滑曲线 \r\n * @module zrender/shape/util/smoothBezier\r\n * @author pissang (https://www.github.com/pissang) \r\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         errorrik (errorrik@gmail.com)\r\n */\r\ndefine(\r\n    function (require) {\r\n        var vector = require('../../tool/vector');\r\n\r\n        /**\r\n         * 贝塞尔平滑曲线\r\n         * @alias module:zrender/shape/util/smoothBezier\r\n         * @param {Array} points 线段顶点数组\r\n         * @param {number} smooth 平滑等级, 0-1\r\n         * @param {boolean} isLoop\r\n         * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\r\n         *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\r\n         *                           整个折线的包围盒做一个并集用来约束控制点。\r\n         * @param {Array} 计算出来的控制点数组\r\n         */\r\n        return function (points, smooth, isLoop, constraint) {\r\n            var cps = [];\r\n\r\n            var v = [];\r\n            var v1 = [];\r\n            var v2 = [];\r\n            var prevPoint;\r\n            var nextPoint;\r\n\r\n            var hasConstraint = !!constraint;\r\n            var min, max;\r\n            if (hasConstraint) {\r\n                min = [Infinity, Infinity];\r\n                max = [-Infinity, -Infinity];\r\n                for (var i = 0, len = points.length; i < len; i++) {\r\n                    vector.min(min, min, points[i]);\r\n                    vector.max(max, max, points[i]);\r\n                }\r\n                // 与指定的包围盒做并集\r\n                vector.min(min, min, constraint[0]);\r\n                vector.max(max, max, constraint[1]);\r\n            }\r\n\r\n            for (var i = 0, len = points.length; i < len; i++) {\r\n                var point = points[i];\r\n                var prevPoint;\r\n                var nextPoint;\r\n\r\n                if (isLoop) {\r\n                    prevPoint = points[i ? i - 1 : len - 1];\r\n                    nextPoint = points[(i + 1) % len];\r\n                } \r\n                else {\r\n                    if (i === 0 || i === len - 1) {\r\n                        cps.push(vector.clone(points[i]));\r\n                        continue;\r\n                    } \r\n                    else {\r\n                        prevPoint = points[i - 1];\r\n                        nextPoint = points[i + 1];\r\n                    }\r\n                }\r\n\r\n                vector.sub(v, nextPoint, prevPoint);\r\n\r\n                // use degree to scale the handle length\r\n                vector.scale(v, v, smooth);\r\n\r\n                var d0 = vector.distance(point, prevPoint);\r\n                var d1 = vector.distance(point, nextPoint);\r\n                var sum = d0 + d1;\r\n                if (sum !== 0) {\r\n                    d0 /= sum;\r\n                    d1 /= sum;\r\n                }\r\n\r\n                vector.scale(v1, v, -d0);\r\n                vector.scale(v2, v, d1);\r\n                var cp0 = vector.add([], point, v1);\r\n                var cp1 = vector.add([], point, v2);\r\n                if (hasConstraint) {\r\n                    vector.max(cp0, cp0, min);\r\n                    vector.min(cp0, cp0, max);\r\n                    vector.max(cp1, cp1, min);\r\n                    vector.min(cp1, cp1, max);\r\n                }\r\n                cps.push(cp0);\r\n                cps.push(cp1);\r\n            }\r\n            \r\n            if (isLoop) {\r\n                cps.push(vector.clone(cps.shift()));\r\n            }\r\n\r\n            return cps;\r\n        };\r\n    }\r\n);\r\n"
    },
    {
      "id": 34,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\normalIsCover.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/normalIsCover.js",
      "index": 34,
      "index2": 27,
      "size": 348,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 30,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\Symbol.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/Symbol.js",
          "type": "cjs require",
          "userRequest": "./normalIsCover",
          "loc": "183:18-44"
        }
      ],
      "source": "// 由于大多数shape默认的isCover都是相同的逻辑\r\n// 所以在echarts里临时抽象一个module，用于isCover method\r\n// TODO: 对zrender的isCover和getRect方法进行抽象，重新整理该逻辑\r\n\r\ndefine(function () {\r\n    return function (x, y) {\r\n        var originPos = this.transformCoordToLocal(x, y);\r\n        x = originPos[0];\r\n        y = originPos[1];\r\n\r\n        return this.isCoverRect(x, y);\r\n    };\r\n});\r\n"
    },
    {
      "id": 35,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Polyline.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Polyline.js",
      "index": 35,
      "index2": 29,
      "size": 6258,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Polyline",
          "loc": "14:24-59"
        },
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Polyline",
          "loc": "17:19-54"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Polyline",
          "loc": "12:24-59"
        }
      ],
      "source": "/**\r\n * 折线\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @module zrender/shape/Polyline\r\n * @example\r\n *     var Polyline = require('zrender/shape/Polyline');\r\n *     var shape = new Polyline({\r\n *         style: {\r\n *             pointList: [[0, 0], [100, 100], [100, 0]],\r\n *             smooth: 'bezier',\r\n *             strokeColor: 'purple'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IPolylineStyle\r\n * @property {Array.<number>} pointList 顶点坐标数组\r\n * @property {string|number} [smooth=''] 是否做平滑插值, 平滑算法可以选择 bezier, spline\r\n * @property {number} [smoothConstraint] 平滑约束\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {string} [lineJoin='miter'] 线段连接样式，可以是 miter, round, bevel\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        var Base = require('./Base');\r\n        var smoothSpline = require('./util/smoothSpline');\r\n        var smoothBezier = require('./util/smoothBezier');\r\n        var dashedLineTo = require('./util/dashedLineTo');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Polyline\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Polyline = function(options) {\r\n            this.brushTypeOnly = 'stroke';  // 线条只能描边，填充后果自负\r\n            this.textPosition = 'end';\r\n            Base.call(this, options);\r\n            /**\r\n             * 贝赛尔曲线绘制样式\r\n             * @name module:zrender/shape/Polyline#style\r\n             * @type {module:zrender/shape/Polyline~IPolylineStyle}\r\n             */\r\n            /**\r\n             * 贝赛尔曲线高亮绘制样式\r\n             * @name module:zrender/shape/Polyline#highlightStyle\r\n             * @type {module:zrender/shape/Polyline~IPolylineStyle}\r\n             */\r\n        };\r\n\r\n        Polyline.prototype =  {\r\n            type: 'polyline',\r\n\r\n            /**\r\n             * 创建多边形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Polyline~IPolylineStyle} style\r\n             */\r\n            buildPath : function(ctx, style) {\r\n                var pointList = style.pointList;\r\n                if (pointList.length < 2) {\r\n                    // 少于2个点就不画了~\r\n                    return;\r\n                }\r\n                \r\n                var len = Math.min(\r\n                    style.pointList.length, \r\n                    Math.round(style.pointListLength || style.pointList.length)\r\n                );\r\n                \r\n                if (style.smooth && style.smooth !== 'spline') {\r\n                    if (! style.controlPointList) {\r\n                        this.updateControlPoints(style);\r\n                    }\r\n                    var controlPointList = style.controlPointList;\r\n\r\n                    ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                    var cp1;\r\n                    var cp2;\r\n                    var p;\r\n                    for (var i = 0; i < len - 1; i++) {\r\n                        cp1 = controlPointList[i * 2];\r\n                        cp2 = controlPointList[i * 2 + 1];\r\n                        p = pointList[i + 1];\r\n                        ctx.bezierCurveTo(\r\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\r\n                        );\r\n                    }\r\n                }\r\n                else {\r\n                    if (style.smooth === 'spline') {\r\n                        pointList = smoothSpline(pointList);\r\n                        len = pointList.length;\r\n                    }\r\n                    if (!style.lineType || style.lineType == 'solid') {\r\n                        // 默认为实线\r\n                        ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                        for (var i = 1; i < len; i++) {\r\n                            ctx.lineTo(pointList[i][0], pointList[i][1]);\r\n                        }\r\n                    }\r\n                    else if (style.lineType == 'dashed'\r\n                            || style.lineType == 'dotted'\r\n                    ) {\r\n                        var dashLength = (style.lineWidth || 1) \r\n                                         * (style.lineType == 'dashed' ? 5 : 1);\r\n                        ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                        for (var i = 1; i < len; i++) {\r\n                            dashedLineTo(\r\n                                ctx,\r\n                                pointList[i - 1][0], pointList[i - 1][1],\r\n                                pointList[i][0], pointList[i][1],\r\n                                dashLength\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                return;\r\n            },\r\n\r\n            updateControlPoints: function (style) {\r\n                style.controlPointList = smoothBezier(\r\n                    style.pointList, style.smooth, false, style.smoothConstraint\r\n                );\r\n            },\r\n\r\n            /**\r\n             * 计算返回折线包围盒矩形。\r\n             * @param {IZRenderBezierCurveStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function(style) {\r\n                return require('./Polygon').prototype.getRect(style);\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Polyline, Base);\r\n        return Polyline;\r\n    }\r\n);\r\n"
    },
    {
      "id": 36,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\ShapeBundle.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/ShapeBundle.js",
      "index": 36,
      "index2": 30,
      "size": 5197,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/ShapeBundle",
          "loc": "15:22-60"
        },
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/ShapeBundle",
          "loc": "16:22-60"
        }
      ],
      "source": "/**\r\n * ShapeBundle 捆绑多个 shape 的 buildPath 方法，但是共用同一个样式\r\n * @author pissang (https://github.com/pissang)\r\n * @module zrender/shape/ShapeBundle\r\n * @example\r\n *     var poly1 = new PolygonShape();\r\n *     var poly2 = new PolygonShape();\r\n *     var poly3 = new PolygonShape();\r\n *     var shapeBundle = new ShapeBundle({\r\n *         style: {\r\n *             shapeList: [poly1, poly2, poly3],\r\n *             color: 'red'\r\n *         }\r\n *     });\r\n *     zr.addShape(shapeBundle);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IShapeBundleStyle\r\n * @property {string} shapeList shape列表\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(function (require) {\r\n\r\n    var Base = require('./Base');\r\n\r\n    var ShapeBundle = function (options) {\r\n        Base.call(this, options);\r\n        /**\r\n         * ShapeBundle绘制样式\r\n         * @name module:zrender/shape/ShapeBundle#style\r\n         * @type {module:zrender/shape/ShapeBundle~IShapeBundleStyle}\r\n         */\r\n        /**\r\n         * ShapeBundle高亮绘制样式\r\n         * @name module:zrender/shape/ShapeBundle#highlightStyle\r\n         * @type {module:zrender/shape/ShapeBundle~IShapeBundleStyle}\r\n         */\r\n    };\r\n\r\n    ShapeBundle.prototype = {\r\n\r\n        constructor: ShapeBundle,\r\n\r\n        type: 'shape-bundle',\r\n\r\n        brush: function (ctx, isHighlight) {\r\n            var style = this.beforeBrush(ctx, isHighlight);\r\n\r\n            ctx.beginPath();\r\n            for (var i = 0; i < style.shapeList.length; i++) {\r\n                var subShape = style.shapeList[i];\r\n                var subShapeStyle = subShape.style;\r\n                if (isHighlight) {\r\n                    subShapeStyle = subShape.getHighlightStyle(\r\n                        subShapeStyle,\r\n                        subShape.highlightStyle || {},\r\n                        subShape.brushTypeOnly\r\n                    );\r\n                }\r\n                subShape.buildPath(ctx, subShapeStyle);\r\n            }\r\n            switch (style.brushType) {\r\n                /* jshint ignore:start */\r\n                case 'both':\r\n                    ctx.fill();\r\n                case 'stroke':\r\n                    style.lineWidth > 0 && ctx.stroke();\r\n                    break;\r\n                /* jshint ignore:end */\r\n                default:\r\n                    ctx.fill();\r\n            }\r\n\r\n            this.drawText(ctx, style, this.style);\r\n\r\n            this.afterBrush(ctx);\r\n        },\r\n\r\n        /**\r\n         * 计算返回多边形包围盒矩阵\r\n         * @param {module:zrender/shape/Polygon~IShapeBundleStyle} style\r\n         * @return {module:zrender/shape/Base~IBoundingRect}\r\n         */\r\n        getRect: function (style) {\r\n            if (style.__rect) {\r\n                return style.__rect;\r\n            }\r\n            var minX = Infinity;\r\n            var maxX = -Infinity;\r\n            var minY = Infinity;\r\n            var maxY = -Infinity;\r\n            for (var i = 0; i < style.shapeList.length; i++) {\r\n                var subShape = style.shapeList[i];\r\n                // TODO Highlight style ?\r\n                var subRect = subShape.getRect(subShape.style);\r\n\r\n                var minX = Math.min(subRect.x, minX);\r\n                var minY = Math.min(subRect.y, minY);\r\n                var maxX = Math.max(subRect.x + subRect.width, maxX);\r\n                var maxY = Math.max(subRect.y + subRect.height, maxY);\r\n            }\r\n\r\n            style.__rect = {\r\n                x: minX,\r\n                y: minY,\r\n                width: maxX - minX,\r\n                height: maxY - minY\r\n            };\r\n\r\n            return style.__rect;\r\n        },\r\n\r\n        isCover: function (x, y) {\r\n            var originPos = this.transformCoordToLocal(x, y);\r\n            x = originPos[0];\r\n            y = originPos[1];\r\n            \r\n            if (this.isCoverRect(x, y)) {\r\n                for (var i = 0; i < this.style.shapeList.length; i++) {\r\n                    var subShape = this.style.shapeList[i];\r\n                    if (subShape.isCover(x, y)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n    };\r\n\r\n    require('../tool/util').inherits(ShapeBundle, Base);\r\n    return ShapeBundle;\r\n}); "
    },
    {
      "id": 37,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\config.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/config.js",
      "index": 37,
      "index2": 31,
      "size": 9119,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "18:19-39"
        },
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "17:19-39"
        },
        {
          "moduleId": 44,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "9:19-39"
        },
        {
          "moduleId": 51,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "21:19-39"
        },
        {
          "moduleId": 52,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "16:19-39"
        },
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "16:19-39"
        },
        {
          "moduleId": 59,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "14:19-39"
        },
        {
          "moduleId": 60,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "16:19-39"
        },
        {
          "moduleId": 64,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "14:19-39"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "../config",
          "loc": "20:19-39"
        }
      ],
      "source": "/**\r\n * echarts默认配置项\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function() {\r\n    // 请原谅我这样写，这显然可以直接返回个对象，但那样的话outline就显示不出来了~~\r\n    var config = {\r\n        // 图表类型\r\n        CHART_TYPE_LINE: 'line',\r\n        CHART_TYPE_BAR: 'bar',\r\n        CHART_TYPE_SCATTER: 'scatter',\r\n        CHART_TYPE_PIE: 'pie',\r\n        CHART_TYPE_RADAR: 'radar',\r\n        CHART_TYPE_VENN: 'venn',\r\n        CHART_TYPE_TREEMAP: 'treemap',\r\n        CHART_TYPE_TREE: 'tree',\r\n        CHART_TYPE_MAP: 'map',\r\n        CHART_TYPE_K: 'k',\r\n        CHART_TYPE_ISLAND: 'island',\r\n        CHART_TYPE_FORCE: 'force',\r\n        CHART_TYPE_CHORD: 'chord',\r\n        CHART_TYPE_GAUGE: 'gauge',\r\n        CHART_TYPE_FUNNEL: 'funnel',\r\n        CHART_TYPE_EVENTRIVER: 'eventRiver',\r\n        CHART_TYPE_WORDCLOUD: 'wordCloud',\r\n        CHART_TYPE_HEATMAP: 'heatmap',\r\n\r\n        // 组件类型\r\n        COMPONENT_TYPE_TITLE: 'title',\r\n        COMPONENT_TYPE_LEGEND: 'legend',\r\n        COMPONENT_TYPE_DATARANGE: 'dataRange',\r\n        COMPONENT_TYPE_DATAVIEW: 'dataView',\r\n        COMPONENT_TYPE_DATAZOOM: 'dataZoom',\r\n        COMPONENT_TYPE_TOOLBOX: 'toolbox',\r\n        COMPONENT_TYPE_TOOLTIP: 'tooltip',\r\n        COMPONENT_TYPE_GRID: 'grid',\r\n        COMPONENT_TYPE_AXIS: 'axis',\r\n        COMPONENT_TYPE_POLAR: 'polar',\r\n        COMPONENT_TYPE_X_AXIS: 'xAxis',\r\n        COMPONENT_TYPE_Y_AXIS: 'yAxis',\r\n        COMPONENT_TYPE_AXIS_CATEGORY: 'categoryAxis',\r\n        COMPONENT_TYPE_AXIS_VALUE: 'valueAxis',\r\n        COMPONENT_TYPE_TIMELINE: 'timeline',\r\n        COMPONENT_TYPE_ROAMCONTROLLER: 'roamController',\r\n\r\n        // 全图默认背景\r\n        backgroundColor: 'rgba(0,0,0,0)',\r\n        \r\n        // 默认色板\r\n        color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed',\r\n                '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0',\r\n                '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700',\r\n                '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'],\r\n\r\n        markPoint: {\r\n            clickable: true,\r\n            symbol: 'pin',         // 标注类型\r\n            symbolSize: 10,        // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\r\n            // symbolRotate: null, // 标注旋转控制\r\n            large: false,\r\n            effect: {\r\n                show: false,\r\n                loop: true,\r\n                period: 15,             // 运动周期，无单位，值越大越慢\r\n                type: 'scale',          // 可用为 scale | bounce\r\n                scaleSize: 2,           // 放大倍数，以markPoint点size为基准\r\n                bounceDistance: 10     // 跳动距离，单位px\r\n                // color: 'gold',\r\n                // shadowColor: 'rgba(255,215,0,0.8)',\r\n                // shadowBlur: 0          // 炫光模糊\r\n            },\r\n            itemStyle: {\r\n                normal: {\r\n                    // color: 各异，\r\n                    // borderColor: 各异,        // 标注边线颜色，优先于color \r\n                    borderWidth: 2,             // 标注边线线宽，单位px，默认为1\r\n                    label: {\r\n                        show: true,\r\n                        // 标签文本格式器，同Tooltip.formatter，不支持回调\r\n                        // formatter: null,\r\n                        position: 'inside'      // 可选为'left'|'right'|'top'|'bottom'\r\n                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                    }\r\n                },\r\n                emphasis: {\r\n                    // color: 各异\r\n                    label: {\r\n                        show: true\r\n                        // 标签文本格式器，同Tooltip.formatter，不支持回调\r\n                        // formatter: null,\r\n                        // position: 'inside'  // 'left'|'right'|'top'|'bottom'\r\n                        // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        markLine: {\r\n            clickable: true,\r\n            // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string\r\n            symbol: ['circle', 'arrow'],\r\n            // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\r\n            symbolSize: [2, 4],\r\n            // 标线起始和结束的symbol旋转控制\r\n            //symbolRotate: null,\r\n            //smooth: false,\r\n            smoothness: 0.2,    // 平滑度\r\n            precision: 2,\r\n            effect: {\r\n                show: false,\r\n                loop: true,\r\n                period: 15,                     // 运动周期，无单位，值越大越慢\r\n                scaleSize: 2                    // 放大倍数，以markLine线lineWidth为基准\r\n                // color: 'gold',\r\n                // shadowColor: 'rgba(255,215,0,0.8)',\r\n                // shadowBlur: lineWidth * 2    // 炫光模糊，默认等于scaleSize计算所得\r\n            },\r\n            // 边捆绑\r\n            bundling: {\r\n                enable: false,\r\n                // [0, 90]\r\n                maxTurningAngle: 45\r\n            },\r\n            itemStyle: {\r\n                normal: {\r\n                    // color: 各异,               // 标线主色，线色，symbol主色\r\n                    // borderColor: 随color,     // 标线symbol边框颜色，优先于color \r\n                    borderWidth: 1.5,           // 标线symbol边框线宽，单位px，默认为2\r\n                    label: {\r\n                        show: true,\r\n                        // 标签文本格式器，同Tooltip.formatter，不支持回调\r\n                        // formatter: null,\r\n                        // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'\r\n                        position: 'end'\r\n                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                    },\r\n                    lineStyle: {\r\n                        // color: 随borderColor, // 主色，线色，优先级高于borderColor和color\r\n                        // width: 随borderWidth, // 优先于borderWidth\r\n                        type: 'dashed'\r\n                        // shadowColor: 'rgba(0,0,0,0)', //默认透明\r\n                        // shadowBlur: 0,\r\n                        // shadowOffsetX: 0,\r\n                        // shadowOffsetY: 0\r\n                    }\r\n                },\r\n                emphasis: {\r\n                    // color: 各异\r\n                    label: {\r\n                        show: false\r\n                        // 标签文本格式器，同Tooltip.formatter，不支持回调\r\n                        // formatter: null,\r\n                        // position: 'inside' // 'left'|'right'|'top'|'bottom'\r\n                        // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE\r\n                    },\r\n                    lineStyle: {}\r\n                }\r\n            }\r\n        },\r\n\r\n        // 主题，主题\r\n        textStyle: {\r\n            decoration: 'none',\r\n            fontFamily: 'Arial, Verdana, sans-serif',\r\n            fontFamily2: '微软雅黑',    // IE8- 字体模糊并且，不支持不同字体混排，额外指定一份\r\n            fontSize: 12,\r\n            fontStyle: 'normal',\r\n            fontWeight: 'normal'\r\n        },\r\n\r\n        EVENT: {\r\n            // -------全局通用\r\n            REFRESH: 'refresh',\r\n            RESTORE: 'restore',\r\n            RESIZE: 'resize',\r\n            CLICK: 'click',\r\n            DBLCLICK: 'dblclick',\r\n            HOVER: 'hover',\r\n            MOUSEOUT: 'mouseout',\r\n            //MOUSEWHEEL: 'mousewheel',\r\n            // -------业务交互逻辑\r\n            DATA_CHANGED: 'dataChanged',\r\n            DATA_ZOOM: 'dataZoom',\r\n            DATA_RANGE: 'dataRange',\r\n            DATA_RANGE_SELECTED: 'dataRangeSelected',\r\n            DATA_RANGE_HOVERLINK: 'dataRangeHoverLink',\r\n            LEGEND_SELECTED: 'legendSelected',\r\n            LEGEND_HOVERLINK: 'legendHoverLink',\r\n            MAP_SELECTED: 'mapSelected',\r\n            PIE_SELECTED: 'pieSelected',\r\n            MAGIC_TYPE_CHANGED: 'magicTypeChanged',\r\n            DATA_VIEW_CHANGED: 'dataViewChanged',\r\n            TIMELINE_CHANGED: 'timelineChanged',\r\n            MAP_ROAM: 'mapRoam',\r\n            FORCE_LAYOUT_END: 'forceLayoutEnd',\r\n            // -------内部通信\r\n            TOOLTIP_HOVER: 'tooltipHover',\r\n            TOOLTIP_IN_GRID: 'tooltipInGrid',\r\n            TOOLTIP_OUT_GRID: 'tooltipOutGrid',\r\n            ROAMCONTROLLER: 'roamController'\r\n        },\r\n        DRAG_ENABLE_TIME: 120,   // 降低图表内元素拖拽敏感度，单位ms，不建议外部干预\r\n        EFFECT_ZLEVEL : 10,       // 特效动画zlevel\r\n        effectBlendAlpha: 0.95,\r\n        // 主题，默认标志图形类型列表\r\n        symbolList: [\r\n          'circle', 'rectangle', 'triangle', 'diamond',\r\n          'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'\r\n        ],\r\n        loadingEffect: 'spin',\r\n        loadingText: '数据读取中...',\r\n        noDataEffect: 'bubble',\r\n        noDataText: '暂无数据',\r\n        // noDataLoadingOption: null,\r\n        // 可计算特性配置，孤岛，提示颜色\r\n        calculable: false,                      // 默认关闭可计算特性\r\n        calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色\r\n        calculableHolderColor: '#ccc',          // 可计算占位提示颜色\r\n        nameConnector: ' & ',\r\n        valueConnector: ': ',\r\n        animation: true,                // 过渡动画是否开启\r\n        addDataAnimation: true,         // 动态数据接口是否开启动画效果\r\n        animationThreshold: 2000,       // 动画元素阀值，产生的图形原素超过2000不出动画\r\n        animationDuration: 2000,        // 过渡动画参数：进入\r\n        animationDurationUpdate: 500,   // 过渡动画参数：更新\r\n        animationEasing: 'ExponentialOut'    //BounceOut\r\n    };\r\n\r\n    return config;\r\n});\r\n"
    },
    {
      "id": 38,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecData.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecData.js",
      "index": 38,
      "index2": 32,
      "size": 3105,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "../util/ecData",
          "loc": "62:17-42"
        },
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../util/ecData",
          "loc": "18:17-42"
        },
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "../util/ecData",
          "loc": "9:17-42"
        },
        {
          "moduleId": 44,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "type": "cjs require",
          "userRequest": "../util/ecData",
          "loc": "10:17-42"
        },
        {
          "moduleId": 51,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "type": "cjs require",
          "userRequest": "../util/ecData",
          "loc": "22:17-42"
        },
        {
          "moduleId": 64,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "../util/ecData",
          "loc": "22:17-42"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "../util/ecData",
          "loc": "69:17-42"
        }
      ],
      "source": "/**\r\n * echarts通用私有数据服务\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function() {\r\n    /**\r\n     * 打包私有数据\r\n     *\r\n     * @param {shape} shape 修改目标\r\n     * @param {Object} series\r\n     * @param {number} seriesIndex\r\n     * @param {number | Object} data\r\n     * @param {number} dataIndex\r\n     * @param {*=} special\r\n     * @param {*=} special2\r\n     */\r\n    function pack(\r\n        shape, series, seriesIndex, data, dataIndex, name, special, special2\r\n    ) {\r\n        var value;\r\n        if (typeof data != 'undefined') {\r\n            value = data.value == null\r\n                ? data\r\n                : data.value;\r\n        }\r\n\r\n        shape._echartsData = {\r\n            '_series' : series,\r\n            '_seriesIndex' : seriesIndex,\r\n            '_data' : data,\r\n            '_dataIndex' : dataIndex,\r\n            '_name' : name,\r\n            '_value' : value,\r\n            '_special' : special,\r\n            '_special2' : special2\r\n        };\r\n        return shape._echartsData;\r\n    }\r\n\r\n    /**\r\n     * 从私有数据中获取特定项\r\n     * @param {shape} shape\r\n     * @param {string} key\r\n     */\r\n    function get(shape, key) {\r\n        var data = shape._echartsData;\r\n        if (!key) {\r\n            return data;\r\n        }\r\n\r\n        switch (key) {\r\n            case 'series' :\r\n            case 'seriesIndex' :\r\n            case 'data' :\r\n            case 'dataIndex' :\r\n            case 'name' :\r\n            case 'value' :\r\n            case 'special' :\r\n            case 'special2' :\r\n                return data && data['_' + key];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 修改私有数据中获取特定项\r\n     * @param {shape} shape\r\n     * @param {string} key\r\n     * @param {*} value\r\n     */\r\n    function set(shape, key, value) {\r\n        shape._echartsData = shape._echartsData || {};\r\n        switch (key) {\r\n            case 'series' :             // 当前系列值\r\n            case 'seriesIndex' :        // 系列数组位置索引\r\n            case 'data' :               // 当前数据值\r\n            case 'dataIndex' :          // 数据数组位置索引\r\n            case 'name' :\r\n            case 'value' :\r\n            case 'special' :\r\n            case 'special2' :\r\n                shape._echartsData['_' + key] = value;\r\n                break;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 私有数据克隆，把source拷贝到target上\r\n     * @param {shape} source 源\r\n     * @param {shape} target 目标\r\n     */\r\n    function clone(source, target) {\r\n        target._echartsData =  {\r\n            '_series' : source._echartsData._series,\r\n            '_seriesIndex' : source._echartsData._seriesIndex,\r\n            '_data' : source._echartsData._data,\r\n            '_dataIndex' : source._echartsData._dataIndex,\r\n            '_name' : source._echartsData._name,\r\n            '_value' : source._echartsData._value,\r\n            '_special' : source._echartsData._special,\r\n            '_special2' : source._echartsData._special2\r\n        };\r\n    }\r\n\r\n    return {\r\n        pack : pack,\r\n        set : set,\r\n        get : get,\r\n        clone : clone\r\n    };\r\n});"
    },
    {
      "id": 39,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecAnimation.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecAnimation.js",
      "index": 39,
      "index2": 33,
      "size": 18835,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../util/ecAnimation",
          "loc": "19:22-52"
        }
      ],
      "source": "/**\r\n * echarts图表动画基类\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var curveTool = require('zrenderjs/tool/curve');\r\n    \r\n    /**\r\n     * 折线型动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function pointList(zr, oldShape, newShape, duration, easing) {\r\n        var newPointList = newShape.style.pointList;\r\n        var newPointListLen = newPointList.length;\r\n        var oldPointList;\r\n\r\n        if (!oldShape) {        // add\r\n            oldPointList = [];\r\n            if (newShape._orient != 'vertical') {\r\n                var y = newPointList[0][1];\r\n                for (var i = 0; i < newPointListLen; i++) {\r\n                    oldPointList[i] = [newPointList[i][0], y];\r\n                }\r\n            }\r\n            else {\r\n                var x = newPointList[0][0];\r\n                for (var i = 0; i < newPointListLen; i++) {\r\n                    oldPointList[i] = [x, newPointList[i][1]];\r\n                }\r\n            }\r\n\r\n            if (newShape.type == 'half-smooth-polygon') {\r\n                oldPointList[newPointListLen - 1] = zrUtil.clone(newPointList[newPointListLen - 1]);\r\n                oldPointList[newPointListLen - 2] = zrUtil.clone(newPointList[newPointListLen - 2]);\r\n            }\r\n            oldShape = {style : {pointList : oldPointList}};\r\n        }\r\n        \r\n        oldPointList = oldShape.style.pointList;\r\n        var oldPointListLen = oldPointList.length;\r\n        if (oldPointListLen == newPointListLen) {\r\n            newShape.style.pointList = oldPointList;\r\n        }\r\n        else if (oldPointListLen < newPointListLen) {\r\n            // 原来短，新的长，补全\r\n            newShape.style.pointList = oldPointList.concat(newPointList.slice(oldPointListLen));\r\n        }\r\n        else {\r\n            // 原来长，新的短，截断\r\n            newShape.style.pointList = oldPointList.slice(0, newPointListLen);\r\n        }\r\n\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                { pointList: newPointList }\r\n            )\r\n            .during(function () {\r\n                // Updating bezier points\r\n                if (newShape.updateControlPoints) {\r\n                    newShape.updateControlPoints(newShape.style);\r\n                }\r\n            })\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 复制样式\r\n     * \r\n     * @inner\r\n     * @param {Object} target 目标对象\r\n     * @param {Object} source 源对象\r\n     * @param {...string} props 复制的属性列表\r\n     */\r\n    function cloneStyle(target, source) {\r\n        var len = arguments.length;\r\n        for (var i = 2; i < len; i++) {\r\n            var prop = arguments[i];\r\n            target.style[prop] = source.style[prop];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 方型动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function rectangle(zr, oldShape, newShape, duration, easing) {\r\n        var newShapeStyle = newShape.style;\r\n        if (!oldShape) {        // add\r\n            oldShape = {\r\n                position : newShape.position,\r\n                style : {\r\n                    x : newShapeStyle.x,\r\n                    y : newShape._orient == 'vertical'\r\n                        ? newShapeStyle.y + newShapeStyle.height\r\n                        : newShapeStyle.y,\r\n                    width: newShape._orient == 'vertical' \r\n                           ? newShapeStyle.width : 0,\r\n                    height: newShape._orient != 'vertical' \r\n                           ? newShapeStyle.height : 0\r\n                }\r\n            };\r\n        }\r\n        \r\n        var newX = newShapeStyle.x;\r\n        var newY = newShapeStyle.y;\r\n        var newWidth = newShapeStyle.width;\r\n        var newHeight = newShapeStyle.height;\r\n        var newPosition = [newShape.position[0], newShape.position[1]];\r\n        cloneStyle(\r\n            newShape, oldShape,\r\n            'x', 'y', 'width', 'height'\r\n        );\r\n        newShape.position = oldShape.position;\r\n\r\n        zr.addShape(newShape);\r\n        if (newPosition[0] != oldShape.position[0] || newPosition[1] != oldShape.position[1]) {\r\n            zr.animate(newShape.id, '')\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        position: newPosition\r\n                    }\r\n                )\r\n                .start(easing);\r\n        }\r\n        \r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    x: newX,\r\n                    y: newY,\r\n                    width: newWidth,\r\n                    height: newHeight\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 蜡烛动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function candle(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            var y = newShape.style.y;\r\n            oldShape = {style : {y : [y[0], y[0], y[0], y[0]]}};\r\n        }\r\n        \r\n        var newY = newShape.style.y;\r\n        newShape.style.y = oldShape.style.y;\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                { y: newY }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n\r\n    /**\r\n     * 环型动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function ring(zr, oldShape, newShape, duration, easing) {\r\n        var x = newShape.style.x;\r\n        var y = newShape.style.y;\r\n        var r0 = newShape.style.r0;\r\n        var r = newShape.style.r;\r\n        \r\n        newShape.__animating = true;\r\n\r\n        if (newShape._animationAdd != 'r') {\r\n            newShape.style.r0 = 0;\r\n            newShape.style.r = 0;\r\n            newShape.rotation = [Math.PI*2, x, y];\r\n            \r\n            zr.addShape(newShape);\r\n            zr.animate(newShape.id, 'style')\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        r0 : r0,\r\n                        r : r\r\n                    }\r\n                )\r\n                .done(function() {\r\n                    newShape.__animating = false;\r\n                })\r\n                .start(easing);\r\n            zr.animate(newShape.id, '')\r\n                .when(\r\n                    duration,\r\n                    { rotation : [0, x, y] }\r\n                )\r\n                .start(easing);\r\n        }\r\n        else {\r\n            newShape.style.r0 = newShape.style.r;\r\n            \r\n            zr.addShape(newShape);\r\n            zr.animate(newShape.id, 'style')\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        r0 : r0\r\n                    }\r\n                )\r\n                .done(function() {\r\n                    newShape.__animating = false;\r\n                })\r\n                .start(easing);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 扇形动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function sector(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            if (newShape._animationAdd != 'r') {\r\n                oldShape = {\r\n                    style : {\r\n                        startAngle : newShape.style.startAngle,\r\n                        endAngle : newShape.style.startAngle\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                oldShape = {style : {r0 : newShape.style.r}};\r\n            }\r\n        }\r\n        \r\n        var startAngle = newShape.style.startAngle;\r\n        var endAngle = newShape.style.endAngle;\r\n        \r\n        cloneStyle(\r\n            newShape, oldShape,\r\n            'startAngle', 'endAngle'\r\n        );\r\n        \r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    startAngle : startAngle,\r\n                    endAngle : endAngle\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 文本动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function text(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            oldShape = {\r\n                style : {\r\n                    x : newShape.style.textAlign == 'left' \r\n                        ? newShape.style.x + 100\r\n                        : newShape.style.x - 100,\r\n                    y : newShape.style.y\r\n                }\r\n            };\r\n        }\r\n        \r\n        var x = newShape.style.x;\r\n        var y = newShape.style.y;\r\n        \r\n        cloneStyle(\r\n            newShape, oldShape,\r\n            'x', 'y'\r\n        );\r\n        \r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    x : x,\r\n                    y : y\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 多边形动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function polygon(zr, oldShape, newShape, duration, easing) {\r\n        var rect = require('zrenderjs/shape/Polygon').prototype.getRect(newShape.style);\r\n        var x = rect.x + rect.width / 2;\r\n        var y = rect.y + rect.height / 2;\r\n        \r\n        newShape.scale = [0.1, 0.1, x, y];\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, '')\r\n            .when(\r\n                duration,\r\n                {\r\n                    scale : [1, 1, x, y]\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * 和弦动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function ribbon(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            oldShape = {\r\n                style : {\r\n                    source0 : 0,\r\n                    source1 : newShape.style.source1 > 0 ? 360 : -360,\r\n                    target0 : 0,\r\n                    target1 : newShape.style.target1 > 0 ? 360 : -360\r\n                }\r\n            };\r\n        }\r\n        \r\n        var source0 = newShape.style.source0;\r\n        var source1 = newShape.style.source1;\r\n        var target0 = newShape.style.target0;\r\n        var target1 = newShape.style.target1;\r\n        \r\n        if (oldShape.style) {\r\n            cloneStyle(\r\n                newShape, oldShape,\r\n                'source0', 'source1', 'target0', 'target1'\r\n            );\r\n        }\r\n        \r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    source0 : source0,\r\n                    source1 : source1,\r\n                    target0 : target0,\r\n                    target1 : target1\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * gaugePointer动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function gaugePointer(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {        // add\r\n            oldShape = {\r\n                style : {\r\n                    angle : newShape.style.startAngle\r\n                }\r\n            };\r\n        }\r\n        \r\n        var angle = newShape.style.angle;\r\n        newShape.style.angle = oldShape.style.angle;\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    angle : angle\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * icon动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function icon(zr, oldShape, newShape, duration, easing, delay) {\r\n        // 避免markPoint特效取值在动画帧上\r\n        newShape.style._x = newShape.style.x;\r\n        newShape.style._y = newShape.style.y;\r\n        newShape.style._width = newShape.style.width;\r\n        newShape.style._height = newShape.style.height;\r\n\r\n        if (!oldShape) {    // add\r\n            var x = newShape._x || 0;\r\n            var y = newShape._y || 0;\r\n            newShape.scale = [0.01, 0.01, x, y];\r\n            zr.addShape(newShape);\r\n            newShape.__animating = true;\r\n            zr.animate(newShape.id, '')\r\n                .delay(delay)\r\n                .when(\r\n                    duration,\r\n                    {scale : [1, 1, x, y]}\r\n                )\r\n                .done(function() {\r\n                    newShape.__animating = false;\r\n                })\r\n                .start(easing || 'QuinticOut');\r\n        }\r\n        else {              // mod\r\n            rectangle(zr, oldShape, newShape, duration, easing);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * line动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function line(zr, oldShape, newShape, duration, easing) {\r\n        if (!oldShape) {\r\n            oldShape = {\r\n                style : {\r\n                    xStart : newShape.style.xStart,\r\n                    yStart : newShape.style.yStart,\r\n                    xEnd : newShape.style.xStart,\r\n                    yEnd : newShape.style.yStart\r\n                }\r\n            };\r\n        }\r\n        \r\n        var xStart = newShape.style.xStart;\r\n        var xEnd = newShape.style.xEnd;\r\n        var yStart = newShape.style.yStart;\r\n        var yEnd = newShape.style.yEnd;\r\n\r\n        cloneStyle(\r\n            newShape, oldShape,\r\n            'xStart', 'xEnd', 'yStart', 'yEnd'\r\n        );\r\n\r\n        zr.addShape(newShape);\r\n        newShape.__animating = true;\r\n        zr.animate(newShape.id, 'style')\r\n            .when(\r\n                duration,\r\n                {\r\n                    xStart: xStart,\r\n                    xEnd: xEnd,\r\n                    yStart: yStart,\r\n                    yEnd: yEnd\r\n                }\r\n            )\r\n            .done(function() {\r\n                newShape.__animating = false;\r\n            })\r\n            .start(easing);\r\n    }\r\n    \r\n    /**\r\n     * markline动画\r\n     * \r\n     * @param {ZRender} zr\r\n     * @param {shape} oldShape\r\n     * @param {shape} newShape\r\n     * @param {number} duration\r\n     * @param {tring} easing\r\n     */\r\n    function markline(zr, oldShape, newShape, duration, easing) {\r\n        easing = easing || 'QuinticOut';\r\n        newShape.__animating = true;\r\n        zr.addShape(newShape);\r\n        var newShapeStyle = newShape.style;\r\n\r\n        var animationDone = function () {\r\n            newShape.__animating = false;\r\n        };\r\n        var x0 = newShapeStyle.xStart;\r\n        var y0 = newShapeStyle.yStart;\r\n        var x2 = newShapeStyle.xEnd;\r\n        var y2 = newShapeStyle.yEnd;\r\n        if (newShapeStyle.curveness > 0) {\r\n            newShape.updatePoints(newShapeStyle);\r\n            var obj = { p: 0 };\r\n            var x1 = newShapeStyle.cpX1;\r\n            var y1 = newShapeStyle.cpY1;\r\n            var newXArr = [];\r\n            var newYArr = [];\r\n            var subdivide = curveTool.quadraticSubdivide;\r\n            zr.animation.animate(obj)\r\n                .when(duration, { p: 1 })\r\n                .during(function () {\r\n                    // Calculate subdivided curve\r\n                    subdivide(x0, x1, x2, obj.p, newXArr);\r\n                    subdivide(y0, y1, y2, obj.p, newYArr);\r\n                    newShapeStyle.cpX1 = newXArr[1];\r\n                    newShapeStyle.cpY1 = newYArr[1];\r\n                    newShapeStyle.xEnd = newXArr[2];\r\n                    newShapeStyle.yEnd = newYArr[2];\r\n                    zr.modShape(newShape);\r\n                })\r\n                .done(animationDone)\r\n                .start(easing);\r\n        }\r\n        else {\r\n            zr.animate(newShape.id, 'style')\r\n                .when(0, {\r\n                    xEnd: x0,\r\n                    yEnd: y0\r\n                })\r\n                .when(duration, {\r\n                    xEnd: x2,\r\n                    yEnd: y2\r\n                })\r\n                .done(animationDone)\r\n                .start(easing);\r\n        }\r\n    }\r\n\r\n    return {\r\n        pointList : pointList,\r\n        rectangle : rectangle,\r\n        candle : candle,\r\n        ring : ring,\r\n        sector : sector,\r\n        text : text,\r\n        polygon : polygon,\r\n        ribbon : ribbon,\r\n        gaugePointer : gaugePointer,\r\n        icon : icon,\r\n        line : line,\r\n        markline : markline\r\n    };\r\n});\r\n"
    },
    {
      "id": 40,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
      "index": 40,
      "index2": 36,
      "size": 16377,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../util/ecEffect",
          "loc": "20:19-46"
        }
      ],
      "source": "/**\r\n * echarts图表特效基类\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ecData = require('../util/ecData');\r\n    \r\n    var CircleShape = require('zrenderjs/shape/Circle');\r\n    var ImageShape = require('zrenderjs/shape/Image');\r\n    var curveTool = require('zrenderjs/tool/curve');\r\n    var IconShape = require('../util/shape/Icon');\r\n    var SymbolShape = require('../util/shape/Symbol');\r\n    var ShapeBundle = require('zrenderjs/shape/ShapeBundle');\r\n    var Polyline = require('zrenderjs/shape/Polyline');\r\n    var vec2 = require('zrenderjs/tool/vector');\r\n\r\n    var canvasSupported = require('zrenderjs/tool/env').canvasSupported;\r\n    \r\n    function point(zr, effectList, shape, zlevel) {\r\n        var effect = shape.effect;\r\n        var color = effect.color || shape.style.strokeColor || shape.style.color;\r\n        var shadowColor = effect.shadowColor || color;\r\n        var size = effect.scaleSize;\r\n        var distance = effect.bounceDistance;\r\n        var shadowBlur = typeof effect.shadowBlur != 'undefined'\r\n                         ? effect.shadowBlur : size;\r\n\r\n        var effectShape;\r\n        if (shape.type !== 'image') {\r\n            effectShape = new IconShape({\r\n                zlevel : zlevel,\r\n                style : {\r\n                    brushType : 'stroke',\r\n                    iconType : shape.style.iconType != 'droplet'\r\n                               ? shape.style.iconType\r\n                               : 'circle',\r\n                    x : shadowBlur + 1, // 线宽\r\n                    y : shadowBlur + 1,\r\n                    n : shape.style.n,\r\n                    width : shape.style._width * size,\r\n                    height : shape.style._height * size,\r\n                    lineWidth : 1,\r\n                    strokeColor : color,\r\n                    shadowColor : shadowColor,\r\n                    shadowBlur : shadowBlur\r\n                },\r\n                draggable : false,\r\n                hoverable : false\r\n            });\r\n            if (shape.style.iconType == 'pin') {\r\n                effectShape.style.y += effectShape.style.height / 2 * 1.5;\r\n            }\r\n\r\n            if (canvasSupported) {  // 提高性能，换成image\r\n                effectShape.style.image = zr.shapeToImage(\r\n                    effectShape, \r\n                    effectShape.style.width + shadowBlur * 2 + 2, \r\n                    effectShape.style.height + shadowBlur * 2 + 2\r\n                ).style.image;\r\n                \r\n                effectShape = new ImageShape({\r\n                    zlevel : effectShape.zlevel,\r\n                    style : effectShape.style,\r\n                    draggable : false,\r\n                    hoverable : false\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            effectShape = new ImageShape({\r\n                zlevel : zlevel,\r\n                style : shape.style,\r\n                draggable : false,\r\n                hoverable : false\r\n            });\r\n        }\r\n        \r\n        ecData.clone(shape, effectShape);\r\n        \r\n        // 改变坐标，不能移到前面\r\n        effectShape.position = shape.position;\r\n        effectList.push(effectShape);\r\n        zr.addShape(effectShape);\r\n        \r\n        var devicePixelRatio = shape.type !== 'image' ? (window.devicePixelRatio || 1) : 1;\r\n        var offset = (effectShape.style.width / devicePixelRatio - shape.style._width) / 2;\r\n        effectShape.style.x = shape.style._x - offset;\r\n        effectShape.style.y = shape.style._y - offset;\r\n\r\n        if (shape.style.iconType == 'pin') {\r\n            effectShape.style.y -= shape.style.height / 2 * 1.5;\r\n        }\r\n\r\n        var duration = (effect.period + Math.random() * 10) * 100;\r\n        \r\n        zr.modShape(\r\n            shape.id, \r\n            { invisible : true}\r\n        );\r\n        \r\n        var centerX = effectShape.style.x + (effectShape.style.width) / 2 / devicePixelRatio;\r\n        var centerY = effectShape.style.y + (effectShape.style.height) / 2 / devicePixelRatio;\r\n\r\n        if (effect.type === 'scale') {\r\n            // 放大效果\r\n            zr.modShape(\r\n                effectShape.id, \r\n                {\r\n                    scale : [0.1, 0.1, centerX, centerY]\r\n                }\r\n            );\r\n            \r\n            zr.animate(effectShape.id, '', effect.loop)\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        scale : [1, 1, centerX, centerY]\r\n                    }\r\n                )\r\n                .done(function() {\r\n                    shape.effect.show = false;\r\n                    zr.delShape(effectShape.id);\r\n                })\r\n                .start();\r\n        }\r\n        else {\r\n            zr.animate(effectShape.id, 'style', effect.loop)\r\n                .when(\r\n                    duration,\r\n                    {\r\n                        y : effectShape.style.y - distance\r\n                    }\r\n                )\r\n                .when(\r\n                    duration * 2,\r\n                    {\r\n                        y : effectShape.style.y\r\n                    }\r\n                )\r\n                .done(function() {\r\n                    shape.effect.show = false;\r\n                    zr.delShape(effectShape.id);\r\n                })\r\n                .start();\r\n        }\r\n        \r\n    }\r\n    \r\n    function largePoint(zr, effectList, shape, zlevel) {\r\n        var effect = shape.effect;\r\n        var color = effect.color || shape.style.strokeColor || shape.style.color;\r\n        var size = effect.scaleSize;\r\n        var shadowColor = effect.shadowColor || color;\r\n        var shadowBlur = typeof effect.shadowBlur != 'undefined'\r\n                         ? effect.shadowBlur : (size * 2);\r\n        var devicePixelRatio = window.devicePixelRatio || 1;\r\n        var effectShape = new SymbolShape({\r\n            zlevel : zlevel,\r\n            position : shape.position,\r\n            scale : shape.scale,\r\n            style : {\r\n                pointList : shape.style.pointList,\r\n                iconType : shape.style.iconType,\r\n                color : color,\r\n                strokeColor : color,\r\n                shadowColor : shadowColor,\r\n                shadowBlur : shadowBlur * devicePixelRatio,\r\n                random : true,\r\n                brushType: 'fill',\r\n                lineWidth:1,\r\n                size : shape.style.size\r\n            },\r\n            draggable : false,\r\n            hoverable : false\r\n        });\r\n        \r\n        effectList.push(effectShape);\r\n        zr.addShape(effectShape);\r\n        zr.modShape(\r\n            shape.id, \r\n            { invisible : true}\r\n        );\r\n        \r\n        var duration = Math.round(effect.period * 100);\r\n        var clip1 = {};\r\n        var clip2 = {};\r\n        for (var i = 0; i < 20; i++) {\r\n            effectShape.style['randomMap' + i] = 0;\r\n            clip1 = {};\r\n            clip1['randomMap' + i] = 100;\r\n            clip2 = {};\r\n            clip2['randomMap' + i] = 0;\r\n            effectShape.style['randomMap' + i] = Math.random() * 100;\r\n            zr.animate(effectShape.id, 'style', true)\r\n                .when(duration, clip1)\r\n                .when(duration * 2, clip2)\r\n                .when(duration * 3, clip1)\r\n                .when(duration * 4, clip1)\r\n                .delay(Math.random() * duration * i)\r\n                //.delay(duration / 15 * (15 - i + 1))\r\n                .start();\r\n            \r\n        }\r\n    }\r\n    \r\n    function line(zr, effectList, shape, zlevel, isLarge) {\r\n        var effect = shape.effect;\r\n        var shapeStyle = shape.style;\r\n        var color = effect.color || shapeStyle.strokeColor || shapeStyle.color;\r\n        var shadowColor = effect.shadowColor || shapeStyle.strokeColor || color;\r\n        var size = shapeStyle.lineWidth * effect.scaleSize;\r\n        var shadowBlur = typeof effect.shadowBlur != 'undefined'\r\n                         ? effect.shadowBlur : size;\r\n\r\n        var effectShape = new CircleShape({\r\n            zlevel : zlevel,\r\n            style : {\r\n                x : shadowBlur,\r\n                y : shadowBlur,\r\n                r : size,\r\n                color : color,\r\n                shadowColor : shadowColor,\r\n                shadowBlur : shadowBlur\r\n            },\r\n            hoverable : false\r\n        });\r\n\r\n        var offset = 0;\r\n        if (canvasSupported && ! isLarge) {  // 提高性能，换成image\r\n            var zlevel = effectShape.zlevel;\r\n            effectShape = zr.shapeToImage(\r\n                effectShape,\r\n                (size + shadowBlur) * 2,\r\n                (size + shadowBlur) * 2\r\n            );\r\n            effectShape.zlevel = zlevel;\r\n            effectShape.hoverable = false;\r\n\r\n            offset = shadowBlur;\r\n        }\r\n\r\n        if (! isLarge) {\r\n            ecData.clone(shape, effectShape);\r\n            // 改变坐标， 不能移到前面\r\n            effectShape.position = shape.position;\r\n            effectList.push(effectShape);\r\n            zr.addShape(effectShape);\r\n        }\r\n\r\n        var effectDone = function () {\r\n            if (! isLarge) {\r\n                shape.effect.show = false;\r\n                zr.delShape(effectShape.id);   \r\n            }\r\n            effectShape.effectAnimator = null;\r\n        };\r\n\r\n        if (shape instanceof Polyline) {\r\n            var distanceList = [0];\r\n            var totalDist = 0;\r\n            var pointList = shapeStyle.pointList;\r\n            var controlPointList = shapeStyle.controlPointList;\r\n            for (var i = 1; i < pointList.length; i++) {\r\n                if (controlPointList) {\r\n                    var cp1 = controlPointList[(i - 1) * 2];\r\n                    var cp2 = controlPointList[(i - 1) * 2 + 1];\r\n                    totalDist += vec2.dist(pointList[i - 1], cp1)\r\n                         + vec2.dist(cp1, cp2)\r\n                         + vec2.dist(cp2, pointList[i]);\r\n                }\r\n                else {\r\n                    totalDist += vec2.dist(pointList[i - 1], pointList[i]);\r\n                }\r\n                distanceList.push(totalDist);\r\n            }\r\n            var obj = { p: 0 };\r\n            var animator = zr.animation.animate(obj, { loop: effect.loop });\r\n\r\n            for (var i = 0; i < distanceList.length; i++) {\r\n                animator.when(distanceList[i] * effect.period, { p: i });\r\n            }\r\n            animator.during(function () {\r\n                var i = Math.floor(obj.p);\r\n                var x, y;\r\n                if (i == pointList.length - 1) {\r\n                    x = pointList[i][0];\r\n                    y = pointList[i][1];\r\n                }\r\n                else {\r\n                    var t = obj.p - i;\r\n                    var p0 = pointList[i];\r\n                    var p1 = pointList[i + 1];\r\n                    if (controlPointList) {\r\n                        var cp1 = controlPointList[i * 2];\r\n                        var cp2 = controlPointList[i * 2 + 1];\r\n                        x = curveTool.cubicAt(\r\n                            p0[0], cp1[0], cp2[0], p1[0], t\r\n                        );\r\n                        y = curveTool.cubicAt(\r\n                            p0[1], cp1[1], cp2[1], p1[1], t\r\n                        );\r\n                    }\r\n                    else {\r\n                        x = (p1[0] - p0[0]) * t + p0[0];\r\n                        y = (p1[1] - p0[1]) * t + p0[1];   \r\n                    }\r\n                }\r\n                effectShape.style.x = x;\r\n                effectShape.style.y = y;\r\n                if (! isLarge) {\r\n                    zr.modShape(effectShape);\r\n                }\r\n            })\r\n            .done(effectDone)\r\n            .start();\r\n\r\n            animator.duration = totalDist * effect.period;\r\n\r\n            effectShape.effectAnimator = animator;\r\n        }\r\n        else {\r\n            var x0 = shapeStyle.xStart - offset;\r\n            var y0 = shapeStyle.yStart - offset;\r\n            var x2 = shapeStyle.xEnd - offset;\r\n            var y2 = shapeStyle.yEnd - offset;\r\n            effectShape.style.x = x0;\r\n            effectShape.style.y = y0;\r\n\r\n            var distance = (x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0);\r\n            var duration = Math.round(Math.sqrt(Math.round(\r\n                distance * effect.period * effect.period\r\n            )));\r\n\r\n            if (shape.style.curveness > 0) {\r\n                var x1 = shapeStyle.cpX1 - offset;\r\n                var y1 = shapeStyle.cpY1 - offset;\r\n                effectShape.effectAnimator = zr.animation.animate(effectShape, { loop: effect.loop })\r\n                    .when(duration, { p: 1 })\r\n                    .during(function (target, t) {\r\n                        effectShape.style.x = curveTool.quadraticAt(\r\n                            x0, x1, x2, t\r\n                        );\r\n                        effectShape.style.y = curveTool.quadraticAt(\r\n                            y0, y1, y2, t\r\n                        );\r\n                        if (! isLarge) {\r\n                            zr.modShape(effectShape);\r\n                        }\r\n                    })\r\n                    .done(effectDone)\r\n                    .start();\r\n            }\r\n            else {\r\n                // 不用 zr.animate，因为在用 ShapeBundle 的时候单个 effectShape 不会\r\n                // 被加到 zrender 中\r\n                effectShape.effectAnimator = zr.animation.animate(effectShape.style, { loop: effect.loop })\r\n                    .when(duration, {\r\n                        x: x2,\r\n                        y: y2\r\n                    })\r\n                    .during(function () {\r\n                        if (! isLarge) {\r\n                            zr.modShape(effectShape);\r\n                        }\r\n                    })\r\n                    .done(effectDone)\r\n                    .start();\r\n            }\r\n            effectShape.effectAnimator.duration = duration;\r\n        }\r\n        return effectShape;\r\n    }\r\n\r\n    function largeLine(zr, effectList, shape, zlevel) {\r\n        var effectShape = new ShapeBundle({\r\n            style: {\r\n                shapeList: []\r\n            },\r\n            zlevel: zlevel,\r\n            hoverable: false\r\n        });\r\n        var shapeList = shape.style.shapeList;\r\n        var effect = shape.effect;\r\n        effectShape.position = shape.position;\r\n\r\n        var maxDuration = 0;\r\n        var subEffectAnimators = [];\r\n        for (var i = 0; i < shapeList.length; i++) {\r\n            shapeList[i].effect = effect;\r\n            var subEffectShape = line(zr, null, shapeList[i], zlevel, true);\r\n            var subEffectAnimator = subEffectShape.effectAnimator;\r\n            effectShape.style.shapeList.push(subEffectShape);\r\n            if (subEffectAnimator.duration > maxDuration) {\r\n                maxDuration = subEffectAnimator.duration;\r\n            }\r\n            if (i === 0) {\r\n                effectShape.style.color = subEffectShape.style.color;\r\n                effectShape.style.shadowBlur = subEffectShape.style.shadowBlur;\r\n                effectShape.style.shadowColor = subEffectShape.style.shadowColor;\r\n            }\r\n            subEffectAnimators.push(subEffectAnimator);\r\n        }\r\n        effectList.push(effectShape);\r\n        zr.addShape(effectShape);\r\n\r\n        var clearAllAnimators = function () {\r\n            for (var i = 0; i < subEffectAnimators.length; i++) {\r\n                subEffectAnimators[i].stop();\r\n            }\r\n        };\r\n        if (maxDuration) {\r\n            effectShape.__dummy = 0;\r\n            // Proxy animator\r\n            var animator = zr.animate(effectShape.id, '', effect.loop)\r\n                .when(maxDuration, {\r\n                    __dummy: 1\r\n                })\r\n                .during(function () {\r\n                    zr.modShape(effectShape);\r\n                })\r\n                .done(function () {\r\n                    shape.effect.show = false;\r\n                    zr.delShape(effectShape.id);\r\n                })\r\n                .start();\r\n            var oldStop = animator.stop;\r\n\r\n            animator.stop = function () {\r\n                clearAllAnimators();\r\n                oldStop.call(this);\r\n            };\r\n        }\r\n    }\r\n\r\n    return {\r\n        point : point,\r\n        largePoint : largePoint,\r\n        line : line,\r\n        largeLine: largeLine\r\n    };\r\n});\r\n"
    },
    {
      "id": 41,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Circle.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Circle.js",
      "index": 41,
      "index2": 34,
      "size": 4026,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Circle",
          "loc": "11:22-55"
        },
        {
          "moduleId": 64,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Circle",
          "loc": "12:22-55"
        }
      ],
      "source": "/**\r\n * 圆形\r\n * @module zrender/shape/Circle\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *   var Circle = require('zrender/shape/Circle');\r\n *   var shape = new Circle({\r\n *       style: {\r\n *           x: 100,\r\n *           y: 100,\r\n *           r: 40,\r\n *           brushType: 'both',\r\n *           color: 'blue',\r\n *           strokeColor: 'red',\r\n *           lineWidth: 3,\r\n *           text: 'Circle'\r\n *       }    \r\n *   });\r\n *   zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} ICircleStyle\r\n * @property {number} x 圆心x坐标\r\n * @property {number} y 圆心y坐标\r\n * @property {number} r 半径\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        'use strict';\r\n\r\n        var Base = require('./Base');\r\n\r\n        /**\r\n         * @alias module:zrender/shape/Circle\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Circle = function(options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 圆形绘制样式\r\n             * @name module:zrender/shape/Circle#style\r\n             * @type {module:zrender/shape/Circle~ICircleStyle}\r\n             */\r\n            /**\r\n             * 圆形高亮绘制样式\r\n             * @name module:zrender/shape/Circle#highlightStyle\r\n             * @type {module:zrender/shape/Circle~ICircleStyle}\r\n             */\r\n        };\r\n\r\n        Circle.prototype = {\r\n            type: 'circle',\r\n            /**\r\n             * 创建圆形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {module:zrender/shape/Circle~ICircleStyle} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                // Better stroking in ShapeBundle\r\n                ctx.moveTo(style.x + style.r, style.y);\r\n                ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, true);\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 计算返回圆形的包围盒矩形\r\n             * @param {module:zrender/shape/Circle~ICircleStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var lineWidth;\r\n                if (style.brushType == 'stroke' || style.brushType == 'fill') {\r\n                    lineWidth = style.lineWidth || 1;\r\n                }\r\n                else {\r\n                    lineWidth = 0;\r\n                }\r\n                style.__rect = {\r\n                    x : Math.round(style.x - style.r - lineWidth / 2),\r\n                    y : Math.round(style.y - style.r - lineWidth / 2),\r\n                    width : style.r * 2 + lineWidth,\r\n                    height : style.r * 2 + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Circle, Base);\r\n        return Circle;\r\n    }\r\n);\r\n"
    },
    {
      "id": 42,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\env.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/env.js",
      "index": 42,
      "index2": 35,
      "size": 4079,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 40,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecEffect.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecEffect.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/env",
          "loc": "20:26-55"
        },
        {
          "moduleId": 44,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/env",
          "loc": "56:25-54"
        }
      ],
      "source": "/**\r\n * echarts设备环境识别\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author firede[firede@firede.us]\r\n * @desc thanks zepto.\r\n */\r\ndefine(function() {\r\n    // Zepto.js\r\n    // (c) 2010-2013 Thomas Fuchs\r\n    // Zepto.js may be freely distributed under the MIT license.\r\n\r\n    function detect(ua) {\r\n        var os = this.os = {};\r\n        var browser = this.browser = {};\r\n        var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\r\n        var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\r\n        var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\r\n        var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\r\n        var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\r\n        var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\r\n        var touchpad = webos && ua.match(/TouchPad/);\r\n        var kindle = ua.match(/Kindle\\/([\\d.]+)/);\r\n        var silk = ua.match(/Silk\\/([\\d._]+)/);\r\n        var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\r\n        var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\r\n        var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\r\n        var playbook = ua.match(/PlayBook/);\r\n        var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\r\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\r\n        var ie = ua.match(/MSIE ([\\d.]+)/);\r\n        var safari = webkit && ua.match(/Mobile\\//) && !chrome;\r\n        var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\r\n        var ie = ua.match(/MSIE\\s([\\d.]+)/);\r\n\r\n        // Todo: clean this up with a better OS/browser seperation:\r\n        // - discern (more) between multiple browsers on android\r\n        // - decide if kindle fire in silk mode is android or not\r\n        // - Firefox on Android doesn't specify the Android version\r\n        // - possibly devide in os, device and browser hashes\r\n\r\n        if (browser.webkit = !!webkit) browser.version = webkit[1];\r\n\r\n        if (android) os.android = true, os.version = android[2];\r\n        if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\r\n        if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\r\n        if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\r\n        if (webos) os.webos = true, os.version = webos[2];\r\n        if (touchpad) os.touchpad = true;\r\n        if (blackberry) os.blackberry = true, os.version = blackberry[2];\r\n        if (bb10) os.bb10 = true, os.version = bb10[2];\r\n        if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\r\n        if (playbook) browser.playbook = true;\r\n        if (kindle) os.kindle = true, os.version = kindle[1];\r\n        if (silk) browser.silk = true, browser.version = silk[1];\r\n        if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\r\n        if (chrome) browser.chrome = true, browser.version = chrome[1];\r\n        if (firefox) browser.firefox = true, browser.version = firefox[1];\r\n        if (ie) browser.ie = true, browser.version = ie[1];\r\n        if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\r\n        if (webview) browser.webview = true;\r\n        if (ie) browser.ie = true, browser.version = ie[1];\r\n\r\n        os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\r\n            (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\r\n        os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 ||\r\n            (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\r\n            (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\r\n\r\n        return {\r\n            browser: browser,\r\n            os: os,\r\n            // 原生canvas支持，改极端点了\r\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\r\n            canvasSupported : document.createElement('canvas').getContext ? true : false\r\n        };\r\n    }\r\n\r\n    return detect(navigator.userAgent);\r\n});"
    },
    {
      "id": 43,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\accMath.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/accMath.js",
      "index": 43,
      "index2": 37,
      "size": 2091,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../util/accMath",
          "loc": "21:18-44"
        },
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "../util/accMath",
          "loc": "763:26-52"
        },
        {
          "moduleId": 64,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "../util/accMath",
          "loc": "82:26-52"
        }
      ],
      "source": "/**\r\n * 高精度数学运算\r\n */\r\ndefine(function() {\r\n    // 除法函数，用来得到精确的除法结果 \r\n    // 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 \r\n    // 调用：accDiv(arg1,arg2) \r\n    // 返回值：arg1除以arg2的精确结果\r\n    function accDiv(arg1,arg2){\r\n        var s1 = arg1.toString();\r\n        var s2 = arg2.toString(); \r\n        var m = 0;\r\n        try {\r\n            m = s2.split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        try {\r\n            m -= s1.split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        \r\n        return (s1.replace('.', '') - 0) / (s2.replace('.', '') - 0) * Math.pow(10, m);\r\n    }\r\n\r\n    // 乘法函数，用来得到精确的乘法结果\r\n    // 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 \r\n    // 调用：accMul(arg1,arg2) \r\n    // 返回值：arg1乘以arg2的精确结果\r\n    function accMul(arg1, arg2) {\r\n        var s1 = arg1.toString();\r\n        var s2 = arg2.toString();\r\n        var m = 0;\r\n        try {\r\n            m += s1.split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        try {\r\n            m += s2.split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        \r\n        return (s1.replace('.', '') - 0) * (s2.replace('.', '') - 0) / Math.pow(10, m);\r\n    }\r\n\r\n    // 加法函数，用来得到精确的加法结果 \r\n    // 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 \r\n    // 调用：accAdd(arg1,arg2) \r\n    // 返回值：arg1加上arg2的精确结果 \r\n    function accAdd(arg1, arg2) {\r\n        var r1 = 0;\r\n        var r2 = 0;\r\n        try {\r\n            r1 = arg1.toString().split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        try {\r\n            r2 = arg2.toString().split('.')[1].length;\r\n        }\r\n        catch(e) {}\r\n        \r\n        var m = Math.pow(10, Math.max(r1, r2));\r\n        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m; \r\n    }\r\n\r\n    //减法函数，用来得到精确的减法结果 \r\n    //说明：javascript的减法结果会有误差，在两个浮点数减法的时候会比较明显。这个函数返回较为精确的减法结果。 \r\n    //调用：accSub(arg1,arg2) \r\n    //返回值：arg1减法arg2的精确结果 \r\n    function accSub(arg1,arg2) {\r\n        return accAdd(arg1, -arg2);\r\n    }\r\n\r\n    return {\r\n        accDiv : accDiv,\r\n        accMul : accMul,\r\n        accAdd : accAdd,\r\n        accSub : accSub\r\n    };\r\n});"
    },
    {
      "id": 44,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
      "index": 44,
      "index2": 40,
      "size": 7851,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../component/base",
          "loc": "22:24-52"
        },
        {
          "moduleId": 51,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "type": "cjs require",
          "userRequest": "./base",
          "loc": "17:15-32"
        },
        {
          "moduleId": 52,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "type": "cjs require",
          "userRequest": "./base",
          "loc": "9:15-32"
        },
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "./base",
          "loc": "9:15-32"
        },
        {
          "moduleId": 59,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "type": "cjs require",
          "userRequest": "./base",
          "loc": "9:15-32"
        },
        {
          "moduleId": 60,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "type": "cjs require",
          "userRequest": "./base",
          "loc": "9:15-32"
        }
      ],
      "source": "/**\r\n * echarts组件基类\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ecConfig = require('../config');\r\n    var ecData = require('../util/ecData');\r\n    var ecQuery = require('../util/ecQuery');\r\n    var number = require('../util/number');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    \r\n    function Base(ecTheme, messageCenter, zr, option, myChart){\r\n        this.ecTheme = ecTheme;\r\n        this.messageCenter = messageCenter;\r\n        this.zr =zr;\r\n        this.option = option;\r\n        this.series = option.series;\r\n        this.myChart = myChart;\r\n        this.component = myChart.component;\r\n\r\n        this.shapeList = [];\r\n        this.effectList = [];\r\n        \r\n        var self = this;\r\n        \r\n        self._onlegendhoverlink = function(param) {\r\n            if (self.legendHoverLink) {\r\n                var targetName = param.target;\r\n                var name;\r\n                for (var i = self.shapeList.length - 1; i >= 0; i--) {\r\n                    name = self.type == ecConfig.CHART_TYPE_PIE\r\n                           || self.type == ecConfig.CHART_TYPE_FUNNEL\r\n                           ? ecData.get(self.shapeList[i], 'name')\r\n                           : (ecData.get(self.shapeList[i], 'series') || {}).name;\r\n                    if (name == targetName \r\n                        && !self.shapeList[i].invisible \r\n                        && !self.shapeList[i].__animating\r\n                    ) {\r\n                        self.zr.addHoverShape(self.shapeList[i]);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        messageCenter && messageCenter.bind(\r\n            ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 基类方法\r\n     */\r\n    Base.prototype = {\r\n        canvasSupported: require('zrenderjs/tool/env').canvasSupported,\r\n        _getZ : function(zWhat) {\r\n            if (this[zWhat] != null) {\r\n                return this[zWhat];\r\n            }\r\n            var opt = this.ecTheme[this.type];\r\n            if (opt && opt[zWhat] != null) {\r\n                return opt[zWhat];\r\n            }\r\n            opt = ecConfig[this.type];\r\n            if (opt && opt[zWhat] != null) {\r\n                return opt[zWhat];\r\n            }\r\n            return 0;\r\n        },\r\n\r\n        /**\r\n         * 获取zlevel基数配置\r\n         */\r\n        getZlevelBase: function () {\r\n            return this._getZ('zlevel');\r\n        },\r\n        \r\n        /**\r\n         * 获取z基数配置\r\n         */\r\n        getZBase: function() {\r\n            return this._getZ('z');\r\n        },\r\n\r\n        /**\r\n         * 参数修正&默认值赋值\r\n         * @param {Object} opt 参数\r\n         *\r\n         * @return {Object} 修正后的参数\r\n         */\r\n        reformOption: function (opt) {\r\n            // 默认配置项动态多级合并，依赖加载的组件选项未被merge到ecTheme里，需要从config里取\r\n            opt = zrUtil.merge(\r\n                       zrUtil.merge(\r\n                           opt || {},\r\n                           zrUtil.clone(this.ecTheme[this.type] || {})\r\n                       ),\r\n                       zrUtil.clone(ecConfig[this.type] || {})\r\n                   );\r\n            this.z = opt.z;\r\n            this.zlevel = opt.zlevel;\r\n            return opt;\r\n        },\r\n        \r\n        /**\r\n         * css类属性数组补全，如padding，margin等~\r\n         */\r\n        reformCssArray: function (p) {\r\n            if (p instanceof Array) {\r\n                switch (p.length + '') {\r\n                    case '4':\r\n                        return p;\r\n                    case '3':\r\n                        return [p[0], p[1], p[2], p[1]];\r\n                    case '2':\r\n                        return [p[0], p[1], p[0], p[1]];\r\n                    case '1':\r\n                        return [p[0], p[0], p[0], p[0]];\r\n                    case '0':\r\n                        return [0, 0, 0, 0];\r\n                }\r\n            }\r\n            else {\r\n                return [p, p, p, p];\r\n            }\r\n        },\r\n        \r\n        getShapeById: function(id) {\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                if (this.shapeList[i].id === id) {\r\n                    return this.shapeList[i];\r\n                }\r\n            }\r\n            return null;\r\n        },\r\n        \r\n        /**\r\n         * 获取自定义和默认配置合并后的字体设置\r\n         */\r\n        getFont: function (textStyle) {\r\n            var finalTextStyle = this.getTextStyle(\r\n                zrUtil.clone(textStyle)\r\n            );\r\n            return finalTextStyle.fontStyle + ' '\r\n                   + finalTextStyle.fontWeight + ' '\r\n                   + finalTextStyle.fontSize + 'px '\r\n                   + finalTextStyle.fontFamily;\r\n        },\r\n\r\n        /**\r\n         * 获取统一主题字体样式\r\n         */\r\n        getTextStyle: function(targetStyle) {\r\n            return zrUtil.merge(\r\n                       zrUtil.merge(\r\n                           targetStyle || {},\r\n                           this.ecTheme.textStyle\r\n                       ),\r\n                       ecConfig.textStyle\r\n                   );\r\n        },\r\n        \r\n        getItemStyleColor: function (itemColor, seriesIndex, dataIndex, data) {\r\n            return typeof itemColor === 'function'\r\n                   ? itemColor.call(\r\n                        this.myChart,\r\n                        {\r\n                            seriesIndex: seriesIndex,\r\n                            series: this.series[seriesIndex],\r\n                            dataIndex: dataIndex,\r\n                            data: data\r\n                        }\r\n                   )\r\n                   : itemColor;\r\n            \r\n        }, \r\n\r\n        /**\r\n         * @parmas {object | number} data 目标data\r\n         * @params {string= | number=} defaultData 无数据时默认返回\r\n         */\r\n        getDataFromOption: function (data, defaultData) {\r\n            return data != null ? (data.value != null ? data.value : data) : defaultData;\r\n        },\r\n        \r\n        // 亚像素优化\r\n        subPixelOptimize: function (position, lineWidth) {\r\n            if (lineWidth % 2 === 1) {\r\n                //position += position === Math.ceil(position) ? 0.5 : 0;\r\n                position = Math.floor(position) + 0.5;\r\n            }\r\n            else {\r\n                position = Math.round(position);\r\n            }\r\n            return position;\r\n        },\r\n        \r\n        // 默认resize\r\n        resize: function () {\r\n            this.refresh && this.refresh();\r\n            this.clearEffectShape && this.clearEffectShape(true);\r\n            var self = this;\r\n            setTimeout(function(){\r\n                self.animationEffect && self.animationEffect();\r\n            },200);\r\n        },\r\n\r\n        /**\r\n         * 清除图形数据，实例仍可用\r\n         */\r\n        clear :function () {\r\n            this.clearEffectShape && this.clearEffectShape();\r\n            this.zr && this.zr.delShape(this.shapeList);\r\n            this.shapeList = [];\r\n        },\r\n\r\n        /**\r\n         * 释放后实例不可用\r\n         */\r\n        dispose: function () {\r\n            this.onbeforDispose && this.onbeforDispose();\r\n            this.clear();\r\n            this.shapeList = null;\r\n            this.effectList = null;\r\n            this.messageCenter && this.messageCenter.unbind(\r\n                ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink\r\n            );\r\n            this.onafterDispose && this.onafterDispose();\r\n        },\r\n        \r\n        query: ecQuery.query,\r\n        deepQuery: ecQuery.deepQuery,\r\n        deepMerge: ecQuery.deepMerge,\r\n        \r\n        parsePercent: number.parsePercent,\r\n        parseCenter: number.parseCenter,\r\n        parseRadius: number.parseRadius,\r\n        numAddCommas: number.addCommas,\r\n\r\n        getPrecision: number.getPrecision\r\n    };\r\n    \r\n    return Base;\r\n});\r\n"
    },
    {
      "id": 45,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\ecQuery.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/ecQuery.js",
      "index": 45,
      "index2": 38,
      "size": 2215,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 44,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "type": "cjs require",
          "userRequest": "../util/ecQuery",
          "loc": "11:18-44"
        }
      ],
      "source": "/**\r\n * echarts层级查找方法\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function(require) {\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    \r\n    /**\r\n     * 获取嵌套选项的基础方法\r\n     * 返回optionTarget中位于optionLocation上的值，如果没有定义，则返回undefined\r\n     */\r\n    function query(optionTarget, optionLocation) {\r\n        if (typeof optionTarget == 'undefined') {\r\n            return;\r\n        }\r\n\r\n        if (!optionLocation) {\r\n            return optionTarget;\r\n        }\r\n\r\n        optionLocation = optionLocation.split('.');\r\n        var length = optionLocation.length;\r\n        var curIdx = 0;\r\n        while (curIdx < length) {\r\n            optionTarget = optionTarget[optionLocation[curIdx]];\r\n            if (typeof optionTarget == 'undefined') {\r\n                return;\r\n            }\r\n            curIdx++;\r\n        }\r\n\r\n        return optionTarget;\r\n    }\r\n        \r\n    /**\r\n     * 获取多级控制嵌套属性的基础方法\r\n     * 返回ctrList中优先级最高（最靠前）的非undefined属性，ctrList中均无定义则返回undefined\r\n     */\r\n    function deepQuery(ctrList, optionLocation) {\r\n        var finalOption;\r\n        for (var i = 0, l = ctrList.length; i < l; i++) {\r\n            finalOption = query(ctrList[i], optionLocation);\r\n            if (typeof finalOption != 'undefined') {\r\n                return finalOption;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 获取多级控制嵌套属性的基础方法\r\n     * 根据ctrList中优先级合并产出目标属性\r\n     */\r\n    function deepMerge(ctrList, optionLocation) {\r\n        var finalOption;\r\n        var len = ctrList.length;\r\n        while (len--) {\r\n            var tempOption = query(ctrList[len], optionLocation);\r\n            if (typeof tempOption != 'undefined') {\r\n                if (typeof finalOption == 'undefined') {\r\n                    finalOption = zrUtil.clone(tempOption);\r\n                }\r\n                else {\r\n                    zrUtil.merge(\r\n                        finalOption, tempOption, true\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        \r\n        return finalOption;\r\n    }\r\n    \r\n    return {\r\n        query : query,\r\n        deepQuery : deepQuery,\r\n        deepMerge : deepMerge\r\n    };\r\n});\r\n"
    },
    {
      "id": 46,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\number.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/number.js",
      "index": 46,
      "index2": 39,
      "size": 2235,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 44,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/base.js",
          "type": "cjs require",
          "userRequest": "../util/number",
          "loc": "12:17-42"
        },
        {
          "moduleId": 58,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\smartLogSteps.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/util/smartLogSteps.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/util/smartLogSteps.js",
          "type": "cjs require",
          "userRequest": "./number",
          "loc": "11:17-36"
        }
      ],
      "source": "/**\r\n * echarts数字运算相关\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function() {\r\n    function _trim(str) {\r\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n    }\r\n    \r\n    /**\r\n     * 百分比计算\r\n     */\r\n    function parsePercent(value, maxValue) {\r\n        if (typeof value === 'string') {\r\n            if (_trim(value).match(/%$/)) {\r\n                return parseFloat(value) / 100 * maxValue;\r\n            }\r\n\r\n            return parseFloat(value);\r\n        }\r\n\r\n        return value;\r\n    }\r\n    \r\n    /**\r\n     * 获取中心坐标\r\n     */ \r\n    function parseCenter(zr, center) {\r\n        return [\r\n            parsePercent(center[0], zr.getWidth()),\r\n            parsePercent(center[1], zr.getHeight())\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * 获取自适应半径\r\n     */ \r\n    function parseRadius(zr, radius) {\r\n        // 传数组实现环形图，[内半径，外半径]，传单个则默认为外半径为\r\n        if (!(radius instanceof Array)) {\r\n            radius = [0, radius];\r\n        }\r\n        var zrSize = Math.min(zr.getWidth(), zr.getHeight()) / 2;\r\n        return [\r\n            parsePercent(radius[0], zrSize),\r\n            parsePercent(radius[1], zrSize)\r\n        ];\r\n    }\r\n    \r\n    /**\r\n     * 每三位默认加,格式化\r\n     */\r\n    function addCommas(x) {\r\n        if (isNaN(x)) {\r\n            return '-';\r\n        }\r\n        x = (x + '').split('.');\r\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,') \r\n               + (x.length > 1 ? ('.' + x[1]) : '');\r\n    }\r\n\r\n    /**\r\n     * 获取数字的小数位数\r\n     * @param {number} val\r\n     */\r\n    \r\n    // It is much faster than methods converting number to string as follows \r\n    //      var tmp = val.toString();\r\n    //      return tmp.length - 1 - tmp.indexOf('.');\r\n    // especially when precision is low\r\n    function getPrecision(val) {\r\n        var e = 1;\r\n        var count = 0;\r\n        while (Math.round(val * e) / e !== val) {\r\n            e *= 10;\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n    \r\n    return {\r\n        parsePercent: parsePercent,\r\n        parseCenter: parseCenter,\r\n        parseRadius: parseRadius,\r\n        addCommas: addCommas,\r\n        getPrecision: getPrecision\r\n    };\r\n});"
    },
    {
      "id": 47,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\layout\\EdgeBundling.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
      "index": 47,
      "index2": 43,
      "size": 15154,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 5,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
          "type": "cjs require",
          "userRequest": "../layout/EdgeBundling",
          "loc": "23:23-56"
        }
      ],
      "source": "/**\r\n * Edge bundling laytout\r\n *\r\n * Use MINGLE algorithm\r\n * Multilevel agglomerative edge bundling for visualizing large graphs\r\n *\r\n * @module echarts/layout/EdgeBundling\r\n */\r\ndefine(function (require) {\r\n\r\n    var KDTree = require('../data/KDTree');\r\n    var vec2 = require('zrenderjs/tool/vector');\r\n    var v2Create = vec2.create;\r\n    var v2DistSquare = vec2.distSquare;\r\n    var v2Dist = vec2.dist;\r\n    var v2Copy = vec2.copy;\r\n    var v2Clone = vec2.clone;\r\n\r\n    function squaredDistance(a, b) {\r\n        a = a.array;\r\n        b = b.array;\r\n\r\n        var x = b[0] - a[0];\r\n        var y = b[1] - a[1];\r\n        var z = b[2] - a[2];\r\n        var w = b[3] - a[3];\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n    }\r\n\r\n    function CoarsenedEdge(group) {\r\n        this.points = [\r\n            group.mp0, group.mp1\r\n        ];\r\n\r\n        this.group = group;\r\n    }\r\n\r\n    function Edge(edge) {\r\n        var points = edge.points;\r\n        // Sort on y\r\n        if (\r\n            points[0][1] < points[1][1]\r\n            // If coarsened edge is flipped, the final composition of meet point\r\n            // will be unordered\r\n            || edge instanceof CoarsenedEdge\r\n        ) {\r\n            this.array = [points[0][0], points[0][1], points[1][0], points[1][1]];\r\n            this._startPoint = points[0];\r\n            this._endPoint = points[1];\r\n        }\r\n        else {\r\n            this.array = [points[1][0], points[1][1], points[0][0], points[0][1]];\r\n            this._startPoint = points[1];\r\n            this._endPoint = points[0];\r\n        }\r\n\r\n        this.ink = v2Dist(points[0], points[1]);\r\n\r\n        this.edge = edge;\r\n\r\n        this.group = null;\r\n    }\r\n\r\n    Edge.prototype.getStartPoint = function () {\r\n        return this._startPoint;\r\n    };\r\n\r\n    Edge.prototype.getEndPoint = function () {\r\n        return this._endPoint;\r\n    };\r\n\r\n    function BundledEdgeGroup() {\r\n\r\n        this.edgeList = [];\r\n\r\n        this.mp0 = v2Create();\r\n        this.mp1 = v2Create();\r\n\r\n        this.ink = 0;\r\n    }\r\n\r\n    BundledEdgeGroup.prototype.addEdge = function (edge) {\r\n        edge.group = this;\r\n        this.edgeList.push(edge);\r\n    };\r\n\r\n    BundledEdgeGroup.prototype.removeEdge = function (edge) {\r\n        edge.group = null;\r\n        this.edgeList.splice(this.edgeList.indexOf(edge), 1);\r\n    };\r\n\r\n    /**\r\n     * @constructor\r\n     * @alias module:echarts/layout/EdgeBundling\r\n     */\r\n    function EdgeBundling() {\r\n        this.maxNearestEdge = 6;\r\n        this.maxTurningAngle = Math.PI / 4;\r\n        this.maxIteration = 20;\r\n    }\r\n\r\n    EdgeBundling.prototype = {\r\n        \r\n        constructor: EdgeBundling,\r\n\r\n        run: function (rawEdges) {\r\n            var res = this._iterate(rawEdges);\r\n            var nIterate = 0;\r\n            while (nIterate++ < this.maxIteration) {\r\n                var coarsenedEdges = [];\r\n                for (var i = 0; i < res.groups.length; i++) {\r\n                    coarsenedEdges.push(new CoarsenedEdge(res.groups[i]));\r\n                }\r\n                var newRes = this._iterate(coarsenedEdges);\r\n                if (newRes.savedInk <= 0) {\r\n                    break;\r\n                } else {\r\n                    res = newRes;\r\n                }\r\n            }\r\n\r\n            // Get new edges\r\n            var newEdges = [];\r\n\r\n            function pointApproxEqual(p0, p1) {\r\n                // Use Float32Array may affect the precision\r\n                return v2DistSquare(p0, p1) < 1e-10;\r\n            }\r\n            // Clone all points to make sure all points in edge will not reference to the same array\r\n            // And clean the duplicate points\r\n            function cleanEdgePoints(edgePoints, rawEdgePoints) {\r\n                var res = [];\r\n                var off = 0;\r\n                for (var i = 0; i < edgePoints.length; i++) {\r\n                    if (! (off > 0 && pointApproxEqual(edgePoints[i], res[off - 1]))) {\r\n                        res[off++] = v2Clone(edgePoints[i]);\r\n                    }\r\n                }\r\n                // Edge has been reversed\r\n                if (rawEdgePoints[0] && !pointApproxEqual(res[0], rawEdgePoints[0])) {\r\n                    res = res.reverse();\r\n                }\r\n                return res;\r\n            }\r\n\r\n            var buildNewEdges = function (groups, fromEdgePoints) {\r\n                var newEdgePoints;\r\n                for (var i = 0; i < groups.length; i++) {\r\n                    var group = groups[i];\r\n                    if (\r\n                        group.edgeList[0]\r\n                        && (group.edgeList[0].edge instanceof CoarsenedEdge)\r\n                    ) {\r\n                        var newGroups = [];\r\n                        for (var j = 0; j < group.edgeList.length; j++) {\r\n                            newGroups.push(group.edgeList[j].edge.group);\r\n                        }\r\n                        if (! fromEdgePoints) {\r\n                            newEdgePoints = [];\r\n                        } else {\r\n                            newEdgePoints = fromEdgePoints.slice();\r\n                        }\r\n                        newEdgePoints.unshift(group.mp0);\r\n                        newEdgePoints.push(group.mp1);\r\n                        buildNewEdges(newGroups, newEdgePoints);\r\n                    } else {\r\n                        // console.log(group.edgeList.length);\r\n                        for (var j = 0; j < group.edgeList.length; j++) {\r\n                            var edge = group.edgeList[j];\r\n                            if (! fromEdgePoints) {\r\n                                newEdgePoints = [];\r\n                            } else {\r\n                                newEdgePoints = fromEdgePoints.slice();\r\n                            }\r\n                            newEdgePoints.unshift(group.mp0);\r\n                            newEdgePoints.push(group.mp1);\r\n                            newEdgePoints.unshift(edge.getStartPoint());\r\n                            newEdgePoints.push(edge.getEndPoint());\r\n                            newEdges.push({\r\n                                points: cleanEdgePoints(newEdgePoints, edge.edge.points),\r\n                                rawEdge: edge.edge\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            buildNewEdges(res.groups);\r\n\r\n            return newEdges;\r\n        },\r\n\r\n        _iterate: function (rawEdges) {\r\n            var edges = [];\r\n            var groups = [];\r\n            var totalSavedInk = 0;\r\n            for (var i = 0; i < rawEdges.length; i++) {\r\n                var edge = new Edge(rawEdges[i]);\r\n                edges.push(edge);\r\n            }\r\n\r\n            var tree = new KDTree(edges, 4);\r\n\r\n            var nearests = [];\r\n\r\n            var _mp0 = v2Create();\r\n            var _mp1 = v2Create();\r\n            var _newGroupInk = 0;\r\n            var mp0 = v2Create();\r\n            var mp1 = v2Create();\r\n            var newGroupInk = 0;\r\n            for (var i = 0; i < edges.length; i++) {\r\n                var edge = edges[i];\r\n                if (edge.group) {\r\n                    // Edge have been groupped\r\n                    continue;\r\n                }\r\n                tree.nearestN(\r\n                    edge, this.maxNearestEdge,\r\n                    squaredDistance, nearests\r\n                );\r\n                var maxSavedInk = 0;\r\n                var mostSavingInkEdge = null;\r\n                var lastCheckedGroup = null;\r\n                for (var j = 0; j < nearests.length; j++) {\r\n                    var nearest = nearests[j];\r\n                    var savedInk = 0;\r\n                    if (nearest.group) {\r\n                        if (nearest.group !== lastCheckedGroup) {\r\n                            lastCheckedGroup = nearest.group;\r\n                            _newGroupInk = this._calculateGroupEdgeInk(\r\n                                nearest.group, edge, _mp0, _mp1\r\n                            );\r\n                            savedInk = nearest.group.ink + edge.ink - _newGroupInk;\r\n                        }\r\n                    }\r\n                    else {\r\n                        _newGroupInk = this._calculateEdgeEdgeInk(\r\n                            edge, nearest, _mp0, _mp1\r\n                        );\r\n                        savedInk = nearest.ink + edge.ink - _newGroupInk;\r\n                    }\r\n                    if (savedInk > maxSavedInk) {\r\n                        maxSavedInk = savedInk;\r\n                        mostSavingInkEdge = nearest;\r\n                        v2Copy(mp1, _mp1);\r\n                        v2Copy(mp0, _mp0);\r\n                        newGroupInk = _newGroupInk;\r\n                    }\r\n                }\r\n                if (mostSavingInkEdge) {\r\n                    totalSavedInk += maxSavedInk;\r\n                    var group;\r\n                    if (! mostSavingInkEdge.group) {\r\n                        group = new BundledEdgeGroup();\r\n                        groups.push(group);\r\n                        group.addEdge(mostSavingInkEdge);\r\n                    }\r\n                    group = mostSavingInkEdge.group;\r\n                    // Use the meet point and group ink calculated before\r\n                    v2Copy(group.mp0, mp0);\r\n                    v2Copy(group.mp1, mp1);\r\n                    group.ink = newGroupInk;\r\n                    mostSavingInkEdge.group.addEdge(edge);\r\n                }\r\n                else {\r\n                    var group = new BundledEdgeGroup();\r\n                    groups.push(group);\r\n                    v2Copy(group.mp0, edge.getStartPoint());\r\n                    v2Copy(group.mp1, edge.getEndPoint());\r\n                    group.ink = edge.ink;\r\n                    group.addEdge(edge);\r\n                }\r\n            }\r\n\r\n            return {\r\n                groups: groups,\r\n                edges: edges,\r\n                savedInk: totalSavedInk\r\n            };\r\n        },\r\n\r\n        _calculateEdgeEdgeInk: (function () {\r\n            var startPointSet = [];\r\n            var endPointSet = [];\r\n            return function (e0, e1, mp0, mp1) {\r\n                startPointSet[0] = e0.getStartPoint();\r\n                startPointSet[1] = e1.getStartPoint();\r\n                endPointSet[0] = e0.getEndPoint();\r\n                endPointSet[1] = e1.getEndPoint();\r\n\r\n                this._calculateMeetPoints(\r\n                    startPointSet, endPointSet, mp0, mp1\r\n                );\r\n                var ink = v2Dist(startPointSet[0], mp0)\r\n                    + v2Dist(mp0, mp1)\r\n                    + v2Dist(mp1, endPointSet[0])\r\n                    + v2Dist(startPointSet[1], mp0)\r\n                    + v2Dist(mp1, endPointSet[1]);\r\n\r\n                return ink;\r\n            };\r\n        })(),\r\n\r\n        _calculateGroupEdgeInk: function (group, edgeTryAdd, mp0, mp1) {\r\n            var startPointSet = [];\r\n            var endPointSet = [];\r\n            for (var i = 0; i < group.edgeList.length; i++) {\r\n                var edge = group.edgeList[i];\r\n                startPointSet.push(edge.getStartPoint());\r\n                endPointSet.push(edge.getEndPoint());\r\n            }\r\n            startPointSet.push(edgeTryAdd.getStartPoint());\r\n            endPointSet.push(edgeTryAdd.getEndPoint());\r\n\r\n            this._calculateMeetPoints(\r\n                startPointSet, endPointSet, mp0, mp1\r\n            );\r\n\r\n            var ink = v2Dist(mp0, mp1);\r\n            for (var i = 0; i < startPointSet.length; i++) {\r\n                ink += v2Dist(startPointSet[i], mp0)\r\n                    + v2Dist(endPointSet[i], mp1);\r\n            }\r\n\r\n            return ink;\r\n        },\r\n\r\n        /**\r\n         * Calculating the meet points\r\n         * @method\r\n         * @param {Array} startPointSet Start points set of bundled edges\r\n         * @param {Array} endPointSet End points set of bundled edges\r\n         * @param {Array.<number>} mp0 Output meet point 0\r\n         * @param {Array.<number>} mp1 Output meet point 1\r\n         */\r\n        _calculateMeetPoints: (function () {\r\n            var cp0 = v2Create();\r\n            var cp1 = v2Create();\r\n            return function (startPointSet, endPointSet, mp0, mp1) {\r\n                vec2.set(cp0, 0, 0);\r\n                vec2.set(cp1, 0, 0);\r\n                var len = startPointSet.length;\r\n                // Calculate the centroid of start points set\r\n                for (var i = 0; i < len; i++) {\r\n                    vec2.add(cp0, cp0, startPointSet[i]);\r\n                }\r\n                vec2.scale(cp0, cp0, 1 / len);\r\n\r\n                // Calculate the centroid of end points set\r\n                len = endPointSet.length;\r\n                for (var i = 0; i < len; i++) {\r\n                    vec2.add(cp1, cp1, endPointSet[i]);\r\n                }\r\n                vec2.scale(cp1, cp1, 1 / len);\r\n\r\n                this._limitTurningAngle(\r\n                    startPointSet, cp0, cp1, mp0\r\n                );\r\n                this._limitTurningAngle(\r\n                    endPointSet, cp1, cp0, mp1\r\n                );\r\n            };\r\n        })(),\r\n\r\n        _limitTurningAngle: (function () {\r\n            var v10 = v2Create();\r\n            var vTmp = v2Create();\r\n            var project = v2Create();\r\n            var tmpOut = v2Create();\r\n            return function (pointSet, p0, p1, out) {\r\n                // Limit the max turning angle\r\n                var maxTurningAngleCos = Math.cos(this.maxTurningAngle);\r\n                var maxTurningAngleTan = Math.tan(this.maxTurningAngle);\r\n\r\n                vec2.sub(v10, p0, p1);\r\n                vec2.normalize(v10, v10);\r\n\r\n                // Simply copy the centroid point if no need to turn the angle\r\n                vec2.copy(out, p0);\r\n\r\n                var maxMovement = 0;\r\n                for (var i = 0; i < pointSet.length; i++) {\r\n                    var p = pointSet[i];\r\n                    vec2.sub(vTmp, p, p0);\r\n                    var len = vec2.len(vTmp);\r\n                    vec2.scale(vTmp, vTmp, 1 / len);\r\n                    var turningAngleCos = vec2.dot(vTmp, v10);\r\n                    // Turning angle is to large\r\n                    if (turningAngleCos < maxTurningAngleCos) {\r\n                        // Calculat p's project point on vector p1-p0 \r\n                        // and distance to the vector\r\n                        vec2.scaleAndAdd(\r\n                            project, p0, v10, len * turningAngleCos\r\n                        );\r\n                        var distance = v2Dist(project, p);\r\n\r\n                        // Use the max turning angle to calculate the new meet point\r\n                        var d = distance / maxTurningAngleTan;\r\n                        vec2.scaleAndAdd(tmpOut, project, v10, -d);\r\n\r\n                        var movement = v2DistSquare(tmpOut, p0);\r\n                        if (movement > maxMovement) {\r\n                            maxMovement = movement;\r\n                            vec2.copy(out, tmpOut);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        })()\r\n    };\r\n\r\n    return EdgeBundling;\r\n});"
    },
    {
      "id": 48,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\data\\KDTree.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/data/KDTree.js",
      "index": 48,
      "index2": 42,
      "size": 7954,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\layout\\EdgeBundling.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 47,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\layout\\EdgeBundling.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/layout/EdgeBundling.js",
          "type": "cjs require",
          "userRequest": "../data/KDTree",
          "loc": "11:17-42"
        }
      ],
      "source": "/**\r\n * K-Dimension Tree\r\n *\r\n * @module echarts/data/KDTree\r\n * @author Yi Shen(https://github.com/pissang)\r\n */\r\ndefine(function (require) {\r\n\r\n    var quickSelect = require('./quickSelect');\r\n\r\n    function Node(axis, data) {\r\n        this.left = null;\r\n        this.right = null;\r\n        this.axis = axis;\r\n\r\n        this.data = data;\r\n    }\r\n\r\n    /**\r\n     * @constructor\r\n     * @alias module:echarts/data/KDTree\r\n     * @param {Array} points List of points.\r\n     * each point needs an array property to repesent the actual data\r\n     * @param {Number} [dimension]\r\n     *        Point dimension.\r\n     *        Default will use the first point's length as dimensiont\r\n     */\r\n    var KDTree = function (points, dimension) {\r\n        if (!points.length) {\r\n            return;\r\n        }\r\n\r\n        if (!dimension) {\r\n            dimension = points[0].array.length;\r\n        }\r\n        this.dimension = dimension;\r\n        this.root = this._buildTree(points, 0, points.length - 1, 0);\r\n\r\n        // Use one stack to avoid allocation \r\n        // each time searching the nearest point\r\n        this._stack = [];\r\n        // Again avoid allocating a new array\r\n        // each time searching nearest N points\r\n        this._nearstNList = [];\r\n    };\r\n\r\n    /**\r\n     * Resursively build the tree\r\n     */\r\n    KDTree.prototype._buildTree = function (points, left, right, axis) {\r\n        if (right < left) {\r\n            return null;\r\n        }\r\n\r\n        var medianIndex = Math.floor((left + right) / 2);\r\n        medianIndex = quickSelect(\r\n            points, left, right, medianIndex,\r\n            function (a, b) {\r\n                return a.array[axis] - b.array[axis];\r\n            }\r\n        );\r\n        var median = points[medianIndex];\r\n\r\n        var node = new Node(axis, median);\r\n\r\n        axis = (axis + 1) % this.dimension;\r\n        if (right > left) {\r\n            node.left = this._buildTree(points, left, medianIndex - 1, axis);\r\n            node.right = this._buildTree(points, medianIndex + 1, right, axis);   \r\n        }\r\n\r\n        return node;\r\n    };\r\n\r\n    /**\r\n     * Find nearest point\r\n     * @param  {Array} target Target point\r\n     * @param  {Function} squaredDistance Squared distance function\r\n     * @return {Array} Nearest point\r\n     */\r\n    KDTree.prototype.nearest = function (target, squaredDistance) {\r\n        var curr = this.root;\r\n        var stack = this._stack;\r\n        var idx = 0;\r\n        var minDist = Infinity;\r\n        var nearestNode = null;\r\n        if (curr.data !== target) {\r\n            minDist = squaredDistance(curr.data, target);\r\n            nearestNode = curr;\r\n        }\r\n\r\n        if (target.array[curr.axis] < curr.data.array[curr.axis]) {\r\n            // Left first\r\n            curr.right && (stack[idx++] = curr.right);\r\n            curr.left && (stack[idx++] = curr.left);\r\n        }\r\n        else {\r\n            // Right first\r\n            curr.left && (stack[idx++] = curr.left);\r\n            curr.right && (stack[idx++] = curr.right);\r\n        }\r\n\r\n        while (idx--) {\r\n            curr = stack[idx];\r\n            var currDist = target.array[curr.axis] - curr.data.array[curr.axis];\r\n            var isLeft = currDist < 0;\r\n            var needsCheckOtherSide = false;\r\n            currDist = currDist * currDist;\r\n            // Intersecting right hyperplane with minDist hypersphere\r\n            if (currDist < minDist) {\r\n                currDist = squaredDistance(curr.data, target);\r\n                if (currDist < minDist && curr.data !== target) {\r\n                    minDist = currDist;\r\n                    nearestNode = curr;\r\n                }\r\n                needsCheckOtherSide = true;\r\n            }\r\n            if (isLeft) {\r\n                if (needsCheckOtherSide) {\r\n                    curr.right && (stack[idx++] = curr.right);\r\n                }\r\n                // Search in the left area\r\n                curr.left && (stack[idx++] = curr.left);\r\n            }\r\n            else {\r\n                if (needsCheckOtherSide) {\r\n                    curr.left && (stack[idx++] = curr.left);\r\n                }\r\n                // Search the right area\r\n                curr.right && (stack[idx++] = curr.right);\r\n            }\r\n        }\r\n\r\n        return nearestNode.data;\r\n    };\r\n\r\n    KDTree.prototype._addNearest = function (found, dist, node) {\r\n        var nearestNList = this._nearstNList;\r\n\r\n        // Insert to the right position\r\n        // Sort from small to large\r\n        for (var i = found - 1; i > 0; i--) {\r\n            if (dist >= nearestNList[i - 1].dist) {                \r\n                break;\r\n            }\r\n            else {\r\n                nearestNList[i].dist = nearestNList[i - 1].dist;\r\n                nearestNList[i].node = nearestNList[i - 1].node;\r\n            }\r\n        }\r\n\r\n        nearestNList[i].dist = dist;\r\n        nearestNList[i].node = node;\r\n    };\r\n\r\n    /**\r\n     * Find nearest N points\r\n     * @param  {Array} target Target point\r\n     * @param  {number} N\r\n     * @param  {Function} squaredDistance Squared distance function\r\n     * @param  {Array} [output] Output nearest N points\r\n     */\r\n    KDTree.prototype.nearestN = function (target, N, squaredDistance, output) {\r\n        if (N <= 0) {\r\n            output.length = 0;\r\n            return output;\r\n        }\r\n\r\n        var curr = this.root;\r\n        var stack = this._stack;\r\n        var idx = 0;\r\n\r\n        var nearestNList = this._nearstNList;\r\n        for (var i = 0; i < N; i++) {\r\n            // Allocate\r\n            if (!nearestNList[i]) {\r\n                nearestNList[i] = {};\r\n            }\r\n            nearestNList[i].dist = 0;\r\n            nearestNList[i].node = null;\r\n        }\r\n        var currDist = squaredDistance(curr.data, target);\r\n\r\n        var found = 0;\r\n        if (curr.data !== target) {\r\n            found++;\r\n            this._addNearest(found, currDist, curr);\r\n        }\r\n\r\n        if (target.array[curr.axis] < curr.data.array[curr.axis]) {\r\n            // Left first\r\n            curr.right && (stack[idx++] = curr.right);\r\n            curr.left && (stack[idx++] = curr.left);\r\n        }\r\n        else {\r\n            // Right first\r\n            curr.left && (stack[idx++] = curr.left);\r\n            curr.right && (stack[idx++] = curr.right);\r\n        }\r\n\r\n        while (idx--) {\r\n            curr = stack[idx];\r\n            var currDist = target.array[curr.axis] - curr.data.array[curr.axis];\r\n            var isLeft = currDist < 0;\r\n            var needsCheckOtherSide = false;\r\n            currDist = currDist * currDist;\r\n            // Intersecting right hyperplane with minDist hypersphere\r\n            if (found < N || currDist < nearestNList[found - 1].dist) {\r\n                currDist = squaredDistance(curr.data, target);\r\n                if (\r\n                    (found < N || currDist < nearestNList[found - 1].dist)\r\n                    && curr.data !== target\r\n                ) {\r\n                    if (found < N) {\r\n                        found++;\r\n                    }\r\n                    this._addNearest(found, currDist, curr);\r\n                }\r\n                needsCheckOtherSide = true;\r\n            }\r\n            if (isLeft) {\r\n                if (needsCheckOtherSide) {\r\n                    curr.right && (stack[idx++] = curr.right);\r\n                }\r\n                // Search in the left area\r\n                curr.left && (stack[idx++] = curr.left);\r\n            }\r\n            else {\r\n                if (needsCheckOtherSide) {\r\n                    curr.left && (stack[idx++] = curr.left);\r\n                }\r\n                // Search the right area\r\n                curr.right && (stack[idx++] = curr.right);\r\n            }\r\n        }\r\n\r\n        // Copy to output\r\n        for (var i = 0; i < found; i++) {\r\n            output[i] = nearestNList[i].node.data;\r\n        }\r\n        output.length = found;\r\n\r\n        return output;\r\n    };\r\n\r\n    return KDTree;\r\n});"
    },
    {
      "id": 49,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\data\\quickSelect.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/data/quickSelect.js",
      "index": 49,
      "index2": 41,
      "size": 2339,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\data\\KDTree.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 48,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\data\\KDTree.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/data/KDTree.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/data/KDTree.js",
          "type": "cjs require",
          "userRequest": "./quickSelect",
          "loc": "9:22-46"
        }
      ],
      "source": "/**\r\n * Quick select n-th element in an array.\r\n *\r\n * Note: it will change the elements placement in array.\r\n *\r\n * @module echarts/data/quickSelect\r\n * @author Yi Shen(https://github.com/pissang)\r\n */\r\ndefine(function (require) {\r\n\r\n    function defaultCompareFunc(a, b) {\r\n        return a - b;\r\n    }\r\n\r\n    function swapElement(list, idx0, idx1) {\r\n        var tmp = list[idx0];\r\n        list[idx0] = list[idx1];\r\n        list[idx1] = tmp;\r\n    }\r\n\r\n    function select(list, left, right, nth, compareFunc) {\r\n        var pivotIdx = left;\r\n        while (right > left) {\r\n            var pivotIdx = Math.round((right + left) / 2);\r\n            var pivotValue = list[pivotIdx];\r\n            // Swap pivot to the end\r\n            swapElement(list, pivotIdx, right);\r\n            pivotIdx = left;\r\n            for (var i = left; i <= right - 1; i++) {\r\n                if (compareFunc(pivotValue, list[i]) >= 0) {\r\n                    swapElement(list, i, pivotIdx);\r\n                    pivotIdx++;\r\n                }\r\n            }\r\n            swapElement(list, right, pivotIdx);\r\n\r\n            if (pivotIdx === nth) {\r\n                return pivotIdx;\r\n            } else if (pivotIdx < nth) {\r\n                left = pivotIdx + 1;\r\n            } else {\r\n                right = pivotIdx - 1;\r\n            }\r\n        }\r\n        // Left == right\r\n        return left;\r\n    }\r\n\r\n    /**\r\n     * @alias module:echarts/data/quickSelect\r\n     * @param {Array} list\r\n     * @param {number} [left]\r\n     * @param {number} [right]\r\n     * @param {number} nth\r\n     * @param {Function} [compareFunc]\r\n     * @example\r\n     *     var quickSelect = require('echarts/data/quickSelect');\r\n     *     var list = [5, 2, 1, 4, 3]\r\n     *     quickSelect(list, 3);\r\n     *     quickSelect(list, 0, 3, 1, function (a, b) {return a - b});\r\n     *\r\n     * @return {number}\r\n     */\r\n    function quickSelect(list, left, right, nth, compareFunc) {\r\n        if (arguments.length <= 3) {\r\n            nth = left;\r\n            if (arguments.length == 2) {\r\n                compareFunc = defaultCompareFunc;\r\n            } else {\r\n                compareFunc = right;\r\n            }\r\n            left = 0;\r\n            right = list.length - 1;\r\n        }\r\n        return select(list, left, right, nth, compareFunc);\r\n    }\r\n    \r\n    return quickSelect;\r\n});"
    },
    {
      "id": 50,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Rectangle.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Rectangle.js",
      "index": 50,
      "index2": 45,
      "size": 7506,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Rectangle",
          "loc": "12:25-61"
        },
        {
          "moduleId": 52,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Rectangle",
          "loc": "14:25-61"
        },
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Rectangle",
          "loc": "14:25-61"
        },
        {
          "moduleId": 59,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Rectangle",
          "loc": "12:25-61"
        },
        {
          "moduleId": 60,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Rectangle",
          "loc": "12:25-61"
        }
      ],
      "source": "/**\r\n * 矩形\r\n * @module zrender/shape/Rectangle\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com) , \r\n *         strwind (@劲风FEI)\r\n * @example\r\n *     var Rectangle = require('zrender/shape/Rectangle');\r\n *     var shape = new Rectangle({\r\n *         style: {\r\n *             x: 0,\r\n *             y: 0,\r\n *             width: 100,\r\n *             height: 100,\r\n *             radius: 20\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} IRectangleStyle\r\n * @property {number} x 左上角x坐标\r\n * @property {number} y 左上角y坐标\r\n * @property {number} width 宽度\r\n * @property {number} height 高度\r\n * @property {number|Array.<number>} radius 矩形圆角，可以用数组分别指定四个角的圆角\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n * @property {string} [text] 图形中的附加文本\r\n * @property {string} [textColor='#000000'] 文本颜色\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom\r\n * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。\r\n *                                可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n */\r\ndefine(\r\n    function (require) {\r\n        var Base = require('./Base');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/Rectangle\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Rectangle = function (options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 矩形绘制样式\r\n             * @name module:zrender/shape/Rectangle#style\r\n             * @type {module:zrender/shape/Rectangle~IRectangleStyle}\r\n             */\r\n            /**\r\n             * 矩形高亮绘制样式\r\n             * @name module:zrender/shape/Rectangle#highlightStyle\r\n             * @type {module:zrender/shape/Rectangle~IRectangleStyle}\r\n             */\r\n        };\r\n\r\n        Rectangle.prototype =  {\r\n            type: 'rectangle',\r\n\r\n            _buildRadiusPath: function (ctx, style) {\r\n                // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\r\n                // r缩写为1         相当于 [1, 1, 1, 1]\r\n                // r缩写为[1]       相当于 [1, 1, 1, 1]\r\n                // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\r\n                // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\r\n                var x = style.x;\r\n                var y = style.y;\r\n                var width = style.width;\r\n                var height = style.height;\r\n                var r = style.radius;\r\n                var r1; \r\n                var r2; \r\n                var r3; \r\n                var r4;\r\n                  \r\n                if (typeof r === 'number') {\r\n                    r1 = r2 = r3 = r4 = r;\r\n                }\r\n                else if (r instanceof Array) {\r\n                    if (r.length === 1) {\r\n                        r1 = r2 = r3 = r4 = r[0];\r\n                    }\r\n                    else if (r.length === 2) {\r\n                        r1 = r3 = r[0];\r\n                        r2 = r4 = r[1];\r\n                    }\r\n                    else if (r.length === 3) {\r\n                        r1 = r[0];\r\n                        r2 = r4 = r[1];\r\n                        r3 = r[2];\r\n                    }\r\n                    else {\r\n                        r1 = r[0];\r\n                        r2 = r[1];\r\n                        r3 = r[2];\r\n                        r4 = r[3];\r\n                    }\r\n                }\r\n                else {\r\n                    r1 = r2 = r3 = r4 = 0;\r\n                }\r\n                \r\n                var total;\r\n                if (r1 + r2 > width) {\r\n                    total = r1 + r2;\r\n                    r1 *= width / total;\r\n                    r2 *= width / total;\r\n                }\r\n                if (r3 + r4 > width) {\r\n                    total = r3 + r4;\r\n                    r3 *= width / total;\r\n                    r4 *= width / total;\r\n                }\r\n                if (r2 + r3 > height) {\r\n                    total = r2 + r3;\r\n                    r2 *= height / total;\r\n                    r3 *= height / total;\r\n                }\r\n                if (r1 + r4 > height) {\r\n                    total = r1 + r4;\r\n                    r1 *= height / total;\r\n                    r4 *= height / total;\r\n                }\r\n                ctx.moveTo(x + r1, y);\r\n                ctx.lineTo(x + width - r2, y);\r\n                r2 !== 0 && ctx.quadraticCurveTo(\r\n                    x + width, y, x + width, y + r2\r\n                );\r\n                ctx.lineTo(x + width, y + height - r3);\r\n                r3 !== 0 && ctx.quadraticCurveTo(\r\n                    x + width, y + height, x + width - r3, y + height\r\n                );\r\n                ctx.lineTo(x + r4, y + height);\r\n                r4 !== 0 && ctx.quadraticCurveTo(\r\n                    x, y + height, x, y + height - r4\r\n                );\r\n                ctx.lineTo(x, y + r1);\r\n                r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\r\n            },\r\n            \r\n            /**\r\n             * 创建矩形路径\r\n             * @param {CanvasRenderingContext2D} ctx\r\n             * @param {Object} style\r\n             */\r\n            buildPath : function (ctx, style) {\r\n                if (!style.radius) {\r\n                    ctx.moveTo(style.x, style.y);\r\n                    ctx.lineTo(style.x + style.width, style.y);\r\n                    ctx.lineTo(style.x + style.width, style.y + style.height);\r\n                    ctx.lineTo(style.x, style.y + style.height);\r\n                    ctx.lineTo(style.x, style.y);\r\n                    // ctx.rect(style.x, style.y, style.width, style.height);\r\n                }\r\n                else {\r\n                    this._buildRadiusPath(ctx, style);\r\n                }\r\n                ctx.closePath();\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 计算返回矩形包围盒矩阵\r\n             * @param {module:zrender/shape/Rectangle~IRectangleStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function(style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var lineWidth;\r\n                if (style.brushType == 'stroke' || style.brushType == 'fill') {\r\n                    lineWidth = style.lineWidth || 1;\r\n                }\r\n                else {\r\n                    lineWidth = 0;\r\n                }\r\n                style.__rect = {\r\n                    x : Math.round(style.x - lineWidth / 2),\r\n                    y : Math.round(style.y - lineWidth / 2),\r\n                    width : style.width + lineWidth,\r\n                    height : style.height + lineWidth\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Rectangle, Base);\r\n        return Rectangle;\r\n    }\r\n);\r\n"
    },
    {
      "id": 51,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
      "index": 51,
      "index2": 53,
      "size": 13662,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "../component/axis",
          "loc": "14:4-32"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "../component/axis",
          "loc": "16:4-32"
        }
      ],
      "source": "/**\r\n * echarts组件类： 坐标轴\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * 直角坐标系中坐标轴数组，数组中每一项代表一条横轴（纵轴）坐标轴。\r\n * 标准（1.0）中规定最多同时存在2条横轴和2条纵轴\r\n *    单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时则默认第一条安放于底部，第二天安放于顶部\r\n *    单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时则默认第一条安放于左侧，第二天安放于右侧。\r\n * 坐标轴有两种类型，类目型和数值型（区别详见axis）：\r\n *    横轴通常为类目型，但条形图时则横轴为数值型，散点图时则横纵均为数值型\r\n *    纵轴通常为数值型，但条形图时则纵轴为类目型。\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n\r\n    var LineShape = require('zrenderjs/shape/Line');\r\n\r\n    var ecConfig = require('../config');\r\n    var ecData = require('../util/ecData');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrColor = require('zrenderjs/tool/color');\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 图表选项\r\n     *     @param {string=} option.xAxis.type 坐标轴类型，横轴默认为类目型'category'\r\n     *     @param {string=} option.yAxis.type 坐标轴类型，纵轴默认为类目型'value'\r\n     * @param {Object} component 组件\r\n     * @param {string} axisType 横走or纵轴\r\n     */\r\n    function Axis(ecTheme, messageCenter, zr, option, myChart, axisType) {\r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this.axisType = axisType;\r\n        this._axisList = [];\r\n\r\n        this.refresh(option);\r\n    }\r\n\r\n    Axis.prototype = {\r\n        type: ecConfig.COMPONENT_TYPE_AXIS,\r\n        axisBase: {\r\n            // 轴线\r\n            _buildAxisLine: function () {\r\n                var lineWidth = this.option.axisLine.lineStyle.width;\r\n                var halfLineWidth = lineWidth / 2;\r\n                var axShape = {\r\n                    _axisShape: 'axisLine',\r\n                    zlevel: this.getZlevelBase(),\r\n                    z: this.getZBase() + 3,\r\n                    hoverable: false\r\n                };\r\n                var grid = this.grid;\r\n                switch (this.option.position) {\r\n                    case 'left' :\r\n                        axShape.style = {\r\n                            xStart: grid.getX() - halfLineWidth,\r\n                            yStart: grid.getYend(),\r\n                            xEnd: grid.getX() - halfLineWidth,\r\n                            yEnd: grid.getY(),\r\n                            lineCap: 'round'\r\n                        };\r\n                        break;\r\n                    case 'right' :\r\n                        axShape.style = {\r\n                            xStart: grid.getXend() + halfLineWidth,\r\n                            yStart: grid.getYend(),\r\n                            xEnd: grid.getXend() + halfLineWidth,\r\n                            yEnd: grid.getY(),\r\n                            lineCap: 'round'\r\n                        };\r\n                        break;\r\n                    case 'bottom' :\r\n                        axShape.style = {\r\n                            xStart: grid.getX(),\r\n                            yStart: grid.getYend() + halfLineWidth,\r\n                            xEnd: grid.getXend(),\r\n                            yEnd: grid.getYend() + halfLineWidth,\r\n                            lineCap: 'round'\r\n                        };\r\n                        break;\r\n                    case 'top' :\r\n                        axShape.style = {\r\n                            xStart: grid.getX(),\r\n                            yStart: grid.getY() - halfLineWidth,\r\n                            xEnd: grid.getXend(),\r\n                            yEnd: grid.getY() - halfLineWidth,\r\n                            lineCap: 'round'\r\n                        };\r\n                        break;\r\n                }\r\n                var style = axShape.style;\r\n                if (this.option.name !== '') { // 别帮我代码规范\r\n                    style.text = this.option.name;\r\n                    style.textPosition = this.option.nameLocation;\r\n                    style.textFont = this.getFont(this.option.nameTextStyle);\r\n                    if (this.option.nameTextStyle.align) {\r\n                        style.textAlign = this.option.nameTextStyle.align;\r\n                    }\r\n                    if (this.option.nameTextStyle.baseline) {\r\n                        style.textBaseline = this.option.nameTextStyle.baseline;\r\n                    }\r\n                    if (this.option.nameTextStyle.color) {\r\n                        style.textColor = this.option.nameTextStyle.color;\r\n                    }\r\n                }\r\n                style.strokeColor = this.option.axisLine.lineStyle.color;\r\n\r\n                style.lineWidth = lineWidth;\r\n                // 亚像素优化\r\n                if (this.isHorizontal()) {\r\n                    // 横向布局，优化y\r\n                    style.yStart\r\n                        = style.yEnd\r\n                        = this.subPixelOptimize(style.yEnd, lineWidth);\r\n                }\r\n                else {\r\n                    // 纵向布局，优化x\r\n                    style.xStart\r\n                        = style.xEnd\r\n                        = this.subPixelOptimize(style.xEnd, lineWidth);\r\n                }\r\n\r\n                style.lineType = this.option.axisLine.lineStyle.type;\r\n\r\n                axShape = new LineShape(axShape);\r\n                this.shapeList.push(axShape);\r\n            },\r\n\r\n            _axisLabelClickable: function(clickable, axShape) {\r\n                if (clickable) {\r\n                    ecData.pack(\r\n                        axShape, undefined, -1, undefined, -1, axShape.style.text\r\n                    );\r\n                    axShape.hoverable = true;\r\n                    axShape.clickable = true;\r\n                    axShape.highlightStyle = {\r\n                        color: zrColor.lift(axShape.style.color, 1),\r\n                        brushType: 'fill'\r\n                    };\r\n                    return axShape;\r\n                }\r\n                else {\r\n                    return axShape;\r\n                }\r\n            },\r\n\r\n            refixAxisShape: function(zeroX, zeroY) {\r\n                if (!this.option.axisLine.onZero) {\r\n                    return;\r\n                }\r\n                var tickLength;\r\n                if (this.isHorizontal() && zeroY != null) {\r\n                    // 横向布局调整纵向y\r\n                    for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                        if (this.shapeList[i]._axisShape === 'axisLine') {\r\n                            this.shapeList[i].style.yStart\r\n                                = this.shapeList[i].style.yEnd\r\n                                = this.subPixelOptimize(\r\n                                    zeroY, this.shapeList[i].stylelineWidth\r\n                                );\r\n                            this.zr.modShape(this.shapeList[i].id);\r\n                        }\r\n                        else if (this.shapeList[i]._axisShape === 'axisTick') {\r\n                            tickLength = this.shapeList[i].style.yEnd\r\n                                         - this.shapeList[i].style.yStart;\r\n                            this.shapeList[i].style.yStart = zeroY - tickLength;\r\n                            this.shapeList[i].style.yEnd = zeroY;\r\n                            this.zr.modShape(this.shapeList[i].id);\r\n                        }\r\n                    }\r\n                }\r\n                if (!this.isHorizontal() && zeroX != null) {\r\n                    // 纵向布局调整横向x\r\n                    for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                        if (this.shapeList[i]._axisShape === 'axisLine') {\r\n                            this.shapeList[i].style.xStart\r\n                                = this.shapeList[i].style.xEnd\r\n                                = this.subPixelOptimize(\r\n                                    zeroX, this.shapeList[i].stylelineWidth\r\n                                );\r\n                            this.zr.modShape(this.shapeList[i].id);\r\n                        }\r\n                        else if (this.shapeList[i]._axisShape === 'axisTick') {\r\n                            tickLength = this.shapeList[i].style.xEnd\r\n                                         - this.shapeList[i].style.xStart;\r\n                            this.shapeList[i].style.xStart = zeroX;\r\n                            this.shapeList[i].style.xEnd = zeroX + tickLength;\r\n                            this.zr.modShape(this.shapeList[i].id);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n\r\n            getPosition: function () {\r\n                return this.option.position;\r\n            },\r\n\r\n            isHorizontal: function() {\r\n                return this.option.position === 'bottom' || this.option.position === 'top';\r\n            }\r\n        },\r\n        /**\r\n         * 参数修正&默认值赋值，重载基类方法\r\n         * @param {Object} opt 参数\r\n         */\r\n        reformOption: function (opt) {\r\n            // 不写或传了个空数值默认为数值轴\r\n            if (!opt || (opt instanceof Array && opt.length === 0)) {\r\n                opt = [ { type: ecConfig.COMPONENT_TYPE_AXIS_VALUE } ];\r\n            }\r\n            else if (!(opt instanceof Array)){\r\n                opt = [opt];\r\n            }\r\n\r\n            // 最多两条，其他参数忽略\r\n            if (opt.length > 2) {\r\n                opt = [opt[0], opt[1]];\r\n            }\r\n\r\n            if (this.axisType === 'xAxis') {\r\n                // 横轴位置默认配置\r\n                if (!opt[0].position            // 没配置或配置错\r\n                    || (opt[0].position != 'bottom' && opt[0].position != 'top')\r\n                ) {\r\n                    opt[0].position = 'bottom';\r\n                }\r\n                if (opt.length > 1) {\r\n                    opt[1].position = opt[0].position === 'bottom' ? 'top' : 'bottom';\r\n                }\r\n\r\n                for (var i = 0, l = opt.length; i < l; i++) {\r\n                    // 坐标轴类型，横轴默认为类目型'category'\r\n                    opt[i].type = opt[i].type || 'category';\r\n                    // 标识轴类型&索引\r\n                    opt[i].xAxisIndex = i;\r\n                    opt[i].yAxisIndex = -1;\r\n                }\r\n            }\r\n            else {\r\n                // 纵轴位置默认配置\r\n                if (!opt[0].position            // 没配置或配置错\r\n                    || (opt[0].position != 'left'  && opt[0].position != 'right')\r\n                ) {\r\n                    opt[0].position = 'left';\r\n                }\r\n\r\n                if (opt.length > 1) {\r\n                    opt[1].position = opt[0].position === 'left' ? 'right' : 'left';\r\n                }\r\n\r\n                for (var i = 0, l = opt.length; i < l; i++) {\r\n                    // 坐标轴类型，纵轴默认为数值型'value'\r\n                    opt[i].type = opt[i].type || 'value';\r\n                    // 标识轴类型&索引\r\n                    opt[i].xAxisIndex = -1;\r\n                    opt[i].yAxisIndex = i;\r\n                }\r\n            }\r\n\r\n            return opt;\r\n        },\r\n\r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption) {\r\n            var axisOption;\r\n            if (newOption) {\r\n                this.option = newOption;\r\n                if (this.axisType === 'xAxis') {\r\n                    this.option.xAxis = this.reformOption(newOption.xAxis);\r\n                    axisOption = this.option.xAxis;\r\n                }\r\n                else {\r\n                    this.option.yAxis = this.reformOption(newOption.yAxis);\r\n                    axisOption = this.option.yAxis;\r\n                }\r\n                this.series = newOption.series;\r\n            }\r\n\r\n            var CategoryAxis = require('./categoryAxis');\r\n            var ValueAxis = require('./valueAxis');\r\n            var len = Math.max((axisOption && axisOption.length || 0), this._axisList.length);\r\n            for (var i = 0; i < len; i++) {\r\n                if (this._axisList[i]   // 已有实例\r\n                    && newOption        // 非空刷新\r\n                    && (!axisOption[i] || this._axisList[i].type != axisOption[i].type) // 类型不匹配\r\n                ) {\r\n                    this._axisList[i].dispose && this._axisList[i].dispose();\r\n                    this._axisList[i] = false;\r\n                }\r\n\r\n                if (this._axisList[i]) {\r\n                    this._axisList[i].refresh && this._axisList[i].refresh(\r\n                        axisOption ? axisOption[i] : false,\r\n                        this.series\r\n                    );\r\n                }\r\n                else if (axisOption && axisOption[i]) {\r\n                    this._axisList[i] = axisOption[i].type === 'category'\r\n                        ? new CategoryAxis(\r\n                               this.ecTheme, this.messageCenter, this.zr,\r\n                               axisOption[i], this.myChart, this.axisBase\r\n                           )\r\n                        : new ValueAxis(\r\n                               this.ecTheme, this.messageCenter, this.zr,\r\n                               axisOption[i], this.myChart, this.axisBase,\r\n                               this.series\r\n                        );\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 根据值换算位置\r\n         * @param {number} idx 坐标轴索引0~1\r\n         */\r\n        getAxis: function (idx) {\r\n            return this._axisList[idx];\r\n        },\r\n\r\n        getAxisCount: function () {\r\n            return this._axisList.length;\r\n        },\r\n\r\n        clear: function () {\r\n            for (var i = 0, l = this._axisList.length; i < l; i++) {\r\n                this._axisList[i].dispose && this._axisList[i].dispose();\r\n            }\r\n            this._axisList = [];\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(Axis, Base);\r\n\r\n    require('../component').define('axis', Axis);\r\n\r\n    return Axis;\r\n});\r\n"
    },
    {
      "id": 52,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
      "index": 52,
      "index2": 48,
      "size": 32791,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 51,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "type": "cjs require",
          "userRequest": "./categoryAxis",
          "loc": "287:31-56"
        }
      ],
      "source": "/**\r\n * echarts组件： 类目轴\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n    \r\n    // 图形依赖\r\n    var TextShape = require('zrenderjs/shape/Text');\r\n    var LineShape = require('zrenderjs/shape/Line');\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n    \r\n    var ecConfig = require('../config');\r\n    // 类目轴\r\n    ecConfig.categoryAxis =  {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 0,                       // 二级层叠\r\n        show: true,\r\n        position: 'bottom',    // 位置\r\n        name: '',              // 坐标轴名字，默认为空\r\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\r\n        nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式\r\n        boundaryGap: true,     // 类目起始和结束两端空白策略\r\n        axisLine: {            // 坐标轴线\r\n            show: true,        // 默认显示，属性show控制显示与否\r\n            onZero: true,\r\n            lineStyle: {       // 属性lineStyle控制线条样式\r\n                color: '#48b',\r\n                width: 2,\r\n                type: 'solid'\r\n            }\r\n        },\r\n        axisTick: {            // 坐标轴小标记\r\n            show: true,        // 属性show控制显示与否，默认不显示\r\n            interval: 'auto',\r\n            inside: false,    // 控制小标记是否在grid里 \r\n            // onGap: null,\r\n            length :5,         // 属性length控制线长\r\n            lineStyle: {       // 属性lineStyle控制线条样式\r\n                color: '#333',\r\n                width: 1\r\n            }\r\n        },\r\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\r\n            show: true,\r\n            interval: 'auto',\r\n            rotate: 0,\r\n            margin: 8,\r\n            // clickable: false,\r\n            // formatter: null,\r\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\r\n                color: '#333'\r\n            }\r\n        },\r\n        splitLine: {           // 分隔线\r\n            show: true,        // 默认显示，属性show控制显示与否\r\n            // onGap: null,\r\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\r\n                color: ['#ccc'],\r\n                width: 1,\r\n                type: 'solid'\r\n            }\r\n        },\r\n        splitArea: {           // 分隔区域\r\n            show: false,       // 默认不显示，属性show控制显示与否\r\n            // onGap: null,\r\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\r\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\r\n            }\r\n        }\r\n    };\r\n\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrArea = require('zrenderjs/tool/area');\r\n    \r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 类目轴参数\r\n     * @param {Grid} component 组件\r\n     */\r\n    function CategoryAxis(ecTheme, messageCenter, zr, option, myChart, axisBase) {\r\n        if (option.data.length < 1) {\r\n            console.error('option.data.length < 1.');\r\n            return;\r\n        }\r\n        \r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n        \r\n        this.grid = this.component.grid;\r\n        \r\n        for (var method in axisBase) {\r\n            this[method] = axisBase[method];\r\n        }\r\n        \r\n        this.refresh(option);\r\n    }\r\n    \r\n    CategoryAxis.prototype = {\r\n        type : ecConfig.COMPONENT_TYPE_AXIS_CATEGORY,\r\n        _getReformedLabel : function (idx) {\r\n            var data = this.getDataFromOption(this.option.data[idx]);\r\n            var formatter = this.option.data[idx].formatter \r\n                            || this.option.axisLabel.formatter;\r\n            if (formatter) {\r\n                if (typeof formatter == 'function') {\r\n                    data = formatter.call(this.myChart, data);\r\n                }\r\n                else if (typeof formatter == 'string') {\r\n                    data = formatter.replace('{value}', data);\r\n                }\r\n            }\r\n            return data;\r\n        },\r\n        \r\n        /**\r\n         * 计算标签显示挑选间隔\r\n         */\r\n        _getInterval : function () {\r\n            var interval   = this.option.axisLabel.interval;\r\n            if (interval == 'auto') {\r\n                // 麻烦的自适应计算\r\n                var fontSize = this.option.axisLabel.textStyle.fontSize;\r\n                var data = this.option.data;\r\n                var dataLength = this.option.data.length;\r\n\r\n                if (this.isHorizontal()) {\r\n                    // 横向\r\n                    if (dataLength > 3) {\r\n                        var gap = this.getGap();\r\n                        var isEnough = false;\r\n                        var labelSpace;\r\n                        var labelSize;\r\n                        var step = Math.floor(0.5 / gap);\r\n                        step = step < 1 ? 1 : step;\r\n                        interval = Math.floor(15 / gap);\r\n                        while (!isEnough && interval < dataLength) {\r\n                            interval += step;\r\n                            isEnough = true;\r\n                            labelSpace = Math.floor(gap * interval); // 标签左右至少间隔为3px\r\n                            for (var i = Math.floor((dataLength - 1)/ interval) * interval; \r\n                                 i >= 0; i -= interval\r\n                             ) {\r\n                                if (this.option.axisLabel.rotate !== 0) {\r\n                                    // 有旋转\r\n                                    labelSize = fontSize;\r\n                                }\r\n                                else if (data[i].textStyle) {\r\n                                    labelSize = zrArea.getTextWidth(\r\n                                        this._getReformedLabel(i),\r\n                                        this.getFont(\r\n                                            zrUtil.merge(\r\n                                                data[i].textStyle,\r\n                                                this.option.axisLabel.textStyle\r\n                                           )\r\n                                        )\r\n                                    );\r\n                                }\r\n                                else {\r\n                                    /*\r\n                                    labelSize = zrArea.getTextWidth(\r\n                                        this._getReformedLabel(i),\r\n                                        font\r\n                                    );\r\n                                    */\r\n                                    // 不定义data级特殊文本样式，用fontSize优化getTextWidth\r\n                                    var label = this._getReformedLabel(i) + '';\r\n                                    var wLen = (label.match(/\\w/g) || '').length;\r\n                                    var oLen = label.length - wLen;\r\n                                    labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;\r\n                                }\r\n\r\n                                if (labelSpace < labelSize) {\r\n                                    // 放不下，中断循环让interval++\r\n                                    isEnough = false;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // 少于3个则全部显示\r\n                        interval = 1;\r\n                    }\r\n                }\r\n                else {\r\n                    // 纵向\r\n                    if (dataLength > 3) {\r\n                        var gap = this.getGap();\r\n                        interval = Math.floor(11 / gap);\r\n                        // 标签上下至少间隔为3px\r\n                        while ((gap * interval - 6) < fontSize\r\n                                && interval < dataLength\r\n                        ) {\r\n                            interval++;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // 少于3个则全部显示\r\n                        interval = 1;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // 用户自定义间隔，支持funtion\r\n                interval = typeof interval == 'function' ? 1 : (interval - 0 + 1);\r\n            }\r\n\r\n            return interval;\r\n        },\r\n        \r\n        /**\r\n         * 绘制图形\r\n         */\r\n        _buildShape : function () {\r\n            // 标签显示的挑选间隔\r\n            this._interval = this._getInterval();\r\n            if (!this.option.show) {\r\n                return;\r\n            }\r\n            this.option.splitArea.show && this._buildSplitArea();\r\n            this.option.splitLine.show && this._buildSplitLine();\r\n            this.option.axisLine.show && this._buildAxisLine();\r\n            this.option.axisTick.show && this._buildAxisTick();\r\n            this.option.axisLabel.show && this._buildAxisLabel();\r\n\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                this.zr.addShape(this.shapeList[i]);\r\n            }\r\n        },\r\n\r\n        // 小标记\r\n        _buildAxisTick : function () {\r\n            var axShape;\r\n            var data       = this.option.data;\r\n            var dataLength = this.option.data.length;\r\n            var tickOption = this.option.axisTick;\r\n            var length     = tickOption.length;\r\n            var color      = tickOption.lineStyle.color;\r\n            var lineWidth  = tickOption.lineStyle.width;\r\n            var intervalFunction = typeof tickOption.interval == 'function'\r\n                                   ? tickOption.interval \r\n                                   : tickOption.interval == 'auto'\r\n                                     ? typeof this.option.axisLabel.interval == 'function'\r\n                                       ? this.option.axisLabel.interval : false\r\n                                     : false;\r\n            var interval   = intervalFunction\r\n                             ? 1\r\n                             : tickOption.interval == 'auto' \r\n                               ? this._interval\r\n                               : (tickOption.interval - 0 + 1);\r\n            var onGap      = tickOption.onGap;\r\n            var optGap     = onGap \r\n                             ? (this.getGap() / 2) \r\n                             : typeof onGap == 'undefined'\r\n                                   ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)\r\n                                   : 0;\r\n            var startIndex = optGap > 0 ? -interval : 0;                       \r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var yPosition = this.option.position == 'bottom'\r\n                        ? (tickOption.inside \r\n                           ? (this.grid.getYend() - length - 1) : (this.grid.getYend() + 1))\r\n                        : (tickOption.inside \r\n                           ? (this.grid.getY() + 1) : (this.grid.getY() - length - 1));\r\n                var x;\r\n                for (var i = startIndex; i < dataLength; i += interval) {\r\n                    if (intervalFunction && !intervalFunction(i, data[i])) {\r\n                        // 回调并且回调返回false则跳过渲染\r\n                        continue;\r\n                    }\r\n                    // 亚像素优化\r\n                    x = this.subPixelOptimize(\r\n                        this.getCoordByIndex(i) + (i >= 0 ? optGap : 0), lineWidth\r\n                    );\r\n                    axShape = {\r\n                        _axisShape : 'axisTick',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable : false,\r\n                        style : {\r\n                            xStart : x,\r\n                            yStart : yPosition,\r\n                            xEnd : x,\r\n                            yEnd : yPosition + length,\r\n                            strokeColor : color,\r\n                            lineWidth : lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n            else {\r\n                // 纵向\r\n                var xPosition = this.option.position == 'left'\r\n                    ? (tickOption.inside \r\n                       ? (this.grid.getX() + 1) : (this.grid.getX() - length - 1))\r\n                    : (tickOption.inside \r\n                       ? (this.grid.getXend() - length - 1) : (this.grid.getXend() + 1));\r\n                        \r\n                var y;\r\n                for (var i = startIndex; i < dataLength; i += interval) {\r\n                    if (intervalFunction && !intervalFunction(i, data[i])) {\r\n                        // 回调并且回调返回false则中断渲染\r\n                        continue;\r\n                    }\r\n                    // 亚像素优化\r\n                    y = this.subPixelOptimize(\r\n                        this.getCoordByIndex(i) - (i >= 0 ? optGap : 0), lineWidth\r\n                    );\r\n                    axShape = {\r\n                        _axisShape : 'axisTick',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable : false,\r\n                        style : {\r\n                            xStart : xPosition,\r\n                            yStart : y,\r\n                            xEnd : xPosition + length,\r\n                            yEnd : y,\r\n                            strokeColor : color,\r\n                            lineWidth : lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n        },\r\n\r\n        // 坐标轴文本\r\n        _buildAxisLabel : function () {\r\n            var axShape;\r\n            var data       = this.option.data;\r\n            var dataLength = this.option.data.length;\r\n            var labelOption = this.option.axisLabel;\r\n            var rotate     = labelOption.rotate;\r\n            var margin     = labelOption.margin;\r\n            var clickable  = labelOption.clickable;\r\n            var textStyle  = labelOption.textStyle;\r\n            var intervalFunction = typeof labelOption.interval == 'function'\r\n                                   ? labelOption.interval : false;\r\n            var dataTextStyle;\r\n\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var yPosition;\r\n                var baseLine;\r\n                if (this.option.position == 'bottom') {\r\n                    yPosition = this.grid.getYend() + margin;\r\n                    baseLine = 'top';\r\n                }\r\n                else {\r\n                    yPosition = this.grid.getY() - margin;\r\n                    baseLine = 'bottom';\r\n                }\r\n\r\n                for (var i = 0; i < dataLength; i += this._interval) {\r\n                    if ((intervalFunction && !intervalFunction(i, data[i])) \r\n                        // 回调并且回调返回false则中断渲染\r\n                        || this._getReformedLabel(i) === '' // 空文本优化\r\n                    ) {\r\n                        continue;\r\n                    }\r\n                    dataTextStyle = zrUtil.merge(\r\n                        data[i].textStyle || {},\r\n                        textStyle\r\n                    );\r\n                    axShape = {\r\n                        // shape : 'text',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase() + 3,\r\n                        hoverable : false,\r\n                        style : {\r\n                            x : this.getCoordByIndex(i),\r\n                            y : yPosition,\r\n                            color : dataTextStyle.color,\r\n                            text : this._getReformedLabel(i),\r\n                            textFont : this.getFont(dataTextStyle),\r\n                            textAlign : dataTextStyle.align || 'center',\r\n                            textBaseline : dataTextStyle.baseline || baseLine\r\n                        }\r\n                    };\r\n                    if (rotate) {\r\n                        axShape.style.textAlign = rotate > 0\r\n                                                  ? (this.option.position == 'bottom'\r\n                                                    ? 'right' : 'left')\r\n                                                  : (this.option.position == 'bottom'\r\n                                                    ? 'left' : 'right');\r\n                        axShape.rotation = [\r\n                            rotate * Math.PI / 180,\r\n                            axShape.style.x,\r\n                            axShape.style.y\r\n                        ];\r\n                    }\r\n                    this.shapeList.push(new TextShape(\r\n                        this._axisLabelClickable(clickable, axShape)\r\n                    ));\r\n                }\r\n            }\r\n            else {\r\n                // 纵向\r\n                var xPosition;\r\n                var align;\r\n                if (this.option.position == 'left') {\r\n                    xPosition = this.grid.getX() - margin;\r\n                    align = 'right';\r\n                }\r\n                else {\r\n                    xPosition = this.grid.getXend() + margin;\r\n                    align = 'left';\r\n                }\r\n\r\n                for (var i = 0; i < dataLength; i += this._interval) {\r\n                    if ((intervalFunction && !intervalFunction(i, data[i])) \r\n                        // 回调并且回调返回false则中断渲染\r\n                        || this._getReformedLabel(i) === '' // 空文本优化\r\n                    ) {\r\n                        continue;\r\n                    }\r\n                    dataTextStyle = zrUtil.merge(\r\n                        data[i].textStyle || {},\r\n                        textStyle\r\n                    );\r\n                    axShape = {\r\n                        // shape : 'text',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase() + 3,\r\n                        hoverable : false,\r\n                        style : {\r\n                            x : xPosition,\r\n                            y : this.getCoordByIndex(i),\r\n                            color : dataTextStyle.color,\r\n                            text : this._getReformedLabel(i),\r\n                            textFont : this.getFont(dataTextStyle),\r\n                            textAlign : dataTextStyle.align || align,\r\n                            textBaseline : dataTextStyle.baseline \r\n                                           || (i === 0 && this.option.name !== '')\r\n                                               ? 'bottom'\r\n                                               : (i == (dataLength - 1) \r\n                                                  && this.option.name !== '')\r\n                                                 ? 'top'\r\n                                                 : 'middle'\r\n                        }\r\n                    };\r\n                    \r\n                    if (rotate) {\r\n                        axShape.rotation = [\r\n                            rotate * Math.PI / 180,\r\n                            axShape.style.x,\r\n                            axShape.style.y\r\n                        ];\r\n                    }\r\n                    this.shapeList.push(new TextShape(\r\n                        this._axisLabelClickable(clickable, axShape)\r\n                    ));\r\n                }\r\n            }\r\n        },\r\n        \r\n        _buildSplitLine : function () {\r\n            var axShape;\r\n            var data        = this.option.data;\r\n            var dataLength  = this.option.data.length;\r\n            var sLineOption = this.option.splitLine;\r\n            var lineType    = sLineOption.lineStyle.type;\r\n            var lineWidth   = sLineOption.lineStyle.width;\r\n            var color       = sLineOption.lineStyle.color;\r\n            color = color instanceof Array ? color : [color];\r\n            var colorLength = color.length;\r\n            \r\n            // splitLine随axisLable\r\n            var intervalFunction = typeof this.option.axisLabel.interval == 'function'\r\n                                   ? this.option.axisLabel.interval : false;\r\n\r\n            var onGap      = sLineOption.onGap;\r\n            var optGap     = onGap \r\n                             ? (this.getGap() / 2) \r\n                             : typeof onGap == 'undefined'\r\n                                   ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)\r\n                                   : 0;\r\n            dataLength -= (onGap || (typeof onGap == 'undefined' && this.option.boundaryGap)) \r\n                          ? 1 : 0;\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var sy = this.grid.getY();\r\n                var ey = this.grid.getYend();\r\n                var x;\r\n\r\n                for (var i = 0; i < dataLength; i += this._interval) {\r\n                    if (intervalFunction && !intervalFunction(i, data[i])) {\r\n                        // 回调并且回调返回false则跳过渲染\r\n                        continue;\r\n                    }\r\n                    // 亚像素优化\r\n                    x = this.subPixelOptimize(\r\n                        this.getCoordByIndex(i) + optGap, lineWidth\r\n                    );\r\n                    axShape = {\r\n                        // shape : 'line',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable : false,\r\n                        style : {\r\n                            xStart : x,\r\n                            yStart : sy,\r\n                            xEnd : x,\r\n                            yEnd : ey,\r\n                            strokeColor : color[(i / this._interval) % colorLength],\r\n                            lineType : lineType,\r\n                            lineWidth : lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n\r\n            }\r\n            else {\r\n                // 纵向\r\n                var sx = this.grid.getX();\r\n                var ex = this.grid.getXend();\r\n                var y;\r\n\r\n                for (var i = 0; i < dataLength; i += this._interval) {\r\n                    if (intervalFunction && !intervalFunction(i, data[i])) {\r\n                        // 回调并且回调返回false则跳过渲染\r\n                        continue;\r\n                    }\r\n                    // 亚像素优化\r\n                    y = this.subPixelOptimize(\r\n                        this.getCoordByIndex(i) - optGap, lineWidth\r\n                    );\r\n                    axShape = {\r\n                        // shape : 'line',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable : false,\r\n                        style : {\r\n                            xStart : sx,\r\n                            yStart : y,\r\n                            xEnd : ex,\r\n                            yEnd : y,\r\n                            strokeColor : color[(i / this._interval) % colorLength],\r\n                            lineType : lineType,\r\n                            lineWidth : lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n        },\r\n\r\n        _buildSplitArea : function () {\r\n            var axShape;\r\n            var data        = this.option.data;\r\n            var sAreaOption = this.option.splitArea;\r\n            var color = sAreaOption.areaStyle.color;\r\n            if (!(color instanceof Array)) {\r\n                // 非数组一律认为是单一颜色的字符串，单一颜色则用一个背景，颜色错误不负责啊！！！\r\n                axShape = {\r\n                    // shape : 'rectangle',\r\n                    zlevel: this.getZlevelBase(),\r\n                    z: this.getZBase(),\r\n                    hoverable : false,\r\n                    style : {\r\n                        x : this.grid.getX(),\r\n                        y : this.grid.getY(),\r\n                        width : this.grid.getWidth(),\r\n                        height : this.grid.getHeight(),\r\n                        color : color\r\n                        // type : this.option.splitArea.areaStyle.type,\r\n                    }\r\n                };\r\n                this.shapeList.push(new RectangleShape(axShape));\r\n            }\r\n            else {\r\n                // 多颜色\r\n                var colorLength = color.length;\r\n                var dataLength  = this.option.data.length;\r\n\r\n                // splitArea随axisLable\r\n                var intervalFunction = typeof this.option.axisLabel.interval == 'function'\r\n                                       ? this.option.axisLabel.interval : false;\r\n        \r\n                var onGap      = sAreaOption.onGap;\r\n                var optGap     = onGap \r\n                                 ? (this.getGap() / 2) \r\n                                 : typeof onGap == 'undefined'\r\n                                       ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)\r\n                                       : 0;\r\n                if (this.isHorizontal()) {\r\n                    // 横向\r\n                    var y = this.grid.getY();\r\n                    var height = this.grid.getHeight();\r\n                    var lastX = this.grid.getX();\r\n                    var curX;\r\n    \r\n                    for (var i = 0; i <= dataLength; i += this._interval) {\r\n                        if (intervalFunction && !intervalFunction(i, data[i]) && i < dataLength) {\r\n                            // 回调并且回调返回false则跳过渲染\r\n                            continue;\r\n                        }\r\n                        curX = i < dataLength\r\n                               ? (this.getCoordByIndex(i) + optGap)\r\n                               : this.grid.getXend();\r\n                        axShape = {\r\n                            // shape : 'rectangle',\r\n                            zlevel: this.getZlevelBase(),\r\n                            z: this.getZBase(),\r\n                            hoverable : false,\r\n                            style : {\r\n                                x : lastX,\r\n                                y : y,\r\n                                width : curX - lastX,\r\n                                height : height,\r\n                                color : color[(i / this._interval) % colorLength]\r\n                                // type : this.option.splitArea.areaStyle.type,\r\n                            }\r\n                        };\r\n                        this.shapeList.push(new RectangleShape(axShape));\r\n                        lastX = curX;\r\n                    }\r\n                }\r\n                else {\r\n                    // 纵向\r\n                    var x = this.grid.getX();\r\n                    var width = this.grid.getWidth();\r\n                    var lastYend = this.grid.getYend();\r\n                    var curY;\r\n    \r\n                    for (var i = 0; i <= dataLength; i += this._interval) {\r\n                        if (intervalFunction && !intervalFunction(i, data[i]) && i < dataLength) {\r\n                            // 回调并且回调返回false则跳过渲染\r\n                            continue;\r\n                        }\r\n                        curY = i < dataLength\r\n                               ? (this.getCoordByIndex(i) - optGap)\r\n                               : this.grid.getY();\r\n                        axShape = {\r\n                            // shape : 'rectangle',\r\n                            zlevel: this.getZlevelBase(),\r\n                            z: this.getZBase(),\r\n                            hoverable : false,\r\n                            style : {\r\n                                x : x,\r\n                                y : curY,\r\n                                width : width,\r\n                                height : lastYend - curY,\r\n                                color : color[(i / this._interval) % colorLength]\r\n                                // type : this.option.splitArea.areaStyle.type\r\n                            }\r\n                        };\r\n                        this.shapeList.push(new RectangleShape(axShape));\r\n                        lastYend = curY;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh : function (newOption) {\r\n            if (newOption) {\r\n                this.option = this.reformOption(newOption);\r\n                // 通用字体设置\r\n                this.option.axisLabel.textStyle = this.getTextStyle(\r\n                    this.option.axisLabel.textStyle\r\n                );\r\n            }\r\n            this.clear();\r\n            this._buildShape();\r\n        },\r\n\r\n        /**\r\n         * 返回间隔\r\n         */\r\n        getGap : function () {\r\n            var dataLength = this.option.data.length;\r\n            var total = this.isHorizontal()\r\n                        ? this.grid.getWidth()\r\n                        : this.grid.getHeight();\r\n            if (this.option.boundaryGap) {              // 留空\r\n                return total / dataLength;\r\n            }\r\n            else {                                      // 顶头\r\n                return total / (dataLength > 1 ? (dataLength - 1) : 1);\r\n            }\r\n        },\r\n\r\n        // 根据值换算位置\r\n        getCoord : function (value) {\r\n            var data = this.option.data;\r\n            var dataLength = data.length;\r\n            var gap = this.getGap();\r\n            var position = this.option.boundaryGap ? (gap / 2) : 0;\r\n\r\n            for (var i = 0; i < dataLength; i++) {\r\n                if (this.getDataFromOption(data[i]) == value) {\r\n                    if (this.isHorizontal()) {\r\n                        // 横向\r\n                        position = this.grid.getX() + position;\r\n                    }\r\n                    else {\r\n                        // 纵向\r\n                        position = this.grid.getYend() - position;\r\n                    }\r\n                    \r\n                    return position;\r\n                    // Math.floor可能引起一些偏差，但性能会更好\r\n                    /* 准确更重要\r\n                    return (i === 0 || i == dataLength - 1)\r\n                           ? position\r\n                           : Math.floor(position);\r\n                    */\r\n                }\r\n                position += gap;\r\n            }\r\n        },\r\n\r\n        // 根据类目轴数据索引换算位置\r\n        getCoordByIndex : function (dataIndex) {\r\n            if (dataIndex < 0) {\r\n                if (this.isHorizontal()) {\r\n                    return this.grid.getX();\r\n                }\r\n                else {\r\n                    return this.grid.getYend();\r\n                }\r\n            }\r\n            else if (dataIndex > this.option.data.length - 1) {\r\n                if (this.isHorizontal()) {\r\n                    return this.grid.getXend();\r\n                }\r\n                else {\r\n                    return this.grid.getY();\r\n                }\r\n            }\r\n            else {\r\n                var gap = this.getGap();\r\n                var position = this.option.boundaryGap ? (gap / 2) : 0;\r\n                position += dataIndex * gap;\r\n                \r\n                if (this.isHorizontal()) {\r\n                    // 横向\r\n                    position = this.grid.getX() + position;\r\n                }\r\n                else {\r\n                    // 纵向\r\n                    position = this.grid.getYend() - position;\r\n                }\r\n                \r\n                return position;\r\n                /* 准确更重要\r\n                return (dataIndex === 0 || dataIndex == this.option.data.length - 1)\r\n                       ? position\r\n                       : Math.floor(position);\r\n                */\r\n            }\r\n        },\r\n\r\n        // 根据类目轴数据索引换算类目轴名称\r\n        getNameByIndex : function (dataIndex) {\r\n            return this.getDataFromOption(this.option.data[dataIndex]);\r\n        },\r\n        \r\n        // 根据类目轴名称换算类目轴数据索引\r\n        getIndexByName : function (name) {\r\n            var data = this.option.data;\r\n            var dataLength = data.length;\r\n\r\n            for (var i = 0; i < dataLength; i++) {\r\n                if (this.getDataFromOption(data[i]) == name) {\r\n                    return i;\r\n                }\r\n            }\r\n            \r\n            return -1;\r\n        },\r\n        \r\n        // 根据位置换算值\r\n        getValueFromCoord : function() {\r\n            return '';\r\n        },\r\n\r\n        /**\r\n         * 根据类目轴数据索引返回是否为主轴线\r\n         * @param {number} dataIndex 类目轴数据索引\r\n         * @return {boolean} 是否为主轴\r\n         */\r\n        isMainAxis : function (dataIndex) {\r\n            return dataIndex % this._interval === 0;\r\n        }\r\n    };\r\n    \r\n    zrUtil.inherits(CategoryAxis, Base);\r\n    \r\n    require('../component').define('categoryAxis', CategoryAxis);\r\n    \r\n    return CategoryAxis;\r\n});"
    },
    {
      "id": 53,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\shape\\Text.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/shape/Text.js",
      "index": 53,
      "index2": 46,
      "size": 7484,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 52,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Text",
          "loc": "12:20-51"
        },
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/shape/Text",
          "loc": "12:20-51"
        }
      ],
      "source": "/**\r\n * @module zrender/shape/Text\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @example\r\n *     var Text = require('zrender/shape/Text');\r\n *     var shape = new Text({\r\n *         style: {\r\n *             text: 'Label',\r\n *             x: 100,\r\n *             y: 100,\r\n *             textFont: '14px Arial'\r\n *         }\r\n *     });\r\n *     zr.addShape(shape);\r\n */\r\n\r\n/**\r\n * @typedef {Object} ITextStyle\r\n * @property {number} x 横坐标\r\n * @property {number} y 纵坐标\r\n * @property {string} text 文本内容\r\n * @property {number} [maxWidth=null] 最大宽度限制\r\n * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'\r\n * @property {string} [textAlign] 可以是start, end, left, right, center\r\n * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。\r\n *                                可以是top, bottom, middle, alphabetic, hanging, ideographic\r\n * @property {string} [brushType='fill']\r\n * @property {string} [color='#000000'] 填充颜色\r\n * @property {string} [strokeColor='#000000'] 描边颜色\r\n * @property {number} [lineWidth=1] 描边宽度\r\n * @property {number} [opacity=1] 绘制透明度\r\n * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效\r\n * @property {string} [shadowColor='#000000'] 阴影颜色\r\n * @property {number} [shadowOffsetX=0] 阴影横向偏移\r\n * @property {number} [shadowOffsetY=0] 阴影纵向偏移\r\n */\r\n\r\ndefine(\r\n    function (require) {\r\n        var area = require('../tool/area');\r\n        var Base = require('./Base');\r\n        \r\n        /**\r\n         * @alias module:zrender/shape/Text\r\n         * @constructor\r\n         * @extends module:zrender/shape/Base\r\n         * @param {Object} options\r\n         */\r\n        var Text = function (options) {\r\n            Base.call(this, options);\r\n            /**\r\n             * 文字绘制样式\r\n             * @name module:zrender/shape/Text#style\r\n             * @type {module:zrender/shape/Text~ITextStyle}\r\n             */\r\n            /**\r\n             * 文字高亮绘制样式\r\n             * @name module:zrender/shape/Text#highlightStyle\r\n             * @type {module:zrender/shape/Text~ITextStyle}\r\n             */\r\n        };\r\n\r\n        Text.prototype =  {\r\n            type: 'text',\r\n\r\n            brush : function (ctx, isHighlight) {\r\n                var style = this.style;\r\n                if (isHighlight) {\r\n                    // 根据style扩展默认高亮样式\r\n                    style = this.getHighlightStyle(\r\n                        style, this.highlightStyle || {}\r\n                    );\r\n                }\r\n                \r\n                if (typeof(style.text) == 'undefined' || style.text === false) {\r\n                    return;\r\n                }\r\n\r\n                ctx.save();\r\n                this.doClip(ctx);\r\n\r\n                this.setContext(ctx, style);\r\n\r\n                // 设置transform\r\n                this.setTransform(ctx);\r\n\r\n                if (style.textFont) {\r\n                    ctx.font = style.textFont;\r\n                }\r\n                ctx.textAlign = style.textAlign || 'start';\r\n                ctx.textBaseline = style.textBaseline || 'middle';\r\n\r\n                var text = (style.text + '').split('\\n');\r\n                var lineHeight = area.getTextHeight('国', style.textFont);\r\n                var rect = this.getRect(style);\r\n                var x = style.x;\r\n                var y;\r\n                if (style.textBaseline == 'top') {\r\n                    y = rect.y;\r\n                }\r\n                else if (style.textBaseline == 'bottom') {\r\n                    y = rect.y + lineHeight;\r\n                }\r\n                else {\r\n                    y = rect.y + lineHeight / 2;\r\n                }\r\n                \r\n                for (var i = 0, l = text.length; i < l; i++) {\r\n                    if (style.maxWidth) {\r\n                        switch (style.brushType) {\r\n                            case 'fill':\r\n                                ctx.fillText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                                break;\r\n                            case 'stroke':\r\n                                ctx.strokeText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                                break;\r\n                            case 'both':\r\n                                ctx.fillText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                                ctx.strokeText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                                break;\r\n                            default:\r\n                                ctx.fillText(\r\n                                    text[i],\r\n                                    x, y, style.maxWidth\r\n                                );\r\n                        }\r\n                    }\r\n                    else {\r\n                        switch (style.brushType) {\r\n                            case 'fill':\r\n                                ctx.fillText(text[i], x, y);\r\n                                break;\r\n                            case 'stroke':\r\n                                ctx.strokeText(text[i], x, y);\r\n                                break;\r\n                            case 'both':\r\n                                ctx.fillText(text[i], x, y);\r\n                                ctx.strokeText(text[i], x, y);\r\n                                break;\r\n                            default:\r\n                                ctx.fillText(text[i], x, y);\r\n                        }\r\n                    }\r\n                    y += lineHeight;\r\n                }\r\n\r\n                ctx.restore();\r\n                return;\r\n            },\r\n\r\n            /**\r\n             * 返回文字包围盒矩形\r\n             * @param {module:zrender/shape/Text~ITextStyle} style\r\n             * @return {module:zrender/shape/Base~IBoundingRect}\r\n             */\r\n            getRect : function (style) {\r\n                if (style.__rect) {\r\n                    return style.__rect;\r\n                }\r\n                \r\n                var width = area.getTextWidth(style.text, style.textFont);\r\n                var height = area.getTextHeight(style.text, style.textFont);\r\n                \r\n                var textX = style.x;                 // 默认start == left\r\n                if (style.textAlign == 'end' || style.textAlign == 'right') {\r\n                    textX -= width;\r\n                }\r\n                else if (style.textAlign == 'center') {\r\n                    textX -= (width / 2);\r\n                }\r\n\r\n                var textY;\r\n                if (style.textBaseline == 'top') {\r\n                    textY = style.y;\r\n                }\r\n                else if (style.textBaseline == 'bottom') {\r\n                    textY = style.y - height;\r\n                }\r\n                else {\r\n                    // middle\r\n                    textY = style.y - height / 2;\r\n                }\r\n\r\n                style.__rect = {\r\n                    x : textX,\r\n                    y : textY,\r\n                    width : width,\r\n                    height : height\r\n                };\r\n                \r\n                return style.__rect;\r\n            }\r\n        };\r\n\r\n        require('../tool/util').inherits(Text, Base);\r\n        return Text;\r\n    }\r\n);\r\n\r\n"
    },
    {
      "id": 54,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/component.js",
      "index": 54,
      "index2": 47,
      "size": 666,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 51,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "type": "cjs require",
          "userRequest": "../component",
          "loc": "342:4-27"
        },
        {
          "moduleId": 52,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\categoryAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/categoryAxis.js",
          "type": "cjs require",
          "userRequest": "../component",
          "loc": "801:4-27"
        },
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "../component",
          "loc": "944:4-27"
        },
        {
          "moduleId": 59,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
          "type": "cjs require",
          "userRequest": "../component",
          "loc": "181:4-27"
        },
        {
          "moduleId": 60,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "type": "cjs require",
          "userRequest": "../component",
          "loc": "317:35-58"
        },
        {
          "moduleId": 60,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "type": "cjs require",
          "userRequest": "../component",
          "loc": "1241:4-27"
        }
      ],
      "source": "/**\r\n * echart组件库\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (/*require*/) {     // component\r\n    var self = {};\r\n\r\n    var _componentLibrary = {};     // echart组件库\r\n\r\n    /**\r\n     * 定义图形实现\r\n     * @param {Object} name\r\n     * @param {Object} clazz 图形实现\r\n     */\r\n    self.define = function (name, clazz) {\r\n        _componentLibrary[name] = clazz;\r\n        return self;\r\n    };\r\n\r\n    /**\r\n     * 获取图形实现\r\n     * @param {Object} name\r\n     */\r\n    self.get = function (name) {\r\n        return _componentLibrary[name];\r\n    };\r\n    \r\n    return self;\r\n});"
    },
    {
      "id": 55,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
      "index": 55,
      "index2": 52,
      "size": 37530,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 51,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\axis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/axis.js",
          "type": "cjs require",
          "userRequest": "./valueAxis",
          "loc": "288:28-50"
        }
      ],
      "source": "/**\r\n * echarts组件： 数值轴\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n\r\n    // 图形依赖\r\n    var TextShape = require('zrenderjs/shape/Text');\r\n    var LineShape = require('zrenderjs/shape/Line');\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n\r\n    var ecConfig = require('../config');\r\n    // 数值型坐标轴默认参数\r\n    ecConfig.valueAxis = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 0,                       // 二级层叠\r\n        show: true,\r\n        position: 'left',      // 位置\r\n        name: '',              // 坐标轴名字，默认为空\r\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\r\n        nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式\r\n        boundaryGap: [0, 0],   // 数值起始和结束两端空白策略\r\n        // min: null,          // 最小值\r\n        // max: null,          // 最大值\r\n        // scale: false,       // 脱离0值比例，放大聚焦到最终_min，_max区间\r\n        // splitNumber: 5,        // 分割段数，默认为5\r\n        axisLine: {            // 坐标轴线\r\n            show: true,        // 默认显示，属性show控制显示与否\r\n            onZero: true,\r\n            lineStyle: {       // 属性lineStyle控制线条样式\r\n                color: '#48b',\r\n                width: 2,\r\n                type: 'solid'\r\n            }\r\n        },\r\n        axisTick: {            // 坐标轴小标记\r\n            show: false,       // 属性show控制显示与否，默认不显示\r\n            inside: false,     // 控制小标记是否在grid里\r\n            length :5,         // 属性length控制线长\r\n            lineStyle: {       // 属性lineStyle控制线条样式\r\n                color: '#333',\r\n                width: 1\r\n            }\r\n        },\r\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\r\n            show: true,\r\n            rotate: 0,\r\n            margin: 8,\r\n            // clickable: false,\r\n            // formatter: null,\r\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\r\n                color: '#333'\r\n            }\r\n        },\r\n        splitLine: {           // 分隔线\r\n            show: true,        // 默认显示，属性show控制显示与否\r\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\r\n                color: ['#ccc'],\r\n                width: 1,\r\n                type: 'solid'\r\n            }\r\n        },\r\n        splitArea: {           // 分隔区域\r\n            show: false,       // 默认不显示，属性show控制显示与否\r\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\r\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\r\n            }\r\n        }\r\n    };\r\n\r\n    var ecDate = require('../util/date');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 类目轴参数\r\n     * @param {Object} component 组件\r\n     * @param {Array} series 数据对象\r\n     */\r\n    function ValueAxis(ecTheme, messageCenter, zr, option, myChart, axisBase, series) {\r\n        if (!series || series.length === 0) {\r\n            console.err('option.series.length == 0.');\r\n            return;\r\n        }\r\n\r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this.series = series;\r\n        this.grid = this.component.grid;\r\n\r\n        for (var method in axisBase) {\r\n            this[method] = axisBase[method];\r\n        }\r\n\r\n        this.refresh(option, series);\r\n    }\r\n\r\n    ValueAxis.prototype = {\r\n        type: ecConfig.COMPONENT_TYPE_AXIS_VALUE,\r\n\r\n        _buildShape: function () {\r\n            this._hasData = false;\r\n            this._calculateValue();\r\n            if (!this._hasData || !this.option.show) {\r\n                return;\r\n            }\r\n\r\n            this.option.splitArea.show && this._buildSplitArea();\r\n            this.option.splitLine.show && this._buildSplitLine();\r\n            this.option.axisLine.show && this._buildAxisLine();\r\n            this.option.axisTick.show && this._buildAxisTick();\r\n            this.option.axisLabel.show && this._buildAxisLabel();\r\n\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                this.zr.addShape(this.shapeList[i]);\r\n            }\r\n        },\r\n\r\n        // 小标记\r\n        _buildAxisTick: function () {\r\n            var axShape;\r\n            var data       = this._valueList;\r\n            var dataLength = this._valueList.length;\r\n            var tickOption = this.option.axisTick;\r\n            var length     = tickOption.length;\r\n            var color      = tickOption.lineStyle.color;\r\n            var lineWidth  = tickOption.lineStyle.width;\r\n\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var yPosition = this.option.position === 'bottom'\r\n                        ? (tickOption.inside\r\n                           ? (this.grid.getYend() - length - 1) : (this.grid.getYend()) + 1)\r\n                        : (tickOption.inside\r\n                           ? (this.grid.getY() + 1) : (this.grid.getY() - length - 1));\r\n                var x;\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    // 亚像素优化\r\n                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);\r\n                    axShape = {\r\n                        _axisShape: 'axisTick',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable: false,\r\n                        style: {\r\n                            xStart: x,\r\n                            yStart: yPosition,\r\n                            xEnd: x,\r\n                            yEnd: yPosition + length,\r\n                            strokeColor: color,\r\n                            lineWidth: lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n            else {\r\n                // 纵向\r\n                var xPosition = this.option.position === 'left'\r\n                    ? (tickOption.inside\r\n                       ? (this.grid.getX() + 1) : (this.grid.getX() - length - 1))\r\n                    : (tickOption.inside\r\n                       ? (this.grid.getXend() - length - 1) : (this.grid.getXend() + 1));\r\n\r\n                var y;\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    // 亚像素优化\r\n                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);\r\n                    axShape = {\r\n                        _axisShape: 'axisTick',\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable: false,\r\n                        style: {\r\n                            xStart: xPosition,\r\n                            yStart: y,\r\n                            xEnd: xPosition + length,\r\n                            yEnd: y,\r\n                            strokeColor: color,\r\n                            lineWidth: lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n        },\r\n\r\n        // 坐标轴文本\r\n        _buildAxisLabel: function () {\r\n            var axShape;\r\n            var data       = this._valueList;\r\n            var dataLength = this._valueList.length;\r\n            var rotate     = this.option.axisLabel.rotate;\r\n            var margin     = this.option.axisLabel.margin;\r\n            var clickable  = this.option.axisLabel.clickable;\r\n            var textStyle  = this.option.axisLabel.textStyle;\r\n\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var yPosition;\r\n                var baseLine;\r\n                if (this.option.position === 'bottom') {\r\n                    yPosition = this.grid.getYend() + margin;\r\n                    baseLine = 'top';\r\n                }\r\n                else {\r\n                    yPosition = this.grid.getY() - margin;\r\n                    baseLine = 'bottom';\r\n                }\r\n\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    axShape = {\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase() +3,\r\n                        hoverable: false,\r\n                        style: {\r\n                            x: this.getCoord(data[i]),\r\n                            y: yPosition,\r\n                            color: typeof textStyle.color === 'function'\r\n                                   ? textStyle.color(data[i]) : textStyle.color,\r\n                            text: this._valueLabel[i],\r\n                            textFont: this.getFont(textStyle),\r\n                            textAlign: textStyle.align || 'center',\r\n                            textBaseline: textStyle.baseline || baseLine\r\n                        }\r\n                    };\r\n                    if (rotate) {\r\n                        axShape.style.textAlign = rotate > 0\r\n                                                  ? (this.option.position === 'bottom'\r\n                                                    ? 'right' : 'left')\r\n                                                  : (this.option.position === 'bottom'\r\n                                                    ? 'left' : 'right');\r\n                        axShape.rotation = [\r\n                            rotate * Math.PI / 180,\r\n                            axShape.style.x,\r\n                            axShape.style.y\r\n                        ];\r\n                    }\r\n                    this.shapeList.push(new TextShape(\r\n                        this._axisLabelClickable(clickable, axShape)\r\n                    ));\r\n                }\r\n            }\r\n            else {\r\n                // 纵向\r\n                var xPosition;\r\n                var align;\r\n                if (this.option.position === 'left') {\r\n                    xPosition = this.grid.getX() - margin;\r\n                    align = 'right';\r\n                }\r\n                else {\r\n                    xPosition = this.grid.getXend() + margin;\r\n                    align = 'left';\r\n                }\r\n\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    axShape = {\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase() + 3,\r\n                        hoverable: false,\r\n                        style: {\r\n                            x: xPosition,\r\n                            y: this.getCoord(data[i]),\r\n                            color: typeof textStyle.color === 'function'\r\n                                   ? textStyle.color(data[i]) : textStyle.color,\r\n                            text: this._valueLabel[i],\r\n                            textFont: this.getFont(textStyle),\r\n                            textAlign: textStyle.align || align,\r\n                            textBaseline: textStyle.baseline\r\n                                          || (\r\n                                              (i === 0 && this.option.name !== '')\r\n                                              ? 'bottom'\r\n                                                : (i === dataLength - 1 && this.option.name !== '') ? 'top' : 'middle'\r\n                                          )\r\n                        }\r\n                    };\r\n\r\n                    if (rotate) {\r\n                        axShape.rotation = [\r\n                            rotate * Math.PI / 180,\r\n                            axShape.style.x,\r\n                            axShape.style.y\r\n                        ];\r\n                    }\r\n                    this.shapeList.push(new TextShape(\r\n                        this._axisLabelClickable(clickable, axShape)\r\n                    ));\r\n                }\r\n            }\r\n        },\r\n\r\n        _buildSplitLine: function () {\r\n            var axShape;\r\n            var data        = this._valueList;\r\n            var dataLength  = this._valueList.length;\r\n            var sLineOption = this.option.splitLine;\r\n            var lineType    = sLineOption.lineStyle.type;\r\n            var lineWidth   = sLineOption.lineStyle.width;\r\n            var color       = sLineOption.lineStyle.color;\r\n            color = color instanceof Array ? color : [color];\r\n            var colorLength = color.length;\r\n\r\n            if (this.isHorizontal()) {\r\n                // 横向\r\n                var sy = this.grid.getY();\r\n                var ey = this.grid.getYend();\r\n                var x;\r\n\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    // 亚像素优化\r\n                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);\r\n                    axShape = {\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable: false,\r\n                        style: {\r\n                            xStart: x,\r\n                            yStart: sy,\r\n                            xEnd: x,\r\n                            yEnd: ey,\r\n                            strokeColor: color[i % colorLength],\r\n                            lineType: lineType,\r\n                            lineWidth: lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n\r\n            }\r\n            else {\r\n                // 纵向\r\n                var sx = this.grid.getX();\r\n                var ex = this.grid.getXend();\r\n                var y;\r\n\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    // 亚像素优化\r\n                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);\r\n                    axShape = {\r\n                        zlevel: this.getZlevelBase(),\r\n                        z: this.getZBase(),\r\n                        hoverable: false,\r\n                        style: {\r\n                            xStart: sx,\r\n                            yStart: y,\r\n                            xEnd: ex,\r\n                            yEnd: y,\r\n                            strokeColor: color[i % colorLength],\r\n                            lineType: lineType,\r\n                            lineWidth: lineWidth\r\n                        }\r\n                    };\r\n                    this.shapeList.push(new LineShape(axShape));\r\n                }\r\n            }\r\n        },\r\n\r\n        _buildSplitArea: function () {\r\n            var axShape;\r\n            var color = this.option.splitArea.areaStyle.color;\r\n\r\n            if (!(color instanceof Array)) {\r\n                // 非数组一律认为是单一颜色的字符串，单一颜色则用一个背景，颜色错误不负责啊！！！\r\n                axShape = {\r\n                    zlevel: this.getZlevelBase(),\r\n                    z: this.getZBase(),\r\n                    hoverable: false,\r\n                    style: {\r\n                        x: this.grid.getX(),\r\n                        y: this.grid.getY(),\r\n                        width: this.grid.getWidth(),\r\n                        height: this.grid.getHeight(),\r\n                        color: color\r\n                        // type: this.option.splitArea.areaStyle.type,\r\n                    }\r\n                };\r\n                this.shapeList.push(new RectangleShape(axShape));\r\n            }\r\n            else {\r\n                // 多颜色\r\n                var colorLength = color.length;\r\n                var data        = this._valueList;\r\n                var dataLength  = this._valueList.length;\r\n\r\n                if (this.isHorizontal()) {\r\n                    // 横向\r\n                    var y = this.grid.getY();\r\n                    var height = this.grid.getHeight();\r\n                    var lastX = this.grid.getX();\r\n                    var curX;\r\n\r\n                    for (var i = 0; i <= dataLength; i++) {\r\n                        curX = i < dataLength\r\n                               ? this.getCoord(data[i])\r\n                               : this.grid.getXend();\r\n                        axShape = {\r\n                            zlevel: this.getZlevelBase(),\r\n                            z: this.getZBase(),\r\n                            hoverable: false,\r\n                            style: {\r\n                                x: lastX,\r\n                                y: y,\r\n                                width: curX - lastX,\r\n                                height: height,\r\n                                color: color[i % colorLength]\r\n                                // type: this.option.splitArea.areaStyle.type,\r\n                            }\r\n                        };\r\n                        this.shapeList.push(new RectangleShape(axShape));\r\n                        lastX = curX;\r\n                    }\r\n                }\r\n                else {\r\n                    // 纵向\r\n                    var x = this.grid.getX();\r\n                    var width = this.grid.getWidth();\r\n                    var lastYend = this.grid.getYend();\r\n                    var curY;\r\n\r\n                    for (var i = 0; i <= dataLength; i++) {\r\n                        curY = i < dataLength\r\n                               ? this.getCoord(data[i])\r\n                               : this.grid.getY();\r\n                        axShape = {\r\n                            zlevel: this.getZlevelBase(),\r\n                            z: this.getZBase(),\r\n                            hoverable: false,\r\n                            style: {\r\n                                x: x,\r\n                                y: curY,\r\n                                width: width,\r\n                                height: lastYend - curY,\r\n                                color: color[i % colorLength]\r\n                                // type: this.option.splitArea.areaStyle.type\r\n                            }\r\n                        };\r\n                        this.shapeList.push(new RectangleShape(axShape));\r\n                        lastYend = curY;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 极值计算\r\n         */\r\n        _calculateValue: function () {\r\n            if (isNaN(this.option.min - 0) || isNaN(this.option.max - 0)) {\r\n                // 有一个没指定都得算\r\n                // 数据整形\r\n                var data = {};          // 整形后数据抽取\r\n                var xIdx;\r\n                var yIdx;\r\n                var legend = this.component.legend;\r\n                for (var i = 0, l = this.series.length; i < l; i++) {\r\n                    if (this.series[i].type != ecConfig.CHART_TYPE_LINE\r\n                        && this.series[i].type != ecConfig.CHART_TYPE_BAR\r\n                        && this.series[i].type != ecConfig.CHART_TYPE_SCATTER\r\n                        && this.series[i].type != ecConfig.CHART_TYPE_K\r\n                        && this.series[i].type != ecConfig.CHART_TYPE_EVENTRIVER\r\n                    ) {\r\n                        // 非坐标轴支持的不算极值\r\n                        continue;\r\n                    }\r\n                    // 请允许我写开，跟上面一个不是一样东西\r\n                    if (legend && !legend.isSelected(this.series[i].name)){\r\n                        continue;\r\n                    }\r\n\r\n                    // 不指定默认为第一轴线\r\n                    xIdx = this.series[i].xAxisIndex || 0;\r\n                    yIdx = this.series[i].yAxisIndex || 0;\r\n                    if ((this.option.xAxisIndex != xIdx)\r\n                        && (this.option.yAxisIndex != yIdx)\r\n                    ) {\r\n                        // 不是自己的数据不计算极值\r\n                        continue;\r\n                    }\r\n\r\n                    this._calculSum(data, i);\r\n                }\r\n\r\n                // 找极值\r\n                var oriData;            // 原始数据\r\n                for (var i in data){\r\n                    oriData = data[i];\r\n                    for (var j = 0, k = oriData.length; j < k; j++) {\r\n                        if (!isNaN(oriData[j])){\r\n                            this._hasData = true;\r\n                            this._min = oriData[j];\r\n                            this._max = oriData[j];\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (this._hasData) {\r\n                        break;\r\n                    }\r\n                }\r\n                for (var i in data){\r\n                    oriData = data[i];\r\n                    for (var j = 0, k = oriData.length; j < k; j++) {\r\n                        if (!isNaN(oriData[j])){\r\n                            this._min = Math.min(this._min, oriData[j]);\r\n                            this._max = Math.max(this._max, oriData[j]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // console.log(this._min,this._max,'vvvvv111111',this.option.type)\r\n                // log情况暂时禁用boundaryGap。\r\n                var boundaryGap = this.option.type !== 'log' ? this.option.boundaryGap : [0, 0];\r\n                var gap = Math.abs(this._max - this._min);\r\n                this._min = isNaN(this.option.min - 0)\r\n                       ? (this._min - Math.abs(gap * boundaryGap[0]))\r\n                       : (this.option.min - 0);    // 指定min忽略boundaryGay[0]\r\n\r\n                this._max = isNaN(this.option.max - 0)\r\n                       ? (this._max + Math.abs(gap * boundaryGap[1]))\r\n                       : (this.option.max - 0);    // 指定max忽略boundaryGay[1]\r\n                if (this._min === this._max) {\r\n                    if (this._max === 0) {\r\n                        // 修复全0数据\r\n                        this._max = 1;\r\n                    }\r\n                    // 修复最大值==最小值时数据整形\r\n                    else if (this._max > 0) {\r\n                        this._min = this._max / this.option.splitNumber != null ? this.option.splitNumber : 5;\r\n                    }\r\n                    else { // this._max < 0\r\n                        this._max = this._max / this.option.splitNumber != null ? this.option.splitNumber : 5;\r\n                    }\r\n                }\r\n\r\n                if (this.option.type === 'time') {\r\n                    this._reformTimeValue();\r\n                }\r\n                else if (this.option.type === 'log') {\r\n                    this._reformLogValue();\r\n                }\r\n                else {\r\n                    this._reformValue(this.option.scale);\r\n                }\r\n            }\r\n            else {\r\n                this._hasData = true;\r\n                // 用户指定min max就不多管闲事了\r\n                this._min = this.option.min - 0;    // 指定min忽略boundaryGay[0]\r\n                this._max = this.option.max - 0;    // 指定max忽略boundaryGay[1]\r\n\r\n                if (this.option.type === 'time') {\r\n                    this._reformTimeValue();\r\n                }\r\n                else if (this.option.type === 'log') {\r\n                    this._reformLogValue();\r\n                }\r\n                else {\r\n                    this._customerValue();\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 内部使用，计算某系列下的堆叠和\r\n         */\r\n        _calculSum: function (data, i) {\r\n            var key = this.series[i].name || 'kener';\r\n            var value;\r\n            var oriData;\r\n            if (!this.series[i].stack) {\r\n                data[key] = data[key] || [];\r\n                if (this.series[i].type != ecConfig.CHART_TYPE_EVENTRIVER) {\r\n                    oriData = this.series[i].data;\r\n                    for (var j = 0, k = oriData.length; j < k; j++) {\r\n                        value = this.getDataFromOption(oriData[j]);\r\n                        if (this.series[i].type === ecConfig.CHART_TYPE_K) {\r\n                            data[key].push(value[0]);\r\n                            data[key].push(value[1]);\r\n                            data[key].push(value[2]);\r\n                            data[key].push(value[3]);\r\n                        }\r\n                        else if (value instanceof Array) {\r\n                            // scatter 、 不等距 line bar\r\n                            if (this.option.xAxisIndex != -1) {\r\n                                data[key].push(\r\n                                    this.option.type != 'time'\r\n                                    ? value[0] : ecDate.getNewDate(value[0])\r\n                                );\r\n                            }\r\n                            if (this.option.yAxisIndex != -1) {\r\n                                data[key].push(\r\n                                    this.option.type != 'time'\r\n                                    ? value[1] : ecDate.getNewDate(value[1])\r\n                                );\r\n                            }\r\n                        }\r\n                        else {\r\n                            data[key].push(value);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // eventRiver\r\n                    oriData = this.series[i].data;\r\n                    for (var j = 0, k = oriData.length; j < k; j++) {\r\n                        var evolution = oriData[j].evolution;\r\n                        for (var m = 0, n = evolution.length; m < n; m++) {\r\n                            data[key].push(ecDate.getNewDate(evolution[m].time));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // 堆积数据，需要区分正负向堆积\r\n                var keyP = '__Magic_Key_Positive__' + this.series[i].stack;\r\n                var keyN = '__Magic_Key_Negative__' + this.series[i].stack;\r\n                data[keyP] = data[keyP] || [];\r\n                data[keyN] = data[keyN] || [];\r\n                data[key] = data[key] || [];  // scale下还需要记录每一个量\r\n                oriData = this.series[i].data;\r\n                for (var j = 0, k = oriData.length; j < k; j++) {\r\n                    value = this.getDataFromOption(oriData[j]);\r\n                    if (value === '-') {\r\n                        continue;\r\n                    }\r\n                    value = value - 0;\r\n                    if (value >= 0) {\r\n                        if (data[keyP][j] != null) {\r\n                            data[keyP][j] += value;\r\n                        }\r\n                        else {\r\n                            data[keyP][j] = value;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (data[keyN][j] != null) {\r\n                            data[keyN][j] += value;\r\n                        }\r\n                        else {\r\n                            data[keyN][j] = value;\r\n                        }\r\n                    }\r\n                    if (this.option.scale) {\r\n                        data[key].push(value);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 找到原始数据的极值后根据选项整形最终 this._min / this._max / this._valueList\r\n         * 如果你不知道这个“整形”的用义，请不要试图去理解和修改这个方法！找我也没用，我相信我已经记不起来！\r\n         * 如果你有更简洁的数学推导欢迎重写，后果自负~\r\n         *\r\n         * by kener.linfeng@gmail.com 2013-1-8\r\n         * --------\r\n         * 感谢谢世威(https://github.com/i6ma)，终于有人改这个方法了\r\n         * by Kener 2014-11-6\r\n         */\r\n        _reformValue: function (scale) {\r\n            var smartSteps = require('../util/smartSteps');\r\n            var splitNumber = this.option.splitNumber;\r\n\r\n            // 非scale下双正，修正最小值为0\r\n            if (!scale && this._min >= 0 && this._max >= 0) {\r\n                this._min = 0;\r\n            }\r\n            // 非scale下双负，修正最大值为0\r\n            if (!scale && this._min <= 0 && this._max <= 0) {\r\n                this._max = 0;\r\n            }\r\n\r\n            var stepOpt = smartSteps(this._min, this._max, splitNumber);\r\n            splitNumber = splitNumber != null ? splitNumber : stepOpt.secs;\r\n            //this.option.splitNumber = splitNumber;\r\n            this._min = stepOpt.min;\r\n            this._max = stepOpt.max;\r\n            this._valueList = stepOpt.pnts;\r\n            this._reformLabelData();\r\n        },\r\n\r\n        /**\r\n         * 格式化时间值\r\n         */\r\n        _reformTimeValue : function() {\r\n            var splitNumber = this.option.splitNumber != null ? this.option.splitNumber : 5;\r\n\r\n            // 最优解\r\n            var curValue = ecDate.getAutoFormatter(this._min, this._max, splitNumber);\r\n            // 目标\r\n            var formatter = curValue.formatter;\r\n            var gapValue = curValue.gapValue;\r\n\r\n            this._valueList = [ecDate.getNewDate(this._min)];\r\n            var startGap;\r\n            switch (formatter) {\r\n                case 'week' :\r\n                    startGap = ecDate.nextMonday(this._min);\r\n                    break;\r\n                case 'month' :\r\n                    startGap = ecDate.nextNthOnMonth(this._min, 1);\r\n                    break;\r\n                case 'quarter' :\r\n                    startGap = ecDate.nextNthOnQuarterYear(this._min, 1);\r\n                    break;\r\n                case 'half-year' :\r\n                    startGap = ecDate.nextNthOnHalfYear(this._min, 1);\r\n                    break;\r\n                case 'year' :\r\n                    startGap = ecDate.nextNthOnYear(this._min, 1);\r\n                    break;\r\n                default :\r\n                    // 大于2小时需要考虑时区不能直接取整\r\n                    if (gapValue <= 3600000 * 2) {\r\n                        startGap = (Math.floor(this._min / gapValue) + 1) * gapValue;\r\n                    }\r\n                    else {\r\n                        startGap = ecDate.getNewDate(this._min - (-gapValue));\r\n                        startGap.setHours(Math.round(startGap.getHours() / 6) * 6);\r\n                        startGap.setMinutes(0);\r\n                        startGap.setSeconds(0);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            if (startGap - this._min < gapValue / 2) {\r\n                startGap -= -gapValue;\r\n            }\r\n\r\n            // console.log(startGap,gapValue,this._min, this._max,formatter)\r\n            curValue = ecDate.getNewDate(startGap);\r\n            splitNumber *= 1.5;\r\n            while (splitNumber-- >= 0) {\r\n                if (formatter == 'month'\r\n                    || formatter == 'quarter'\r\n                    || formatter == 'half-year'\r\n                    || formatter == 'year'\r\n                ) {\r\n                    curValue.setDate(1);\r\n                }\r\n                if (this._max - curValue < gapValue / 2) {\r\n                    break;\r\n                }\r\n                this._valueList.push(curValue);\r\n                curValue = ecDate.getNewDate(curValue - (-gapValue));\r\n            }\r\n            this._valueList.push(ecDate.getNewDate(this._max));\r\n\r\n            this._reformLabelData((function (formatterStr) {\r\n                return function (value) {\r\n                    return ecDate.format(formatterStr, value);\r\n                };\r\n            })(formatter));\r\n        },\r\n\r\n        _customerValue: function () {\r\n            var accMath = require('../util/accMath');\r\n            var splitNumber = this.option.splitNumber != null ? this.option.splitNumber : 5;\r\n            var splitGap = (this._max - this._min) / splitNumber;\r\n\r\n            this._valueList = [];\r\n            for (var i = 0; i <= splitNumber; i++) {\r\n                this._valueList.push(accMath.accAdd(this._min, accMath.accMul(splitGap, i)));\r\n            }\r\n            this._reformLabelData();\r\n        },\r\n\r\n        _reformLogValue: function() {\r\n            // log数轴本质就是缩放，相当于默认this.option.scale === true，所以不修正_min和_max到0。\r\n            var thisOption = this.option;\r\n            var result = require('../util/smartLogSteps')({\r\n                dataMin: this._min,\r\n                dataMax: this._max,\r\n                logPositive: thisOption.logPositive,\r\n                logLabelBase: thisOption.logLabelBase,\r\n                splitNumber: thisOption.splitNumber\r\n            });\r\n\r\n            this._min = result.dataMin;\r\n            this._max = result.dataMax;\r\n            this._valueList = result.tickList;\r\n            // {value2Coord: {Function}, coord2Value: {Function}}\r\n            this._dataMappingMethods = result.dataMappingMethods;\r\n\r\n            this._reformLabelData(result.labelFormatter);\r\n        },\r\n\r\n        _reformLabelData: function (innerFormatter) {\r\n            this._valueLabel = [];\r\n            var formatter = this.option.axisLabel.formatter;\r\n            if (formatter) {\r\n                for (var i = 0, l = this._valueList.length; i < l; i++) {\r\n                    if (typeof formatter === 'function') {\r\n                        this._valueLabel.push(\r\n                            innerFormatter\r\n                                ? formatter.call(this.myChart, this._valueList[i], innerFormatter)\r\n                                : formatter.call(this.myChart, this._valueList[i])\r\n                        );\r\n                    }\r\n                    else if (typeof formatter === 'string') {\r\n                        this._valueLabel.push(\r\n                            innerFormatter\r\n                                ? ecDate.format(formatter, this._valueList[i])\r\n                                : formatter.replace('{value}',this._valueList[i])\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0, l = this._valueList.length; i < l; i++) {\r\n                    this._valueLabel.push(\r\n                        innerFormatter\r\n                            ? innerFormatter(this._valueList[i])\r\n                            : this.numAddCommas(this._valueList[i]) // 每三位默认加,格式化\r\n                    );\r\n                }\r\n            }\r\n        },\r\n\r\n        getExtremum: function () {\r\n            this._calculateValue();\r\n            var dataMappingMethods = this._dataMappingMethods;\r\n            return {\r\n                min: this._min,\r\n                max: this._max,\r\n                dataMappingMethods: dataMappingMethods\r\n                    ? zrUtil.merge({}, dataMappingMethods) : null\r\n            };\r\n        },\r\n\r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption, newSeries) {\r\n            if (newOption) {\r\n                this.option = this.reformOption(newOption);\r\n                // 通用字体设置\r\n                this.option.axisLabel.textStyle = zrUtil.merge(\r\n                    this.option.axisLabel.textStyle || {},\r\n                    this.ecTheme.textStyle\r\n                );\r\n                this.series = newSeries;\r\n            }\r\n            if (this.zr) {   // 数值轴的另外一个功能只是用来计算极值\r\n                this.clear();\r\n                this._buildShape();\r\n            }\r\n        },\r\n\r\n        // 根据值换算位置\r\n        getCoord: function (value) {\r\n            if (this._dataMappingMethods) {\r\n                value = this._dataMappingMethods.value2Coord(value);\r\n            }\r\n\r\n            value = value < this._min ? this._min : value;\r\n            value = value > this._max ? this._max : value;\r\n\r\n            var result;\r\n            if (!this.isHorizontal()) {\r\n                // 纵向\r\n                result = this.grid.getYend()\r\n                         - (value - this._min)\r\n                           / (this._max - this._min)\r\n                           * this.grid.getHeight();\r\n            }\r\n            else {\r\n                // 横向\r\n                result = this.grid.getX()\r\n                         + (value - this._min)\r\n                           / (this._max - this._min)\r\n                           * this.grid.getWidth();\r\n            }\r\n\r\n            return result;\r\n            // Math.floor可能引起一些偏差，但性能会更好\r\n            /* 准确更重要\r\n            return (value === this._min || value === this._max)\r\n                   ? result\r\n                   : Math.floor(result);\r\n            */\r\n        },\r\n\r\n        // 根据值换算绝对大小\r\n        getCoordSize: function (value) {\r\n            if (!this.isHorizontal()) {\r\n                // 纵向\r\n                return Math.abs(value / (this._max - this._min) * this.grid.getHeight());\r\n            }\r\n            else {\r\n                // 横向\r\n                return Math.abs(value / (this._max - this._min) * this.grid.getWidth());\r\n            }\r\n        },\r\n\r\n        // 根据位置换算值\r\n        getValueFromCoord: function(coord) {\r\n            var result;\r\n\r\n            if (!this.isHorizontal()) {\r\n                // 纵向\r\n                coord = coord < this.grid.getY() ? this.grid.getY() : coord;\r\n                coord = coord > this.grid.getYend() ? this.grid.getYend() : coord;\r\n                result = this._max\r\n                         - (coord - this.grid.getY())\r\n                           / this.grid.getHeight()\r\n                           * (this._max - this._min);\r\n            }\r\n            else {\r\n                // 横向\r\n                coord = coord < this.grid.getX() ? this.grid.getX() : coord;\r\n                coord = coord > this.grid.getXend() ? this.grid.getXend() : coord;\r\n                result = this._min\r\n                         + (coord - this.grid.getX())\r\n                           / this.grid.getWidth()\r\n                           * (this._max - this._min);\r\n            }\r\n\r\n            if (this._dataMappingMethods) {\r\n                result = this._dataMappingMethods.coord2Value(result);\r\n            }\r\n\r\n            return result.toFixed(2) - 0;\r\n        },\r\n\r\n        isMaindAxis : function (value) {\r\n            for (var i = 0, l = this._valueList.length; i < l; i++) {\r\n                if (this._valueList[i] === value) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ValueAxis, Base);\r\n\r\n    require('../component').define('valueAxis', ValueAxis);\r\n\r\n    return ValueAxis;\r\n});\r\n\r\n"
    },
    {
      "id": 56,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\date.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/date.js",
      "index": 56,
      "index2": 49,
      "size": 5788,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "../util/date",
          "loc": "75:17-40"
        },
        {
          "moduleId": 60,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
          "type": "cjs require",
          "userRequest": "../util/date",
          "loc": "44:17-40"
        }
      ],
      "source": "/**\r\n * echarts日期运算格式化相关\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function() {\r\n    var _timeGap = [\r\n        {formatter: 'hh : mm : ss', value: 1000},               // 1s\r\n        {formatter: 'hh : mm : ss', value: 1000 * 5},           // 5s\r\n        {formatter: 'hh : mm : ss', value: 1000 * 10},          // 10s\r\n        {formatter: 'hh : mm : ss', value: 1000 * 15},          // 15s\r\n        {formatter: 'hh : mm : ss', value: 1000 * 30},          // 30s\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000},          // 1m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000 * 5},      // 5m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000 * 10},     // 10m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000 * 15},     // 15m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 60000 * 30},     // 30m\r\n        {formatter: 'hh : mm\\nMM - dd', value: 3600000},        // 1h\r\n        {formatter: 'hh : mm\\nMM - dd', value: 3600000 * 2},    // 2h\r\n        {formatter: 'hh : mm\\nMM - dd', value: 3600000 * 6},    // 6h\r\n        {formatter: 'hh : mm\\nMM - dd', value: 3600000 * 12},   // 12h\r\n        {formatter: 'MM - dd\\nyyyy', value: 3600000 * 24},      // 1d\r\n        {formatter: 'week', value: 3600000 * 24 * 7},           // 7d\r\n        {formatter: 'month', value: 3600000 * 24 * 31},         // 1M\r\n        {formatter: 'quarter', value: 3600000 * 24 * 380 / 4},  // 3M\r\n        {formatter: 'half-year', value: 3600000 * 24 * 380 / 2},// 6M\r\n        {formatter: 'year', value: 3600000 * 24 * 380}          // 1Y\r\n    ];\r\n    \r\n    /**\r\n     * 获取最佳formatter\r\n     * @params {number} min 最小值\r\n     * @params {number} max 最大值\r\n     * @params {=number} splitNumber 分隔段数\r\n     */\r\n    function getAutoFormatter(min, max, splitNumber) {\r\n        splitNumber = splitNumber > 1 ? splitNumber : 2;\r\n        // 最优解\r\n        var curValue;\r\n        var totalGap;\r\n        // 目标\r\n        var formatter;\r\n        var gapValue;\r\n        for (var i = 0, l = _timeGap.length; i < l; i++) {\r\n            curValue = _timeGap[i].value;\r\n            totalGap = Math.ceil(max / curValue) * curValue \r\n                       - Math.floor(min / curValue) * curValue;\r\n            if (Math.round(totalGap / curValue) <= splitNumber * 1.2) {\r\n                formatter =  _timeGap[i].formatter;\r\n                gapValue = _timeGap[i].value;\r\n                // console.log(formatter, gapValue,i);\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (formatter == null) {\r\n            formatter = 'year';\r\n            curValue = 3600000 * 24 * 367;\r\n            totalGap = Math.ceil(max / curValue) * curValue \r\n                       - Math.floor(min / curValue) * curValue;\r\n            gapValue = Math.round(totalGap / (splitNumber - 1) / curValue) * curValue;\r\n        }\r\n        \r\n        return {\r\n            formatter: formatter,\r\n            gapValue: gapValue\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * 一位数字补0 \r\n     */\r\n    function s2d (v) {\r\n        return v < 10 ? ('0' + v) : v;\r\n    }\r\n    \r\n    /**\r\n     * 百分比计算\r\n     */\r\n    function format(formatter, value) {\r\n        if (formatter == 'week' \r\n            || formatter == 'month' \r\n            || formatter == 'quarter' \r\n            || formatter == 'half-year'\r\n            || formatter == 'year'\r\n        ) {\r\n            formatter = 'MM - dd\\nyyyy';\r\n        }\r\n            \r\n        var date = getNewDate(value);\r\n        var y = date.getFullYear();\r\n        var M = date.getMonth() + 1;\r\n        var d = date.getDate();\r\n        var h = date.getHours();\r\n        var m = date.getMinutes();\r\n        var s = date.getSeconds();\r\n        \r\n        formatter = formatter.replace('MM', s2d(M));\r\n        formatter = formatter.toLowerCase();\r\n        formatter = formatter.replace('yyyy', y);\r\n        formatter = formatter.replace('yy', y % 100);\r\n        formatter = formatter.replace('dd', s2d(d));\r\n        formatter = formatter.replace('d', d);\r\n        formatter = formatter.replace('hh', s2d(h));\r\n        formatter = formatter.replace('h', h);\r\n        formatter = formatter.replace('mm', s2d(m));\r\n        formatter = formatter.replace('m', m);\r\n        formatter = formatter.replace('ss', s2d(s));\r\n        formatter = formatter.replace('s', s);\r\n\r\n        return formatter;\r\n    }\r\n    \r\n    function nextMonday(value) {\r\n        value = getNewDate(value);\r\n        value.setDate(value.getDate() + 8 - value.getDay());\r\n        return value;\r\n    }\r\n    \r\n    function nextNthPerNmonth(value, nth, nmon) {\r\n        value = getNewDate(value);\r\n        value.setMonth(Math.ceil((value.getMonth() + 1) / nmon) * nmon);\r\n        value.setDate(nth);\r\n        return value;\r\n    }\r\n    \r\n    function nextNthOnMonth(value, nth) {\r\n        return nextNthPerNmonth(value, nth, 1);\r\n    }\r\n    \r\n    function nextNthOnQuarterYear(value, nth) {\r\n        return nextNthPerNmonth(value, nth, 3);\r\n    }\r\n    \r\n    function nextNthOnHalfYear(value, nth) {\r\n        return nextNthPerNmonth(value, nth, 6);\r\n    }\r\n    \r\n    function nextNthOnYear(value, nth) {\r\n        return nextNthPerNmonth(value, nth, 12);\r\n    }\r\n    \r\n    function getNewDate(value) {\r\n        return value instanceof Date\r\n               ? value\r\n               : new Date(typeof value == 'string' ? value.replace(/-/g, '/') : value);\r\n    }\r\n    \r\n    return {\r\n        getAutoFormatter: getAutoFormatter,\r\n        getNewDate: getNewDate,\r\n        format: format,\r\n        nextMonday: nextMonday,\r\n        nextNthPerNmonth: nextNthPerNmonth,\r\n        nextNthOnMonth: nextNthOnMonth,\r\n        nextNthOnQuarterYear: nextNthOnQuarterYear,\r\n        nextNthOnHalfYear: nextNthOnHalfYear,\r\n        nextNthOnYear : nextNthOnYear\r\n    };\r\n});"
    },
    {
      "id": 57,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\smartSteps.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/smartSteps.js",
      "index": 57,
      "index2": 50,
      "size": 18862,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "../util/smartSteps",
          "loc": "667:29-58"
        }
      ],
      "source": "\r\n/**\r\n * echarts 值轴分段刻度计算方法\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n * @author xieshiwei (谢世威, i6ma@i6ma.com)\r\n *\r\n */\r\n\r\n\r\n/**\r\n * 最值、跨度、步长取近似值\r\n * 注意：不适用于高精度需求，或者很多位有效数字的情况！！！\r\n * @function    smartSteps\r\n * @param       {Number}    min             最小值\r\n * @param       {Number}    max             最大值\r\n * @param       {Number}    [section]       段数只能是 [0, 99] 的整数，段数为 0 或者不指定段数时，将自动调整段数\r\n * @param       {Object}    [opts]          其它扩展参数\r\n * @param       {Array}     opts.steps      自定义步长备选值，如 [10, 12, 15, 20, 25, 30, 40, 50, 60, 80] ，但必须 => [10, 99]\r\n * @return      {Object}    {min: 新最小值, max: 新最大值, secs: 分段数, step: 每段长, fix: 小数保留位数, pnts: [分段结果]}\r\n */\r\ndefine(function() {\r\n\r\n\r\n\r\nvar mySteps     = [10, 20, 25, 50];\r\nvar mySections  = [4, 5, 6];\r\n\r\nvar custOpts;\r\nvar custSteps;\r\nvar custSecs;\r\nvar minLocked;\r\nvar maxLocked;\r\n\r\nvar MT          = Math;\r\nvar MATH_ROUND  = MT.round;\r\nvar MATH_FLOOR  = MT.floor;\r\nvar MATH_CEIL   = MT.ceil;\r\nvar MATH_ABS    = MT.abs;\r\n\r\n\r\nfunction MATH_LOG(n) {return MT.log(MATH_ABS(n)) / MT.LN10;}\r\nfunction MATH_POW(n) {return MT.pow(10, n);}\r\nfunction MATH_ISINT(n) {return n === MATH_FLOOR(n);}\r\n\r\n\r\nfunction smartSteps(min, max, section, opts) {\r\n    // 拿公共变量来接收 opts.steps 这个参数，就不用带着参数层层传递了，注意在函数的最终出口处释放这个值\r\n    custOpts    = opts || {};\r\n    custSteps   = custOpts.steps || mySteps;\r\n    custSecs    = custOpts.secs || mySections;\r\n    section     = MATH_ROUND(+section || 0) % 99;           // 段数限定在 [0, 99] ，0 则自适应\r\n    min         = +min || 0;\r\n    max         = +max || 0;\r\n    minLocked   = maxLocked = 0;\r\n    if ('min' in custOpts) {\r\n        min     = +custOpts.min || 0;\r\n        minLocked = 1;\r\n    }\r\n    if ('max' in custOpts) {\r\n        max     = +custOpts.max || 0;\r\n        maxLocked = 1;\r\n    }\r\n    if (min > max) {max = [min, min = max][0];}             // 最值交换\r\n    var span    = max - min;\r\n    if (minLocked && maxLocked) {\r\n        return bothLocked(min, max, section);               // 两个最值同时被锁定，注意差值为 0 的情况\r\n    }\r\n    if (span < (section || 5)) {                            // 跨度值小于要分的段数，步长将会小于 1\r\n        if (MATH_ISINT(min) && MATH_ISINT(max)) {           // 步长小于 1 同时两个最值都是整数，特别处理\r\n            return forInteger(min, max, section);           // 也要考虑差值为 0 的情况\r\n        }\r\n        else if (span === 0) {                              // 非整数且跨度为 0 的情况\r\n            return forSpan0(min, max, section);\r\n        }\r\n    }\r\n    return coreCalc(min, max, section);                     // 非特殊情况的计算，须确保 min < max\r\n}\r\n\r\n\r\n\r\n/**\r\n * 构造返回值，处理小数精度等问题\r\n * @param   {Number}    newMin      最小值\r\n * @param   {Number}    newMax      最大值\r\n * @param   {Number}    section     分段数\r\n * @param   {Number}    [expon]     计算量级\r\n * @return  {Object}                同 smartSteps\r\n */\r\nfunction makeResult(newMin, newMax, section, expon) {\r\n    expon       = expon || 0;                               // 这是中间计算量级，受步长增长、特别是最值锁定的影响，可能会小于基准量级，因为整数部分被过度放大\r\n    var expStep = expNum((newMax - newMin) / section, -1);\r\n    var expMin  = expNum(newMin, -1, 1);                    // 锁定的最值有效数位可能很多，需要全精度保留\r\n    var expMax  = expNum(newMax, -1);\r\n    var minExp  = MT.min(expStep.e, expMin.e, expMax.e);    // 这个值实际上就是各值整数部分尾部多余的 0 的个数\r\n    if (expMin.c === 0) {                                   // 0 可以有任意多个尾0\r\n        minExp  = MT.min(expStep.e, expMax.e);\r\n    } else if (expMax.c === 0) {\r\n        minExp  = MT.min(expStep.e, expMin.e);\r\n    }\r\n    expFixTo(expStep, {c: 0, e: minExp});\r\n    expFixTo(expMin, expStep, 1);\r\n    expFixTo(expMax, expStep);\r\n    expon      += minExp;                                   // 最终的基准量级，在这个量级下，各值刚好能表示成整数\r\n    newMin      = expMin.c;\r\n    newMax      = expMax.c;\r\n    var step    = (newMax - newMin) / section;\r\n    var zoom    = MATH_POW(expon);\r\n    var fixTo   = 0;\r\n    var points  = [];\r\n    for (var i  = section + 1; i--;) {                      // 因为点数比段数多 1\r\n        points[i] = (newMin + step * i) * zoom;             // 如果不涉及小数问题，这里就直接使用数值型\r\n    }\r\n    if (expon   < 0) {\r\n        fixTo   = decimals(zoom);                           // 前面已经去掉了各值尾部多余的 0 ，所以 zoom 的小数位就是最终的 fix 位数\r\n        step    = +(step * zoom).toFixed(fixTo);            // toFixed 处理长尾小数问题，如：0.2 * 0.1 = 0.020000000000000004\r\n        newMin  = +(newMin * zoom).toFixed(fixTo);\r\n        newMax  = +(newMax * zoom).toFixed(fixTo);\r\n        for (var i = points.length; i--;) {\r\n            points[i] = points[i].toFixed(fixTo);           // 为保证小数点对齐，统一转为字符型\r\n            +points[i] === 0 && (points[i] = '0');          // 0.000 不好看\r\n        }\r\n    }\r\n    else {\r\n        newMin *= zoom;\r\n        newMax *= zoom;\r\n        step   *= zoom;\r\n    }\r\n    custSecs    = 0;\r\n    custSteps   = 0;\r\n    custOpts    = 0;\r\n    // 这些公共变量可能持用了对用户参数的引用，这里是函数的最终出口，释放引用\r\n\r\n    return {\r\n        min:    newMin,                 // 新最小值\r\n        max:    newMax,                 // 新最大值\r\n        secs:   section,                // 分段数\r\n        step:   step,                   // 每段长\r\n        fix:    fixTo,                  // 小数保留位数，0 则为整数\r\n        exp:    expon,                  // 基准量级，并非原值所在的量级，而是说在这个量级下，各值能表示成整数\r\n        pnts:   points                  // 分段结果，整数都是数值型，小数时为了对齐小数点，都是字符型，但其中 0 不带小数点，即没有 \"0.000\"\r\n    };\r\n}\r\n\r\n\r\n\r\n/**\r\n * 量级计数法 表示数值，不适用于很大或者很小的数，0 更不行\r\n * @param       {Number}    num             原数\r\n * @param       {Number}    [digit = 2]     精度位数，必须 => [1, 9]\r\n * @param       {Boolean}   [byFloor = 0]   默认为 0 表示近似值不小于原值，置 1 表示近似值不大于原值\r\n * @return      {Object}    {c: c, e: e}    c e 都是整数，c * 10 ^ e 即为原值的近似数\r\n * @description             返回值应该更详细一点：{c: c, e: e, d: d, n: n} ，其中 d 是 c 的位数，n = c * 10 ^ e ，不过目前好像不太有用\r\n */\r\nfunction expNum(num, digit, byFloor) {\r\n    digit       = MATH_ROUND(digit % 10) || 2;\r\n    if (digit   < 0) {                                      // 全精度位数\r\n        if (MATH_ISINT(num)) {                              // 整数的全精度位数，要去掉尾 0 ，但 0 也是整数，要专门留一位精度\r\n            digit = ('' + MATH_ABS(num)).replace(/0+$/, '').length || 1;\r\n        }\r\n        else {                                              // 小数的全精度位数，要去掉首 0\r\n            num = num.toFixed(15).replace(/0+$/, '');       // toFixed 处理长尾小数\r\n            digit = num.replace('.', '').replace(/^[-0]+/, '').length;\r\n            num = +num;                                     // '' + 0.0000001 会得到 '1e-7'\r\n        }\r\n    }\r\n    var expon   = MATH_FLOOR(MATH_LOG(num)) - digit + 1;\r\n    var cNum    = +(num * MATH_POW(-expon)).toFixed(15) || 0;   // toFixed 处理长尾小数问题\r\n    cNum        = byFloor ? MATH_FLOOR(cNum) : MATH_CEIL(cNum); // 向上取整可能发生进位，使精度位数增加 1\r\n    !cNum && (expon = 0);\r\n    if (('' + MATH_ABS(cNum)).length > digit) {                 // 整数位数判断，字符串法比对数法快近一倍\r\n        expon  += 1;\r\n        cNum   /= 10;\r\n    }\r\n    return {\r\n        c: cNum,\r\n        e: expon\r\n    };\r\n}\r\n\r\n\r\n/**\r\n * 将前者的指数对齐到后者，如果前者量级较小，就是强制加大指数，值误差可能严重放大，甚至值变为 0\r\n */\r\nfunction expFixTo(expnum1, expnum2, byFloor) {\r\n    var deltaExp    = expnum2.e - expnum1.e;\r\n    if (deltaExp) {\r\n        expnum1.e  += deltaExp;                             // 指数减小时，只需将整数部分相应放大\r\n        expnum1.c  *= MATH_POW(-deltaExp);                  // 指数增加时，整数部分将缩小，就涉及 floor ceil 取整和变 0 问题\r\n        expnum1.c   = byFloor ? MATH_FLOOR(expnum1.c) : MATH_CEIL(expnum1.c);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * 将两个量级数的指数对齐到较小者\r\n */\r\nfunction expFixMin(expnum1, expnum2, byFloor) {\r\n    if (expnum1.e < expnum2.e) {\r\n        expFixTo(expnum2, expnum1, byFloor);\r\n    }\r\n    else {\r\n        expFixTo(expnum1, expnum2, byFloor);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * 基于量级计数法，对原值的整数部分取近似，不适用于负数和 0\r\n * @param       {Number}    num             原值\r\n * @param       {Array}     [rounds]        在取近似时，提供预置选项，近似到 rounds 中的某项\r\n * @return      {Object}    expNum          2 位精度的量级计数法对象，不小于原值\r\n */\r\nfunction getCeil(num, rounds) {\r\n    rounds      = rounds || mySteps;\r\n    num         = expNum(num);                              // 2 位精度量级计数法\r\n    var cNum    = num.c;\r\n    var i       = 0;\r\n    while (cNum > rounds[i]) {                              // 在预置的近似数中，找到不小于目标 cNum 的项\r\n        i++;\r\n    }\r\n    if (!rounds[i]) {                                       // 如果没找到合适的预置项，一定是目标值大于全部的预置项\r\n        cNum   /= 10;                                       // 将目标值缩小 10 倍，重找一次定能命中\r\n        num.e  += 1;\r\n        i       = 0;\r\n        while (cNum > rounds[i]) {\r\n            i++;\r\n        }\r\n    }\r\n    num.c       = rounds[i];\r\n    return num;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * 基于量级计数法的计算，必须 min < max\r\n */\r\nfunction coreCalc(min, max, section) {\r\n    var step;\r\n    var secs    = section || +custSecs.slice(-1);\r\n    var expStep = getCeil((max - min) / secs, custSteps);   // 这是可能的最小步长，以它的量级作为后续计算的基准量级，以保证整数计算特性\r\n    var expSpan = expNum(max - min);                        // 2 位精度的最值跨度，过高的精度意味着有效数位更多\r\n    var expMin  = expNum(min, -1, 1);                       // 最小值向下近似，以涵盖原最小值\r\n    var expMax  = expNum(max, -1);     // 最大值向上近似，参数 -1 表示保留全精度，因为要注意 min = 10000001, max = 10000002 等情况\r\n    expFixTo(expSpan, expStep);                             // 指数对齐\r\n    expFixTo(expMin, expStep, 1);                           // 经过指数对齐，原最大值、最小值都有可能变为 0\r\n    expFixTo(expMax, expStep);\r\n    if (!section) {\r\n        secs    = look4sections(expMin, expMax);\r\n    }\r\n    else {\r\n        step    = look4step(expMin, expMax, secs);\r\n    }\r\n\r\n    // 如果原最值都是整数，尽量让输出值也保持整数，但原最值跨 0 的则不调整\r\n    if (MATH_ISINT(min) && MATH_ISINT(max) && min * max >= 0) {\r\n        if (max - min < secs) {                             // 再次出现跨度小于段数\r\n            return forInteger(min, max, secs);\r\n        }\r\n        secs = tryForInt(min, max, section, expMin, expMax, secs);\r\n    }\r\n    var arrMM   = cross0(min, max, expMin.c, expMax.c);\r\n    expMin.c    = arrMM[0];\r\n    expMax.c    = arrMM[1];\r\n    if (minLocked || maxLocked) {\r\n        singleLocked(min, max, expMin, expMax);\r\n    }\r\n    return makeResult(expMin.c, expMax.c, secs, expMax.e);\r\n}\r\n\r\n\r\n\r\n/**\r\n * 在预置的可选段数中，找出一个合适的值，让跨度误差尽量小\r\n */\r\nfunction look4sections(expMin, expMax) {\r\n    var section;\r\n    var tmpStep, tmpMin, tmpMax;\r\n    var reference   = [];\r\n    for (var i      = custSecs.length; i--;) {              // 逐步减小段数，步长就会渐大\r\n        section     = custSecs[i];\r\n        tmpStep     = getCeil((expMax.c - expMin.c) / section, custSteps);\r\n        tmpStep     = tmpStep.c * MATH_POW(tmpStep.e);      // 步长都用常规整数参与计算\r\n        tmpMin      = MATH_FLOOR(expMin.c / tmpStep) * tmpStep;\r\n        tmpMax      = MATH_CEIL(expMax.c / tmpStep) * tmpStep;\r\n        reference[i] = {\r\n            min:    tmpMin,\r\n            max:    tmpMax,\r\n            step:   tmpStep,\r\n            span:   tmpMax - tmpMin                         // 步长的误差被 段数 成倍放大，可能会给跨度造成更大的误差，使最后的段数大于预置的最大值\r\n        };\r\n    }\r\n    reference.sort(function (a, b) {\r\n        var delta = a.span - b.span;                        // 分段调整之后的跨度，一定不小于原跨度，所以越小越好\r\n        if (delta === 0) {\r\n            delta = a.step - b.step;                        // 跨度相同时，步长小者胜出\r\n        }\r\n        return delta;\r\n    });\r\n    reference   = reference[0];\r\n    section     = reference.span / reference.step;\r\n    expMin.c    = reference.min;\r\n    expMax.c    = reference.max;\r\n    return section < 3 ? section * 2 : section;             // 如果最终步长比最小步长大得多，段数就可能变得很小\r\n}\r\n\r\n\r\n/**\r\n * 指定段数，在预置的可选步长中，找出一个合适的值，让 步长 * 段数 积刚好涵盖原最大值与最小值\r\n */\r\nfunction look4step(expMin, expMax, secs) {\r\n    var span;\r\n    var tmpMax;\r\n    var tmpMin      = expMax.c;\r\n    var tmpStep     = (expMax.c - expMin.c) / secs - 1;\r\n    while (tmpMin   > expMin.c) {\r\n        tmpStep     = getCeil(tmpStep + 1, custSteps);\r\n        tmpStep     = tmpStep.c * MATH_POW(tmpStep.e);\r\n        span        = tmpStep * secs;\r\n        tmpMax      = MATH_CEIL(expMax.c / tmpStep) * tmpStep;\r\n        tmpMin      = tmpMax - span;                        // 优先保证 max 端的误差最小，试看原 min 值能否被覆盖到\r\n    }\r\n    var deltaMin    = expMin.c - tmpMin;                    // 上面的计算可能会让 min 端的误差更大，下面尝试均衡误差\r\n    var deltaMax    = tmpMax - expMax.c;\r\n    var deltaDelta  = deltaMin - deltaMax;\r\n    if (deltaDelta  > tmpStep * 1.1) {                      // 当 min 端的误差比 max 端大很多时，考虑将 tmpMin tmpMax 同时上移\r\n        deltaDelta  = MATH_ROUND(deltaDelta / tmpStep / 2) * tmpStep;\r\n        tmpMin     += deltaDelta;\r\n        tmpMax     += deltaDelta;\r\n    }\r\n    expMin.c   = tmpMin;\r\n    expMax.c   = tmpMax;\r\n    return tmpStep;\r\n}\r\n\r\n\r\n/**\r\n * 原最值都是整数时，尝试让输出也保持整数\r\n */\r\nfunction tryForInt(min, max, section, expMin, expMax, secs) {\r\n    var span = expMax.c - expMin.c;\r\n    var step = span / secs * MATH_POW(expMax.e);\r\n    if (!MATH_ISINT(step)) {                                // 原最值都是整数，但计算步长可能出现小数，如 2.5\r\n        step = MATH_FLOOR(step);                            // 步长总是要尽量小，以减小跨度误差，所以 2.5 可能被调整为 2 或者 3\r\n        span = step * secs;\r\n        if (span < max - min) {\r\n            step += 1;\r\n            span = step * secs;\r\n            if (!section && (step * (secs - 1) >= (max - min))) {\r\n                secs -= 1;\r\n                span = step * secs;\r\n            }\r\n        }\r\n        if (span >= max - min) {\r\n            var delta   = span - (max - min);               // 误差均衡\r\n            expMin.c    = MATH_ROUND(min - delta / 2);\r\n            expMax.c    = MATH_ROUND(max + delta / 2);\r\n            expMin.e    = 0;\r\n            expMax.e    = 0;\r\n        }\r\n    }\r\n    return secs;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * 整数情况下，跨度小于段数的处理\r\n */\r\nfunction forInteger(min, max, section) {\r\n    section     = section || 5;\r\n    if (minLocked) {\r\n        max     = min + section;                            // min max 没有写错，因为 min locked 所以 max 在 min 上浮动\r\n    }\r\n    else if (maxLocked) {\r\n        min     = max - section;\r\n    }\r\n    else {\r\n        var delta   = section - (max - min);                // 没有端点锁定时，向上下延展跨度\r\n        var newMin  = MATH_ROUND(min - delta / 2);\r\n        var newMax  = MATH_ROUND(max + delta / 2);\r\n        var arrMM   = cross0(min, max, newMin, newMax);     // 避免跨 0\r\n        min         = arrMM[0];\r\n        max         = arrMM[1];\r\n    }\r\n    return makeResult(min, max, section);\r\n}\r\n\r\n\r\n/**\r\n * 非整数情况下，跨度为 0 的处理\r\n */\r\nfunction forSpan0(min, max, section) {\r\n    section     = section || 5;\r\n    // delta 一定不为 0 ，因为 min === max === 0 的情况会进入 forInteger 分支\r\n    var delta   = MT.min(MATH_ABS(max / section), section) / 2.1;\r\n    if (minLocked) {\r\n        max     = min + delta;                              // min max 没有写错，因为 min locked 所以 max 在 min 上浮动\r\n    }\r\n    else if (maxLocked) {\r\n        min     = max - delta;\r\n    }\r\n    else {                                                  // 以最值为中心，上下各延展一小段\r\n        min     = min - delta;\r\n        max     = max + delta;\r\n    }\r\n    return coreCalc(min, max, section);\r\n}\r\n\r\n\r\n/**\r\n * 当原始最值都在 0 的同侧时，让输出也保持在 0 的同侧\r\n */\r\nfunction cross0(min, max, newMin, newMax) {\r\n    if (min >= 0 && newMin < 0) {\r\n        newMax -= newMin;\r\n        newMin  = 0;\r\n    }\r\n    else if (max <= 0 && newMax > 0) {\r\n        newMin -= newMax;\r\n        newMax  = 0;\r\n    }\r\n    return [newMin, newMax];\r\n}\r\n\r\n\r\n/**\r\n * 取一个数的小数位数\r\n * @param   {Number}    num         原数值\r\n * @return  {Number}    decimals    整数则返回 0 ，小数则返回小数点后的位数\r\n */\r\nfunction decimals(num) {\r\n    num = (+num).toFixed(15).split('.');                    // String(0.0000001) 会得到 '1e-7'\r\n    return num.pop().replace(/0+$/, '').length;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * 单个最值锁定处理，只是在原计算的基础上，锁定一个，平移另一个\r\n */\r\nfunction singleLocked(min, max, emin, emax) {\r\n    if (minLocked) {\r\n        var expMin  = expNum(min, 4, 1);                    // 4 位精度向下近似\r\n        if (emin.e  - expMin.e > 6) {                       // 如果锁定值的量级远小于基准量级，认为锁定失败，强置为 0\r\n            expMin  = {c: 0, e: emin.e};\r\n        }\r\n        expFixMin(emin, expMin);                            // 将指数与量级较小者对齐\r\n        expFixMin(emax, expMin);\r\n        emax.c     += expMin.c - emin.c;                    // 最大值平移\r\n        emin.c      = expMin.c;                             // 最小值锁定\r\n    }\r\n    else if (maxLocked) {\r\n        var expMax  = expNum(max, 4);                       // 4 位精度向上近似\r\n        if (emax.e  - expMax.e > 6) {                       // 如果锁定值的量级远小于基准量级，认为锁定失败，强置为 0\r\n            expMax  = {c: 0, e: emax.e};\r\n        }\r\n        expFixMin(emin, expMax);                            // 将指数与量级较小者对齐\r\n        expFixMin(emax, expMax);\r\n        emin.c     += expMax.c - emax.c;                    // 最小值平移\r\n        emax.c      = expMax.c;                             // 最大值锁定\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * 最小值和最大值同时被锁定的情况在这里，其它地方只考虑单边最值锁定\r\n * @param   {Number}    min         锁定的最小值\r\n * @param   {Number}    max         锁定的最大值\r\n * @param   {Number}    [section]   段数\r\n * @return  {Object}                同 smartSteps\r\n */\r\nfunction bothLocked(min, max, section) {\r\n    var trySecs     = section ? [section] : custSecs;\r\n    var span        = max - min;\r\n    if (span       === 0) {                                 // 最大最小值都锁定到同一个值上，认为锁定失败\r\n        max         = expNum(max, 3);                       // 3 位精度向上近似\r\n        section     = trySecs[0];\r\n        max.c       = MATH_ROUND(max.c + section / 2);\r\n        return makeResult(max.c - section, max.c, section, max.e);\r\n    }\r\n    if (MATH_ABS(max / span) < 1e-6) {                      // 如果锁定值远小于跨度，也认为锁定失败，强置为 0\r\n        max         = 0;\r\n    }\r\n    if (MATH_ABS(min / span) < 1e-6) {\r\n        min         = 0;\r\n    }\r\n    var step, deltaSpan, score;\r\n    var scoreS      = [[5, 10], [10, 2], [50, 10], [100, 2]];\r\n    var reference   = [];\r\n    var debugLog    = [];\r\n    var expSpan     = expNum((max - min), 3);               // 3 位精度向上近似\r\n    var expMin      = expNum(min, -1, 1);\r\n    var expMax      = expNum(max, -1);\r\n    expFixTo(expMin, expSpan, 1);\r\n    expFixTo(expMax, expSpan);\r\n    span            = expMax.c - expMin.c;\r\n    expSpan.c       = span;\r\n    \r\n    for (var i      = trySecs.length; i--;) {\r\n        section     = trySecs[i];\r\n        step        = MATH_CEIL(span / section);\r\n        deltaSpan   = step * section - span;\r\n        score       = (deltaSpan + 3) * 3;                  // 误差越大得分越高\r\n        score      += (section - trySecs[0] + 2) * 2;       // 分段越多得分越高\r\n        if (section % 5 === 0) {                            // 段数为 5 可以减分\r\n            score  -= 10;\r\n        }\r\n        for (var j  = scoreS.length; j--;) {                // 好的步长是最重要的减分项\r\n            if (step % scoreS[j][0] === 0) {\r\n                score /= scoreS[j][1];\r\n            }\r\n        }\r\n        debugLog[i] = [section, step, deltaSpan, score].join();\r\n        reference[i] = {\r\n            secs:   section,\r\n            step:   step,\r\n            delta:  deltaSpan,\r\n            score:  score\r\n        };\r\n    }\r\n    //console.log(debugLog);\r\n    reference.sort(function (a, b) {return a.score - b.score;});\r\n    reference   = reference[0];\r\n    expMin.c    = MATH_ROUND(expMin.c - reference.delta / 2);\r\n    expMax.c    = MATH_ROUND(expMax.c + reference.delta / 2);\r\n    return makeResult(expMin.c, expMax.c, reference.secs, expSpan.e);\r\n}\r\n\r\n\r\n\r\n\r\nreturn smartSteps;\r\n});\r\n\r\n\r\n\r\n"
    },
    {
      "id": 58,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\smartLogSteps.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/smartLogSteps.js",
      "index": 58,
      "index2": 51,
      "size": 16048,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 55,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\valueAxis.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/component/valueAxis.js",
          "type": "cjs require",
          "userRequest": "../util/smartLogSteps",
          "loc": "777:25-57"
        }
      ],
      "source": "/**\r\n * Echarts, logarithmic axis reform\r\n *\r\n * @author sushuang (sushuang@baidu.com),\r\n *         Ievgenii (@Ievgeny, ievgeny@zoomdata.com)\r\n */\r\n\r\ndefine(function(require) {\r\n\r\n    // Reference\r\n    var number = require('./number');\r\n    var Mt = Math;\r\n    var mathLog = Mt.log;\r\n    var mathPow = Mt.pow;\r\n    var mathAbs = Mt.abs;\r\n    var mathCeil = Mt.ceil;\r\n    var mathFloor = Mt.floor;\r\n\r\n    // Constant\r\n    var LOG_BASE = Mt.E; // It is not necessary to specify log base,\r\n                         // because log(logBase, x) = ln(x) / ln(logBase),\r\n                         // thus final result (axis tick location) is only determined by ln(x).\r\n    var LN10 = Mt.LN10;\r\n    var LN2 = Mt.LN2;\r\n    var LN2D10 = LN2 / LN10;\r\n    var EPSILON = 1e-9;\r\n    var DEFAULT_SPLIT_NUMBER = 5;\r\n    var MIN_BASE_10_SPLIT_NUMBER = 2;\r\n    var SUPERSCRIPTS = {\r\n        '0': '⁰',\r\n        '1': '¹',\r\n        '2': '²',\r\n        '3': '³',\r\n        '4': '⁴',\r\n        '5': '⁵',\r\n        '6': '⁶',\r\n        '7': '⁷',\r\n        '8': '⁸',\r\n        '9': '⁹',\r\n        '-': '⁻'\r\n    };\r\n\r\n    // Static variable\r\n    var logPositive;\r\n    var logLabelBase;\r\n    var logLabelMode; // enumeration:\r\n                      // 'plain' (i.e. axis labels are shown like 10000)\r\n                      // 'exponent' (i.e. axis labels are shown like 10²)\r\n    var lnBase;\r\n    var custOpts;\r\n    var splitNumber;\r\n    var logMappingOffset;\r\n    var absMin;\r\n    var absMax;\r\n    var tickList;\r\n\r\n    /**\r\n     * Test cases:\r\n     * [2, 4, 8, 16, 32, 64, 128]\r\n     * [0.01, 0.1, 10, 100, 1000] logLabelBase: 3\r\n     * [0.01, 0.1, 10, 100, 1000] logLabelBase: -12\r\n     * [-2, -4, -8, -16, -32, -64, -128] logLabelBase: 3\r\n     * [2, 4, 8, 16, '-', 64, 128]\r\n     * [2, 4, 8, 16, 32, 64]\r\n     * [2, 4, 8, 16, 32]\r\n     * [0.00000256, 0.0016, 0.04, 0.2]\r\n     * [0.1, 1, 10, 100, 1000, 10000, 100000, 1000000] splitNumber: 3\r\n     * [1331, 3434, 500, 1, 1212, 4]\r\n     * [0.14, 2, 45, 1001, 200, 0.33, 10001]\r\n     * [0.00001, 0.00005]\r\n     * [0.00001, 0.00005] boundaryGap: [0.2, 0.4]\r\n     * [0.001, 2, -45, 1001, 200, 0.33, 10000]\r\n     * [0.00000001, 0.00000012]\r\n     * [0.000000000000001]\r\n     * [0.00000001, 0.00000001]\r\n     * [3, 3]\r\n     * [12, -3, 47, 19]\r\n     * [12, -3, 47, 19] logPositive: false\r\n     * [-2, -4, -8, -16, -32, -64, -128]\r\n     * [-2, -4, -8, -16, -32, -64]\r\n     * [2, 4, 8, 16, 32] boundaryGap: [0.2, 0.4]\r\n     * []\r\n     * [0]\r\n     * [10, 10, 10]\r\n     * [0.00003, 0.00003, 0.00003]\r\n     * [0.00001, 0.00001, 0.00001]\r\n     * [-0.00001, -0.00001, -0.00001]\r\n     * ['-', '-']\r\n     * ['-', 10]\r\n     * logarithmic axis in scatter (try dataZoom)\r\n     * logarithmic axis width dataZoom component (try xAxis and yAxis)\r\n     */\r\n\r\n    /**\r\n     * Main function. Return data object with values for axis building.\r\n     *\r\n     * @public\r\n     * @param {Object} [opts] Configurable options\r\n     * @param {number} opts.dataMin data Minimum\r\n     * @param {number} opts.dataMax data Maximum\r\n     * @param {number=} opts.logPositive Logarithmic sign. If not specified, it will be auto-detected.\r\n     * @param {number=} opts.logLabelBase Logaithmic base in axis label.\r\n     *                                    If not specified, it will be set to 10 (and use 2 for detail)\r\n     * @param {number=} opts.splitNumber Number of sections perfered.\r\n     * @return {Object} {\r\n     *                      dataMin: New min,\r\n     *                      dataMax: New max,\r\n     *                      tickList: [Array of tick data]\r\n     *                      logPositive: Type of data sign\r\n     *                      dataMappingMethods: [Set of logarithmic methods]\r\n     *                  }\r\n     */\r\n    function smartLogSteps(opts) {\r\n        clearStaticVariables();\r\n        custOpts = opts || {};\r\n\r\n        reformSetting();\r\n        makeTicksList();\r\n\r\n        return [\r\n            makeResult(),\r\n            clearStaticVariables()\r\n        ][0];\r\n    }\r\n\r\n    /**\r\n     * All of static variables must be clear here.\r\n     */\r\n    function clearStaticVariables() {\r\n        logPositive = custOpts = logMappingOffset = lnBase =\r\n        absMin = absMax = splitNumber = tickList = logLabelBase = logLabelMode = null;\r\n    }\r\n\r\n    /**\r\n     * Determine sign (logPositive, negative) of data set, if not specified.\r\n     * Reform min and max of data.\r\n     */\r\n    function reformSetting() {\r\n        // Settings of log label base\r\n        logLabelBase = custOpts.logLabelBase;\r\n        if (logLabelBase == null) {\r\n            logLabelMode = 'plain';\r\n            logLabelBase = 10;\r\n            lnBase = LN10;\r\n        }\r\n        else {\r\n            logLabelBase = +logLabelBase;\r\n            if (logLabelBase < 1) { // log base less than 1 is not supported.\r\n                logLabelBase = 10;\r\n            }\r\n            logLabelMode = 'exponent';\r\n            lnBase = mathLog(logLabelBase);\r\n        }\r\n\r\n        // Settings of split number\r\n        splitNumber = custOpts.splitNumber;\r\n        splitNumber == null && (splitNumber = DEFAULT_SPLIT_NUMBER);\r\n\r\n        // Setting of data min and max\r\n        var dataMin = parseFloat(custOpts.dataMin);\r\n        var dataMax = parseFloat(custOpts.dataMax);\r\n\r\n        if (!isFinite(dataMin) && !isFinite(dataMax)) {\r\n            dataMin = dataMax = 1;\r\n        }\r\n        else if (!isFinite(dataMin)) {\r\n            dataMin = dataMax;\r\n        }\r\n        else if (!isFinite(dataMax)) {\r\n            dataMax = dataMin;\r\n        }\r\n        else if (dataMin > dataMax) {\r\n            dataMax = [dataMin, dataMin = dataMax][0]; // Exchange min, max.\r\n        }\r\n\r\n        // Settings of log positive\r\n        logPositive = custOpts.logPositive;\r\n        // If not specified, determine sign by data.\r\n        if (logPositive == null) {\r\n            // LogPositive is false when dataMax <= 0 && dataMin < 0.\r\n            // LogPositive is true when dataMin >= 0.\r\n            // LogPositive is true when dataMax >= 0 && dataMin < 0 (singular points may exists)\r\n            logPositive = dataMax > 0 || dataMin === 0;\r\n        }\r\n\r\n        // Settings of absMin and absMax, which must be greater than 0.\r\n        absMin = logPositive ? dataMin : -dataMax;\r\n        absMax = logPositive ? dataMax : -dataMin;\r\n        // FIXME\r\n        // If there is any data item less then zero, it is suppose to be igonred and min should be re-calculated.\r\n        // But it is difficult to do that in current code stucture.\r\n        // So refactor of xxAxis.js is desired.\r\n        absMin < EPSILON && (absMin = EPSILON);\r\n        absMax < EPSILON && (absMax = EPSILON);\r\n    }\r\n\r\n    /**\r\n     * Make tick list.\r\n     */\r\n    function makeTicksList() {\r\n        tickList = [];\r\n\r\n        // Estimate max exponent and min exponent\r\n        var maxDataLog = fixAccurate(mathLog(absMax) / lnBase);\r\n        var minDataLog = fixAccurate(mathLog(absMin) / lnBase);\r\n        var maxExpon = mathCeil(maxDataLog);\r\n        var minExpon = mathFloor(minDataLog);\r\n        var spanExpon = maxExpon - minExpon;\r\n        var spanDataLog = maxDataLog - minDataLog;\r\n\r\n        if (logLabelMode === 'exponent') {\r\n            baseAnalysis();\r\n        }\r\n        else { // logLabelMode === 'plain', we will self-adapter\r\n            !(\r\n                spanExpon <= MIN_BASE_10_SPLIT_NUMBER\r\n                && splitNumber > MIN_BASE_10_SPLIT_NUMBER\r\n            )\r\n                ? baseAnalysis() : detailAnalysis();\r\n        }\r\n\r\n        // In this situation, only draw base-10 ticks.\r\n        // Base-10 ticks: 10^h (i.e. 0.01, 0.1, 1, 10, 100, ...)\r\n        function baseAnalysis() {\r\n            if (spanExpon < splitNumber) {\r\n                splitNumber = spanExpon;\r\n            }\r\n            // Suppose:\r\n            //      spanExpon > splitNumber\r\n            //      stepExpon := floor(spanExpon / splitNumber)\r\n            //      splitNumberFloat := spanExpon / stepExpon\r\n            // There are tow expressions which are identically-true:\r\n            //      splitNumberFloat - splitNumber <= 1\r\n            //      stepExpon * ceil(splitNumberFloat) - spanExpon <= stepExpon\r\n            // So we can calculate as follows:\r\n            var stepExpon = mathFloor(fixAccurate(spanExpon / splitNumber));\r\n\r\n            // Put the plot in the middle of the min, max.\r\n            var splitNumberAdjust = mathCeil(fixAccurate(spanExpon / stepExpon));\r\n            var spanExponAdjust = stepExpon * splitNumberAdjust;\r\n            var halfDiff = (spanExponAdjust - spanDataLog) / 2;\r\n            var minExponAdjust = mathFloor(fixAccurate(minDataLog - halfDiff));\r\n\r\n            if (aroundZero(minExponAdjust - minDataLog)) {\r\n                minExponAdjust -= 1;\r\n            }\r\n\r\n            // Build logMapping offset\r\n            logMappingOffset = -minExponAdjust * lnBase;\r\n\r\n            // Build tickList\r\n            for (var n = minExponAdjust; n - stepExpon <= maxDataLog; n += stepExpon) {\r\n                tickList.push(mathPow(logLabelBase, n));\r\n            }\r\n        }\r\n\r\n        // In this situation, base-2|10 ticks are used to make detailed split.\r\n        // Base-2|10 ticks: 10^h * 2^k (i.e. 0.1, 0.2, 0.4, 1, 2, 4, 10, 20, 40),\r\n        // where k in [0, 1, 2].\r\n        // Because LN2 * 3 < LN10 and LN2 * 4 > LN10, k should be less than 3.\r\n        // And when k === 3, the tick is too close to that of k === 0, which looks weird.\r\n        // So we do not use 3.\r\n        function detailAnalysis() {\r\n            // Find max exponent and min exponent.\r\n            // Calculate base on 3-hexadecimal (0, 1, 2, 10, 11, 12, 20).\r\n            var minDecimal = toDecimalFrom4Hex(minExpon, 0);\r\n            var endDecimal = minDecimal + 2;\r\n            while (\r\n                minDecimal < endDecimal\r\n                && toH(minDecimal + 1) + toK(minDecimal + 1) * LN2D10 < minDataLog\r\n            ) {\r\n                minDecimal++;\r\n            }\r\n            var maxDecimal = toDecimalFrom4Hex(maxExpon, 0);\r\n            var endDecimal = maxDecimal - 2; // maxDecimal is greater than 4\r\n            while (\r\n                maxDecimal > endDecimal\r\n                && toH(maxDecimal - 1) + toK(maxDecimal - 1) * LN2D10 > maxDataLog\r\n            ) {\r\n                maxDecimal--;\r\n            }\r\n\r\n            // Build logMapping offset\r\n            logMappingOffset = -(toH(minDecimal) * LN10 + toK(minDecimal) * LN2);\r\n\r\n            // Build logMapping tickList\r\n            for (var i = minDecimal; i <= maxDecimal; i++) {\r\n                var h = toH(i);\r\n                var k = toK(i);\r\n                tickList.push(mathPow(10, h) * mathPow(2, k));\r\n            }\r\n        }\r\n\r\n        // Convert to decimal number from 4-hexadecimal number,\r\n        // where h, k means: if there is a 4-hexadecimal numer 23, then h is 2, k is 3.\r\n        // h can be any integer (notice: h can be greater than 10 or less than 0),\r\n        // and k belongs to [0, 1, 2, 3].\r\n        function toDecimalFrom4Hex(h, k) {\r\n            return h * 3 + k;\r\n        }\r\n\r\n        function toK(decimal) {\r\n            return decimal - toH(decimal) * 3; // Can not calculate by '%'\r\n        }\r\n\r\n        function toH(decimal) {\r\n            return mathFloor(fixAccurate(decimal / 3));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Make result\r\n     */\r\n    function makeResult() {\r\n        var resultTickList = [];\r\n        for (var i = 0, len = tickList.length; i < len; i++) {\r\n            resultTickList[i] = (logPositive ? 1 : -1) * tickList[i];\r\n        }\r\n        !logPositive && resultTickList.reverse();\r\n\r\n        var dataMappingMethods = makeDataMappingMethods();\r\n        var value2Coord = dataMappingMethods.value2Coord;\r\n\r\n        var newDataMin = value2Coord(resultTickList[0]);\r\n        var newDataMax = value2Coord(resultTickList[resultTickList.length - 1]);\r\n\r\n        if (newDataMin === newDataMax) {\r\n            newDataMin -= 1;\r\n            newDataMax += 1;\r\n        }\r\n\r\n        return {\r\n            dataMin: newDataMin,\r\n            dataMax: newDataMax,\r\n            tickList: resultTickList,\r\n            logPositive: logPositive,\r\n            labelFormatter: makeLabelFormatter(),\r\n            dataMappingMethods: dataMappingMethods\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Make axis label formatter.\r\n     */\r\n    function makeLabelFormatter() {\r\n        if (logLabelMode === 'exponent') { // For label style like 3⁴.\r\n            // Static variables should be fixed in the scope of the methods.\r\n            var myLogLabelBase = logLabelBase;\r\n            var myLnBase = lnBase;\r\n\r\n            return function (value) {\r\n                if (!isFinite(parseFloat(value))) {\r\n                    return '';\r\n                }\r\n                var sign = '';\r\n                if (value < 0) {\r\n                    value = -value;\r\n                    sign = '-';\r\n                }\r\n                return sign + myLogLabelBase + makeSuperscriptExponent(mathLog(value) / myLnBase);\r\n            };\r\n        }\r\n        else {\r\n            return function (value) { // Normal style like 0.001, 10,000,0\r\n                if (!isFinite(parseFloat(value))) {\r\n                    return '';\r\n                }\r\n                return number.addCommas(formatNumber(value));\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Make calculate methods.\r\n     */\r\n    function makeDataMappingMethods() {\r\n        // Static variables should be fixed in the scope of the methods.\r\n        var myLogPositive = logPositive;\r\n        var myLogMappingOffset = logMappingOffset;\r\n\r\n        return {\r\n            value2Coord: function (x) {\r\n                if (x == null || isNaN(x) || !isFinite(x)) {\r\n                    return x;\r\n                }\r\n                x = parseFloat(x); // to number\r\n                if (!isFinite(x)) {\r\n                    x = EPSILON;\r\n                }\r\n                else if (myLogPositive && x < EPSILON) {\r\n                    // FIXME\r\n                    // It is suppose to be ignore, but not be set to EPSILON. See comments above.\r\n                    x = EPSILON;\r\n                }\r\n                else if (!myLogPositive && x > -EPSILON) {\r\n                    x = -EPSILON;\r\n                }\r\n                x = mathAbs(x);\r\n                return (myLogPositive ? 1 : -1) * (mathLog(x) + myLogMappingOffset);\r\n            },\r\n            coord2Value: function (x) {\r\n                if (x == null || isNaN(x) || !isFinite(x)) {\r\n                    return x;\r\n                }\r\n                x = parseFloat(x); // to number\r\n                if (!isFinite(x)) {\r\n                    x = EPSILON;\r\n                }\r\n                return myLogPositive\r\n                    ? mathPow(LOG_BASE, x - myLogMappingOffset)\r\n                    : -mathPow(LOG_BASE, -x + myLogMappingOffset);\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * For example, Math.log(1000) / Math.LN10 get the result of 2.9999999999999996, rather than 3.\r\n     * This method trys to fix it.\r\n     * (accMath.div can not fix this problem yet.)\r\n     */\r\n    function fixAccurate(result) {\r\n        return +Number(+result).toFixed(14);\r\n    }\r\n\r\n    /**\r\n     * Avoid show float number like '1e-9', '-1e-10', ...\r\n     * @return {string}\r\n     */\r\n    function formatNumber(num) {\r\n        return Number(num).toFixed(15).replace(/\\.?0*$/, '');\r\n    }\r\n\r\n    /**\r\n     * Make superscript exponent\r\n     */\r\n    function makeSuperscriptExponent(exponent) {\r\n        exponent = formatNumber(Math.round(exponent)); // Do not support float superscript.\r\n                                                       // (because I can not find superscript style of '.')\r\n        var result = [];\r\n        for (var i = 0, len = exponent.length; i < len; i++) {\r\n            var cha = exponent.charAt(i);\r\n            result.push(SUPERSCRIPTS[cha] || '');\r\n        }\r\n        return result.join('');\r\n    }\r\n\r\n    /**\r\n     * Decide whether near zero\r\n     */\r\n    function aroundZero(val) {\r\n        return val > -EPSILON && val < EPSILON;\r\n    }\r\n\r\n    return smartLogSteps;\r\n});\r\n"
    },
    {
      "id": 59,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\grid.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/grid.js",
      "index": 59,
      "index2": 54,
      "size": 6138,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "../component/grid",
          "loc": "15:4-32"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "../component/grid",
          "loc": "17:4-32"
        }
      ],
      "source": "/**\r\n * echarts组件： 网格\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n    \r\n    // 图形依赖\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n    \r\n    var ecConfig = require('../config');\r\n    // 网格\r\n    ecConfig.grid = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 0,                       // 二级层叠\r\n        x: 80,\r\n        y: 60,\r\n        x2: 80,\r\n        y2: 60,\r\n        // width: {totalWidth} - x - x2,\r\n        // height: {totalHeight} - y - y2,\r\n        backgroundColor: 'rgba(0,0,0,0)',\r\n        borderWidth: 1,\r\n        borderColor: '#ccc'\r\n    };\r\n\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 图表选项\r\n     *      @param {number=} option.grid.x 直角坐标系内绘图网格起始横坐标，数值单位px\r\n     *      @param {number=} option.grid.y 直角坐标系内绘图网格起始纵坐标，数值单位px\r\n     *      @param {number=} option.grid.width 直角坐标系内绘图网格宽度，数值单位px\r\n     *      @param {number=} option.grid.height 直角坐标系内绘图网格高度，数值单位px\r\n     */\r\n    function Grid(ecTheme, messageCenter, zr, option, myChart) {\r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this.refresh(option);\r\n    }\r\n    \r\n    Grid.prototype = {\r\n        type: ecConfig.COMPONENT_TYPE_GRID,\r\n\r\n        getX: function () {\r\n            return this._x;\r\n        },\r\n\r\n        getY: function () {\r\n            return this._y;\r\n        },\r\n\r\n        getWidth: function () {\r\n            return this._width;\r\n        },\r\n\r\n        getHeight: function () {\r\n            return this._height;\r\n        },\r\n\r\n        getXend: function () {\r\n            return this._x + this._width;\r\n        },\r\n\r\n        getYend: function () {\r\n            return this._y + this._height;\r\n        },\r\n\r\n        getArea: function () {\r\n            return {\r\n                x: this._x,\r\n                y: this._y,\r\n                width: this._width,\r\n                height: this._height\r\n            };\r\n        },\r\n        \r\n        getBbox: function() {\r\n            return [\r\n                [ this._x, this._y ],\r\n                [ this.getXend(), this.getYend() ]\r\n            ];\r\n        },\r\n        \r\n        /**\r\n         * 实在找不到合适的地方做了，各种粗暴的写法~ -_-\r\n         */\r\n        refixAxisShape: function(component) {\r\n            var zeroX;\r\n            var zeroY;\r\n            var axisList = component.xAxis._axisList.concat(\r\n                component.yAxis ? component.yAxis._axisList : []\r\n            );\r\n            var len = axisList.length;\r\n            var axis;\r\n            while (len--) {\r\n                axis = axisList[len];\r\n                if (axis.type == ecConfig.COMPONENT_TYPE_AXIS_VALUE \r\n                    && axis._min < 0  \r\n                    && axis._max >= 0\r\n                ) {\r\n                    axis.isHorizontal()\r\n                    ? (zeroX = axis.getCoord(0))\r\n                    : (zeroY = axis.getCoord(0));\r\n                }\r\n            }\r\n            if (typeof zeroX != 'undefined' || typeof zeroY != 'undefined') {\r\n                len = axisList.length;\r\n                while (len--) {\r\n                    axisList[len].refixAxisShape(zeroX, zeroY);\r\n                }\r\n            }\r\n        },\r\n        \r\n        refresh: function (newOption) {\r\n            if (newOption\r\n                || this._zrWidth != this.zr.getWidth() \r\n                || this._zrHeight != this.zr.getHeight()\r\n            ) {\r\n                this.clear();\r\n                this.option = newOption || this.option;\r\n                this.option.grid = this.reformOption(this.option.grid);\r\n    \r\n                var gridOption = this.option.grid;\r\n                this._zrWidth = this.zr.getWidth();\r\n                this._zrHeight = this.zr.getHeight();\r\n                this._x = this.parsePercent(gridOption.x, this._zrWidth);\r\n                this._y = this.parsePercent(gridOption.y, this._zrHeight);\r\n                var x2 = this.parsePercent(gridOption.x2, this._zrWidth);\r\n                var y2 = this.parsePercent(gridOption.y2, this._zrHeight);\r\n                \r\n    \r\n                if (typeof gridOption.width == 'undefined') {\r\n                    this._width = this._zrWidth - this._x - x2;\r\n                }\r\n                else {\r\n                    this._width = this.parsePercent(gridOption.width, this._zrWidth);\r\n                }\r\n                this._width = this._width <= 0 ? 10 : this._width;\r\n    \r\n                if (typeof gridOption.height == 'undefined') {\r\n                    this._height = this._zrHeight - this._y - y2;\r\n                }\r\n                else {\r\n                    this._height = this.parsePercent(gridOption.height, this._zrHeight);\r\n                }\r\n                this._height = this._height <= 0 ? 10 : this._height;\r\n                \r\n                this._x = this.subPixelOptimize(this._x, gridOption.borderWidth);\r\n                this._y = this.subPixelOptimize(this._y, gridOption.borderWidth);\r\n    \r\n                this.shapeList.push(new RectangleShape({\r\n                    zlevel: this.getZlevelBase(),\r\n                    z: this.getZBase(),\r\n                    hoverable: false,\r\n                    style: {\r\n                        x: this._x,\r\n                        y: this._y,\r\n                        width: this._width,\r\n                        height: this._height,\r\n                        brushType: gridOption.borderWidth > 0 ? 'both' : 'fill',\r\n                        color: gridOption.backgroundColor,\r\n                        strokeColor: gridOption.borderColor,\r\n                        lineWidth: gridOption.borderWidth\r\n                        // type: this.option.splitArea.areaStyle.type,\r\n                    }\r\n                }));\r\n                this.zr.addShape(this.shapeList[0]);\r\n            }\r\n        }\r\n    };\r\n    \r\n    zrUtil.inherits(Grid, Base);\r\n    \r\n    require('../component').define('grid', Grid);\r\n    \r\n    return Grid;\r\n});"
    },
    {
      "id": 60,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\component\\dataZoom.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/component/dataZoom.js",
      "index": 60,
      "index2": 55,
      "size": 47872,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "../component/dataZoom",
          "loc": "16:4-36"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "../component/dataZoom",
          "loc": "18:4-36"
        }
      ],
      "source": "/**\r\n * echarts组件：数据区域缩放\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var Base = require('./base');\r\n\r\n    // 图形依赖\r\n    var RectangleShape = require('zrenderjs/shape/Rectangle');\r\n    var PolygonShape = require('zrenderjs/shape/Polygon');\r\n    var IconShape = require('../util/shape/Icon');\r\n\r\n    var ecConfig = require('../config');\r\n    // 区域缩放控制器\r\n    ecConfig.dataZoom = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 4,                       // 二级层叠\r\n        show: false,\r\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\r\n                                   // 'horizontal' ¦ 'vertical'\r\n        // x: {number},            // 水平安放位置，默认为根据grid参数适配，可选为：\r\n                                   // {number}（x坐标，单位px）\r\n        // y: {number},            // 垂直安放位置，默认为根据grid参数适配，可选为：\r\n                                   // {number}（y坐标，单位px）\r\n        // width: {number},        // 指定宽度，横向布局时默认为根据grid参数适配\r\n        // height: {number},       // 指定高度，纵向布局时默认为根据grid参数适配\r\n        backgroundColor: 'rgba(0,0,0,0)',       // 背景颜色\r\n        dataBackgroundColor: '#eee',            // 数据背景颜色\r\n        fillerColor: 'rgba(144,197,237,0.2)',   // 填充颜色\r\n        handleColor: 'rgba(70,130,180,0.8)',    // 手柄颜色\r\n        handleSize: 8,\r\n        showDetail: true,\r\n        // xAxisIndex: [],         // 默认控制所有横向类目\r\n        // yAxisIndex: [],         // 默认控制所有横向类目\r\n        // start: 0,               // 默认为0\r\n        // end: 100,               // 默认为全部 100%\r\n        realtime: true\r\n        // zoomLock: false         // 是否锁定选择区域大小\r\n    };\r\n\r\n    var ecDate = require('../util/date');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 图表参数\r\n     * @param {Object} component 组件\r\n     */\r\n    function DataZoom(ecTheme, messageCenter, zr, option, myChart) {\r\n        Base.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        var self = this;\r\n        self._ondrift = function (dx, dy) {\r\n            return self.__ondrift(this, dx, dy);\r\n        };\r\n        self._ondragend = function () {\r\n            return self.__ondragend();\r\n        };\r\n\r\n        this._fillerSize = 30;       // 控件大小，水平布局为高，纵向布局为宽\r\n        // this._fillerShae;            // 填充\r\n        // this._startShape;            // 起始手柄\r\n        // this._endShape;              // 结束手柄\r\n        // this._startFrameShape;       // 起始特效边框\r\n        // this._endFrameShape;         // 结束特效边框\r\n        // this._syncTicket;\r\n        this._isSilence = false;\r\n        this._zoom = {};\r\n        // this._originalData;\r\n\r\n        this.option.dataZoom = this.reformOption(this.option.dataZoom);\r\n        this.zoomOption = this.option.dataZoom;\r\n        this._handleSize = this.zoomOption.handleSize;\r\n        if (!this.myChart.canvasSupported) {\r\n            // 不支持Canvas的强制关闭实时动画\r\n            this.zoomOption.realtime = false;\r\n        }\r\n\r\n        // 位置参数，通过计算所得x, y, width, height\r\n        this._location = this._getLocation();\r\n        // 缩放参数\r\n        this._zoom =  this._getZoom();\r\n        this._backupData();\r\n\r\n        if (this.option.dataZoom.show) {\r\n            this._buildShape();\r\n        }\r\n        this._syncData();\r\n    }\r\n\r\n    DataZoom.prototype = {\r\n        type : ecConfig.COMPONENT_TYPE_DATAZOOM,\r\n        _buildShape : function () {\r\n            this._buildBackground();\r\n            this._buildFiller();\r\n            this._buildHandle();\r\n            this._buildFrame();\r\n\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                this.zr.addShape(this.shapeList[i]);\r\n            }\r\n            this._syncFrameShape();\r\n        },\r\n\r\n        /**\r\n         * 根据选项计算实体的位置坐标\r\n         */\r\n        _getLocation : function () {\r\n            var x;\r\n            var y;\r\n            var width;\r\n            var height;\r\n            var grid = this.component.grid;\r\n\r\n            // 不指定则根据grid适配\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                // 水平布局\r\n                width = this.zoomOption.width || grid.getWidth();\r\n                height = this.zoomOption.height || this._fillerSize;\r\n                x = this.zoomOption.x != null ? this.zoomOption.x : grid.getX();\r\n                y = this.zoomOption.y != null ? this.zoomOption.y : (this.zr.getHeight() - height - 2);\r\n            }\r\n            else {\r\n                // 垂直布局\r\n                width = this.zoomOption.width || this._fillerSize;\r\n                height = this.zoomOption.height || grid.getHeight();\r\n                x = this.zoomOption.x != null ? this.zoomOption.x : 2;\r\n                y = this.zoomOption.y != null ? this.zoomOption.y : grid.getY();\r\n            }\r\n\r\n            return {\r\n                x : x,\r\n                y : y,\r\n                width : width,\r\n                height : height\r\n            };\r\n        },\r\n\r\n        /**\r\n         * 计算缩放参数\r\n         * 修正单坐标轴只传对象为数组。\r\n         */\r\n        _getZoom : function () {\r\n            var series = this.option.series;\r\n            var xAxis = this.option.xAxis;\r\n            if (xAxis && !(xAxis instanceof Array)) {\r\n                xAxis = [xAxis];\r\n                this.option.xAxis = xAxis;\r\n            }\r\n            var yAxis = this.option.yAxis;\r\n            if (yAxis && !(yAxis instanceof Array)) {\r\n                yAxis = [yAxis];\r\n                this.option.yAxis = yAxis;\r\n            }\r\n\r\n            var zoomSeriesIndex = [];\r\n            var xAxisIndex;\r\n            var yAxisIndex;\r\n\r\n            var zOptIdx = this.zoomOption.xAxisIndex;\r\n            if (xAxis && zOptIdx == null) {\r\n                xAxisIndex = [];\r\n                for (var i = 0, l = xAxis.length; i < l; i++) {\r\n                    // 横纵默认为类目轴\r\n                    if (xAxis[i].type == 'category' || xAxis[i].type == null) {\r\n                        xAxisIndex.push(i);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (zOptIdx instanceof Array) {\r\n                    xAxisIndex = zOptIdx;\r\n                }\r\n                else if (zOptIdx != null) {\r\n                    xAxisIndex = [zOptIdx];\r\n                }\r\n                else {\r\n                    xAxisIndex = [];\r\n                }\r\n            }\r\n\r\n            zOptIdx = this.zoomOption.yAxisIndex;\r\n            if (yAxis && zOptIdx == null) {\r\n                yAxisIndex = [];\r\n                for (var i = 0, l = yAxis.length; i < l; i++) {\r\n                    if (yAxis[i].type == 'category') {\r\n                        yAxisIndex.push(i);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (zOptIdx instanceof Array) {\r\n                    yAxisIndex = zOptIdx;\r\n                }\r\n                else if (zOptIdx != null) {\r\n                    yAxisIndex = [zOptIdx];\r\n                }\r\n                else {\r\n                    yAxisIndex = [];\r\n                }\r\n            }\r\n\r\n            // 找到缩放控制的所有series\r\n            var serie;\r\n            for (var i = 0, l = series.length; i < l; i++) {\r\n                serie = series[i];\r\n                if (serie.type != ecConfig.CHART_TYPE_LINE\r\n                    && serie.type != ecConfig.CHART_TYPE_BAR\r\n                    && serie.type != ecConfig.CHART_TYPE_SCATTER\r\n                    && serie.type != ecConfig.CHART_TYPE_K\r\n                ) {\r\n                    continue;\r\n                }\r\n                for (var j = 0, k = xAxisIndex.length; j < k; j++) {\r\n                    if (xAxisIndex[j] == (serie.xAxisIndex || 0)) {\r\n                        zoomSeriesIndex.push(i);\r\n                        break;\r\n                    }\r\n                }\r\n                for (var j = 0, k = yAxisIndex.length; j < k; j++) {\r\n                    if (yAxisIndex[j] == (serie.yAxisIndex || 0)) {\r\n                        zoomSeriesIndex.push(i);\r\n                        break;\r\n                    }\r\n                }\r\n                // 不指定接管坐标轴，则散点图、双数值轴折线图柱形图都被纳入接管范围\r\n                if (this.zoomOption.xAxisIndex == null\r\n                    && this.zoomOption.yAxisIndex == null\r\n                    && serie.data\r\n                    && this.getDataFromOption(serie.data[0]) instanceof Array\r\n                    && (serie.type == ecConfig.CHART_TYPE_SCATTER\r\n                        || serie.type == ecConfig.CHART_TYPE_LINE\r\n                        || serie.type == ecConfig.CHART_TYPE_BAR)\r\n                ) {\r\n                    zoomSeriesIndex.push(i);\r\n                }\r\n            }\r\n\r\n            var start = this._zoom.start != null\r\n                        ? this._zoom.start\r\n                        : (this.zoomOption.start != null ? this.zoomOption.start : 0);\r\n            var end = this._zoom.end != null\r\n                      ? this._zoom.end\r\n                      : (this.zoomOption.end != null ? this.zoomOption.end : 100);\r\n\r\n            if (start > end) {\r\n                // 大小颠倒自动翻转\r\n                start = start + end;\r\n                end = start - end;\r\n                start = start - end;\r\n            }\r\n            var size = Math.round(\r\n                (end - start) / 100\r\n                * (\r\n                    this.zoomOption.orient == 'horizontal'\r\n                    ? this._location.width : this._location.height\r\n                )\r\n            );\r\n            return {\r\n                start : start,\r\n                end : end,\r\n                start2 : 0,\r\n                end2 : 100,\r\n                size : size,\r\n                xAxisIndex : xAxisIndex,\r\n                yAxisIndex : yAxisIndex,\r\n                seriesIndex : zoomSeriesIndex,\r\n                scatterMap : this._zoom.scatterMap || {}\r\n            };\r\n        },\r\n\r\n        _backupData : function () {\r\n            this._originalData = {\r\n                xAxis : {},\r\n                yAxis : {},\r\n                series : {}\r\n            };\r\n            var xAxis = this.option.xAxis;\r\n            var xAxisIndex = this._zoom.xAxisIndex;\r\n            for (var i = 0, l = xAxisIndex.length; i < l; i++) {\r\n                this._originalData.xAxis[xAxisIndex[i]] = xAxis[xAxisIndex[i]].data;\r\n            }\r\n\r\n            var yAxis = this.option.yAxis;\r\n            var yAxisIndex = this._zoom.yAxisIndex;\r\n            for (var i = 0, l = yAxisIndex.length; i < l; i++) {\r\n                this._originalData.yAxis[yAxisIndex[i]] = yAxis[yAxisIndex[i]].data;\r\n            }\r\n\r\n            var series = this.option.series;\r\n            var seriesIndex = this._zoom.seriesIndex;\r\n            var serie;\r\n            for (var i = 0, l = seriesIndex.length; i < l; i++) {\r\n                serie = series[seriesIndex[i]];\r\n                this._originalData.series[seriesIndex[i]] = serie.data;\r\n                if (serie.data\r\n                    && this.getDataFromOption(serie.data[0]) instanceof Array\r\n                    && (serie.type == ecConfig.CHART_TYPE_SCATTER\r\n                        || serie.type == ecConfig.CHART_TYPE_LINE\r\n                        || serie.type == ecConfig.CHART_TYPE_BAR)\r\n                ) {\r\n                    this._backupScale();\r\n                    this._calculScatterMap(seriesIndex[i]);\r\n                }\r\n            }\r\n        },\r\n\r\n        // 不止是scatter，双数值轴也使用此方法\r\n        _calculScatterMap : function (seriesIndex) {\r\n            this._zoom.scatterMap = this._zoom.scatterMap || {};\r\n            this._zoom.scatterMap[seriesIndex] = this._zoom.scatterMap[seriesIndex] || {};\r\n            var componentLibrary = require('../component');\r\n            // x轴极值\r\n            var Axis = componentLibrary.get('axis');\r\n            var axisOption = zrUtil.clone(this.option.xAxis);\r\n            if (axisOption[0].type == 'category') {\r\n                axisOption[0].type = 'value';\r\n            }\r\n            // axisOption[0].scale = true;\r\n            // axisOption[0].boundary = [0, 0];\r\n            if (axisOption[1] && axisOption[1].type == 'category') {\r\n                axisOption[1].type = 'value';\r\n            }\r\n\r\n            var vAxis = new Axis(\r\n                this.ecTheme,\r\n                null,   // messageCenter\r\n                false,  // this.zr\r\n                {\r\n                    xAxis: axisOption,\r\n                    series : this.option.series\r\n                },\r\n                this,\r\n                'xAxis'\r\n            );\r\n            var axisIndex = this.option.series[seriesIndex].xAxisIndex || 0;\r\n            this._zoom.scatterMap[seriesIndex].x = vAxis.getAxis(axisIndex).getExtremum();\r\n            vAxis.dispose();\r\n\r\n            // y轴极值\r\n            axisOption = zrUtil.clone(this.option.yAxis);\r\n            if (axisOption[0].type == 'category') {\r\n                axisOption[0].type = 'value';\r\n            }\r\n            // axisOption[0].scale = true;\r\n            // axisOption[1].boundary = [0, 0];\r\n            if (axisOption[1] && axisOption[1].type == 'category') {\r\n                axisOption[1].type = 'value';\r\n            }\r\n            vAxis = new Axis(\r\n                this.ecTheme,\r\n                null,   // messageCenter\r\n                false,  // this.zr\r\n                {\r\n                    yAxis: axisOption,\r\n                    series : this.option.series\r\n                },\r\n                this,\r\n                'yAxis'\r\n            );\r\n            axisIndex = this.option.series[seriesIndex].yAxisIndex || 0;\r\n            this._zoom.scatterMap[seriesIndex].y = vAxis.getAxis(axisIndex).getExtremum();\r\n            vAxis.dispose();\r\n            // console.log(this._zoom.scatterMap);\r\n        },\r\n\r\n        _buildBackground : function () {\r\n            var width = this._location.width;\r\n            var height = this._location.height;\r\n\r\n            // 背景\r\n            this.shapeList.push(new RectangleShape({\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                hoverable :false,\r\n                style : {\r\n                    x : this._location.x,\r\n                    y : this._location.y,\r\n                    width : width,\r\n                    height : height,\r\n                    color : this.zoomOption.backgroundColor\r\n                }\r\n            }));\r\n\r\n            // 数据阴影\r\n            var maxLength = 0;\r\n            var xAxis = this._originalData.xAxis;\r\n            var xAxisIndex = this._zoom.xAxisIndex;\r\n            for (var i = 0, l = xAxisIndex.length; i < l; i++) {\r\n                maxLength = Math.max(\r\n                    maxLength, xAxis[xAxisIndex[i]].length\r\n                );\r\n            }\r\n            var yAxis = this._originalData.yAxis;\r\n            var yAxisIndex = this._zoom.yAxisIndex;\r\n            for (var i = 0, l = yAxisIndex.length; i < l; i++) {\r\n                maxLength = Math.max(\r\n                    maxLength, yAxis[yAxisIndex[i]].length\r\n                );\r\n            }\r\n\r\n            var seriesIndex = this._zoom.seriesIndex[0];\r\n            var data = this._originalData.series[seriesIndex];\r\n            var maxValue = Number.MIN_VALUE;\r\n            var minValue = Number.MAX_VALUE;\r\n            var value;\r\n            for (var i = 0, l = data.length; i < l; i++) {\r\n                value = this.getDataFromOption(data[i], 0);\r\n                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {\r\n                    value = value[1];   // 收盘价\r\n                }\r\n                if (isNaN(value)) {\r\n                    value = 0;\r\n                }\r\n                maxValue = Math.max(maxValue, value);\r\n                minValue = Math.min(minValue, value);\r\n            }\r\n            var valueRange = maxValue - minValue;\r\n\r\n            var pointList = [];\r\n            var x = width / (maxLength - (maxLength > 1 ? 1 : 0));\r\n            var y = height / (maxLength - (maxLength > 1 ? 1 : 0));\r\n            var step = 1;\r\n            if (this.zoomOption.orient == 'horizontal' && x < 1) {\r\n                step = Math.floor(maxLength * 3 / width);\r\n            }\r\n            else if (this.zoomOption.orient == 'vertical' && y < 1){\r\n                step = Math.floor(maxLength * 3 / height);\r\n            }\r\n\r\n            for (var i = 0, l = maxLength; i < l; i += step) {\r\n                value = this.getDataFromOption(data[i], 0);\r\n                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {\r\n                    value = value[1];   // 收盘价\r\n                }\r\n                if (isNaN(value)) {\r\n                    value = 0;\r\n                }\r\n                if (this.zoomOption.orient == 'horizontal') {\r\n                    pointList.push([\r\n                        this._location.x + x * i,\r\n                        this._location.y + height - 1 - Math.round(\r\n                            (value - minValue) / valueRange * (height - 10)\r\n                        )\r\n                    ]);\r\n                }\r\n                else {\r\n                    pointList.push([\r\n                        this._location.x + 1 + Math.round(\r\n                            (value - minValue) / valueRange * (width - 10)\r\n                        ),\r\n                        this._location.y + y * (l - i - 1)\r\n                    ]);\r\n                }\r\n            }\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                pointList.push([\r\n                    this._location.x + width,\r\n                    this._location.y + height\r\n                ]);\r\n                pointList.push([\r\n                    this._location.x, this._location.y + height\r\n                ]);\r\n            }\r\n            else {\r\n                pointList.push([\r\n                    this._location.x, this._location.y\r\n                ]);\r\n                pointList.push([\r\n                    this._location.x, this._location.y + height\r\n                ]);\r\n            }\r\n\r\n            this.shapeList.push(new PolygonShape({\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                style : {\r\n                    pointList : pointList,\r\n                    color : this.zoomOption.dataBackgroundColor\r\n                },\r\n                hoverable : false\r\n            }));\r\n        },\r\n\r\n        /**\r\n         * 构建填充物\r\n         */\r\n        _buildFiller : function () {\r\n            this._fillerShae = {\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                draggable : true,\r\n                ondrift : this._ondrift,\r\n                ondragend : this._ondragend,\r\n                _type : 'filler'\r\n            };\r\n\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                // 横向\r\n                this._fillerShae.style = {\r\n                    x : this._location.x\r\n                        + Math.round(this._zoom.start / 100 * this._location.width)\r\n                        + this._handleSize,\r\n                    y : this._location.y,\r\n                    width : this._zoom.size - this._handleSize * 2,\r\n                    height : this._location.height,\r\n                    color : this.zoomOption.fillerColor,\r\n                    // strokeColor : '#fff', // this.zoomOption.handleColor,\r\n                    // lineWidth: 2,\r\n                    text : ':::',\r\n                    textPosition : 'inside'\r\n                };\r\n            }\r\n            else {\r\n                // 纵向\r\n                this._fillerShae.style ={\r\n                    x : this._location.x,\r\n                    y : this._location.y\r\n                        + Math.round(this._zoom.start / 100 * this._location.height)\r\n                        + this._handleSize,\r\n                    width :  this._location.width,\r\n                    height : this._zoom.size - this._handleSize * 2,\r\n                    color : this.zoomOption.fillerColor,\r\n                    // strokeColor : '#fff', // this.zoomOption.handleColor,\r\n                    // lineWidth: 2,\r\n                    text : '::',\r\n                    textPosition : 'inside'\r\n                };\r\n            }\r\n\r\n            this._fillerShae.highlightStyle = {\r\n                brushType: 'fill',\r\n                color : 'rgba(0,0,0,0)'\r\n                /*\r\n                color : require('zrenderjs/tool/color').alpha(\r\n                            this._fillerShae.style.color, 0\r\n                        )\r\n                */\r\n            };\r\n            this._fillerShae = new RectangleShape(this._fillerShae);\r\n            this.shapeList.push(this._fillerShae);\r\n        },\r\n\r\n        /**\r\n         * 构建拖拽手柄\r\n         */\r\n        _buildHandle : function () {\r\n            var detail = this.zoomOption.showDetail ? this._getDetail() : {start: '',end: ''};\r\n            this._startShape = {\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                draggable : true,\r\n                style : {\r\n                    iconType: 'rectangle',\r\n                    x: this._location.x,\r\n                    y: this._location.y,\r\n                    width: this._handleSize,\r\n                    height: this._handleSize,\r\n                    color: this.zoomOption.handleColor,\r\n                    text: '=',\r\n                    textPosition: 'inside'\r\n                },\r\n                highlightStyle: {\r\n                    text: detail.start,\r\n                    brushType: 'fill',\r\n                    textPosition: 'left'\r\n                },\r\n                ondrift: this._ondrift,\r\n                ondragend: this._ondragend\r\n            };\r\n\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                this._startShape.style.height = this._location.height;\r\n                this._endShape = zrUtil.clone(this._startShape);\r\n\r\n                this._startShape.style.x = this._fillerShae.style.x - this._handleSize,\r\n                this._endShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;\r\n                this._endShape.highlightStyle.text = detail.end;\r\n                this._endShape.highlightStyle.textPosition = 'right';\r\n            }\r\n            else {\r\n                this._startShape.style.width = this._location.width;\r\n                this._endShape = zrUtil.clone(this._startShape);\r\n\r\n                this._startShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;\r\n                this._startShape.highlightStyle.textPosition = 'bottom';\r\n\r\n                this._endShape.style.y = this._fillerShae.style.y - this._handleSize;\r\n                this._endShape.highlightStyle.text = detail.end;\r\n                this._endShape.highlightStyle.textPosition = 'top';\r\n            }\r\n            this._startShape = new IconShape(this._startShape);\r\n            this._endShape = new IconShape(this._endShape);\r\n            this.shapeList.push(this._startShape);\r\n            this.shapeList.push(this._endShape);\r\n        },\r\n\r\n        /**\r\n         * 构建特效边框\r\n         */\r\n        _buildFrame : function () {\r\n            // 特效框线，亚像素优化\r\n            var x = this.subPixelOptimize(this._location.x, 1);\r\n            var y = this.subPixelOptimize(this._location.y, 1);\r\n            this._startFrameShape = {\r\n                zlevel: this.getZlevelBase(),\r\n                z: this.getZBase(),\r\n                hoverable :false,\r\n                style : {\r\n                    x : x,\r\n                    y : y,\r\n                    width : this._location.width - (x > this._location.x ? 1 : 0),\r\n                    height : this._location.height - (y > this._location.y ? 1 : 0),\r\n                    lineWidth: 1,\r\n                    brushType: 'stroke',\r\n                    strokeColor : this.zoomOption.handleColor\r\n                }\r\n            };\r\n            this._endFrameShape = zrUtil.clone(this._startFrameShape);\r\n\r\n            this._startFrameShape = new RectangleShape(this._startFrameShape);\r\n            this._endFrameShape = new RectangleShape(this._endFrameShape);\r\n            this.shapeList.push(this._startFrameShape);\r\n            this.shapeList.push(this._endFrameShape);\r\n            return;\r\n        },\r\n\r\n        _syncHandleShape : function () {\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                this._startShape.style.x = this._fillerShae.style.x - this._handleSize;\r\n                this._endShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;\r\n\r\n                this._zoom.start = (\r\n                    this._startShape.style.x - this._location.x\r\n                ) / this._location.width * 100;\r\n                this._zoom.end = (\r\n                    this._endShape.style.x + this._handleSize - this._location.x\r\n                ) / this._location.width * 100;\r\n            }\r\n            else {\r\n                this._startShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;\r\n                this._endShape.style.y = this._fillerShae.style.y - this._handleSize;\r\n\r\n                this._zoom.start = (\r\n                    this._location.y + this._location.height\r\n                    - this._startShape.style.y\r\n                ) / this._location.height * 100;\r\n                this._zoom.end = (\r\n                    this._location.y + this._location.height\r\n                    - this._endShape.style.y - this._handleSize\r\n                ) / this._location.height * 100;\r\n            }\r\n            this.zr.modShape(this._startShape.id);\r\n            this.zr.modShape(this._endShape.id);\r\n\r\n            // 同步边框\r\n            this._syncFrameShape();\r\n\r\n            this.zr.refreshNextFrame();\r\n        },\r\n\r\n        _syncFillerShape : function () {\r\n            var a;\r\n            var b;\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                a = this._startShape.style.x;\r\n                b = this._endShape.style.x;\r\n                this._fillerShae.style.x = Math.min(a, b) + this._handleSize;\r\n                this._fillerShae.style.width = Math.abs(a - b) - this._handleSize;\r\n                this._zoom.start = (\r\n                    Math.min(a, b) - this._location.x\r\n                ) / this._location.width * 100;\r\n                this._zoom.end = (\r\n                    Math.max(a, b) + this._handleSize - this._location.x\r\n                ) / this._location.width * 100;\r\n            }\r\n            else {\r\n                a = this._startShape.style.y;\r\n                b = this._endShape.style.y;\r\n                this._fillerShae.style.y = Math.min(a, b) + this._handleSize;\r\n                this._fillerShae.style.height = Math.abs(a - b) - this._handleSize;\r\n                this._zoom.start = (\r\n                    this._location.y + this._location.height - Math.max(a, b)\r\n                ) / this._location.height * 100;\r\n                this._zoom.end = (\r\n                    this._location.y + this._location.height - Math.min(a, b) - this._handleSize\r\n                ) / this._location.height * 100;\r\n            }\r\n\r\n            this.zr.modShape(this._fillerShae.id);\r\n\r\n            // 同步边框\r\n            this._syncFrameShape();\r\n\r\n            this.zr.refreshNextFrame();\r\n        },\r\n\r\n        _syncFrameShape : function () {\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                this._startFrameShape.style.width =\r\n                    this._fillerShae.style.x - this._location.x;\r\n                this._endFrameShape.style.x =\r\n                    this._fillerShae.style.x + this._fillerShae.style.width;\r\n                this._endFrameShape.style.width =\r\n                    this._location.x + this._location.width - this._endFrameShape.style.x;\r\n            }\r\n            else {\r\n                this._startFrameShape.style.y =\r\n                    this._fillerShae.style.y + this._fillerShae.style.height;\r\n                this._startFrameShape.style.height =\r\n                    this._location.y + this._location.height - this._startFrameShape.style.y;\r\n                this._endFrameShape.style.height =\r\n                    this._fillerShae.style.y - this._location.y;\r\n            }\r\n\r\n            this.zr.modShape(this._startFrameShape.id);\r\n            this.zr.modShape(this._endFrameShape.id);\r\n        },\r\n\r\n        _syncShape : function () {\r\n            if (!this.zoomOption.show) {\r\n                // 没有伸缩控件\r\n                return;\r\n            }\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                this._startShape.style.x = this._location.x\r\n                                           + this._zoom.start / 100 * this._location.width;\r\n                this._endShape.style.x   = this._location.x\r\n                                           + this._zoom.end / 100 * this._location.width\r\n                                           - this._handleSize;\r\n\r\n                this._fillerShae.style.x     = this._startShape.style.x + this._handleSize;\r\n                this._fillerShae.style.width = this._endShape.style.x\r\n                                               - this._startShape.style.x\r\n                                               - this._handleSize;\r\n            }\r\n            else {\r\n                this._startShape.style.y = this._location.y + this._location.height\r\n                                           - this._zoom.start / 100 * this._location.height;\r\n                this._endShape.style.y   = this._location.y + this._location.height\r\n                                           - this._zoom.end / 100 * this._location.height\r\n                                           - this._handleSize;\r\n\r\n                this._fillerShae.style.y      = this._endShape.style.y + this._handleSize;\r\n                this._fillerShae.style.height = this._startShape.style.y\r\n                                                - this._endShape.style.y\r\n                                                - this._handleSize;\r\n            }\r\n\r\n            this.zr.modShape(this._startShape.id);\r\n            this.zr.modShape(this._endShape.id);\r\n            this.zr.modShape(this._fillerShae.id);\r\n            // 同步边框\r\n            this._syncFrameShape();\r\n            this.zr.refresh();\r\n        },\r\n\r\n         _syncData : function (dispatchNow) {\r\n            var target;\r\n            var start;\r\n            var end;\r\n            var length;\r\n            var data;\r\n\r\n            for (var key in this._originalData) {\r\n                target = this._originalData[key];\r\n                for (var idx in target) {\r\n                    data = target[idx];\r\n                    if (data == null) {\r\n                        continue;\r\n                    }\r\n                    length = data.length;\r\n                    start = Math.floor(this._zoom.start / 100 * length);\r\n                    end = Math.ceil(this._zoom.end / 100 * length);\r\n\r\n                    if (!(this.getDataFromOption(data[0]) instanceof Array)\r\n                        || this.option[key][idx].type == ecConfig.CHART_TYPE_K\r\n                    ) {\r\n                        this.option[key][idx].data = data.slice(start, end);\r\n                    }\r\n                    else {\r\n                        // 散点图，双数值轴折线图柱形图特殊处理\r\n                        // axis.data[0]不会是Array，所以axis的情况不会走进这个分支\r\n                        this._setScale();\r\n                        this.option[key][idx].data = this._synScatterData(idx, data);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!this._isSilence && (this.zoomOption.realtime || dispatchNow)) {\r\n                this.messageCenter.dispatch(\r\n                    ecConfig.EVENT.DATA_ZOOM,\r\n                    null,\r\n                    {zoom: this._zoom},\r\n                    this.myChart\r\n                );\r\n            }\r\n\r\n            //this.zoomOption.start = this._zoom.start;\r\n            //this.zoomOption.end = this._zoom.end;\r\n        },\r\n\r\n        _synScatterData : function (seriesIndex, data) {\r\n            if (this._zoom.start === 0\r\n                && this._zoom.end == 100\r\n                && this._zoom.start2 === 0\r\n                && this._zoom.end2 == 100\r\n            ) {\r\n                return data;\r\n            }\r\n            var newData = [];\r\n            var scale = this._zoom.scatterMap[seriesIndex];\r\n            var total;\r\n            var xStart;\r\n            var xEnd;\r\n            var yStart;\r\n            var yEnd;\r\n\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                total = scale.x.max - scale.x.min;\r\n                xStart = this._zoom.start / 100 * total + scale.x.min;\r\n                xEnd = this._zoom.end / 100 * total + scale.x.min;\r\n\r\n                total = scale.y.max - scale.y.min;\r\n                yStart = this._zoom.start2 / 100 * total + scale.y.min;\r\n                yEnd = this._zoom.end2 / 100 * total + scale.y.min;\r\n            }\r\n            else {\r\n                total = scale.x.max - scale.x.min;\r\n                xStart = this._zoom.start2 / 100 * total + scale.x.min;\r\n                xEnd = this._zoom.end2 / 100 * total + scale.x.min;\r\n\r\n                total = scale.y.max - scale.y.min;\r\n                yStart = this._zoom.start / 100 * total + scale.y.min;\r\n                yEnd = this._zoom.end / 100 * total + scale.y.min;\r\n            }\r\n\r\n            var dataMappingMethods;\r\n            if (dataMappingMethods = scale.x.dataMappingMethods) {\r\n                xStart = dataMappingMethods.coord2Value(xStart);\r\n                xEnd = dataMappingMethods.coord2Value(xEnd);\r\n            }\r\n            if (dataMappingMethods = scale.y.dataMappingMethods) {\r\n                yStart = dataMappingMethods.coord2Value(yStart);\r\n                yEnd = dataMappingMethods.coord2Value(yEnd);\r\n            }\r\n\r\n            // console.log(xStart,xEnd,yStart,yEnd);\r\n\r\n            var value;\r\n            for (var i = 0, l = data.length; i < l; i++) {\r\n                value = data[i].value || data[i];\r\n                if (value[0] >= xStart\r\n                    && value[0] <= xEnd\r\n                    && value[1] >= yStart\r\n                    && value[1] <= yEnd\r\n                ) {\r\n                    newData.push(data[i]);\r\n                }\r\n            }\r\n\r\n            return newData;\r\n        },\r\n\r\n        /**\r\n         * 发生缩放后修改axis的scale\r\n         */\r\n        _setScale: function() {\r\n            var needScale = this._zoom.start !== 0\r\n                            || this._zoom.end !== 100\r\n                            || this._zoom.start2 !== 0\r\n                            || this._zoom.end2 !== 100;\r\n            var axis = {\r\n                xAxis : this.option.xAxis,\r\n                yAxis : this.option.yAxis\r\n            };\r\n            for (var key in axis) {\r\n                for (var i = 0, l = axis[key].length; i < l; i++) {\r\n                    axis[key][i].scale = needScale || axis[key][i]._scale;\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 备份可能存在的scale设置\r\n         */\r\n        _backupScale: function() {\r\n            var axis = {\r\n                xAxis : this.option.xAxis,\r\n                yAxis : this.option.yAxis\r\n            };\r\n            for (var key in axis) {\r\n                for (var i = 0, l = axis[key].length; i < l; i++) {\r\n                    axis[key][i]._scale = axis[key][i].scale;\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 获取当前定位\r\n         */\r\n        _getDetail : function () {\r\n            var key = ['xAxis', 'yAxis'];\r\n            for (var i = 0, l = key.length; i < l; i++) {\r\n                var target = this._originalData[key[i]];\r\n                for (var idx in target) {\r\n                    var data = target[idx];\r\n                    if (data == null) {\r\n                        continue;\r\n                    }\r\n                    var length = data.length;\r\n                    var start = Math.floor(this._zoom.start / 100 * length);\r\n                    var end = Math.ceil(this._zoom.end / 100 * length);\r\n                    end -= end > 0 ? 1 : 0;\r\n                    return {\r\n                        start : this.getDataFromOption(data[start]),\r\n                        end : this.getDataFromOption(data[end])\r\n                    };\r\n                }\r\n            }\r\n\r\n            key = this.zoomOption.orient == 'horizontal' ? 'xAxis' : 'yAxis';\r\n            var seriesIndex = this._zoom.seriesIndex[0];\r\n            var axisIndex = this.option.series[seriesIndex][key + 'Index'] || 0;\r\n            var axisType = this.option[key][axisIndex].type;\r\n            var min = this._zoom.scatterMap[seriesIndex][key.charAt(0)].min;\r\n            var max = this._zoom.scatterMap[seriesIndex][key.charAt(0)].max;\r\n            var gap = max - min;\r\n\r\n            if (axisType == 'value') {\r\n                return {\r\n                    start : min + gap * this._zoom.start / 100,\r\n                    end : min + gap * this._zoom.end / 100\r\n                };\r\n            }\r\n            else if (axisType == 'time') {\r\n                // 最优解\r\n                max = min + gap * this._zoom.end / 100;\r\n                min = min + gap * this._zoom.start / 100;\r\n                var formatter = ecDate.getAutoFormatter(min, max).formatter;\r\n                return {\r\n                    start : ecDate.format(formatter, min),\r\n                    end : ecDate.format(formatter, max)\r\n                };\r\n            }\r\n\r\n            return {\r\n                start : '',\r\n                end : ''\r\n            };\r\n        },\r\n\r\n        /**\r\n         * 拖拽范围控制\r\n         */\r\n        __ondrift : function (shape, dx, dy) {\r\n            if (this.zoomOption.zoomLock) {\r\n                // zoomLock时把handle转成filler的拖拽\r\n                shape = this._fillerShae;\r\n            }\r\n\r\n            var detailSize = shape._type == 'filler' ? this._handleSize : 0;\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                if (shape.style.x + dx - detailSize <= this._location.x) {\r\n                    shape.style.x = this._location.x + detailSize;\r\n                }\r\n                else if (shape.style.x + dx + shape.style.width + detailSize\r\n                         >= this._location.x + this._location.width\r\n                ) {\r\n                    shape.style.x = this._location.x + this._location.width\r\n                                - shape.style.width - detailSize;\r\n                }\r\n                else {\r\n                    shape.style.x += dx;\r\n                }\r\n            }\r\n            else {\r\n                if (shape.style.y + dy - detailSize <= this._location.y) {\r\n                    shape.style.y = this._location.y + detailSize;\r\n                }\r\n                else if (shape.style.y + dy + shape.style.height + detailSize\r\n                         >= this._location.y + this._location.height\r\n                ) {\r\n                    shape.style.y = this._location.y + this._location.height\r\n                                - shape.style.height - detailSize;\r\n                }\r\n                else {\r\n                    shape.style.y += dy;\r\n                }\r\n            }\r\n\r\n            if (shape._type == 'filler') {\r\n                this._syncHandleShape();\r\n            }\r\n            else {\r\n                this._syncFillerShape();\r\n            }\r\n\r\n            if (this.zoomOption.realtime) {\r\n                this._syncData();\r\n            }\r\n\r\n            if (this.zoomOption.showDetail) {\r\n                var detail = this._getDetail();\r\n                this._startShape.style.text = this._startShape.highlightStyle.text = detail.start;\r\n                this._endShape.style.text = this._endShape.highlightStyle.text = detail.end;\r\n                this._startShape.style.textPosition = this._startShape.highlightStyle.textPosition;\r\n                this._endShape.style.textPosition = this._endShape.highlightStyle.textPosition;\r\n            }\r\n            return true;\r\n        },\r\n\r\n        __ondragend : function () {\r\n            if (this.zoomOption.showDetail) {\r\n                this._startShape.style.text = this._endShape.style.text = '=';\r\n                this._startShape.style.textPosition = this._endShape.style.textPosition = 'inside';\r\n                this.zr.modShape(this._startShape.id);\r\n                this.zr.modShape(this._endShape.id);\r\n                this.zr.refreshNextFrame();\r\n            }\r\n            this.isDragend = true;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽出去\r\n         */\r\n        ondragend : function (param, status) {\r\n            if (!this.isDragend || !param.target) {\r\n                // 没有在当前实例上发生拖拽行为则直接返回\r\n                return;\r\n            }\r\n\r\n            !this.zoomOption.realtime && this._syncData();\r\n\r\n            // 别status = {}赋值啊！！\r\n            status.dragOut = true;\r\n            status.dragIn = true;\r\n            if (!this._isSilence && !this.zoomOption.realtime) {\r\n                this.messageCenter.dispatch(\r\n                    ecConfig.EVENT.DATA_ZOOM,\r\n                    null,\r\n                    {zoom: this._zoom},\r\n                    this.myChart\r\n                );\r\n            }\r\n            status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍\r\n            // 处理完拖拽事件后复位\r\n            this.isDragend = false;\r\n\r\n            return;\r\n        },\r\n\r\n        ondataZoom : function (param, status) {\r\n            status.needRefresh = true;\r\n            return;\r\n        },\r\n\r\n        absoluteZoom : function (param) {\r\n            this._zoom.start = param.start;\r\n            this._zoom.end = param.end;\r\n            this._zoom.start2 = param.start2;\r\n            this._zoom.end2 = param.end2;\r\n            this._syncShape();\r\n            this._syncData(true);\r\n            return;\r\n        },\r\n\r\n        rectZoom : function (param) {\r\n            if (!param) {\r\n                // 重置拖拽\r\n                //this.zoomOption.start =\r\n                //this.zoomOption.start2 =\r\n                this._zoom.start = this._zoom.start2 = 0;\r\n\r\n                //this.zoomOption.end =\r\n                //this.zoomOption.end2 =\r\n                this._zoom.end = this._zoom.end2 = 100;\r\n\r\n                this._syncShape();\r\n                this._syncData(true);\r\n                return this._zoom;\r\n            }\r\n            var gridArea = this.component.grid.getArea();\r\n            var rect = {\r\n                x : param.x,\r\n                y : param.y,\r\n                width : param.width,\r\n                height : param.height\r\n            };\r\n            // 修正方向框选\r\n            if (rect.width < 0) {\r\n                rect.x += rect.width;\r\n                rect.width = -rect.width;\r\n            }\r\n            if (rect.height < 0) {\r\n                rect.y += rect.height;\r\n                rect.height = -rect.height;\r\n            }\r\n            // console.log(rect,this._zoom);\r\n\r\n            // 剔除无效缩放\r\n            if (rect.x > gridArea.x + gridArea.width || rect.y > gridArea.y + gridArea.height) {\r\n                return false; // 无效缩放\r\n            }\r\n\r\n            // 修正框选超出\r\n            if (rect.x < gridArea.x) {\r\n                rect.x = gridArea.x;\r\n            }\r\n            if (rect.x + rect.width > gridArea.x + gridArea.width) {\r\n                rect.width = gridArea.x + gridArea.width - rect.x;\r\n            }\r\n            if (rect.y + rect.height > gridArea.y + gridArea.height) {\r\n                rect.height = gridArea.y + gridArea.height - rect.y;\r\n            }\r\n\r\n            var total;\r\n            var sdx = (rect.x - gridArea.x) / gridArea.width;\r\n            var edx = 1 - (rect.x + rect.width - gridArea.x) / gridArea.width;\r\n            var sdy = 1 - (rect.y + rect.height - gridArea.y) / gridArea.height;\r\n            var edy = (rect.y - gridArea.y) / gridArea.height;\r\n            // console.log('this',sdy,edy,this._zoom.start,this._zoom.end)\r\n            if (this.zoomOption.orient == 'horizontal') {\r\n                total = this._zoom.end - this._zoom.start;\r\n                this._zoom.start += total * sdx;\r\n                this._zoom.end -= total * edx;\r\n\r\n                total = this._zoom.end2 - this._zoom.start2;\r\n                this._zoom.start2 += total * sdy;\r\n                this._zoom.end2 -= total * edy;\r\n            }\r\n            else {\r\n                total = this._zoom.end - this._zoom.start;\r\n                this._zoom.start += total * sdy;\r\n                this._zoom.end -= total * edy;\r\n\r\n                total = this._zoom.end2 - this._zoom.start2;\r\n                this._zoom.start2 += total * sdx;\r\n                this._zoom.end2 -= total * edx;\r\n            }\r\n            //console.log(this._zoom.start,this._zoom.end,this._zoom.start2,this._zoom.end2)\r\n            //this.zoomOption.start = this._zoom.start;\r\n            //this.zoomOption.end = this._zoom.end;\r\n            //this.zoomOption.start2 = this._zoom.start2;\r\n            //this.zoomOption.end2 = this._zoom.end2;\r\n            //console.log(rect,gridArea,this._zoom,total)\r\n            this._syncShape();\r\n            this._syncData(true);\r\n            return this._zoom;\r\n        },\r\n\r\n        syncBackupData : function (curOption) {\r\n            var start;\r\n            var target = this._originalData['series'];\r\n            var curSeries = curOption.series;\r\n            var curData;\r\n            for (var i = 0, l = curSeries.length; i < l; i++) {\r\n                curData = curSeries[i].data || curSeries[i].eventList;\r\n                if (target[i]) {\r\n                    // dataZoom接管的\r\n                    start = Math.floor(this._zoom.start / 100 * target[i].length);\r\n                }\r\n                else {\r\n                    // 非dataZoom接管\r\n                    start = 0;\r\n                }\r\n                for (var j = 0, k = curData.length; j < k; j++) {\r\n                    //optionBackup.series[i].data[j + start] = curData[j];\r\n                    if (target[i]) {\r\n                        // 同步内部备份\r\n                        target[i][j + start] = curData[j];\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        syncOption : function(magicOption) {\r\n            this.silence(true);\r\n            this.option = magicOption;\r\n            this.option.dataZoom = this.reformOption(this.option.dataZoom);\r\n            this.zoomOption = this.option.dataZoom;\r\n            if (!this.myChart.canvasSupported) {\r\n                // 不支持Canvas的强制关闭实时动画\r\n                this.zoomOption.realtime = false;\r\n            }\r\n\r\n            this.clear();\r\n            // 位置参数，通过计算所得x, y, width, height\r\n            this._location = this._getLocation();\r\n            // 缩放参数\r\n            this._zoom =  this._getZoom();\r\n\r\n            this._backupData();\r\n            if (this.option.dataZoom && this.option.dataZoom.show) {\r\n                this._buildShape();\r\n            }\r\n            this._syncData();\r\n\r\n            this.silence(false);\r\n        },\r\n\r\n        silence : function (s) {\r\n            this._isSilence = s;\r\n        },\r\n\r\n        getRealDataIndex : function (sIdx, dIdx) {\r\n            if (!this._originalData || (this._zoom.start === 0 && this._zoom.end == 100)) {\r\n                return dIdx;\r\n            }\r\n            var sreies = this._originalData.series;\r\n            if (sreies[sIdx]) {\r\n                return Math.floor(this._zoom.start / 100 * sreies[sIdx].length) + dIdx;\r\n            }\r\n            return -1;\r\n        },\r\n\r\n        /**\r\n         * 避免dataZoom带来两次refresh，不设refresh接口，resize重复一下buildshape逻辑\r\n         */\r\n        resize : function () {\r\n            this.clear();\r\n\r\n            // 位置参数，通过计算所得x, y, width, height\r\n            this._location = this._getLocation();\r\n            // 缩放参数\r\n            this._zoom =  this._getZoom();\r\n\r\n            if (this.option.dataZoom.show) {\r\n                this._buildShape();\r\n            }\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(DataZoom, Base);\r\n\r\n    require('../component').define('dataZoom', DataZoom);\r\n\r\n    return DataZoom;\r\n});\r\n"
    },
    {
      "id": 61,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart.js",
      "index": 61,
      "index2": 56,
      "size": 644,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\bar.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/bar.js",
          "type": "cjs require",
          "userRequest": "../chart",
          "loc": "950:4-23"
        },
        {
          "moduleId": 64,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "../chart",
          "loc": "248:4-23"
        },
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "../chart",
          "loc": "1055:4-23"
        }
      ],
      "source": "/**\r\n * echart图表库\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n */\r\ndefine(function (/*require*/) {     //chart\r\n    var self = {};\r\n\r\n    var _chartLibrary = {};         //echart图表库\r\n\r\n    /**\r\n     * 定义图形实现\r\n     * @param {Object} name\r\n     * @param {Object} clazz 图形实现\r\n     */\r\n    self.define = function (name, clazz) {\r\n        _chartLibrary[name] = clazz;\r\n        return self;\r\n    };\r\n\r\n    /**\r\n     * 获取图形实现\r\n     * @param {Object} name\r\n     */\r\n    self.get = function (name) {\r\n        return _chartLibrary[name];\r\n    };\r\n\r\n    return self;\r\n});"
    },
    {
      "id": 62,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\base.js",
      "name": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/base.js",
      "index": 62,
      "index2": 59,
      "size": 281,
      "cacheable": true,
      "built": true,
      "optional": true,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
          "type": "context element",
          "userRequest": "./base.js"
        }
      ],
      "source": "var cbs = [], \n\tdata;\nmodule.exports = function(cb) {\n\tif(cbs) cbs.push(cb);\n\telse cb(data);\n}\nrequire.ensure([], function(require) {\n\tdata = require(\"!!./base.js\");\n\tvar callbacks = cbs;\n\tcbs = null;\n\tfor(var i = 0, l = callbacks.length; i < l; i++) {\n\t\tcallbacks[i](data);\n\t}\n});"
    },
    {
      "id": 63,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
      "name": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
      "index": 63,
      "index2": 62,
      "size": 283,
      "cacheable": true,
      "built": true,
      "optional": true,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
          "type": "context element",
          "userRequest": "./island.js"
        }
      ],
      "source": "var cbs = [], \n\tdata;\nmodule.exports = function(cb) {\n\tif(cbs) cbs.push(cb);\n\telse cb(data);\n}\nrequire.ensure([], function(require) {\n\tdata = require(\"!!./island.js\");\n\tvar callbacks = cbs;\n\tcbs = null;\n\tfor(var i = 0, l = callbacks.length; i < l; i++) {\n\t\tcallbacks[i](data);\n\t}\n});"
    },
    {
      "id": 64,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
      "index": 64,
      "index2": 61,
      "size": 8317,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        4
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 63,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "!!./island.js",
          "loc": "8:8-32"
        }
      ],
      "source": "/**\r\n * echarts组件：孤岛数据\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ChartBase = require('./base');\r\n    \r\n    // 图形依赖\r\n    var CircleShape = require('zrenderjs/shape/Circle');\r\n    \r\n    var ecConfig = require('../config');\r\n    ecConfig.island = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 5,                       // 二级层叠\r\n        r: 15,\r\n        calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%\r\n    };\r\n\r\n    var ecData = require('../util/ecData');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrEvent = require('zrenderjs/tool/event');\r\n    \r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} option 图表选项\r\n     */\r\n    function Island(ecTheme, messageCenter, zr, option, myChart) {\r\n        // 图表基类\r\n        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this._nameConnector;\r\n        this._valueConnector;\r\n        this._zrHeight = this.zr.getHeight();\r\n        this._zrWidth = this.zr.getWidth();\r\n\r\n        var self = this;\r\n        /**\r\n         * 滚轮改变孤岛数据值\r\n         */\r\n        self.shapeHandler.onmousewheel = function (param) {\r\n            var shape = param.target;\r\n\r\n            var event = param.event;\r\n            var delta = zrEvent.getDelta(event);\r\n            delta = delta > 0 ? (-1) : 1;\r\n            shape.style.r -= delta;\r\n            shape.style.r = shape.style.r < 5 ? 5 : shape.style.r;\r\n\r\n            var value = ecData.get(shape, 'value');\r\n            var dvalue = value * self.option.island.calculateStep;\r\n            value = dvalue > 1\r\n                    ? (Math.round(value - dvalue * delta))\r\n                    : +(value - dvalue * delta).toFixed(2);\r\n\r\n            var name = ecData.get(shape, 'name');\r\n            shape.style.text = name + ':' + value;\r\n\r\n            ecData.set(shape, 'value', value);\r\n            ecData.set(shape, 'name', name);\r\n\r\n            self.zr.modShape(shape.id);\r\n            self.zr.refreshNextFrame();\r\n            zrEvent.stop(event);\r\n        };\r\n    }\r\n    \r\n    Island.prototype = {\r\n        type: ecConfig.CHART_TYPE_ISLAND,\r\n        /**\r\n         * 孤岛合并\r\n         *\r\n         * @param {string} tarShapeIndex 目标索引\r\n         * @param {Object} srcShape 源目标，合入目标后删除\r\n         */\r\n        _combine: function (tarShape, srcShape) {\r\n            var zrColor = require('zrenderjs/tool/color');\r\n            var accMath = require('../util/accMath');\r\n            var value = accMath.accAdd(\r\n                            ecData.get(tarShape, 'value'),\r\n                            ecData.get(srcShape, 'value')\r\n                        );\r\n            var name = ecData.get(tarShape, 'name')\r\n                       + this._nameConnector\r\n                       + ecData.get(srcShape, 'name');\r\n\r\n            tarShape.style.text = name + this._valueConnector + value;\r\n\r\n            ecData.set(tarShape, 'value', value);\r\n            ecData.set(tarShape, 'name', name);\r\n            tarShape.style.r = this.option.island.r;\r\n            tarShape.style.color = zrColor.mix(\r\n                tarShape.style.color,\r\n                srcShape.style.color\r\n            );\r\n        },\r\n\r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption) {\r\n            if (newOption) {\r\n                newOption.island = this.reformOption(newOption.island);\r\n                this.option = newOption;\r\n    \r\n                this._nameConnector = this.option.nameConnector;\r\n                this._valueConnector = this.option.valueConnector;\r\n            }\r\n        },\r\n        \r\n        getOption: function () {\r\n            return this.option;\r\n        },\r\n\r\n        resize: function () {\r\n            var newWidth = this.zr.getWidth();\r\n            var newHieght = this.zr.getHeight();\r\n            var xScale = newWidth / (this._zrWidth || newWidth);\r\n            var yScale = newHieght / (this._zrHeight || newHieght);\r\n            if (xScale === 1 && yScale === 1) {\r\n                return;\r\n            }\r\n            this._zrWidth = newWidth;\r\n            this._zrHeight = newHieght;\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                this.zr.modShape(\r\n                    this.shapeList[i].id,\r\n                    {\r\n                        style: {\r\n                            x: Math.round(this.shapeList[i].style.x * xScale),\r\n                            y: Math.round(this.shapeList[i].style.y * yScale)\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n        },\r\n\r\n        add: function (shape) {\r\n            var name = ecData.get(shape, 'name');\r\n            var value = ecData.get(shape, 'value');\r\n            var seriesName = ecData.get(shape, 'series') != null\r\n                             ? ecData.get(shape, 'series').name\r\n                             : '';\r\n            var font = this.getFont(this.option.island.textStyle);\r\n            var islandOption = this.option.island;\r\n            var islandShape = {\r\n                zlevel: islandOption.zlevel,\r\n                z: islandOption.z,\r\n                style: {\r\n                    x: shape.style.x,\r\n                    y: shape.style.y,\r\n                    r: this.option.island.r,\r\n                    color: shape.style.color || shape.style.strokeColor,\r\n                    text: name + this._valueConnector + value,\r\n                    textFont: font\r\n                },\r\n                draggable: true,\r\n                hoverable: true,\r\n                onmousewheel: this.shapeHandler.onmousewheel,\r\n                _type: 'island'\r\n            };\r\n            if (islandShape.style.color === '#fff') {\r\n                islandShape.style.color = shape.style.strokeColor;\r\n            }\r\n            this.setCalculable(islandShape);\r\n            islandShape.dragEnableTime = 0;\r\n            ecData.pack(\r\n                islandShape,\r\n                {name:seriesName}, -1,\r\n                value, -1,\r\n                name\r\n            );\r\n            islandShape = new CircleShape(islandShape);\r\n            this.shapeList.push(islandShape);\r\n            this.zr.addShape(islandShape);\r\n        },\r\n\r\n        del: function (shape) {\r\n            this.zr.delShape(shape.id);\r\n            var newShapeList = [];\r\n            for (var i = 0, l = this.shapeList.length; i < l; i++) {\r\n                if (this.shapeList[i].id != shape.id) {\r\n                    newShapeList.push(this.shapeList[i]);\r\n                }\r\n            }\r\n            this.shapeList = newShapeList;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽进来， 重载基类方法\r\n         */\r\n        ondrop: function (param, status) {\r\n            if (!this.isDrop || !param.target) {\r\n                // 没有在当前实例上发生拖拽行为则直接返回\r\n                return;\r\n            }\r\n            // 拖拽产生孤岛数据合并\r\n            var target = param.target;      // 拖拽安放目标\r\n            var dragged = param.dragged;    // 当前被拖拽的图形对象\r\n\r\n            this._combine(target, dragged);\r\n            this.zr.modShape(target.id);\r\n\r\n            status.dragIn = true;\r\n\r\n            // 处理完拖拽事件后复位\r\n            this.isDrop = false;\r\n\r\n            return;\r\n        },\r\n\r\n        /**\r\n         * 数据项被拖拽出去， 重载基类方法\r\n         */\r\n        ondragend: function (param, status) {\r\n            var target = param.target;      // 拖拽安放目标\r\n            if (!this.isDragend) {\r\n                // 拖拽的不是孤岛数据，如果没有图表接受孤岛数据，需要新增孤岛数据\r\n                if (!status.dragIn) {\r\n                    target.style.x = zrEvent.getX(param.event);\r\n                    target.style.y = zrEvent.getY(param.event);\r\n                    this.add(target);\r\n                    status.needRefresh = true;\r\n                }\r\n            }\r\n            else {\r\n                // 拖拽的是孤岛数据，如果有图表接受了孤岛数据，需要删除孤岛数据\r\n                if (status.dragIn) {\r\n                    this.del(target);\r\n                    status.needRefresh = true;\r\n                }\r\n            }\r\n\r\n            // 处理完拖拽事件后复位\r\n            this.isDragend = false;\r\n\r\n            return;\r\n        }\r\n    };\r\n    \r\n    zrUtil.inherits(Island, ChartBase);\r\n    \r\n    // 图表注册\r\n    require('../chart').define('island', Island);\r\n    \r\n    return Island;\r\n});"
    },
    {
      "id": 65,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\node_modules\\zrenderjs\\tool\\event.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/~/zrenderjs/tool/event.js",
      "index": 65,
      "index2": 60,
      "size": 2351,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        4
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 64,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\island.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/island.js",
          "type": "cjs require",
          "userRequest": "zrenderjs/tool/event",
          "loc": "24:18-49"
        }
      ],
      "source": "/**\r\n * 事件辅助类\r\n * @module zrender/tool/event\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n */\r\ndefine(\r\n    function(require) {\r\n\r\n        'use strict';\r\n\r\n        var Eventful = require('../mixin/Eventful');\r\n\r\n        /**\r\n        * 提取鼠标（手指）x坐标\r\n        * @memberOf module:zrender/tool/event\r\n        * @param  {Event} e 事件.\r\n        * @return {number} 鼠标（手指）x坐标.\r\n        */\r\n        function getX(e) {\r\n            return typeof e.zrenderX != 'undefined' && e.zrenderX\r\n                   || typeof e.offsetX != 'undefined' && e.offsetX\r\n                   || typeof e.layerX != 'undefined' && e.layerX\r\n                   || typeof e.clientX != 'undefined' && e.clientX;\r\n        }\r\n\r\n        /**\r\n        * 提取鼠标y坐标\r\n        * @memberOf module:zrender/tool/event\r\n        * @param  {Event} e 事件.\r\n        * @return {number} 鼠标（手指）y坐标.\r\n        */\r\n        function getY(e) {\r\n            return typeof e.zrenderY != 'undefined' && e.zrenderY\r\n                   || typeof e.offsetY != 'undefined' && e.offsetY\r\n                   || typeof e.layerY != 'undefined' && e.layerY\r\n                   || typeof e.clientY != 'undefined' && e.clientY;\r\n        }\r\n\r\n        /**\r\n        * 提取鼠标滚轮变化\r\n        * @memberOf module:zrender/tool/event\r\n        * @param  {Event} e 事件.\r\n        * @return {number} 滚轮变化，正值说明滚轮是向上滚动，如果是负值说明滚轮是向下滚动\r\n        */\r\n        function getDelta(e) {\r\n            return typeof e.zrenderDelta != 'undefined' && e.zrenderDelta\r\n                   || typeof e.wheelDelta != 'undefined' && e.wheelDelta\r\n                   || typeof e.detail != 'undefined' && -e.detail;\r\n        }\r\n\r\n        /**\r\n         * 停止冒泡和阻止默认行为\r\n         * @memberOf module:zrender/tool/event\r\n         * @method\r\n         * @param {Event} e : event对象\r\n         */\r\n        var stop = typeof window.addEventListener === 'function'\r\n            ? function (e) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                e.cancelBubble = true;\r\n            }\r\n            : function (e) {\r\n                e.returnValue = false;\r\n                e.cancelBubble = true;\r\n            };\r\n        \r\n        return {\r\n            getX : getX,\r\n            getY : getY,\r\n            getDelta : getDelta,\r\n            stop : stop,\r\n            // 做向上兼容\r\n            Dispatcher : Eventful\r\n        };\r\n    }\r\n);\r\n"
    },
    {
      "id": 66,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
      "name": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
      "index": 66,
      "index2": 65,
      "size": 281,
      "cacheable": true,
      "built": true,
      "optional": true,
      "prefetched": false,
      "chunks": [
        2
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 2,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!/^\\.\\/.*\\.js$/",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart E:/www/Test/webpack-lok'tar/~/bundle-loader^\\.\\/.*\\.js$",
          "type": "context element",
          "userRequest": "./line.js"
        }
      ],
      "source": "var cbs = [], \n\tdata;\nmodule.exports = function(cb) {\n\tif(cbs) cbs.push(cb);\n\telse cb(data);\n}\nrequire.ensure([], function(require) {\n\tdata = require(\"!!./line.js\");\n\tvar callbacks = cbs;\n\tcbs = null;\n\tfor(var i = 0, l = callbacks.length; i < l; i++) {\n\t\tcallbacks[i](data);\n\t}\n});"
    },
    {
      "id": 67,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
      "index": 67,
      "index2": 64,
      "size": 45576,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        5
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 66,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\bundle-loader\\index.js!E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/bundle-loader!E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "!!./line.js",
          "loc": "8:8-30"
        }
      ],
      "source": "/**\r\n * echarts图表类：折线图\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n */\r\ndefine(function (require) {\r\n    var ChartBase = require('./base');\r\n    \r\n    // 图形依赖\r\n    var PolylineShape = require('zrenderjs/shape/Polyline');\r\n    var IconShape = require('../util/shape/Icon');\r\n    var HalfSmoothPolygonShape = require('../util/shape/HalfSmoothPolygon');\r\n    // 组件依赖\r\n    require('../component/axis');\r\n    require('../component/grid');\r\n    require('../component/dataZoom');\r\n    \r\n    var ecConfig = require('../config');\r\n    // 折线图默认参数\r\n    ecConfig.line = {\r\n        zlevel: 0,                  // 一级层叠\r\n        z: 2,                       // 二级层叠\r\n        clickable: true,\r\n        legendHoverLink: true,\r\n        // stack: null\r\n        xAxisIndex: 0,\r\n        yAxisIndex: 0,\r\n        // 'nearest', 'min', 'max', 'average'\r\n        dataFilter: 'nearest',\r\n        itemStyle: {\r\n            normal: {\r\n                // color: 各异,\r\n                label: {\r\n                    show: false\r\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\r\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\r\n                    //           'inside'|'left'|'right'|'top'|'bottom'\r\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                },\r\n                lineStyle: {\r\n                    width: 2,\r\n                    type: 'solid',\r\n                    shadowColor: 'rgba(0,0,0,0)', //默认透明\r\n                    shadowBlur: 0,\r\n                    shadowOffsetX: 0,\r\n                    shadowOffsetY: 0\r\n                }\r\n            },\r\n            emphasis: {\r\n                // color: 各异,\r\n                label: {\r\n                    show: false\r\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\r\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\r\n                    //           'inside'|'left'|'right'|'top'|'bottom'\r\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\r\n                }\r\n            }\r\n        },\r\n        // smooth: false,\r\n        // symbol: null,         // 拐点图形类型\r\n        symbolSize: 2,           // 拐点图形大小\r\n        // symbolRotate: null,   // 拐点图形旋转控制\r\n        showAllSymbol: false     // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\r\n    };\r\n\r\n    var ecData = require('../util/ecData');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    var zrColor = require('zrenderjs/tool/color');\r\n    \r\n    /**\r\n     * 构造函数\r\n     * @param {Object} messageCenter echart消息中心\r\n     * @param {ZRender} zr zrender实例\r\n     * @param {Object} series 数据\r\n     * @param {Object} component 组件\r\n     */\r\n    function Line(ecTheme, messageCenter, zr, option, myChart){\r\n        // 图表基类\r\n        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);\r\n\r\n        this.refresh(option);\r\n    }\r\n    \r\n    Line.prototype = {\r\n        type: ecConfig.CHART_TYPE_LINE,\r\n        /**\r\n         * 绘制图形\r\n         */\r\n        _buildShape: function () {\r\n            this.finalPLMap = {}; // 完成的point list(PL)\r\n            this._buildPosition();\r\n        },\r\n\r\n        /**\r\n         * 构建类目轴为水平方向的折线图系列\r\n         */\r\n        _buildHorizontal: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            var series = this.series;\r\n            // 确定类目轴和数值轴，同一方向随便找一个即可\r\n            var seriesIndex = locationMap[0][0];\r\n            var serie = series[seriesIndex];\r\n            var categoryAxis = this.component.xAxis.getAxis(serie.xAxisIndex || 0);\r\n            var valueAxis;  // 数值轴各异\r\n\r\n            var x;\r\n            var y;\r\n            var lastYP; // 正向堆积处理\r\n            var baseYP;\r\n            var lastYN; // 负向堆积处理\r\n            var baseYN;\r\n            //var this.finalPLMap = {}; // 完成的point list(PL)\r\n            var curPLMap = {};   // 正在记录的point list(PL)\r\n            var data;\r\n            var value;\r\n            for (var i = 0, l = maxDataLength; i < l; i++) {\r\n                if (categoryAxis.getNameByIndex(i) == null) {\r\n                    // 系列数据超出类目轴长度\r\n                    break;\r\n                }\r\n                x = categoryAxis.getCoordByIndex(i);\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    // 堆积数据用第一条valueAxis\r\n                    valueAxis = this.component.yAxis.getAxis(\r\n                        series[locationMap[j][0]].yAxisIndex || 0\r\n                    );\r\n                    baseYP = lastYP = baseYN = lastYN = valueAxis.getCoord(0);\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];\r\n                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                                || {\r\n                                                    min: Number.POSITIVE_INFINITY,\r\n                                                    max: Number.NEGATIVE_INFINITY,\r\n                                                    sum: 0,\r\n                                                    counter: 0,\r\n                                                    average: 0\r\n                                                };\r\n                        if (value === '-') {\r\n                            // 空数据则把正在记录的curPLMap添加到finalPLMap中\r\n                            if (curPLMap[seriesIndex].length > 0) {\r\n                                this.finalPLMap[seriesIndex] =\r\n                                    this.finalPLMap[seriesIndex] || [];\r\n\r\n                                this.finalPLMap[seriesIndex].push(\r\n                                    curPLMap[seriesIndex]\r\n                                );\r\n\r\n                                curPLMap[seriesIndex] = [];\r\n                            }\r\n                            continue;\r\n                        }\r\n                        //y = valueAxis.getCoord(value);\r\n                        if (value >= 0) {\r\n                            // 正向堆积\r\n                            lastYP -= m > 0\r\n                                      ? valueAxis.getCoordSize(value)\r\n                                      : (baseYP - valueAxis.getCoord(value));\r\n                            y = lastYP;\r\n                        }\r\n                        else if (value < 0){\r\n                            // 负向堆积\r\n                            lastYN += m > 0 \r\n                                      ? valueAxis.getCoordSize(value)\r\n                                      : (valueAxis.getCoord(value) - baseYN);\r\n                            y = lastYN;\r\n                        }\r\n                        curPLMap[seriesIndex].push(\r\n                            [x, y, i, categoryAxis.getNameByIndex(i), x, baseYP]\r\n                        );\r\n                        \r\n                        if (xMarkMap[seriesIndex].min > value) {\r\n                            xMarkMap[seriesIndex].min = value;\r\n                            xMarkMap[seriesIndex].minY = y;\r\n                            xMarkMap[seriesIndex].minX = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max < value) {\r\n                            xMarkMap[seriesIndex].max = value;\r\n                            xMarkMap[seriesIndex].maxY = y;\r\n                            xMarkMap[seriesIndex].maxX = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum += value;\r\n                        xMarkMap[seriesIndex].counter++;\r\n                    }\r\n                }\r\n                // 补充空数据的拖拽提示\r\n                lastYP = this.component.grid.getY();\r\n                var symbolSize;\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        if (value != '-') {\r\n                            // 只关心空数据\r\n                            continue;\r\n                        }\r\n                        if (this.deepQuery([data, serie, this.option], 'calculable')) {\r\n                            symbolSize = this.deepQuery(\r\n                                [data, serie],\r\n                                'symbolSize'\r\n                            );\r\n                            lastYP += symbolSize * 2 + 5;\r\n                            y = lastYP;\r\n                            this.shapeList.push(this._getCalculableItem(\r\n                                seriesIndex, i, categoryAxis.getNameByIndex(i),\r\n                                x, y, 'horizontal'\r\n                            ));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // 把剩余未完成的curPLMap全部添加到finalPLMap中\r\n            for (var sId in curPLMap) {\r\n                if (curPLMap[sId].length > 0) {\r\n                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];\r\n                    this.finalPLMap[sId].push(curPLMap[sId]);\r\n                    curPLMap[sId] = [];\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, 'y');\r\n            \r\n            this._buildBorkenLine(seriesArray, this.finalPLMap, categoryAxis, 'horizontal');\r\n        },\r\n\r\n        /**\r\n         * 构建类目轴为垂直方向的折线图系列\r\n         */\r\n        _buildVertical: function (seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            var series = this.series;\r\n            // 确定类目轴和数值轴，同一方向随便找一个即可\r\n            var seriesIndex = locationMap[0][0];\r\n            var serie = series[seriesIndex];\r\n            var categoryAxis = this.component.yAxis.getAxis(serie.yAxisIndex || 0);\r\n            var valueAxis;  // 数值轴各异\r\n\r\n            var x;\r\n            var y;\r\n            var lastXP; // 正向堆积处理\r\n            var baseXP;\r\n            var lastXN; // 负向堆积处理\r\n            var baseXN;\r\n            //var this.finalPLMap = {}; // 完成的point list(PL)\r\n            var curPLMap = {};   // 正在记录的point list(PL)\r\n            var data;\r\n            var value;\r\n            for (var i = 0, l = maxDataLength; i < l; i++) {\r\n                if (categoryAxis.getNameByIndex(i) == null) {\r\n                    // 系列数据超出类目轴长度\r\n                    break;\r\n                }\r\n                y = categoryAxis.getCoordByIndex(i);\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    // 堆积数据用第一条valueAxis\r\n                    valueAxis = this.component.xAxis.getAxis(\r\n                        series[locationMap[j][0]].xAxisIndex || 0\r\n                    );\r\n                    baseXP = lastXP = baseXN = lastXN = valueAxis.getCoord(0);\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];\r\n                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                                || {\r\n                                                    min: Number.POSITIVE_INFINITY,\r\n                                                    max: Number.NEGATIVE_INFINITY,\r\n                                                    sum: 0,\r\n                                                    counter: 0,\r\n                                                    average: 0\r\n                                                };\r\n                        if (value === '-') {\r\n                            // 空数据则把正在记录的curPLMap添加到finalPLMap中\r\n                            if (curPLMap[seriesIndex].length > 0) {\r\n                                this.finalPLMap[seriesIndex] =\r\n                                    this.finalPLMap[seriesIndex] || [];\r\n\r\n                                this.finalPLMap[seriesIndex].push(\r\n                                    curPLMap[seriesIndex]\r\n                                );\r\n\r\n                                curPLMap[seriesIndex] = [];\r\n                            }\r\n                            continue;\r\n                        }\r\n                        //x = valueAxis.getCoord(value);\r\n                        if (value >= 0) {\r\n                            // 正向堆积\r\n                            lastXP += m > 0\r\n                                      ? valueAxis.getCoordSize(value)\r\n                                      : (valueAxis.getCoord(value) - baseXP);\r\n                            x = lastXP;\r\n                        }\r\n                        else if (value < 0){\r\n                            // 负向堆积\r\n                            lastXN -= m > 0\r\n                                      ? valueAxis.getCoordSize(value)\r\n                                      : (baseXN - valueAxis.getCoord(value));\r\n                            x = lastXN;\r\n                        }\r\n                        curPLMap[seriesIndex].push(\r\n                            [x, y, i, categoryAxis.getNameByIndex(i), baseXP, y]\r\n                        );\r\n                        \r\n                        if (xMarkMap[seriesIndex].min > value) {\r\n                            xMarkMap[seriesIndex].min = value;\r\n                            xMarkMap[seriesIndex].minX = x;\r\n                            xMarkMap[seriesIndex].minY = y;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max < value) {\r\n                            xMarkMap[seriesIndex].max = value;\r\n                            xMarkMap[seriesIndex].maxX = x;\r\n                            xMarkMap[seriesIndex].maxY = y;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum += value;\r\n                        xMarkMap[seriesIndex].counter++;\r\n                    }\r\n                }\r\n                // 补充空数据的拖拽提示\r\n                lastXP = this.component.grid.getXend();\r\n                var symbolSize;\r\n                for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                    for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                        seriesIndex = locationMap[j][m];\r\n                        serie = series[seriesIndex];\r\n                        data = serie.data[i];\r\n                        value = this.getDataFromOption(data, '-');\r\n                        if (value != '-') {\r\n                            // 只关心空数据\r\n                            continue;\r\n                        }\r\n                        if (this.deepQuery([data, serie, this.option], 'calculable')) {\r\n                            symbolSize = this.deepQuery(\r\n                                [data, serie],\r\n                                'symbolSize'\r\n                            );\r\n                            lastXP -= symbolSize * 2 + 5;\r\n                            x = lastXP;\r\n                            this.shapeList.push(this._getCalculableItem(\r\n                                seriesIndex, i, categoryAxis.getNameByIndex(i),\r\n                                x, y, 'vertical'\r\n                            ));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 把剩余未完成的curPLMap全部添加到finalPLMap中\r\n            for (var sId in curPLMap) {\r\n                if (curPLMap[sId].length > 0) {\r\n                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];\r\n                    this.finalPLMap[sId].push(curPLMap[sId]);\r\n                    curPLMap[sId] = [];\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, 'x');\r\n            \r\n            this._buildBorkenLine(seriesArray, this.finalPLMap, categoryAxis, 'vertical');\r\n        },\r\n\r\n        /**\r\n         * 构建双数值轴折线图 \r\n         */\r\n        _buildOther: function(seriesArray, maxDataLength, locationMap, xMarkMap) {\r\n            var series = this.series;\r\n            var curPLMap = {};   // 正在记录的point list(PL)\r\n            var xAxis;\r\n            \r\n            for (var j = 0, k = locationMap.length; j < k; j++) {\r\n                for (var m = 0, n = locationMap[j].length; m < n; m++) {\r\n                    var seriesIndex = locationMap[j][m];\r\n                    var serie = series[seriesIndex];\r\n                    xAxis = this.component.xAxis.getAxis(serie.xAxisIndex || 0);\r\n                    var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex || 0);\r\n                    var baseY = yAxis.getCoord(0);\r\n                    \r\n                    curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];\r\n                    xMarkMap[seriesIndex] = xMarkMap[seriesIndex] \r\n                                            || {\r\n                                                min0: Number.POSITIVE_INFINITY,\r\n                                                min1: Number.POSITIVE_INFINITY,\r\n                                                max0: Number.NEGATIVE_INFINITY,\r\n                                                max1: Number.NEGATIVE_INFINITY,\r\n                                                sum0: 0,\r\n                                                sum1: 0,\r\n                                                counter0: 0,\r\n                                                counter1: 0,\r\n                                                average0: 0,\r\n                                                average1: 0\r\n                                            };\r\n                    \r\n                    for (var i = 0, l = serie.data.length; i < l; i++) {\r\n                        var data = serie.data[i];\r\n                        var value = this.getDataFromOption(data, '-');\r\n                        if (!(value instanceof Array)) {\r\n                            continue;\r\n                        }\r\n                        \r\n                        var x = xAxis.getCoord(value[0]);\r\n                        var y = yAxis.getCoord(value[1]);\r\n                        curPLMap[seriesIndex].push(\r\n                            // x, y, dataIndex, name, 填充用\r\n                            [x, y, i, value[0], x, baseY]\r\n                        );\r\n                        \r\n                        if (xMarkMap[seriesIndex].min0 > value[0]) {\r\n                            xMarkMap[seriesIndex].min0 = value[0];\r\n                            xMarkMap[seriesIndex].minY0 = y;\r\n                            xMarkMap[seriesIndex].minX0 = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max0 < value[0]) {\r\n                            xMarkMap[seriesIndex].max0 = value[0];\r\n                            xMarkMap[seriesIndex].maxY0 = y;\r\n                            xMarkMap[seriesIndex].maxX0 = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum0 += value[0];\r\n                        xMarkMap[seriesIndex].counter0++;\r\n                        \r\n                        if (xMarkMap[seriesIndex].min1 > value[1]) {\r\n                            xMarkMap[seriesIndex].min1 = value[1];\r\n                            xMarkMap[seriesIndex].minY1 = y;\r\n                            xMarkMap[seriesIndex].minX1 = x;\r\n                        }\r\n                        if (xMarkMap[seriesIndex].max1 < value[1]) {\r\n                            xMarkMap[seriesIndex].max1 = value[1];\r\n                            xMarkMap[seriesIndex].maxY1 = y;\r\n                            xMarkMap[seriesIndex].maxX1 = x;\r\n                        }\r\n                        xMarkMap[seriesIndex].sum1 += value[1];\r\n                        xMarkMap[seriesIndex].counter1++;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // 把剩余未完成的curPLMap全部添加到finalPLMap中\r\n            for (var sId in curPLMap) {\r\n                if (curPLMap[sId].length > 0) {\r\n                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];\r\n                    this.finalPLMap[sId].push(curPLMap[sId]);\r\n                    curPLMap[sId] = [];\r\n                }\r\n            }\r\n            \r\n            this._calculMarkMapXY(xMarkMap, locationMap, 'xy');\r\n            \r\n            this._buildBorkenLine(seriesArray, this.finalPLMap, xAxis, 'other');\r\n        },\r\n        \r\n        /**\r\n         * 生成折线和折线上的拐点\r\n         */\r\n        _buildBorkenLine: function (seriesArray, pointList, categoryAxis, curOrient) {\r\n            var orient = curOrient == 'other' ? 'horizontal' : curOrient;\r\n            var series = this.series;\r\n            var data;\r\n            \r\n            // 堆积层叠需求，反顺序构建\r\n            for (var sIdx = seriesArray.length - 1; sIdx >= 0; sIdx--) {\r\n                var seriesIndex = seriesArray[sIdx];\r\n                var serie = series[seriesIndex];\r\n                var seriesPL = pointList[seriesIndex];\r\n                if (serie.type === this.type && seriesPL != null) {\r\n                    var bbox = this._getBbox(seriesIndex, orient);\r\n                    var defaultColor = this._sIndex2ColorMap[seriesIndex];\r\n                    // 折线相关，多级控制\r\n                    var lineWidth = this.query(\r\n                        serie, 'itemStyle.normal.lineStyle.width'\r\n                    );\r\n                    var lineType = this.query(\r\n                        serie, 'itemStyle.normal.lineStyle.type'\r\n                    );\r\n                    var lineColor = this.query(\r\n                        serie, 'itemStyle.normal.lineStyle.color'\r\n                    );\r\n                    var normalColor = this.getItemStyleColor(\r\n                        this.query(serie, 'itemStyle.normal.color'), seriesIndex, -1\r\n                    );\r\n\r\n                    // 填充相关\r\n                    var isFill = this.query(serie, 'itemStyle.normal.areaStyle') != null;\r\n                    var fillNormalColor = this.query(\r\n                        serie, 'itemStyle.normal.areaStyle.color'\r\n                    );\r\n\r\n                    for (var i = 0, l = seriesPL.length; i < l; i++) {\r\n                        var singlePL = seriesPL[i];\r\n                        var isLarge = curOrient != 'other' && this._isLarge(orient, singlePL);\r\n                        if (!isLarge) { // 非大数据模式才显示拐点symbol\r\n                            for (var j = 0, k = singlePL.length; j < k; j++) {\r\n                                data = serie.data[singlePL[j][2]];\r\n                                if (this.deepQuery([data, serie, this.option], 'calculable') // 可计算\r\n                                    || this.deepQuery([data, serie], 'showAllSymbol')        // 全显示\r\n                                    || (categoryAxis.type === 'categoryAxis'                 // 主轴非空\r\n                                        && categoryAxis.isMainAxis(singlePL[j][2])\r\n                                        && this.deepQuery([data, serie], 'symbol') != 'none'\r\n                                       )\r\n                                ) {\r\n                                    this.shapeList.push(this._getSymbol(\r\n                                        seriesIndex,\r\n                                        singlePL[j][2], // dataIndex\r\n                                        singlePL[j][3], // name\r\n                                        singlePL[j][0], // x\r\n                                        singlePL[j][1], // y\r\n                                        orient\r\n                                    ));\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            // 大数据模式截取pointList\r\n                            singlePL = this._getLargePointList(\r\n                                orient, singlePL, serie.dataFilter\r\n                            );\r\n                        }\r\n\r\n                        // 折线图\r\n                        var polylineShape = new PolylineShape({\r\n                            zlevel: serie.zlevel,\r\n                            z: serie.z,\r\n                            style: {\r\n                                miterLimit: lineWidth,\r\n                                pointList: singlePL,\r\n                                strokeColor: lineColor\r\n                                             || normalColor \r\n                                             || defaultColor,\r\n                                lineWidth: lineWidth,\r\n                                lineType: lineType,\r\n                                smooth: this._getSmooth(serie.smooth),\r\n                                smoothConstraint: bbox,\r\n                                shadowColor: this.query(\r\n                                  serie,\r\n                                  'itemStyle.normal.lineStyle.shadowColor'\r\n                                ),\r\n                                shadowBlur: this.query(\r\n                                  serie,\r\n                                  'itemStyle.normal.lineStyle.shadowBlur'\r\n                                ),\r\n                                shadowOffsetX: this.query(\r\n                                  serie,\r\n                                  'itemStyle.normal.lineStyle.shadowOffsetX'\r\n                                ),\r\n                                shadowOffsetY: this.query(\r\n                                  serie,\r\n                                  'itemStyle.normal.lineStyle.shadowOffsetY'\r\n                                )\r\n                            },\r\n                            hoverable: false,\r\n                            _main: true,\r\n                            _seriesIndex: seriesIndex,\r\n                            _orient: orient\r\n                        });\r\n                        \r\n                        ecData.pack(\r\n                            polylineShape,\r\n                            series[seriesIndex], seriesIndex,\r\n                            0, i, series[seriesIndex].name\r\n                        );\r\n                        \r\n                        this.shapeList.push(polylineShape);\r\n                        \r\n                        if (isFill) {\r\n                            var halfSmoothPolygonShape = new HalfSmoothPolygonShape({\r\n                                zlevel: serie.zlevel,\r\n                                z: serie.z,\r\n                                style: {\r\n                                    miterLimit: lineWidth,\r\n                                    pointList: zrUtil.clone(singlePL).concat([\r\n                                        [\r\n                                            singlePL[singlePL.length - 1][4],\r\n                                            singlePL[singlePL.length - 1][5]\r\n                                        ],\r\n                                        [\r\n                                            singlePL[0][4],\r\n                                            singlePL[0][5]\r\n                                        ]\r\n                                    ]),\r\n                                    brushType: 'fill',\r\n                                    smooth: this._getSmooth(serie.smooth),\r\n                                    smoothConstraint: bbox,\r\n                                    color: fillNormalColor\r\n                                           ? fillNormalColor\r\n                                           : zrColor.alpha(defaultColor,0.5)\r\n                                },\r\n                                highlightStyle: {\r\n                                    brushType: 'fill'\r\n                                },\r\n                                hoverable: false,\r\n                                _main: true,\r\n                                _seriesIndex: seriesIndex,\r\n                                _orient: orient\r\n                            });\r\n                            ecData.pack(\r\n                                halfSmoothPolygonShape,\r\n                                series[seriesIndex], seriesIndex,\r\n                                0, i, series[seriesIndex].name\r\n                            );\r\n                            this.shapeList.push(halfSmoothPolygonShape);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        _getBbox: function(seriesIndex, orient) {\r\n            var bbox = this.component.grid.getBbox();\r\n            var xMarkMap = this.xMarkMap[seriesIndex];\r\n            if (xMarkMap.minX0 != null) {\r\n                return [\r\n                    [\r\n                        Math.min(xMarkMap.minX0, xMarkMap.maxX0, xMarkMap.minX1, xMarkMap.maxX1),\r\n                        Math.min(xMarkMap.minY0, xMarkMap.maxY0, xMarkMap.minY1, xMarkMap.maxY1)\r\n                    ],\r\n                    [\r\n                        Math.max(xMarkMap.minX0, xMarkMap.maxX0, xMarkMap.minX1, xMarkMap.maxX1),\r\n                        Math.max(xMarkMap.minY0, xMarkMap.maxY0, xMarkMap.minY1, xMarkMap.maxY1)\r\n                    ]\r\n                ];\r\n            }\r\n            else if (orient === 'horizontal') {\r\n                bbox[0][1] = Math.min(xMarkMap.minY, xMarkMap.maxY);\r\n                bbox[1][1] = Math.max(xMarkMap.minY, xMarkMap.maxY);\r\n            }\r\n            else {\r\n                bbox[0][0] = Math.min(xMarkMap.minX, xMarkMap.maxX);\r\n                bbox[1][0] = Math.max(xMarkMap.minX, xMarkMap.maxX);\r\n            }\r\n            return bbox;\r\n        },\r\n        \r\n        _isLarge: function(orient, singlePL) {\r\n            if (singlePL.length < 2) {\r\n                return false;\r\n            }\r\n            else {\r\n                return orient === 'horizontal'\r\n                       ? (Math.abs(singlePL[0][0] - singlePL[1][0]) < 0.5)\r\n                       : (Math.abs(singlePL[0][1] - singlePL[1][1]) < 0.5);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * 大规模pointList优化 \r\n         */\r\n        _getLargePointList: function(orient, singlePL, filter) {\r\n            var total;\r\n            if (orient === 'horizontal') {\r\n                total = this.component.grid.getWidth();\r\n            }\r\n            else {\r\n                total = this.component.grid.getHeight();\r\n            }\r\n            \r\n            var len = singlePL.length;\r\n            var newList = [];\r\n\r\n            if (typeof(filter) != 'function') {\r\n                switch (filter) {\r\n                    case 'min':\r\n                        filter = function (arr) {\r\n                            return Math.max.apply(null, arr);\r\n                        };\r\n                        break;\r\n                    case 'max':\r\n                        filter = function (arr) {\r\n                            return Math.min.apply(null, arr);\r\n                        };\r\n                        break;\r\n                    case 'average':\r\n                        filter = function (arr) {\r\n                            var total = 0;\r\n                            for (var i = 0; i < arr.length; i++) {\r\n                                total += arr[i];\r\n                            }\r\n                            return total / arr.length;\r\n                        };\r\n                        break;\r\n                    default:\r\n                        filter = function (arr) {\r\n                            return arr[0];\r\n                        }\r\n                }\r\n            }\r\n\r\n            var windowData = [];\r\n            for (var i = 0; i < total; i++) {\r\n                var idx0 = Math.floor(len / total * i);\r\n                var idx1 = Math.min(Math.floor(len / total * (i + 1)), len);\r\n                if (idx1 <= idx0) {\r\n                    continue;\r\n                }\r\n\r\n                for (var j = idx0; j < idx1; j++) {\r\n                    windowData[j - idx0] = orient === 'horizontal'\r\n                        ? singlePL[j][1] : singlePL[j][0];\r\n                }\r\n\r\n                windowData.length = idx1 - idx0;\r\n                var filteredVal = filter(windowData);\r\n                var nearestIdx = -1;\r\n                var minDist = Infinity;\r\n                // 寻找值最相似的点，使用其其它属性\r\n                for (var j = idx0; j < idx1; j++) {\r\n                    var val = orient === 'horizontal'\r\n                        ? singlePL[j][1] : singlePL[j][0];\r\n                    var dist = Math.abs(val - filteredVal);\r\n                    if (dist < minDist) {\r\n                        nearestIdx = j;\r\n                        minDist = dist;\r\n                    }\r\n                }\r\n\r\n                var newItem = singlePL[nearestIdx].slice();\r\n                if (orient === 'horizontal') {\r\n                    newItem[1] = filteredVal;\r\n                }\r\n                else {\r\n                    newItem[0] = filteredVal;\r\n                }\r\n                newList.push(newItem);\r\n            }\r\n            return newList;\r\n        },\r\n\r\n        _getSmooth: function (isSmooth/*, pointList, orient*/) {\r\n            if (isSmooth) {\r\n                /* 不科学啊，发现0.3通用了\r\n                var delta;\r\n                if (orient === 'horizontal') {\r\n                    delta = Math.abs(pointList[0][0] - pointList[1][0]);\r\n                }\r\n                else {\r\n                    delta = Math.abs(pointList[0][1] - pointList[1][1]);\r\n                }\r\n                */\r\n                return 0.3;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 生成空数据所需的可计算提示图形\r\n         */\r\n        _getCalculableItem: function (seriesIndex, dataIndex, name, x, y, orient) {\r\n            var series = this.series;\r\n            var color = series[seriesIndex].calculableHolderColor\r\n                        || this.ecTheme.calculableHolderColor\r\n                        || ecConfig.calculableHolderColor;\r\n\r\n            var itemShape = this._getSymbol(\r\n                seriesIndex, dataIndex, name,\r\n                x, y, orient\r\n            );\r\n            itemShape.style.color = color;\r\n            itemShape.style.strokeColor = color;\r\n            itemShape.rotation = [0,0];\r\n            itemShape.hoverable = false;\r\n            itemShape.draggable = false;\r\n            itemShape.style.text = undefined;\r\n\r\n            return itemShape;\r\n        },\r\n\r\n        /**\r\n         * 生成折线图上的拐点图形\r\n         */\r\n        _getSymbol: function (seriesIndex, dataIndex, name, x, y, orient) {\r\n            var series = this.series;\r\n            var serie = series[seriesIndex];\r\n            var data = serie.data[dataIndex];\r\n            \r\n            var itemShape = this.getSymbolShape(\r\n                serie, seriesIndex, data, dataIndex, name, \r\n                x, y,\r\n                this._sIndex2ShapeMap[seriesIndex], \r\n                this._sIndex2ColorMap[seriesIndex],\r\n                '#fff',\r\n                orient === 'vertical' ? 'horizontal' : 'vertical' // 翻转\r\n            );\r\n            itemShape.zlevel = serie.zlevel;\r\n            itemShape.z = serie.z + 1;\r\n            \r\n            if (this.deepQuery([data, serie, this.option], 'calculable')) {\r\n                this.setCalculable(itemShape);\r\n                itemShape.draggable = true;\r\n            }\r\n            \r\n            return itemShape;\r\n        },\r\n\r\n        // 位置转换\r\n        getMarkCoord: function (seriesIndex, mpData) {\r\n            var serie = this.series[seriesIndex];\r\n            var xMarkMap = this.xMarkMap[seriesIndex];\r\n            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);\r\n            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);\r\n            \r\n            if (mpData.type\r\n                && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')\r\n            ) {\r\n                // 特殊值内置支持\r\n                var valueIndex = mpData.valueIndex != null \r\n                                 ? mpData.valueIndex \r\n                                 : xMarkMap.maxX0 != null \r\n                                   ? '1' : '';\r\n                return [\r\n                    xMarkMap[mpData.type + 'X' + valueIndex],\r\n                    xMarkMap[mpData.type + 'Y' + valueIndex],\r\n                    xMarkMap[mpData.type + 'Line' + valueIndex],\r\n                    xMarkMap[mpData.type + valueIndex]\r\n                ];\r\n            }\r\n            \r\n            return [\r\n                typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex\r\n                    ? xAxis.getCoordByIndex(mpData.xAxis || 0)\r\n                    : xAxis.getCoord(mpData.xAxis || 0),\r\n                \r\n                typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex\r\n                    ? yAxis.getCoordByIndex(mpData.yAxis || 0)\r\n                    : yAxis.getCoord(mpData.yAxis || 0)\r\n            ];\r\n        },\r\n        \r\n        /**\r\n         * 刷新\r\n         */\r\n        refresh: function (newOption) {\r\n            if (newOption) {\r\n                this.option = newOption;\r\n                this.series = newOption.series;\r\n            }\r\n            \r\n            this.backupShapeList();\r\n            this._buildShape();\r\n        },\r\n        \r\n        ontooltipHover: function (param, tipShape) {\r\n            var seriesIndex = param.seriesIndex;\r\n            var dataIndex = param.dataIndex;\r\n            var seriesPL;\r\n            var singlePL;\r\n            var len = seriesIndex.length;\r\n            while (len--) {\r\n                seriesPL = this.finalPLMap[seriesIndex[len]];\r\n                if (seriesPL) {\r\n                    for (var i = 0, l = seriesPL.length; i < l; i++) {\r\n                        singlePL = seriesPL[i];\r\n                        for (var j = 0, k = singlePL.length; j < k; j++) {\r\n                            if (dataIndex === singlePL[j][2]) {\r\n                                tipShape.push(this._getSymbol(\r\n                                    seriesIndex[len],   // seriesIndex\r\n                                    singlePL[j][2],     // dataIndex\r\n                                    singlePL[j][3],     // name\r\n                                    singlePL[j][0],     // x\r\n                                    singlePL[j][1],     // y\r\n                                    'horizontal'\r\n                                ));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 动态数据增加动画 \r\n         */\r\n        addDataAnimation: function (params, done) {\r\n            var series = this.series;\r\n            var aniMap = {}; // seriesIndex索引参数\r\n            for (var i = 0, l = params.length; i < l; i++) {\r\n                aniMap[params[i][0]] = params[i];\r\n            }\r\n            var x;\r\n            var dx;\r\n            var y;\r\n            var dy;\r\n            var seriesIndex;\r\n            var pointList;\r\n            var isHorizontal; // 是否横向布局， isHorizontal;\r\n\r\n            var aniCount = 0;\r\n            function animationDone() {\r\n                aniCount--;\r\n                if (aniCount === 0) {\r\n                    done && done();\r\n                }\r\n            }\r\n            function animationDuring(target) {\r\n                // 强制更新曲线控制点\r\n                target.style.controlPointList = null;\r\n            }\r\n\r\n            for (var i = this.shapeList.length - 1; i >= 0; i--) {\r\n                seriesIndex = this.shapeList[i]._seriesIndex;\r\n                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {\r\n                    // 有数据删除才有移动的动画\r\n                    if (this.shapeList[i]._main && this.shapeList[i].style.pointList.length > 1) {\r\n                        pointList = this.shapeList[i].style.pointList;\r\n                        // 主线动画\r\n                        dx = Math.abs(pointList[0][0] - pointList[1][0]);\r\n                        dy = Math.abs(pointList[0][1] - pointList[1][1]);\r\n                        isHorizontal = this.shapeList[i]._orient === 'horizontal';\r\n                            \r\n                        if (aniMap[seriesIndex][2]) {\r\n                            // 队头加入删除末尾\r\n                            if (this.shapeList[i].type === 'half-smooth-polygon') {\r\n                                //区域图\r\n                                var len = pointList.length;\r\n                                this.shapeList[i].style.pointList[len - 3] = pointList[len - 2];\r\n                                this.shapeList[i].style.pointList[len - 3][isHorizontal ? 0 : 1]\r\n                                    = pointList[len - 4][isHorizontal ? 0 : 1];\r\n                                this.shapeList[i].style.pointList[len - 2] = pointList[len - 1];\r\n                            }\r\n                            this.shapeList[i].style.pointList.pop();\r\n                            isHorizontal ? (x = dx, y = 0) : (x = 0, y = -dy);\r\n                        }\r\n                        else {\r\n                            // 队尾加入删除头部\r\n                            this.shapeList[i].style.pointList.shift();\r\n                            if (this.shapeList[i].type === 'half-smooth-polygon') {\r\n                                //区域图\r\n                                var targetPoint =this.shapeList[i].style.pointList.pop();\r\n                                isHorizontal\r\n                                ? (targetPoint[0] = pointList[0][0])\r\n                                : (targetPoint[1] = pointList[0][1]);\r\n                                this.shapeList[i].style.pointList.push(targetPoint);\r\n                            }\r\n                            isHorizontal ? (x = -dx, y = 0) : (x = 0, y = dy);\r\n                        }\r\n                        this.shapeList[i].style.controlPointList = null;\r\n                        \r\n                        this.zr.modShape(this.shapeList[i]);\r\n                    }\r\n                    else {\r\n                        // 拐点动画\r\n                        if (aniMap[seriesIndex][2] \r\n                            && this.shapeList[i]._dataIndex \r\n                                === series[seriesIndex].data.length - 1\r\n                        ) {\r\n                            // 队头加入删除末尾\r\n                            this.zr.delShape(this.shapeList[i].id);\r\n                            continue;\r\n                        }\r\n                        else if (!aniMap[seriesIndex][2] \r\n                                 && this.shapeList[i]._dataIndex === 0\r\n                        ) {\r\n                            // 队尾加入删除头部\r\n                            this.zr.delShape(this.shapeList[i].id);\r\n                            continue;\r\n                        }\r\n                    }\r\n                    this.shapeList[i].position = [0, 0];\r\n\r\n                    aniCount++;\r\n                    this.zr.animate(this.shapeList[i].id, '')\r\n                        .when(\r\n                            this.query(this.option, 'animationDurationUpdate'),\r\n                            { position: [ x, y ] }\r\n                        )\r\n                        .during(animationDuring)\r\n                        .done(animationDone)\r\n                        .start();\r\n                }\r\n            }\r\n\r\n            // 没有动画\r\n            if (!aniCount) {\r\n                done && done();\r\n            }\r\n        }\r\n    };\r\n\r\n    function legendLineIcon(ctx, style, refreshNextFrame) {\r\n        var x = style.x;\r\n        var y = style.y;\r\n        var width = style.width;\r\n        var height = style.height;\r\n        \r\n        var dy = height / 2;\r\n        \r\n        if (style.symbol.match('empty')) {\r\n            ctx.fillStyle = '#fff';\r\n        }\r\n        style.brushType = 'both';\r\n        \r\n        var symbol = style.symbol.replace('empty', '').toLowerCase();\r\n        if (symbol.match('star')) {\r\n            dy = (symbol.replace('star','') - 0) || 5;\r\n            y -= 1;\r\n            symbol = 'star';\r\n        } \r\n        else if (symbol === 'rectangle' || symbol === 'arrow') {\r\n            x += (width - height) / 2;\r\n            width = height;\r\n        }\r\n        \r\n        var imageLocation = '';\r\n        if (symbol.match('image')) {\r\n            imageLocation = symbol.replace(\r\n                    new RegExp('^image:\\\\/\\\\/'), ''\r\n                );\r\n            symbol = 'image';\r\n            x += Math.round((width - height) / 2) - 1;\r\n            width = height = height + 2;\r\n        }\r\n        symbol = IconShape.prototype.iconLibrary[symbol];\r\n        \r\n        if (symbol) {\r\n            var x2 = style.x;\r\n            var y2 = style.y;\r\n            ctx.moveTo(x2, y2 + dy);\r\n            ctx.lineTo(x2 + 5, y2 + dy);\r\n            ctx.moveTo(x2 + style.width - 5, y2 + dy);\r\n            ctx.lineTo(x2 + style.width, y2 + dy);\r\n            var self = this;\r\n            symbol(\r\n                ctx,\r\n                {\r\n                    x: x + 4,\r\n                    y: y + 4,\r\n                    width: width - 8,\r\n                    height: height - 8,\r\n                    n: dy,\r\n                    image: imageLocation\r\n                },\r\n                function () {\r\n                    self.modSelf();\r\n                    refreshNextFrame();\r\n                }\r\n            );\r\n        }\r\n        else {\r\n            ctx.moveTo(x, y + dy);\r\n            ctx.lineTo(x + width, y + dy);\r\n        }\r\n    }\r\n    IconShape.prototype.iconLibrary['legendLineIcon'] = legendLineIcon;\r\n    \r\n    zrUtil.inherits(Line, ChartBase);\r\n    \r\n    // 图表注册\r\n    require('../chart').define('line', Line);\r\n    \r\n    return Line;\r\n});"
    },
    {
      "id": 68,
      "identifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\util\\shape\\HalfSmoothPolygon.js",
      "name": "E:/www/Test/webpack-lok'tar/~/echarts/util/shape/HalfSmoothPolygon.js",
      "index": 68,
      "index2": 63,
      "size": 3072,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        5
      ],
      "assets": [],
      "issuer": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 67,
          "moduleIdentifier": "E:\\www\\Test\\webpack-lok'tar\\node_modules\\echarts\\chart\\line.js",
          "module": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "moduleName": "E:/www/Test/webpack-lok'tar/~/echarts/chart/line.js",
          "type": "cjs require",
          "userRequest": "../util/shape/HalfSmoothPolygon",
          "loc": "14:33-75"
        }
      ],
      "source": "/**\r\n * zrender\r\n *\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *\r\n * shape类：支持半平滑的polygon，折线面积图使用\r\n * 可配图形属性：\r\n   {\r\n       // 基础属性\r\n       shape  : 'halfSmoothPolygon',      // 必须，shape类标识，需要显式指定\r\n       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成\r\n       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中\r\n       invisible : {boolean},   // 默认为false，是否可见\r\n\r\n       // 样式属性，默认状态样式样式属性\r\n       style  : {\r\n           pointList     : {Array},   // 必须，多边形各个顶角坐标\r\n       },\r\n\r\n       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示\r\n       highlightStyle : {\r\n           // 同style\r\n       }\r\n\r\n       // 交互属性，详见shape.Base\r\n\r\n       // 事件属性，详见shape.Base\r\n   }\r\n         例子：\r\n   {\r\n       shape  : 'halfSmoothPolygon',\r\n       id     : '123456',\r\n       zlevel : 1,\r\n       style  : {\r\n           pointList : [[10, 10], [300, 20], [298, 400], [50, 450]]\r\n           color : '#eee',\r\n           text : 'Baidu'\r\n       },\r\n       myName : 'kener',  // 可自带任何有效自定义属性\r\n\r\n       clickable : true,\r\n       onClick : function (eventPacket) {\r\n           alert(eventPacket.target.myName);\r\n       }\r\n   }\r\n */\r\ndefine(function (require) {\r\n    var Base = require('zrenderjs/shape/Base');\r\n    var smoothBezier = require('zrenderjs/shape/util/smoothBezier');\r\n    var zrUtil = require('zrenderjs/tool/util');\r\n    \r\n    function HalfSmoothPolygon(options) {\r\n        Base.call(this, options);\r\n    }\r\n\r\n    HalfSmoothPolygon.prototype = {\r\n        type : 'half-smooth-polygon',\r\n        /**\r\n         * 创建多边形路径\r\n         * @param {Context2D} ctx Canvas 2D上下文\r\n         * @param {Object} style 样式\r\n         */\r\n        buildPath : function (ctx, style) {\r\n            var pointList = style.pointList;\r\n            if (pointList.length < 2) {\r\n                // 少于2个点就不画了~\r\n                return;\r\n            }\r\n            if (style.smooth) {\r\n                var controlPoints = smoothBezier(\r\n                    pointList.slice(0, -2), style.smooth, false, style.smoothConstraint\r\n                );\r\n\r\n                ctx.moveTo(pointList[0][0], pointList[0][1]);\r\n                var cp1;\r\n                var cp2;\r\n                var p;\r\n                var l = pointList.length;\r\n                for (var i = 0; i < l - 3; i++) {\r\n                    cp1 = controlPoints[i * 2];\r\n                    cp2 = controlPoints[i * 2 + 1];\r\n                    p = pointList[i + 1];\r\n                    ctx.bezierCurveTo(\r\n                        cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\r\n                    );\r\n                }\r\n                ctx.lineTo(pointList[l - 2][0], pointList[l - 2][1]);\r\n                ctx.lineTo(pointList[l - 1][0], pointList[l - 1][1]);\r\n                ctx.lineTo(pointList[0][0], pointList[0][1]);\r\n            } \r\n            else {\r\n                require('zrenderjs/shape/Polygon').prototype.buildPath(\r\n                    ctx, style\r\n                );\r\n            }\r\n            return;\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(HalfSmoothPolygon, Base);\r\n    \r\n    return HalfSmoothPolygon;\r\n});"
    }
  ],
  "filteredModules": 0,
  "children": []
}
